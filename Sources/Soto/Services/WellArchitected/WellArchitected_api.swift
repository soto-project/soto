//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS WellArchitected service.
///
/// Well-Architected Tool This is the Well-Architected Tool API Reference. The WA Tool API provides programmatic access to the  Well-Architected Tool in the  Amazon Web Services Management Console. For information  about the Well-Architected Tool, see the  Well-Architected Tool User Guide.
public struct WellArchitected: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the WellArchitected client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "WellArchitected",
            serviceIdentifier: "wellarchitected",
            serviceProtocol: .restjson,
            apiVersion: "2020-03-31",
            endpoint: endpoint,
            errorType: WellArchitectedErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Associate a lens to a workload. Up to 10 lenses can be associated with a workload in a single API operation. A  maximum of 20 lenses can be associated with a workload.   Disclaimer  By accessing and/or applying custom lenses created by another Amazon Web Services user or account,  you acknowledge that custom lenses created by other users and shared with you are  Third Party Content as defined in the Amazon Web Services Customer Agreement.
    @Sendable
    @inlinable
    public func associateLenses(_ input: AssociateLensesInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "AssociateLenses", 
            path: "/workloads/{WorkloadId}/associateLenses", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associate a lens to a workload. Up to 10 lenses can be associated with a workload in a single API operation. A  maximum of 20 lenses can be associated with a workload.   Disclaimer  By accessing and/or applying custom lenses created by another Amazon Web Services user or account,  you acknowledge that custom lenses created by other users and shared with you are  Third Party Content as defined in the Amazon Web Services Customer Agreement.
    ///
    /// Parameters:
    ///   - lensAliases: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func associateLenses(
        lensAliases: [String]? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = AssociateLensesInput(
            lensAliases: lensAliases, 
            workloadId: workloadId
        )
        return try await self.associateLenses(input, logger: logger)
    }

    /// Associate a profile with a workload.
    @Sendable
    @inlinable
    public func associateProfiles(_ input: AssociateProfilesInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "AssociateProfiles", 
            path: "/workloads/{WorkloadId}/associateProfiles", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associate a profile with a workload.
    ///
    /// Parameters:
    ///   - profileArns: The list of profile ARNs to associate with the workload.
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func associateProfiles(
        profileArns: [String]? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = AssociateProfilesInput(
            profileArns: profileArns, 
            workloadId: workloadId
        )
        return try await self.associateProfiles(input, logger: logger)
    }

    /// Create a lens share. The owner of a lens can share it with other Amazon Web Services accounts, users, an organization, and organizational units (OUs) in the same Amazon Web Services Region. Lenses provided by Amazon Web Services (Amazon Web Services Official Content) cannot be shared.  Shared access to a lens is not removed until the lens invitation is deleted. If you share a lens with an organization or OU, all accounts in the organization or OU are granted access to the lens. For more information, see Sharing a custom lens in the Well-Architected Tool User Guide.   Disclaimer  By sharing your custom lenses with other Amazon Web Services accounts,  you acknowledge that Amazon Web Services will make your custom lenses available to those  other accounts. Those other accounts may continue to access and use your  shared custom lenses even if you delete the custom lenses  from your own Amazon Web Services account or terminate  your Amazon Web Services account.
    @Sendable
    @inlinable
    public func createLensShare(_ input: CreateLensShareInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLensShareOutput {
        try await self.client.execute(
            operation: "CreateLensShare", 
            path: "/lenses/{LensAlias}/shares", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a lens share. The owner of a lens can share it with other Amazon Web Services accounts, users, an organization, and organizational units (OUs) in the same Amazon Web Services Region. Lenses provided by Amazon Web Services (Amazon Web Services Official Content) cannot be shared.  Shared access to a lens is not removed until the lens invitation is deleted. If you share a lens with an organization or OU, all accounts in the organization or OU are granted access to the lens. For more information, see Sharing a custom lens in the Well-Architected Tool User Guide.   Disclaimer  By sharing your custom lenses with other Amazon Web Services accounts,  you acknowledge that Amazon Web Services will make your custom lenses available to those  other accounts. Those other accounts may continue to access and use your  shared custom lenses even if you delete the custom lenses  from your own Amazon Web Services account or terminate  your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - lensAlias: 
    ///   - sharedWith: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createLensShare(
        clientRequestToken: String? = nil,
        lensAlias: String,
        sharedWith: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLensShareOutput {
        let input = CreateLensShareInput(
            clientRequestToken: clientRequestToken, 
            lensAlias: lensAlias, 
            sharedWith: sharedWith
        )
        return try await self.createLensShare(input, logger: logger)
    }

    /// Create a new lens version. A lens can have up to 100 versions. Use this operation to publish a new lens version after you have imported a lens. The LensAlias  is used to identify the lens to be published.  The owner of a lens can share the lens with other  Amazon Web Services accounts and users in the same Amazon Web Services Region. Only the owner of a lens can delete it.
    @Sendable
    @inlinable
    public func createLensVersion(_ input: CreateLensVersionInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLensVersionOutput {
        try await self.client.execute(
            operation: "CreateLensVersion", 
            path: "/lenses/{LensAlias}/versions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new lens version. A lens can have up to 100 versions. Use this operation to publish a new lens version after you have imported a lens. The LensAlias  is used to identify the lens to be published.  The owner of a lens can share the lens with other  Amazon Web Services accounts and users in the same Amazon Web Services Region. Only the owner of a lens can delete it.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - isMajorVersion: Set to true if this new major lens version.
    ///   - lensAlias: 
    ///   - lensVersion: The version of the lens being created.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLensVersion(
        clientRequestToken: String? = nil,
        isMajorVersion: Bool? = nil,
        lensAlias: String,
        lensVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLensVersionOutput {
        let input = CreateLensVersionInput(
            clientRequestToken: clientRequestToken, 
            isMajorVersion: isMajorVersion, 
            lensAlias: lensAlias, 
            lensVersion: lensVersion
        )
        return try await self.createLensVersion(input, logger: logger)
    }

    /// Create a milestone for an existing workload.
    @Sendable
    @inlinable
    public func createMilestone(_ input: CreateMilestoneInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMilestoneOutput {
        try await self.client.execute(
            operation: "CreateMilestone", 
            path: "/workloads/{WorkloadId}/milestones", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a milestone for an existing workload.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - milestoneName: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createMilestone(
        clientRequestToken: String? = nil,
        milestoneName: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMilestoneOutput {
        let input = CreateMilestoneInput(
            clientRequestToken: clientRequestToken, 
            milestoneName: milestoneName, 
            workloadId: workloadId
        )
        return try await self.createMilestone(input, logger: logger)
    }

    /// Create a profile.
    @Sendable
    @inlinable
    public func createProfile(_ input: CreateProfileInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateProfileOutput {
        try await self.client.execute(
            operation: "CreateProfile", 
            path: "/profiles", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a profile.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - profileDescription: The profile description.
    ///   - profileName: Name of the profile.
    ///   - profileQuestions: The profile questions.
    ///   - tags: The tags assigned to the profile.
    ///   - logger: Logger use during operation
    @inlinable
    public func createProfile(
        clientRequestToken: String? = nil,
        profileDescription: String? = nil,
        profileName: String? = nil,
        profileQuestions: [ProfileQuestionUpdate]? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateProfileOutput {
        let input = CreateProfileInput(
            clientRequestToken: clientRequestToken, 
            profileDescription: profileDescription, 
            profileName: profileName, 
            profileQuestions: profileQuestions, 
            tags: tags
        )
        return try await self.createProfile(input, logger: logger)
    }

    /// Create a profile share.
    @Sendable
    @inlinable
    public func createProfileShare(_ input: CreateProfileShareInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateProfileShareOutput {
        try await self.client.execute(
            operation: "CreateProfileShare", 
            path: "/profiles/{ProfileArn}/shares", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a profile share.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - profileArn: The profile ARN.
    ///   - sharedWith: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createProfileShare(
        clientRequestToken: String? = nil,
        profileArn: String,
        sharedWith: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateProfileShareOutput {
        let input = CreateProfileShareInput(
            clientRequestToken: clientRequestToken, 
            profileArn: profileArn, 
            sharedWith: sharedWith
        )
        return try await self.createProfileShare(input, logger: logger)
    }

    /// Create a review template.   Disclaimer  Do not include or gather personal identifiable information (PII) of end users or other identifiable individuals in or via your review templates. If your review template or those shared with you and used in your account do include or collect PII you are responsible for: ensuring that the included PII is processed in accordance with applicable law, providing adequate privacy notices, and obtaining necessary consents for processing such data.
    @Sendable
    @inlinable
    public func createReviewTemplate(_ input: CreateReviewTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReviewTemplateOutput {
        try await self.client.execute(
            operation: "CreateReviewTemplate", 
            path: "/reviewTemplates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a review template.   Disclaimer  Do not include or gather personal identifiable information (PII) of end users or other identifiable individuals in or via your review templates. If your review template or those shared with you and used in your account do include or collect PII you are responsible for: ensuring that the included PII is processed in accordance with applicable law, providing adequate privacy notices, and obtaining necessary consents for processing such data.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - description: The review template description.
    ///   - lenses: Lenses applied to the review template.
    ///   - notes: 
    ///   - tags: The tags assigned to the review template.
    ///   - templateName: Name of the review template.
    ///   - logger: Logger use during operation
    @inlinable
    public func createReviewTemplate(
        clientRequestToken: String? = nil,
        description: String? = nil,
        lenses: [String]? = nil,
        notes: String? = nil,
        tags: [String: String]? = nil,
        templateName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateReviewTemplateOutput {
        let input = CreateReviewTemplateInput(
            clientRequestToken: clientRequestToken, 
            description: description, 
            lenses: lenses, 
            notes: notes, 
            tags: tags, 
            templateName: templateName
        )
        return try await self.createReviewTemplate(input, logger: logger)
    }

    /// Create a review template share. The owner of a review template can share it with other Amazon Web Services accounts, users, an organization, and organizational units (OUs) in the same Amazon Web Services Region.  Shared access to a review template is not removed until the review template share invitation is deleted. If you share a review template with an organization or OU, all accounts in the organization or OU are granted access to the review template.   Disclaimer  By sharing your review template with other Amazon Web Services accounts, you acknowledge that Amazon Web Services will make your review template available to those other accounts.
    @Sendable
    @inlinable
    public func createTemplateShare(_ input: CreateTemplateShareInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTemplateShareOutput {
        try await self.client.execute(
            operation: "CreateTemplateShare", 
            path: "/templates/shares/{TemplateArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a review template share. The owner of a review template can share it with other Amazon Web Services accounts, users, an organization, and organizational units (OUs) in the same Amazon Web Services Region.  Shared access to a review template is not removed until the review template share invitation is deleted. If you share a review template with an organization or OU, all accounts in the organization or OU are granted access to the review template.   Disclaimer  By sharing your review template with other Amazon Web Services accounts, you acknowledge that Amazon Web Services will make your review template available to those other accounts.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - sharedWith: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTemplateShare(
        clientRequestToken: String? = nil,
        sharedWith: String? = nil,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTemplateShareOutput {
        let input = CreateTemplateShareInput(
            clientRequestToken: clientRequestToken, 
            sharedWith: sharedWith, 
            templateArn: templateArn
        )
        return try await self.createTemplateShare(input, logger: logger)
    }

    /// Create a new workload. The owner of a workload can share the workload with other Amazon Web Services accounts, users, an organization, and organizational units (OUs)  in the same Amazon Web Services Region. Only the owner of a workload can delete it. For more information, see Defining a Workload in the Well-Architected Tool User Guide.  Either AwsRegions, NonAwsRegions, or both must be specified when creating a workload. You also must specify ReviewOwner, even though the parameter is listed as not being required in the following section.   When creating a workload using a review template, you must have the following IAM permissions:    wellarchitected:GetReviewTemplate     wellarchitected:GetReviewTemplateAnswer     wellarchitected:ListReviewTemplateAnswers     wellarchitected:GetReviewTemplateLensReview
    @Sendable
    @inlinable
    public func createWorkload(_ input: CreateWorkloadInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkloadOutput {
        try await self.client.execute(
            operation: "CreateWorkload", 
            path: "/workloads", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new workload. The owner of a workload can share the workload with other Amazon Web Services accounts, users, an organization, and organizational units (OUs)  in the same Amazon Web Services Region. Only the owner of a workload can delete it. For more information, see Defining a Workload in the Well-Architected Tool User Guide.  Either AwsRegions, NonAwsRegions, or both must be specified when creating a workload. You also must specify ReviewOwner, even though the parameter is listed as not being required in the following section.   When creating a workload using a review template, you must have the following IAM permissions:    wellarchitected:GetReviewTemplate     wellarchitected:GetReviewTemplateAnswer     wellarchitected:ListReviewTemplateAnswers     wellarchitected:GetReviewTemplateLensReview
    ///
    /// Parameters:
    ///   - accountIds: 
    ///   - applications: List of AppRegistry application ARNs associated to the workload.
    ///   - architecturalDesign: 
    ///   - awsRegions: 
    ///   - clientRequestToken: 
    ///   - description: 
    ///   - discoveryConfig: Well-Architected discovery configuration settings associated to the workload.
    ///   - environment: 
    ///   - industry: 
    ///   - industryType: 
    ///   - jiraConfiguration: Jira configuration settings when creating a workload.
    ///   - lenses: 
    ///   - nonAwsRegions: 
    ///   - notes: 
    ///   - pillarPriorities: 
    ///   - profileArns: The list of profile ARNs associated with the workload.
    ///   - reviewOwner: 
    ///   - reviewTemplateArns: The list of review template ARNs to associate with the workload.
    ///   - tags: The tags to be associated with the workload.
    ///   - workloadName: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkload(
        accountIds: [String]? = nil,
        applications: [String]? = nil,
        architecturalDesign: String? = nil,
        awsRegions: [String]? = nil,
        clientRequestToken: String? = nil,
        description: String? = nil,
        discoveryConfig: WorkloadDiscoveryConfig? = nil,
        environment: WorkloadEnvironment? = nil,
        industry: String? = nil,
        industryType: String? = nil,
        jiraConfiguration: WorkloadJiraConfigurationInput? = nil,
        lenses: [String]? = nil,
        nonAwsRegions: [String]? = nil,
        notes: String? = nil,
        pillarPriorities: [String]? = nil,
        profileArns: [String]? = nil,
        reviewOwner: String? = nil,
        reviewTemplateArns: [String]? = nil,
        tags: [String: String]? = nil,
        workloadName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkloadOutput {
        let input = CreateWorkloadInput(
            accountIds: accountIds, 
            applications: applications, 
            architecturalDesign: architecturalDesign, 
            awsRegions: awsRegions, 
            clientRequestToken: clientRequestToken, 
            description: description, 
            discoveryConfig: discoveryConfig, 
            environment: environment, 
            industry: industry, 
            industryType: industryType, 
            jiraConfiguration: jiraConfiguration, 
            lenses: lenses, 
            nonAwsRegions: nonAwsRegions, 
            notes: notes, 
            pillarPriorities: pillarPriorities, 
            profileArns: profileArns, 
            reviewOwner: reviewOwner, 
            reviewTemplateArns: reviewTemplateArns, 
            tags: tags, 
            workloadName: workloadName
        )
        return try await self.createWorkload(input, logger: logger)
    }

    /// Create a workload share. The owner of a workload can share it with other Amazon Web Services accounts and users in the same Amazon Web Services Region. Shared access to a workload is not removed until the workload invitation is deleted. If you share a workload with an organization or OU, all accounts in the organization or OU are granted access to the workload. For more information, see Sharing a workload in the Well-Architected Tool User Guide.
    @Sendable
    @inlinable
    public func createWorkloadShare(_ input: CreateWorkloadShareInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkloadShareOutput {
        try await self.client.execute(
            operation: "CreateWorkloadShare", 
            path: "/workloads/{WorkloadId}/shares", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a workload share. The owner of a workload can share it with other Amazon Web Services accounts and users in the same Amazon Web Services Region. Shared access to a workload is not removed until the workload invitation is deleted. If you share a workload with an organization or OU, all accounts in the organization or OU are granted access to the workload. For more information, see Sharing a workload in the Well-Architected Tool User Guide.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - permissionType: 
    ///   - sharedWith: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkloadShare(
        clientRequestToken: String? = nil,
        permissionType: PermissionType? = nil,
        sharedWith: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkloadShareOutput {
        let input = CreateWorkloadShareInput(
            clientRequestToken: clientRequestToken, 
            permissionType: permissionType, 
            sharedWith: sharedWith, 
            workloadId: workloadId
        )
        return try await self.createWorkloadShare(input, logger: logger)
    }

    /// Delete an existing lens. Only the owner of a lens can delete it.  After the lens is deleted,  Amazon Web Services accounts and users  that you shared the lens with can continue to use it, but they will no longer be able to apply it to new workloads.    Disclaimer  By sharing your custom lenses with other Amazon Web Services accounts,  you acknowledge that Amazon Web Services will make your custom lenses available to those  other accounts. Those other accounts may continue to access and use your  shared custom lenses even if you delete the custom lenses  from your own Amazon Web Services account or terminate  your Amazon Web Services account.
    @Sendable
    @inlinable
    public func deleteLens(_ input: DeleteLensInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteLens", 
            path: "/lenses/{LensAlias}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete an existing lens. Only the owner of a lens can delete it.  After the lens is deleted,  Amazon Web Services accounts and users  that you shared the lens with can continue to use it, but they will no longer be able to apply it to new workloads.    Disclaimer  By sharing your custom lenses with other Amazon Web Services accounts,  you acknowledge that Amazon Web Services will make your custom lenses available to those  other accounts. Those other accounts may continue to access and use your  shared custom lenses even if you delete the custom lenses  from your own Amazon Web Services account or terminate  your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - lensAlias: 
    ///   - lensStatus: The status of the lens to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLens(
        clientRequestToken: String? = nil,
        lensAlias: String,
        lensStatus: LensStatusType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteLensInput(
            clientRequestToken: clientRequestToken, 
            lensAlias: lensAlias, 
            lensStatus: lensStatus
        )
        return try await self.deleteLens(input, logger: logger)
    }

    /// Delete a lens share. After the lens share is deleted,  Amazon Web Services accounts, users, organizations, and organizational units (OUs)  that you shared the lens with can continue to use it, but they will no longer be able to apply it to new workloads.   Disclaimer  By sharing your custom lenses with other Amazon Web Services accounts,  you acknowledge that Amazon Web Services will make your custom lenses available to those  other accounts. Those other accounts may continue to access and use your  shared custom lenses even if you delete the custom lenses  from your own Amazon Web Services account or terminate  your Amazon Web Services account.
    @Sendable
    @inlinable
    public func deleteLensShare(_ input: DeleteLensShareInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteLensShare", 
            path: "/lenses/{LensAlias}/shares/{ShareId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a lens share. After the lens share is deleted,  Amazon Web Services accounts, users, organizations, and organizational units (OUs)  that you shared the lens with can continue to use it, but they will no longer be able to apply it to new workloads.   Disclaimer  By sharing your custom lenses with other Amazon Web Services accounts,  you acknowledge that Amazon Web Services will make your custom lenses available to those  other accounts. Those other accounts may continue to access and use your  shared custom lenses even if you delete the custom lenses  from your own Amazon Web Services account or terminate  your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - lensAlias: 
    ///   - shareId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLensShare(
        clientRequestToken: String? = nil,
        lensAlias: String,
        shareId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteLensShareInput(
            clientRequestToken: clientRequestToken, 
            lensAlias: lensAlias, 
            shareId: shareId
        )
        return try await self.deleteLensShare(input, logger: logger)
    }

    /// Delete a profile.   Disclaimer  By sharing your profile with other Amazon Web Services accounts,  you acknowledge that Amazon Web Services will make your profile available to those  other accounts. Those other accounts may continue to access and use your  shared profile even if you delete the profile  from your own Amazon Web Services account or terminate  your Amazon Web Services account.
    @Sendable
    @inlinable
    public func deleteProfile(_ input: DeleteProfileInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteProfile", 
            path: "/profiles/{ProfileArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a profile.   Disclaimer  By sharing your profile with other Amazon Web Services accounts,  you acknowledge that Amazon Web Services will make your profile available to those  other accounts. Those other accounts may continue to access and use your  shared profile even if you delete the profile  from your own Amazon Web Services account or terminate  your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - profileArn: The profile ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteProfile(
        clientRequestToken: String? = nil,
        profileArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteProfileInput(
            clientRequestToken: clientRequestToken, 
            profileArn: profileArn
        )
        return try await self.deleteProfile(input, logger: logger)
    }

    /// Delete a profile share.
    @Sendable
    @inlinable
    public func deleteProfileShare(_ input: DeleteProfileShareInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteProfileShare", 
            path: "/profiles/{ProfileArn}/shares/{ShareId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a profile share.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - profileArn: The profile ARN.
    ///   - shareId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteProfileShare(
        clientRequestToken: String? = nil,
        profileArn: String,
        shareId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteProfileShareInput(
            clientRequestToken: clientRequestToken, 
            profileArn: profileArn, 
            shareId: shareId
        )
        return try await self.deleteProfileShare(input, logger: logger)
    }

    /// Delete a review template. Only the owner of a review template can delete it. After the review template is deleted, Amazon Web Services accounts, users, organizations, and organizational units (OUs) that you shared the review template with will no longer be able to apply it to new workloads.
    @Sendable
    @inlinable
    public func deleteReviewTemplate(_ input: DeleteReviewTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteReviewTemplate", 
            path: "/reviewTemplates/{TemplateArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a review template. Only the owner of a review template can delete it. After the review template is deleted, Amazon Web Services accounts, users, organizations, and organizational units (OUs) that you shared the review template with will no longer be able to apply it to new workloads.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReviewTemplate(
        clientRequestToken: String? = nil,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteReviewTemplateInput(
            clientRequestToken: clientRequestToken, 
            templateArn: templateArn
        )
        return try await self.deleteReviewTemplate(input, logger: logger)
    }

    /// Delete a review template share. After the review template share is deleted, Amazon Web Services accounts, users, organizations, and organizational units (OUs) that you shared the review template with will no longer be able to apply it to new workloads.
    @Sendable
    @inlinable
    public func deleteTemplateShare(_ input: DeleteTemplateShareInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteTemplateShare", 
            path: "/templates/shares/{TemplateArn}/{ShareId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a review template share. After the review template share is deleted, Amazon Web Services accounts, users, organizations, and organizational units (OUs) that you shared the review template with will no longer be able to apply it to new workloads.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - shareId: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTemplateShare(
        clientRequestToken: String? = nil,
        shareId: String,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteTemplateShareInput(
            clientRequestToken: clientRequestToken, 
            shareId: shareId, 
            templateArn: templateArn
        )
        return try await self.deleteTemplateShare(input, logger: logger)
    }

    /// Delete an existing workload.
    @Sendable
    @inlinable
    public func deleteWorkload(_ input: DeleteWorkloadInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteWorkload", 
            path: "/workloads/{WorkloadId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete an existing workload.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkload(
        clientRequestToken: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteWorkloadInput(
            clientRequestToken: clientRequestToken, 
            workloadId: workloadId
        )
        return try await self.deleteWorkload(input, logger: logger)
    }

    /// Delete a workload share.
    @Sendable
    @inlinable
    public func deleteWorkloadShare(_ input: DeleteWorkloadShareInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteWorkloadShare", 
            path: "/workloads/{WorkloadId}/shares/{ShareId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a workload share.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - shareId: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkloadShare(
        clientRequestToken: String? = nil,
        shareId: String,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteWorkloadShareInput(
            clientRequestToken: clientRequestToken, 
            shareId: shareId, 
            workloadId: workloadId
        )
        return try await self.deleteWorkloadShare(input, logger: logger)
    }

    /// Disassociate a lens from a workload. Up to 10 lenses can be disassociated from a workload in a single API operation.  The Amazon Web Services Well-Architected Framework lens (wellarchitected) cannot be removed from a workload.
    @Sendable
    @inlinable
    public func disassociateLenses(_ input: DisassociateLensesInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DisassociateLenses", 
            path: "/workloads/{WorkloadId}/disassociateLenses", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociate a lens from a workload. Up to 10 lenses can be disassociated from a workload in a single API operation.  The Amazon Web Services Well-Architected Framework lens (wellarchitected) cannot be removed from a workload.
    ///
    /// Parameters:
    ///   - lensAliases: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateLenses(
        lensAliases: [String]? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DisassociateLensesInput(
            lensAliases: lensAliases, 
            workloadId: workloadId
        )
        return try await self.disassociateLenses(input, logger: logger)
    }

    /// Disassociate a profile from a workload.
    @Sendable
    @inlinable
    public func disassociateProfiles(_ input: DisassociateProfilesInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DisassociateProfiles", 
            path: "/workloads/{WorkloadId}/disassociateProfiles", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociate a profile from a workload.
    ///
    /// Parameters:
    ///   - profileArns: The list of profile ARNs to disassociate from the workload.
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateProfiles(
        profileArns: [String]? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DisassociateProfilesInput(
            profileArns: profileArns, 
            workloadId: workloadId
        )
        return try await self.disassociateProfiles(input, logger: logger)
    }

    /// Export an existing lens. Only the owner of a lens can export it. Lenses provided by Amazon Web Services (Amazon Web Services Official Content)  cannot be exported. Lenses are defined in JSON. For more information, see JSON format specification  in the Well-Architected Tool User Guide.   Disclaimer  Do not include or gather personal identifiable information (PII) of end users or  other identifiable individuals in or via your custom lenses. If your custom  lens or those shared with you and used in your account do include or collect  PII you are responsible for: ensuring that the included PII is processed in accordance  with applicable law, providing adequate privacy notices, and obtaining necessary  consents for processing such data.
    @Sendable
    @inlinable
    public func exportLens(_ input: ExportLensInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ExportLensOutput {
        try await self.client.execute(
            operation: "ExportLens", 
            path: "/lenses/{LensAlias}/export", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Export an existing lens. Only the owner of a lens can export it. Lenses provided by Amazon Web Services (Amazon Web Services Official Content)  cannot be exported. Lenses are defined in JSON. For more information, see JSON format specification  in the Well-Architected Tool User Guide.   Disclaimer  Do not include or gather personal identifiable information (PII) of end users or  other identifiable individuals in or via your custom lenses. If your custom  lens or those shared with you and used in your account do include or collect  PII you are responsible for: ensuring that the included PII is processed in accordance  with applicable law, providing adequate privacy notices, and obtaining necessary  consents for processing such data.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - lensVersion: The lens version to be exported.
    ///   - logger: Logger use during operation
    @inlinable
    public func exportLens(
        lensAlias: String,
        lensVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ExportLensOutput {
        let input = ExportLensInput(
            lensAlias: lensAlias, 
            lensVersion: lensVersion
        )
        return try await self.exportLens(input, logger: logger)
    }

    /// Get the answer to a specific question in a workload review.
    @Sendable
    @inlinable
    public func getAnswer(_ input: GetAnswerInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnswerOutput {
        try await self.client.execute(
            operation: "GetAnswer", 
            path: "/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers/{QuestionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the answer to a specific question in a workload review.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - milestoneNumber: 
    ///   - questionId: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func getAnswer(
        lensAlias: String,
        milestoneNumber: Int? = nil,
        questionId: String,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAnswerOutput {
        let input = GetAnswerInput(
            lensAlias: lensAlias, 
            milestoneNumber: milestoneNumber, 
            questionId: questionId, 
            workloadId: workloadId
        )
        return try await self.getAnswer(input, logger: logger)
    }

    /// Get a consolidated report of your workloads. You can optionally choose to include workloads that have been shared with you.
    @Sendable
    @inlinable
    public func getConsolidatedReport(_ input: GetConsolidatedReportInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetConsolidatedReportOutput {
        try await self.client.execute(
            operation: "GetConsolidatedReport", 
            path: "/consolidatedReport", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a consolidated report of your workloads. You can optionally choose to include workloads that have been shared with you.
    ///
    /// Parameters:
    ///   - format: The format of the consolidated report. For PDF, Base64String is returned. For JSON,  Metrics is returned.
    ///   - includeSharedResources: Set to true to have shared resources included in the report.
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - logger: Logger use during operation
    @inlinable
    public func getConsolidatedReport(
        format: ReportFormat? = nil,
        includeSharedResources: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetConsolidatedReportOutput {
        let input = GetConsolidatedReportInput(
            format: format, 
            includeSharedResources: includeSharedResources, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getConsolidatedReport(input, logger: logger)
    }

    /// Global settings for all workloads.
    @Sendable
    @inlinable
    public func getGlobalSettings(logger: Logger = AWSClient.loggingDisabled) async throws -> GetGlobalSettingsOutput {
        try await self.client.execute(
            operation: "GetGlobalSettings", 
            path: "/global-settings", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            logger: logger
        )
    }

    /// Get an existing lens.
    @Sendable
    @inlinable
    public func getLens(_ input: GetLensInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLensOutput {
        try await self.client.execute(
            operation: "GetLens", 
            path: "/lenses/{LensAlias}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get an existing lens.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - lensVersion: The lens version to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLens(
        lensAlias: String,
        lensVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLensOutput {
        let input = GetLensInput(
            lensAlias: lensAlias, 
            lensVersion: lensVersion
        )
        return try await self.getLens(input, logger: logger)
    }

    /// Get lens review.
    @Sendable
    @inlinable
    public func getLensReview(_ input: GetLensReviewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLensReviewOutput {
        try await self.client.execute(
            operation: "GetLensReview", 
            path: "/workloads/{WorkloadId}/lensReviews/{LensAlias}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get lens review.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - milestoneNumber: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func getLensReview(
        lensAlias: String,
        milestoneNumber: Int? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLensReviewOutput {
        let input = GetLensReviewInput(
            lensAlias: lensAlias, 
            milestoneNumber: milestoneNumber, 
            workloadId: workloadId
        )
        return try await self.getLensReview(input, logger: logger)
    }

    /// Get lens review report.
    @Sendable
    @inlinable
    public func getLensReviewReport(_ input: GetLensReviewReportInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLensReviewReportOutput {
        try await self.client.execute(
            operation: "GetLensReviewReport", 
            path: "/workloads/{WorkloadId}/lensReviews/{LensAlias}/report", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get lens review report.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - milestoneNumber: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func getLensReviewReport(
        lensAlias: String,
        milestoneNumber: Int? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLensReviewReportOutput {
        let input = GetLensReviewReportInput(
            lensAlias: lensAlias, 
            milestoneNumber: milestoneNumber, 
            workloadId: workloadId
        )
        return try await self.getLensReviewReport(input, logger: logger)
    }

    /// Get lens version differences.
    @Sendable
    @inlinable
    public func getLensVersionDifference(_ input: GetLensVersionDifferenceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLensVersionDifferenceOutput {
        try await self.client.execute(
            operation: "GetLensVersionDifference", 
            path: "/lenses/{LensAlias}/versionDifference", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get lens version differences.
    ///
    /// Parameters:
    ///   - baseLensVersion: The base version of the lens.
    ///   - lensAlias: 
    ///   - targetLensVersion: The lens version to target a difference for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLensVersionDifference(
        baseLensVersion: String? = nil,
        lensAlias: String,
        targetLensVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLensVersionDifferenceOutput {
        let input = GetLensVersionDifferenceInput(
            baseLensVersion: baseLensVersion, 
            lensAlias: lensAlias, 
            targetLensVersion: targetLensVersion
        )
        return try await self.getLensVersionDifference(input, logger: logger)
    }

    /// Get a milestone for an existing workload.
    @Sendable
    @inlinable
    public func getMilestone(_ input: GetMilestoneInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMilestoneOutput {
        try await self.client.execute(
            operation: "GetMilestone", 
            path: "/workloads/{WorkloadId}/milestones/{MilestoneNumber}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a milestone for an existing workload.
    ///
    /// Parameters:
    ///   - milestoneNumber: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func getMilestone(
        milestoneNumber: Int,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMilestoneOutput {
        let input = GetMilestoneInput(
            milestoneNumber: milestoneNumber, 
            workloadId: workloadId
        )
        return try await self.getMilestone(input, logger: logger)
    }

    /// Get profile information.
    @Sendable
    @inlinable
    public func getProfile(_ input: GetProfileInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetProfileOutput {
        try await self.client.execute(
            operation: "GetProfile", 
            path: "/profiles/{ProfileArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get profile information.
    ///
    /// Parameters:
    ///   - profileArn: The profile ARN.
    ///   - profileVersion: The profile version.
    ///   - logger: Logger use during operation
    @inlinable
    public func getProfile(
        profileArn: String,
        profileVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetProfileOutput {
        let input = GetProfileInput(
            profileArn: profileArn, 
            profileVersion: profileVersion
        )
        return try await self.getProfile(input, logger: logger)
    }

    /// Get profile template.
    @Sendable
    @inlinable
    public func getProfileTemplate(_ input: GetProfileTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetProfileTemplateOutput {
        try await self.client.execute(
            operation: "GetProfileTemplate", 
            path: "/profileTemplate", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get profile template.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getProfileTemplate(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetProfileTemplateOutput {
        let input = GetProfileTemplateInput(
        )
        return try await self.getProfileTemplate(input, logger: logger)
    }

    /// Get review template.
    @Sendable
    @inlinable
    public func getReviewTemplate(_ input: GetReviewTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReviewTemplateOutput {
        try await self.client.execute(
            operation: "GetReviewTemplate", 
            path: "/reviewTemplates/{TemplateArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get review template.
    ///
    /// Parameters:
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReviewTemplate(
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReviewTemplateOutput {
        let input = GetReviewTemplateInput(
            templateArn: templateArn
        )
        return try await self.getReviewTemplate(input, logger: logger)
    }

    /// Get review template answer.
    @Sendable
    @inlinable
    public func getReviewTemplateAnswer(_ input: GetReviewTemplateAnswerInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReviewTemplateAnswerOutput {
        try await self.client.execute(
            operation: "GetReviewTemplateAnswer", 
            path: "/reviewTemplates/{TemplateArn}/lensReviews/{LensAlias}/answers/{QuestionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get review template answer.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - questionId: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReviewTemplateAnswer(
        lensAlias: String,
        questionId: String,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReviewTemplateAnswerOutput {
        let input = GetReviewTemplateAnswerInput(
            lensAlias: lensAlias, 
            questionId: questionId, 
            templateArn: templateArn
        )
        return try await self.getReviewTemplateAnswer(input, logger: logger)
    }

    /// Get a lens review associated with a review template.
    @Sendable
    @inlinable
    public func getReviewTemplateLensReview(_ input: GetReviewTemplateLensReviewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReviewTemplateLensReviewOutput {
        try await self.client.execute(
            operation: "GetReviewTemplateLensReview", 
            path: "/reviewTemplates/{TemplateArn}/lensReviews/{LensAlias}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a lens review associated with a review template.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReviewTemplateLensReview(
        lensAlias: String,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReviewTemplateLensReviewOutput {
        let input = GetReviewTemplateLensReviewInput(
            lensAlias: lensAlias, 
            templateArn: templateArn
        )
        return try await self.getReviewTemplateLensReview(input, logger: logger)
    }

    /// Get an existing workload.
    @Sendable
    @inlinable
    public func getWorkload(_ input: GetWorkloadInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkloadOutput {
        try await self.client.execute(
            operation: "GetWorkload", 
            path: "/workloads/{WorkloadId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get an existing workload.
    ///
    /// Parameters:
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkload(
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkloadOutput {
        let input = GetWorkloadInput(
            workloadId: workloadId
        )
        return try await self.getWorkload(input, logger: logger)
    }

    /// Import a new custom lens or update an existing custom lens. To update an existing custom lens, specify its ARN as the  LensAlias. If no ARN is specified, a new custom lens is created. The new or updated lens will have a status of DRAFT. The lens cannot be applied to workloads or shared with other Amazon Web Services accounts until it's published with CreateLensVersion. Lenses are defined in JSON. For more information, see JSON format specification  in the Well-Architected Tool User Guide. A custom lens cannot exceed 500 KB in size.   Disclaimer  Do not include or gather personal identifiable information (PII) of end users or  other identifiable individuals in or via your custom lenses. If your custom  lens or those shared with you and used in your account do include or collect  PII you are responsible for: ensuring that the included PII is processed in accordance  with applicable law, providing adequate privacy notices, and obtaining necessary  consents for processing such data.
    @Sendable
    @inlinable
    public func importLens(_ input: ImportLensInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportLensOutput {
        try await self.client.execute(
            operation: "ImportLens", 
            path: "/importLens", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Import a new custom lens or update an existing custom lens. To update an existing custom lens, specify its ARN as the  LensAlias. If no ARN is specified, a new custom lens is created. The new or updated lens will have a status of DRAFT. The lens cannot be applied to workloads or shared with other Amazon Web Services accounts until it's published with CreateLensVersion. Lenses are defined in JSON. For more information, see JSON format specification  in the Well-Architected Tool User Guide. A custom lens cannot exceed 500 KB in size.   Disclaimer  Do not include or gather personal identifiable information (PII) of end users or  other identifiable individuals in or via your custom lenses. If your custom  lens or those shared with you and used in your account do include or collect  PII you are responsible for: ensuring that the included PII is processed in accordance  with applicable law, providing adequate privacy notices, and obtaining necessary  consents for processing such data.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - jsonString: The JSON representation of a lens.
    ///   - lensAlias: 
    ///   - tags: Tags to associate to a lens.
    ///   - logger: Logger use during operation
    @inlinable
    public func importLens(
        clientRequestToken: String? = nil,
        jsonString: String? = nil,
        lensAlias: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportLensOutput {
        let input = ImportLensInput(
            clientRequestToken: clientRequestToken, 
            jsonString: jsonString, 
            lensAlias: lensAlias, 
            tags: tags
        )
        return try await self.importLens(input, logger: logger)
    }

    /// List of answers for a particular workload and lens.
    @Sendable
    @inlinable
    public func listAnswers(_ input: ListAnswersInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnswersOutput {
        try await self.client.execute(
            operation: "ListAnswers", 
            path: "/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List of answers for a particular workload and lens.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - milestoneNumber: 
    ///   - nextToken: 
    ///   - pillarId: 
    ///   - questionPriority: The priority of the question.
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listAnswers(
        lensAlias: String,
        maxResults: Int? = nil,
        milestoneNumber: Int? = nil,
        nextToken: String? = nil,
        pillarId: String? = nil,
        questionPriority: QuestionPriority? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAnswersOutput {
        let input = ListAnswersInput(
            lensAlias: lensAlias, 
            maxResults: maxResults, 
            milestoneNumber: milestoneNumber, 
            nextToken: nextToken, 
            pillarId: pillarId, 
            questionPriority: questionPriority, 
            workloadId: workloadId
        )
        return try await self.listAnswers(input, logger: logger)
    }

    /// List of Trusted Advisor check details by account related to the workload.
    @Sendable
    @inlinable
    public func listCheckDetails(_ input: ListCheckDetailsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCheckDetailsOutput {
        try await self.client.execute(
            operation: "ListCheckDetails", 
            path: "/workloads/{WorkloadId}/checks", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List of Trusted Advisor check details by account related to the workload.
    ///
    /// Parameters:
    ///   - choiceId: 
    ///   - lensArn: Well-Architected Lens ARN.
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - pillarId: 
    ///   - questionId: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listCheckDetails(
        choiceId: String? = nil,
        lensArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pillarId: String? = nil,
        questionId: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCheckDetailsOutput {
        let input = ListCheckDetailsInput(
            choiceId: choiceId, 
            lensArn: lensArn, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            pillarId: pillarId, 
            questionId: questionId, 
            workloadId: workloadId
        )
        return try await self.listCheckDetails(input, logger: logger)
    }

    /// List of Trusted Advisor checks summarized for all accounts related to the workload.
    @Sendable
    @inlinable
    public func listCheckSummaries(_ input: ListCheckSummariesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCheckSummariesOutput {
        try await self.client.execute(
            operation: "ListCheckSummaries", 
            path: "/workloads/{WorkloadId}/checkSummaries", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List of Trusted Advisor checks summarized for all accounts related to the workload.
    ///
    /// Parameters:
    ///   - choiceId: 
    ///   - lensArn: Well-Architected Lens ARN.
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - pillarId: 
    ///   - questionId: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listCheckSummaries(
        choiceId: String? = nil,
        lensArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pillarId: String? = nil,
        questionId: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCheckSummariesOutput {
        let input = ListCheckSummariesInput(
            choiceId: choiceId, 
            lensArn: lensArn, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            pillarId: pillarId, 
            questionId: questionId, 
            workloadId: workloadId
        )
        return try await self.listCheckSummaries(input, logger: logger)
    }

    /// List the improvements of a particular lens review.
    @Sendable
    @inlinable
    public func listLensReviewImprovements(_ input: ListLensReviewImprovementsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLensReviewImprovementsOutput {
        try await self.client.execute(
            operation: "ListLensReviewImprovements", 
            path: "/workloads/{WorkloadId}/lensReviews/{LensAlias}/improvements", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the improvements of a particular lens review.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - milestoneNumber: 
    ///   - nextToken: 
    ///   - pillarId: 
    ///   - questionPriority: The priority of the question.
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listLensReviewImprovements(
        lensAlias: String,
        maxResults: Int? = nil,
        milestoneNumber: Int? = nil,
        nextToken: String? = nil,
        pillarId: String? = nil,
        questionPriority: QuestionPriority? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLensReviewImprovementsOutput {
        let input = ListLensReviewImprovementsInput(
            lensAlias: lensAlias, 
            maxResults: maxResults, 
            milestoneNumber: milestoneNumber, 
            nextToken: nextToken, 
            pillarId: pillarId, 
            questionPriority: questionPriority, 
            workloadId: workloadId
        )
        return try await self.listLensReviewImprovements(input, logger: logger)
    }

    /// List lens reviews for a particular workload.
    @Sendable
    @inlinable
    public func listLensReviews(_ input: ListLensReviewsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLensReviewsOutput {
        try await self.client.execute(
            operation: "ListLensReviews", 
            path: "/workloads/{WorkloadId}/lensReviews", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List lens reviews for a particular workload.
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - milestoneNumber: 
    ///   - nextToken: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listLensReviews(
        maxResults: Int? = nil,
        milestoneNumber: Int? = nil,
        nextToken: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLensReviewsOutput {
        let input = ListLensReviewsInput(
            maxResults: maxResults, 
            milestoneNumber: milestoneNumber, 
            nextToken: nextToken, 
            workloadId: workloadId
        )
        return try await self.listLensReviews(input, logger: logger)
    }

    /// List the lens shares associated with the lens.
    @Sendable
    @inlinable
    public func listLensShares(_ input: ListLensSharesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLensSharesOutput {
        try await self.client.execute(
            operation: "ListLensShares", 
            path: "/lenses/{LensAlias}/shares", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the lens shares associated with the lens.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - sharedWithPrefix: The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the lens is shared.
    ///   - status: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listLensShares(
        lensAlias: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sharedWithPrefix: String? = nil,
        status: ShareStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLensSharesOutput {
        let input = ListLensSharesInput(
            lensAlias: lensAlias, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sharedWithPrefix: sharedWithPrefix, 
            status: status
        )
        return try await self.listLensShares(input, logger: logger)
    }

    /// List the available lenses.
    @Sendable
    @inlinable
    public func listLenses(_ input: ListLensesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLensesOutput {
        try await self.client.execute(
            operation: "ListLenses", 
            path: "/lenses", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the available lenses.
    ///
    /// Parameters:
    ///   - lensName: 
    ///   - lensStatus: The status of lenses to be returned.
    ///   - lensType: The type of lenses to be returned.
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listLenses(
        lensName: String? = nil,
        lensStatus: LensStatusType? = nil,
        lensType: LensType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLensesOutput {
        let input = ListLensesInput(
            lensName: lensName, 
            lensStatus: lensStatus, 
            lensType: lensType, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listLenses(input, logger: logger)
    }

    /// List all milestones for an existing workload.
    @Sendable
    @inlinable
    public func listMilestones(_ input: ListMilestonesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMilestonesOutput {
        try await self.client.execute(
            operation: "ListMilestones", 
            path: "/workloads/{WorkloadId}/milestonesSummaries", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all milestones for an existing workload.
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listMilestones(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMilestonesOutput {
        let input = ListMilestonesInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            workloadId: workloadId
        )
        return try await self.listMilestones(input, logger: logger)
    }

    /// List lens notifications.
    @Sendable
    @inlinable
    public func listNotifications(_ input: ListNotificationsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListNotificationsOutput {
        try await self.client.execute(
            operation: "ListNotifications", 
            path: "/notifications", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List lens notifications.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - resourceArn: The ARN for the related resource for the notification.  Only one of WorkloadID or ResourceARN should be specified.
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listNotifications(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil,
        workloadId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListNotificationsOutput {
        let input = ListNotificationsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceArn: resourceArn, 
            workloadId: workloadId
        )
        return try await self.listNotifications(input, logger: logger)
    }

    /// List profile notifications.
    @Sendable
    @inlinable
    public func listProfileNotifications(_ input: ListProfileNotificationsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListProfileNotificationsOutput {
        try await self.client.execute(
            operation: "ListProfileNotifications", 
            path: "/profileNotifications", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List profile notifications.
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listProfileNotifications(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workloadId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListProfileNotificationsOutput {
        let input = ListProfileNotificationsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            workloadId: workloadId
        )
        return try await self.listProfileNotifications(input, logger: logger)
    }

    /// List profile shares.
    @Sendable
    @inlinable
    public func listProfileShares(_ input: ListProfileSharesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListProfileSharesOutput {
        try await self.client.execute(
            operation: "ListProfileShares", 
            path: "/profiles/{ProfileArn}/shares", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List profile shares.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - profileArn: The profile ARN.
    ///   - sharedWithPrefix: The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the profile is shared.
    ///   - status: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listProfileShares(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        profileArn: String,
        sharedWithPrefix: String? = nil,
        status: ShareStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListProfileSharesOutput {
        let input = ListProfileSharesInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            profileArn: profileArn, 
            sharedWithPrefix: sharedWithPrefix, 
            status: status
        )
        return try await self.listProfileShares(input, logger: logger)
    }

    /// List profiles.
    @Sendable
    @inlinable
    public func listProfiles(_ input: ListProfilesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListProfilesOutput {
        try await self.client.execute(
            operation: "ListProfiles", 
            path: "/profileSummaries", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List profiles.
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - profileNamePrefix: An optional string added to the beginning of each profile name returned in the results.
    ///   - profileOwnerType: Profile owner type.
    ///   - logger: Logger use during operation
    @inlinable
    public func listProfiles(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        profileNamePrefix: String? = nil,
        profileOwnerType: ProfileOwnerType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListProfilesOutput {
        let input = ListProfilesInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            profileNamePrefix: profileNamePrefix, 
            profileOwnerType: profileOwnerType
        )
        return try await self.listProfiles(input, logger: logger)
    }

    /// List the answers of a review template.
    @Sendable
    @inlinable
    public func listReviewTemplateAnswers(_ input: ListReviewTemplateAnswersInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReviewTemplateAnswersOutput {
        try await self.client.execute(
            operation: "ListReviewTemplateAnswers", 
            path: "/reviewTemplates/{TemplateArn}/lensReviews/{LensAlias}/answers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the answers of a review template.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - pillarId: 
    ///   - templateArn: The ARN of the review template.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReviewTemplateAnswers(
        lensAlias: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pillarId: String? = nil,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReviewTemplateAnswersOutput {
        let input = ListReviewTemplateAnswersInput(
            lensAlias: lensAlias, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            pillarId: pillarId, 
            templateArn: templateArn
        )
        return try await self.listReviewTemplateAnswers(input, logger: logger)
    }

    /// List review templates.
    @Sendable
    @inlinable
    public func listReviewTemplates(_ input: ListReviewTemplatesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReviewTemplatesOutput {
        try await self.client.execute(
            operation: "ListReviewTemplates", 
            path: "/reviewTemplates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List review templates.
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listReviewTemplates(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReviewTemplatesOutput {
        let input = ListReviewTemplatesInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listReviewTemplates(input, logger: logger)
    }

    /// List the share invitations.  WorkloadNamePrefix, LensNamePrefix, ProfileNamePrefix, and TemplateNamePrefix are mutually exclusive. Use the parameter that matches your ShareResourceType.
    @Sendable
    @inlinable
    public func listShareInvitations(_ input: ListShareInvitationsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListShareInvitationsOutput {
        try await self.client.execute(
            operation: "ListShareInvitations", 
            path: "/shareInvitations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the share invitations.  WorkloadNamePrefix, LensNamePrefix, ProfileNamePrefix, and TemplateNamePrefix are mutually exclusive. Use the parameter that matches your ShareResourceType.
    ///
    /// Parameters:
    ///   - lensNamePrefix: An optional string added to the beginning of each lens name returned in the results.
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - profileNamePrefix: An optional string added to the beginning of each profile name returned in the results.
    ///   - shareResourceType: The type of share invitations to be returned.
    ///   - templateNamePrefix: An optional string added to the beginning of each review template name returned in the results.
    ///   - workloadNamePrefix: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listShareInvitations(
        lensNamePrefix: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        profileNamePrefix: String? = nil,
        shareResourceType: ShareResourceType? = nil,
        templateNamePrefix: String? = nil,
        workloadNamePrefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListShareInvitationsOutput {
        let input = ListShareInvitationsInput(
            lensNamePrefix: lensNamePrefix, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            profileNamePrefix: profileNamePrefix, 
            shareResourceType: shareResourceType, 
            templateNamePrefix: templateNamePrefix, 
            workloadNamePrefix: workloadNamePrefix
        )
        return try await self.listShareInvitations(input, logger: logger)
    }

    /// List the tags for a resource.  The WorkloadArn parameter can be a workload ARN, a custom lens ARN, a profile ARN, or review template ARN.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceOutput {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{WorkloadArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the tags for a resource.  The WorkloadArn parameter can be a workload ARN, a custom lens ARN, a profile ARN, or review template ARN.
    ///
    /// Parameters:
    ///   - workloadArn: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        workloadArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceOutput {
        let input = ListTagsForResourceInput(
            workloadArn: workloadArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// List review template shares.
    @Sendable
    @inlinable
    public func listTemplateShares(_ input: ListTemplateSharesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTemplateSharesOutput {
        try await self.client.execute(
            operation: "ListTemplateShares", 
            path: "/templates/shares/{TemplateArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List review template shares.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - sharedWithPrefix: The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the profile is shared.
    ///   - status: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTemplateShares(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sharedWithPrefix: String? = nil,
        status: ShareStatus? = nil,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTemplateSharesOutput {
        let input = ListTemplateSharesInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            sharedWithPrefix: sharedWithPrefix, 
            status: status, 
            templateArn: templateArn
        )
        return try await self.listTemplateShares(input, logger: logger)
    }

    /// List the workload shares associated with the workload.
    @Sendable
    @inlinable
    public func listWorkloadShares(_ input: ListWorkloadSharesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkloadSharesOutput {
        try await self.client.execute(
            operation: "ListWorkloadShares", 
            path: "/workloads/{WorkloadId}/shares", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the workload shares associated with the workload.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - sharedWithPrefix: The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload is shared.
    ///   - status: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkloadShares(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sharedWithPrefix: String? = nil,
        status: ShareStatus? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkloadSharesOutput {
        let input = ListWorkloadSharesInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            sharedWithPrefix: sharedWithPrefix, 
            status: status, 
            workloadId: workloadId
        )
        return try await self.listWorkloadShares(input, logger: logger)
    }

    /// Paginated list of workloads.
    @Sendable
    @inlinable
    public func listWorkloads(_ input: ListWorkloadsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkloadsOutput {
        try await self.client.execute(
            operation: "ListWorkloads", 
            path: "/workloadsSummaries", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Paginated list of workloads.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - nextToken: 
    ///   - workloadNamePrefix: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkloads(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workloadNamePrefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkloadsOutput {
        let input = ListWorkloadsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            workloadNamePrefix: workloadNamePrefix
        )
        return try await self.listWorkloads(input, logger: logger)
    }

    /// Adds one or more tags to the specified resource.  The WorkloadArn parameter can be a workload ARN, a custom lens ARN, a profile ARN, or review template ARN.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceOutput {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{WorkloadArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds one or more tags to the specified resource.  The WorkloadArn parameter can be a workload ARN, a custom lens ARN, a profile ARN, or review template ARN.
    ///
    /// Parameters:
    ///   - tags: The tags for the resource.
    ///   - workloadArn: 
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        tags: [String: String]? = nil,
        workloadArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceOutput {
        let input = TagResourceInput(
            tags: tags, 
            workloadArn: workloadArn
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Deletes specified tags from a resource.  The WorkloadArn parameter can be a workload ARN, a custom lens ARN, a profile ARN, or review template ARN.  To specify multiple tags, use separate tagKeys parameters, for example:  DELETE /tags/WorkloadArn?tagKeys=key1&tagKeys=key2
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceOutput {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{WorkloadArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes specified tags from a resource.  The WorkloadArn parameter can be a workload ARN, a custom lens ARN, a profile ARN, or review template ARN.  To specify multiple tags, use separate tagKeys parameters, for example:  DELETE /tags/WorkloadArn?tagKeys=key1&tagKeys=key2
    ///
    /// Parameters:
    ///   - tagKeys: A list of tag keys. Existing tags of the resource  whose keys are members of this list are removed from the resource.
    ///   - workloadArn: 
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        tagKeys: [String]? = nil,
        workloadArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceOutput {
        let input = UntagResourceInput(
            tagKeys: tagKeys, 
            workloadArn: workloadArn
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Update the answer to a specific question in a workload review.
    @Sendable
    @inlinable
    public func updateAnswer(_ input: UpdateAnswerInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAnswerOutput {
        try await self.client.execute(
            operation: "UpdateAnswer", 
            path: "/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers/{QuestionId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update the answer to a specific question in a workload review.
    ///
    /// Parameters:
    ///   - choiceUpdates: A list of choices to update on a question in your workload.  The String key  corresponds to the choice ID to be updated.
    ///   - isApplicable: 
    ///   - lensAlias: 
    ///   - notes: 
    ///   - questionId: 
    ///   - reason: The reason why a question is not applicable to your workload.
    ///   - selectedChoices: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAnswer(
        choiceUpdates: [String: ChoiceUpdate]? = nil,
        isApplicable: Bool? = nil,
        lensAlias: String,
        notes: String? = nil,
        questionId: String,
        reason: AnswerReason? = nil,
        selectedChoices: [String]? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAnswerOutput {
        let input = UpdateAnswerInput(
            choiceUpdates: choiceUpdates, 
            isApplicable: isApplicable, 
            lensAlias: lensAlias, 
            notes: notes, 
            questionId: questionId, 
            reason: reason, 
            selectedChoices: selectedChoices, 
            workloadId: workloadId
        )
        return try await self.updateAnswer(input, logger: logger)
    }

    /// Update whether the Amazon Web Services account is opted into organization sharing and discovery integration features.
    @Sendable
    @inlinable
    public func updateGlobalSettings(_ input: UpdateGlobalSettingsInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateGlobalSettings", 
            path: "/global-settings", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update whether the Amazon Web Services account is opted into organization sharing and discovery integration features.
    ///
    /// Parameters:
    ///   - discoveryIntegrationStatus: The status of discovery support settings.
    ///   - jiraConfiguration: The status of Jira integration settings.
    ///   - organizationSharingStatus: The status of organization sharing settings.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateGlobalSettings(
        discoveryIntegrationStatus: DiscoveryIntegrationStatus? = nil,
        jiraConfiguration: AccountJiraConfigurationInput? = nil,
        organizationSharingStatus: OrganizationSharingStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateGlobalSettingsInput(
            discoveryIntegrationStatus: discoveryIntegrationStatus, 
            jiraConfiguration: jiraConfiguration, 
            organizationSharingStatus: organizationSharingStatus
        )
        return try await self.updateGlobalSettings(input, logger: logger)
    }

    /// Update integration features.
    @Sendable
    @inlinable
    public func updateIntegration(_ input: UpdateIntegrationInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateIntegration", 
            path: "/workloads/{WorkloadId}/updateIntegration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update integration features.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - integratingService: Which integrated service to update.
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIntegration(
        clientRequestToken: String? = nil,
        integratingService: IntegratingService? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateIntegrationInput(
            clientRequestToken: clientRequestToken, 
            integratingService: integratingService, 
            workloadId: workloadId
        )
        return try await self.updateIntegration(input, logger: logger)
    }

    /// Update lens review for a particular workload.
    @Sendable
    @inlinable
    public func updateLensReview(_ input: UpdateLensReviewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLensReviewOutput {
        try await self.client.execute(
            operation: "UpdateLensReview", 
            path: "/workloads/{WorkloadId}/lensReviews/{LensAlias}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update lens review for a particular workload.
    ///
    /// Parameters:
    ///   - jiraConfiguration: Configuration of the Jira integration.
    ///   - lensAlias: 
    ///   - lensNotes: 
    ///   - pillarNotes: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLensReview(
        jiraConfiguration: JiraSelectedQuestionConfiguration? = nil,
        lensAlias: String,
        lensNotes: String? = nil,
        pillarNotes: [String: String]? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLensReviewOutput {
        let input = UpdateLensReviewInput(
            jiraConfiguration: jiraConfiguration, 
            lensAlias: lensAlias, 
            lensNotes: lensNotes, 
            pillarNotes: pillarNotes, 
            workloadId: workloadId
        )
        return try await self.updateLensReview(input, logger: logger)
    }

    /// Update a profile.
    @Sendable
    @inlinable
    public func updateProfile(_ input: UpdateProfileInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateProfileOutput {
        try await self.client.execute(
            operation: "UpdateProfile", 
            path: "/profiles/{ProfileArn}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a profile.
    ///
    /// Parameters:
    ///   - profileArn: The profile ARN.
    ///   - profileDescription: The profile description.
    ///   - profileQuestions: Profile questions.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateProfile(
        profileArn: String,
        profileDescription: String? = nil,
        profileQuestions: [ProfileQuestionUpdate]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateProfileOutput {
        let input = UpdateProfileInput(
            profileArn: profileArn, 
            profileDescription: profileDescription, 
            profileQuestions: profileQuestions
        )
        return try await self.updateProfile(input, logger: logger)
    }

    /// Update a review template.
    @Sendable
    @inlinable
    public func updateReviewTemplate(_ input: UpdateReviewTemplateInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateReviewTemplateOutput {
        try await self.client.execute(
            operation: "UpdateReviewTemplate", 
            path: "/reviewTemplates/{TemplateArn}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a review template.
    ///
    /// Parameters:
    ///   - description: The review template description.
    ///   - lensesToAssociate: A list of lens aliases or ARNs to apply to the review template.
    ///   - lensesToDisassociate: A list of lens aliases or ARNs to unapply to the review template. The wellarchitected lens cannot be unapplied.
    ///   - notes: 
    ///   - templateArn: The review template ARN.
    ///   - templateName: The review template name.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReviewTemplate(
        description: String? = nil,
        lensesToAssociate: [String]? = nil,
        lensesToDisassociate: [String]? = nil,
        notes: String? = nil,
        templateArn: String,
        templateName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateReviewTemplateOutput {
        let input = UpdateReviewTemplateInput(
            description: description, 
            lensesToAssociate: lensesToAssociate, 
            lensesToDisassociate: lensesToDisassociate, 
            notes: notes, 
            templateArn: templateArn, 
            templateName: templateName
        )
        return try await self.updateReviewTemplate(input, logger: logger)
    }

    /// Update a review template answer.
    @Sendable
    @inlinable
    public func updateReviewTemplateAnswer(_ input: UpdateReviewTemplateAnswerInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateReviewTemplateAnswerOutput {
        try await self.client.execute(
            operation: "UpdateReviewTemplateAnswer", 
            path: "/reviewTemplates/{TemplateArn}/lensReviews/{LensAlias}/answers/{QuestionId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a review template answer.
    ///
    /// Parameters:
    ///   - choiceUpdates: A list of choices to be updated.
    ///   - isApplicable: 
    ///   - lensAlias: 
    ///   - notes: 
    ///   - questionId: 
    ///   - reason: The update reason.
    ///   - selectedChoices: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReviewTemplateAnswer(
        choiceUpdates: [String: ChoiceUpdate]? = nil,
        isApplicable: Bool? = nil,
        lensAlias: String,
        notes: String? = nil,
        questionId: String,
        reason: AnswerReason? = nil,
        selectedChoices: [String]? = nil,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateReviewTemplateAnswerOutput {
        let input = UpdateReviewTemplateAnswerInput(
            choiceUpdates: choiceUpdates, 
            isApplicable: isApplicable, 
            lensAlias: lensAlias, 
            notes: notes, 
            questionId: questionId, 
            reason: reason, 
            selectedChoices: selectedChoices, 
            templateArn: templateArn
        )
        return try await self.updateReviewTemplateAnswer(input, logger: logger)
    }

    /// Update a lens review associated with a review template.
    @Sendable
    @inlinable
    public func updateReviewTemplateLensReview(_ input: UpdateReviewTemplateLensReviewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateReviewTemplateLensReviewOutput {
        try await self.client.execute(
            operation: "UpdateReviewTemplateLensReview", 
            path: "/reviewTemplates/{TemplateArn}/lensReviews/{LensAlias}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a lens review associated with a review template.
    ///
    /// Parameters:
    ///   - lensAlias: 
    ///   - lensNotes: 
    ///   - pillarNotes: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReviewTemplateLensReview(
        lensAlias: String,
        lensNotes: String? = nil,
        pillarNotes: [String: String]? = nil,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateReviewTemplateLensReviewOutput {
        let input = UpdateReviewTemplateLensReviewInput(
            lensAlias: lensAlias, 
            lensNotes: lensNotes, 
            pillarNotes: pillarNotes, 
            templateArn: templateArn
        )
        return try await self.updateReviewTemplateLensReview(input, logger: logger)
    }

    /// Update a workload or custom lens share invitation.  This API operation can be called independently of any resource. Previous documentation implied that a workload ARN must be specified.
    @Sendable
    @inlinable
    public func updateShareInvitation(_ input: UpdateShareInvitationInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateShareInvitationOutput {
        try await self.client.execute(
            operation: "UpdateShareInvitation", 
            path: "/shareInvitations/{ShareInvitationId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a workload or custom lens share invitation.  This API operation can be called independently of any resource. Previous documentation implied that a workload ARN must be specified.
    ///
    /// Parameters:
    ///   - shareInvitationAction: 
    ///   - shareInvitationId: The ID assigned to the share invitation.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateShareInvitation(
        shareInvitationAction: ShareInvitationAction? = nil,
        shareInvitationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateShareInvitationOutput {
        let input = UpdateShareInvitationInput(
            shareInvitationAction: shareInvitationAction, 
            shareInvitationId: shareInvitationId
        )
        return try await self.updateShareInvitation(input, logger: logger)
    }

    /// Update an existing workload.
    @Sendable
    @inlinable
    public func updateWorkload(_ input: UpdateWorkloadInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateWorkloadOutput {
        try await self.client.execute(
            operation: "UpdateWorkload", 
            path: "/workloads/{WorkloadId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update an existing workload.
    ///
    /// Parameters:
    ///   - accountIds: 
    ///   - applications: List of AppRegistry application ARNs to associate to the workload.
    ///   - architecturalDesign: 
    ///   - awsRegions: 
    ///   - description: 
    ///   - discoveryConfig: Well-Architected discovery configuration settings to associate to the workload.
    ///   - environment: 
    ///   - improvementStatus: 
    ///   - industry: 
    ///   - industryType: 
    ///   - isReviewOwnerUpdateAcknowledged: Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
    ///   - jiraConfiguration: Configuration of the Jira integration.
    ///   - nonAwsRegions: 
    ///   - notes: 
    ///   - pillarPriorities: 
    ///   - reviewOwner: 
    ///   - workloadId: 
    ///   - workloadName: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorkload(
        accountIds: [String]? = nil,
        applications: [String]? = nil,
        architecturalDesign: String? = nil,
        awsRegions: [String]? = nil,
        description: String? = nil,
        discoveryConfig: WorkloadDiscoveryConfig? = nil,
        environment: WorkloadEnvironment? = nil,
        improvementStatus: WorkloadImprovementStatus? = nil,
        industry: String? = nil,
        industryType: String? = nil,
        isReviewOwnerUpdateAcknowledged: Bool? = nil,
        jiraConfiguration: WorkloadJiraConfigurationInput? = nil,
        nonAwsRegions: [String]? = nil,
        notes: String? = nil,
        pillarPriorities: [String]? = nil,
        reviewOwner: String? = nil,
        workloadId: String,
        workloadName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateWorkloadOutput {
        let input = UpdateWorkloadInput(
            accountIds: accountIds, 
            applications: applications, 
            architecturalDesign: architecturalDesign, 
            awsRegions: awsRegions, 
            description: description, 
            discoveryConfig: discoveryConfig, 
            environment: environment, 
            improvementStatus: improvementStatus, 
            industry: industry, 
            industryType: industryType, 
            isReviewOwnerUpdateAcknowledged: isReviewOwnerUpdateAcknowledged, 
            jiraConfiguration: jiraConfiguration, 
            nonAwsRegions: nonAwsRegions, 
            notes: notes, 
            pillarPriorities: pillarPriorities, 
            reviewOwner: reviewOwner, 
            workloadId: workloadId, 
            workloadName: workloadName
        )
        return try await self.updateWorkload(input, logger: logger)
    }

    /// Update a workload share.
    @Sendable
    @inlinable
    public func updateWorkloadShare(_ input: UpdateWorkloadShareInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateWorkloadShareOutput {
        try await self.client.execute(
            operation: "UpdateWorkloadShare", 
            path: "/workloads/{WorkloadId}/shares/{ShareId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a workload share.
    ///
    /// Parameters:
    ///   - permissionType: 
    ///   - shareId: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorkloadShare(
        permissionType: PermissionType? = nil,
        shareId: String,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateWorkloadShareOutput {
        let input = UpdateWorkloadShareInput(
            permissionType: permissionType, 
            shareId: shareId, 
            workloadId: workloadId
        )
        return try await self.updateWorkloadShare(input, logger: logger)
    }

    /// Upgrade lens review for a particular workload.
    @Sendable
    @inlinable
    public func upgradeLensReview(_ input: UpgradeLensReviewInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpgradeLensReview", 
            path: "/workloads/{WorkloadId}/lensReviews/{LensAlias}/upgrade", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Upgrade lens review for a particular workload.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - lensAlias: 
    ///   - milestoneName: 
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func upgradeLensReview(
        clientRequestToken: String? = nil,
        lensAlias: String,
        milestoneName: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpgradeLensReviewInput(
            clientRequestToken: clientRequestToken, 
            lensAlias: lensAlias, 
            milestoneName: milestoneName, 
            workloadId: workloadId
        )
        return try await self.upgradeLensReview(input, logger: logger)
    }

    /// Upgrade a profile.
    @Sendable
    @inlinable
    public func upgradeProfileVersion(_ input: UpgradeProfileVersionInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpgradeProfileVersion", 
            path: "/workloads/{WorkloadId}/profiles/{ProfileArn}/upgrade", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Upgrade a profile.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - milestoneName: 
    ///   - profileArn: The profile ARN.
    ///   - workloadId: 
    ///   - logger: Logger use during operation
    @inlinable
    public func upgradeProfileVersion(
        clientRequestToken: String? = UpgradeProfileVersionInput.idempotencyToken(),
        milestoneName: String? = nil,
        profileArn: String,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpgradeProfileVersionInput(
            clientRequestToken: clientRequestToken, 
            milestoneName: milestoneName, 
            profileArn: profileArn, 
            workloadId: workloadId
        )
        return try await self.upgradeProfileVersion(input, logger: logger)
    }

    /// Upgrade the lens review of a review template.
    @Sendable
    @inlinable
    public func upgradeReviewTemplateLensReview(_ input: UpgradeReviewTemplateLensReviewInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpgradeReviewTemplateLensReview", 
            path: "/reviewTemplates/{TemplateArn}/lensReviews/{LensAlias}/upgrade", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Upgrade the lens review of a review template.
    ///
    /// Parameters:
    ///   - clientRequestToken: 
    ///   - lensAlias: 
    ///   - templateArn: The ARN of the review template.
    ///   - logger: Logger use during operation
    @inlinable
    public func upgradeReviewTemplateLensReview(
        clientRequestToken: String? = nil,
        lensAlias: String,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpgradeReviewTemplateLensReviewInput(
            clientRequestToken: clientRequestToken, 
            lensAlias: lensAlias, 
            templateArn: templateArn
        )
        return try await self.upgradeReviewTemplateLensReview(input, logger: logger)
    }
}

extension WellArchitected {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: WellArchitected, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension WellArchitected {
    /// Return PaginatorSequence for operation ``getConsolidatedReport(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getConsolidatedReportPaginator(
        _ input: GetConsolidatedReportInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetConsolidatedReportInput, GetConsolidatedReportOutput> {
        return .init(
            input: input,
            command: self.getConsolidatedReport,
            inputKey: \GetConsolidatedReportInput.nextToken,
            outputKey: \GetConsolidatedReportOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getConsolidatedReport(_:logger:)``.
    ///
    /// - Parameters:
    ///   - format: The format of the consolidated report. For PDF, Base64String is returned. For JSON,  Metrics is returned.
    ///   - includeSharedResources: Set to true to have shared resources included in the report.
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func getConsolidatedReportPaginator(
        format: ReportFormat? = nil,
        includeSharedResources: Bool? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetConsolidatedReportInput, GetConsolidatedReportOutput> {
        let input = GetConsolidatedReportInput(
            format: format, 
            includeSharedResources: includeSharedResources, 
            maxResults: maxResults
        )
        return self.getConsolidatedReportPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAnswers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAnswersPaginator(
        _ input: ListAnswersInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAnswersInput, ListAnswersOutput> {
        return .init(
            input: input,
            command: self.listAnswers,
            inputKey: \ListAnswersInput.nextToken,
            outputKey: \ListAnswersOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAnswers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - lensAlias: 
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - milestoneNumber: 
    ///   - pillarId: 
    ///   - questionPriority: The priority of the question.
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listAnswersPaginator(
        lensAlias: String,
        maxResults: Int? = nil,
        milestoneNumber: Int? = nil,
        pillarId: String? = nil,
        questionPriority: QuestionPriority? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAnswersInput, ListAnswersOutput> {
        let input = ListAnswersInput(
            lensAlias: lensAlias, 
            maxResults: maxResults, 
            milestoneNumber: milestoneNumber, 
            pillarId: pillarId, 
            questionPriority: questionPriority, 
            workloadId: workloadId
        )
        return self.listAnswersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCheckDetails(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCheckDetailsPaginator(
        _ input: ListCheckDetailsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCheckDetailsInput, ListCheckDetailsOutput> {
        return .init(
            input: input,
            command: self.listCheckDetails,
            inputKey: \ListCheckDetailsInput.nextToken,
            outputKey: \ListCheckDetailsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCheckDetails(_:logger:)``.
    ///
    /// - Parameters:
    ///   - choiceId: 
    ///   - lensArn: Well-Architected Lens ARN.
    ///   - maxResults: 
    ///   - pillarId: 
    ///   - questionId: 
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listCheckDetailsPaginator(
        choiceId: String? = nil,
        lensArn: String? = nil,
        maxResults: Int? = nil,
        pillarId: String? = nil,
        questionId: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCheckDetailsInput, ListCheckDetailsOutput> {
        let input = ListCheckDetailsInput(
            choiceId: choiceId, 
            lensArn: lensArn, 
            maxResults: maxResults, 
            pillarId: pillarId, 
            questionId: questionId, 
            workloadId: workloadId
        )
        return self.listCheckDetailsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCheckSummaries(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCheckSummariesPaginator(
        _ input: ListCheckSummariesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCheckSummariesInput, ListCheckSummariesOutput> {
        return .init(
            input: input,
            command: self.listCheckSummaries,
            inputKey: \ListCheckSummariesInput.nextToken,
            outputKey: \ListCheckSummariesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCheckSummaries(_:logger:)``.
    ///
    /// - Parameters:
    ///   - choiceId: 
    ///   - lensArn: Well-Architected Lens ARN.
    ///   - maxResults: 
    ///   - pillarId: 
    ///   - questionId: 
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listCheckSummariesPaginator(
        choiceId: String? = nil,
        lensArn: String? = nil,
        maxResults: Int? = nil,
        pillarId: String? = nil,
        questionId: String? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCheckSummariesInput, ListCheckSummariesOutput> {
        let input = ListCheckSummariesInput(
            choiceId: choiceId, 
            lensArn: lensArn, 
            maxResults: maxResults, 
            pillarId: pillarId, 
            questionId: questionId, 
            workloadId: workloadId
        )
        return self.listCheckSummariesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLensReviewImprovements(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLensReviewImprovementsPaginator(
        _ input: ListLensReviewImprovementsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLensReviewImprovementsInput, ListLensReviewImprovementsOutput> {
        return .init(
            input: input,
            command: self.listLensReviewImprovements,
            inputKey: \ListLensReviewImprovementsInput.nextToken,
            outputKey: \ListLensReviewImprovementsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLensReviewImprovements(_:logger:)``.
    ///
    /// - Parameters:
    ///   - lensAlias: 
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - milestoneNumber: 
    ///   - pillarId: 
    ///   - questionPriority: The priority of the question.
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listLensReviewImprovementsPaginator(
        lensAlias: String,
        maxResults: Int? = nil,
        milestoneNumber: Int? = nil,
        pillarId: String? = nil,
        questionPriority: QuestionPriority? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLensReviewImprovementsInput, ListLensReviewImprovementsOutput> {
        let input = ListLensReviewImprovementsInput(
            lensAlias: lensAlias, 
            maxResults: maxResults, 
            milestoneNumber: milestoneNumber, 
            pillarId: pillarId, 
            questionPriority: questionPriority, 
            workloadId: workloadId
        )
        return self.listLensReviewImprovementsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLensReviews(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLensReviewsPaginator(
        _ input: ListLensReviewsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLensReviewsInput, ListLensReviewsOutput> {
        return .init(
            input: input,
            command: self.listLensReviews,
            inputKey: \ListLensReviewsInput.nextToken,
            outputKey: \ListLensReviewsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLensReviews(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - milestoneNumber: 
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listLensReviewsPaginator(
        maxResults: Int? = nil,
        milestoneNumber: Int? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLensReviewsInput, ListLensReviewsOutput> {
        let input = ListLensReviewsInput(
            maxResults: maxResults, 
            milestoneNumber: milestoneNumber, 
            workloadId: workloadId
        )
        return self.listLensReviewsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLensShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLensSharesPaginator(
        _ input: ListLensSharesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLensSharesInput, ListLensSharesOutput> {
        return .init(
            input: input,
            command: self.listLensShares,
            inputKey: \ListLensSharesInput.nextToken,
            outputKey: \ListLensSharesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLensShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - lensAlias: 
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - sharedWithPrefix: The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the lens is shared.
    ///   - status: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listLensSharesPaginator(
        lensAlias: String,
        maxResults: Int? = nil,
        sharedWithPrefix: String? = nil,
        status: ShareStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLensSharesInput, ListLensSharesOutput> {
        let input = ListLensSharesInput(
            lensAlias: lensAlias, 
            maxResults: maxResults, 
            sharedWithPrefix: sharedWithPrefix, 
            status: status
        )
        return self.listLensSharesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLenses(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLensesPaginator(
        _ input: ListLensesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLensesInput, ListLensesOutput> {
        return .init(
            input: input,
            command: self.listLenses,
            inputKey: \ListLensesInput.nextToken,
            outputKey: \ListLensesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLenses(_:logger:)``.
    ///
    /// - Parameters:
    ///   - lensName: 
    ///   - lensStatus: The status of lenses to be returned.
    ///   - lensType: The type of lenses to be returned.
    ///   - maxResults: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listLensesPaginator(
        lensName: String? = nil,
        lensStatus: LensStatusType? = nil,
        lensType: LensType? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLensesInput, ListLensesOutput> {
        let input = ListLensesInput(
            lensName: lensName, 
            lensStatus: lensStatus, 
            lensType: lensType, 
            maxResults: maxResults
        )
        return self.listLensesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMilestones(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMilestonesPaginator(
        _ input: ListMilestonesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMilestonesInput, ListMilestonesOutput> {
        return .init(
            input: input,
            command: self.listMilestones,
            inputKey: \ListMilestonesInput.nextToken,
            outputKey: \ListMilestonesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMilestones(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listMilestonesPaginator(
        maxResults: Int? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMilestonesInput, ListMilestonesOutput> {
        let input = ListMilestonesInput(
            maxResults: maxResults, 
            workloadId: workloadId
        )
        return self.listMilestonesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listNotifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listNotificationsPaginator(
        _ input: ListNotificationsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListNotificationsInput, ListNotificationsOutput> {
        return .init(
            input: input,
            command: self.listNotifications,
            inputKey: \ListNotificationsInput.nextToken,
            outputKey: \ListNotificationsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listNotifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - resourceArn: The ARN for the related resource for the notification.  Only one of WorkloadID or ResourceARN should be specified.
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listNotificationsPaginator(
        maxResults: Int? = nil,
        resourceArn: String? = nil,
        workloadId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListNotificationsInput, ListNotificationsOutput> {
        let input = ListNotificationsInput(
            maxResults: maxResults, 
            resourceArn: resourceArn, 
            workloadId: workloadId
        )
        return self.listNotificationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listProfileNotifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listProfileNotificationsPaginator(
        _ input: ListProfileNotificationsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListProfileNotificationsInput, ListProfileNotificationsOutput> {
        return .init(
            input: input,
            command: self.listProfileNotifications,
            inputKey: \ListProfileNotificationsInput.nextToken,
            outputKey: \ListProfileNotificationsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listProfileNotifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listProfileNotificationsPaginator(
        maxResults: Int? = nil,
        workloadId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListProfileNotificationsInput, ListProfileNotificationsOutput> {
        let input = ListProfileNotificationsInput(
            maxResults: maxResults, 
            workloadId: workloadId
        )
        return self.listProfileNotificationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listProfileShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listProfileSharesPaginator(
        _ input: ListProfileSharesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListProfileSharesInput, ListProfileSharesOutput> {
        return .init(
            input: input,
            command: self.listProfileShares,
            inputKey: \ListProfileSharesInput.nextToken,
            outputKey: \ListProfileSharesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listProfileShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - profileArn: The profile ARN.
    ///   - sharedWithPrefix: The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the profile is shared.
    ///   - status: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listProfileSharesPaginator(
        maxResults: Int? = nil,
        profileArn: String,
        sharedWithPrefix: String? = nil,
        status: ShareStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListProfileSharesInput, ListProfileSharesOutput> {
        let input = ListProfileSharesInput(
            maxResults: maxResults, 
            profileArn: profileArn, 
            sharedWithPrefix: sharedWithPrefix, 
            status: status
        )
        return self.listProfileSharesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listProfilesPaginator(
        _ input: ListProfilesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListProfilesInput, ListProfilesOutput> {
        return .init(
            input: input,
            command: self.listProfiles,
            inputKey: \ListProfilesInput.nextToken,
            outputKey: \ListProfilesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - profileNamePrefix: An optional string added to the beginning of each profile name returned in the results.
    ///   - profileOwnerType: Profile owner type.
    ///   - logger: Logger used for logging
    @inlinable
    public func listProfilesPaginator(
        maxResults: Int? = nil,
        profileNamePrefix: String? = nil,
        profileOwnerType: ProfileOwnerType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListProfilesInput, ListProfilesOutput> {
        let input = ListProfilesInput(
            maxResults: maxResults, 
            profileNamePrefix: profileNamePrefix, 
            profileOwnerType: profileOwnerType
        )
        return self.listProfilesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReviewTemplateAnswers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReviewTemplateAnswersPaginator(
        _ input: ListReviewTemplateAnswersInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReviewTemplateAnswersInput, ListReviewTemplateAnswersOutput> {
        return .init(
            input: input,
            command: self.listReviewTemplateAnswers,
            inputKey: \ListReviewTemplateAnswersInput.nextToken,
            outputKey: \ListReviewTemplateAnswersOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReviewTemplateAnswers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - lensAlias: 
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - pillarId: 
    ///   - templateArn: The ARN of the review template.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReviewTemplateAnswersPaginator(
        lensAlias: String,
        maxResults: Int? = nil,
        pillarId: String? = nil,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReviewTemplateAnswersInput, ListReviewTemplateAnswersOutput> {
        let input = ListReviewTemplateAnswersInput(
            lensAlias: lensAlias, 
            maxResults: maxResults, 
            pillarId: pillarId, 
            templateArn: templateArn
        )
        return self.listReviewTemplateAnswersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReviewTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReviewTemplatesPaginator(
        _ input: ListReviewTemplatesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReviewTemplatesInput, ListReviewTemplatesOutput> {
        return .init(
            input: input,
            command: self.listReviewTemplates,
            inputKey: \ListReviewTemplatesInput.nextToken,
            outputKey: \ListReviewTemplatesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReviewTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listReviewTemplatesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReviewTemplatesInput, ListReviewTemplatesOutput> {
        let input = ListReviewTemplatesInput(
            maxResults: maxResults
        )
        return self.listReviewTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listShareInvitations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listShareInvitationsPaginator(
        _ input: ListShareInvitationsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListShareInvitationsInput, ListShareInvitationsOutput> {
        return .init(
            input: input,
            command: self.listShareInvitations,
            inputKey: \ListShareInvitationsInput.nextToken,
            outputKey: \ListShareInvitationsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listShareInvitations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - lensNamePrefix: An optional string added to the beginning of each lens name returned in the results.
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - profileNamePrefix: An optional string added to the beginning of each profile name returned in the results.
    ///   - shareResourceType: The type of share invitations to be returned.
    ///   - templateNamePrefix: An optional string added to the beginning of each review template name returned in the results.
    ///   - workloadNamePrefix: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listShareInvitationsPaginator(
        lensNamePrefix: String? = nil,
        maxResults: Int? = nil,
        profileNamePrefix: String? = nil,
        shareResourceType: ShareResourceType? = nil,
        templateNamePrefix: String? = nil,
        workloadNamePrefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListShareInvitationsInput, ListShareInvitationsOutput> {
        let input = ListShareInvitationsInput(
            lensNamePrefix: lensNamePrefix, 
            maxResults: maxResults, 
            profileNamePrefix: profileNamePrefix, 
            shareResourceType: shareResourceType, 
            templateNamePrefix: templateNamePrefix, 
            workloadNamePrefix: workloadNamePrefix
        )
        return self.listShareInvitationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTemplateShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTemplateSharesPaginator(
        _ input: ListTemplateSharesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTemplateSharesInput, ListTemplateSharesOutput> {
        return .init(
            input: input,
            command: self.listTemplateShares,
            inputKey: \ListTemplateSharesInput.nextToken,
            outputKey: \ListTemplateSharesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTemplateShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - sharedWithPrefix: The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the profile is shared.
    ///   - status: 
    ///   - templateArn: The review template ARN.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTemplateSharesPaginator(
        maxResults: Int? = nil,
        sharedWithPrefix: String? = nil,
        status: ShareStatus? = nil,
        templateArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTemplateSharesInput, ListTemplateSharesOutput> {
        let input = ListTemplateSharesInput(
            maxResults: maxResults, 
            sharedWithPrefix: sharedWithPrefix, 
            status: status, 
            templateArn: templateArn
        )
        return self.listTemplateSharesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkloadShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadSharesPaginator(
        _ input: ListWorkloadSharesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkloadSharesInput, ListWorkloadSharesOutput> {
        return .init(
            input: input,
            command: self.listWorkloadShares,
            inputKey: \ListWorkloadSharesInput.nextToken,
            outputKey: \ListWorkloadSharesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkloadShares(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - sharedWithPrefix: The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload is shared.
    ///   - status: 
    ///   - workloadId: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadSharesPaginator(
        maxResults: Int? = nil,
        sharedWithPrefix: String? = nil,
        status: ShareStatus? = nil,
        workloadId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkloadSharesInput, ListWorkloadSharesOutput> {
        let input = ListWorkloadSharesInput(
            maxResults: maxResults, 
            sharedWithPrefix: sharedWithPrefix, 
            status: status, 
            workloadId: workloadId
        )
        return self.listWorkloadSharesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkloads(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadsPaginator(
        _ input: ListWorkloadsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkloadsInput, ListWorkloadsOutput> {
        return .init(
            input: input,
            command: self.listWorkloads,
            inputKey: \ListWorkloadsInput.nextToken,
            outputKey: \ListWorkloadsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkloads(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return for this request.
    ///   - workloadNamePrefix: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadsPaginator(
        maxResults: Int? = nil,
        workloadNamePrefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkloadsInput, ListWorkloadsOutput> {
        let input = ListWorkloadsInput(
            maxResults: maxResults, 
            workloadNamePrefix: workloadNamePrefix
        )
        return self.listWorkloadsPaginator(input, logger: logger)
    }
}

extension WellArchitected.GetConsolidatedReportInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.GetConsolidatedReportInput {
        return .init(
            format: self.format,
            includeSharedResources: self.includeSharedResources,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension WellArchitected.ListAnswersInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListAnswersInput {
        return .init(
            lensAlias: self.lensAlias,
            maxResults: self.maxResults,
            milestoneNumber: self.milestoneNumber,
            nextToken: token,
            pillarId: self.pillarId,
            questionPriority: self.questionPriority,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListCheckDetailsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListCheckDetailsInput {
        return .init(
            choiceId: self.choiceId,
            lensArn: self.lensArn,
            maxResults: self.maxResults,
            nextToken: token,
            pillarId: self.pillarId,
            questionId: self.questionId,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListCheckSummariesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListCheckSummariesInput {
        return .init(
            choiceId: self.choiceId,
            lensArn: self.lensArn,
            maxResults: self.maxResults,
            nextToken: token,
            pillarId: self.pillarId,
            questionId: self.questionId,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListLensReviewImprovementsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListLensReviewImprovementsInput {
        return .init(
            lensAlias: self.lensAlias,
            maxResults: self.maxResults,
            milestoneNumber: self.milestoneNumber,
            nextToken: token,
            pillarId: self.pillarId,
            questionPriority: self.questionPriority,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListLensReviewsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListLensReviewsInput {
        return .init(
            maxResults: self.maxResults,
            milestoneNumber: self.milestoneNumber,
            nextToken: token,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListLensSharesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListLensSharesInput {
        return .init(
            lensAlias: self.lensAlias,
            maxResults: self.maxResults,
            nextToken: token,
            sharedWithPrefix: self.sharedWithPrefix,
            status: self.status
        )
    }
}

extension WellArchitected.ListLensesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListLensesInput {
        return .init(
            lensName: self.lensName,
            lensStatus: self.lensStatus,
            lensType: self.lensType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension WellArchitected.ListMilestonesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListMilestonesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListNotificationsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListNotificationsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListProfileNotificationsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListProfileNotificationsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListProfileSharesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListProfileSharesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            profileArn: self.profileArn,
            sharedWithPrefix: self.sharedWithPrefix,
            status: self.status
        )
    }
}

extension WellArchitected.ListProfilesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListProfilesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            profileNamePrefix: self.profileNamePrefix,
            profileOwnerType: self.profileOwnerType
        )
    }
}

extension WellArchitected.ListReviewTemplateAnswersInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListReviewTemplateAnswersInput {
        return .init(
            lensAlias: self.lensAlias,
            maxResults: self.maxResults,
            nextToken: token,
            pillarId: self.pillarId,
            templateArn: self.templateArn
        )
    }
}

extension WellArchitected.ListReviewTemplatesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListReviewTemplatesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension WellArchitected.ListShareInvitationsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListShareInvitationsInput {
        return .init(
            lensNamePrefix: self.lensNamePrefix,
            maxResults: self.maxResults,
            nextToken: token,
            profileNamePrefix: self.profileNamePrefix,
            shareResourceType: self.shareResourceType,
            templateNamePrefix: self.templateNamePrefix,
            workloadNamePrefix: self.workloadNamePrefix
        )
    }
}

extension WellArchitected.ListTemplateSharesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListTemplateSharesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sharedWithPrefix: self.sharedWithPrefix,
            status: self.status,
            templateArn: self.templateArn
        )
    }
}

extension WellArchitected.ListWorkloadSharesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListWorkloadSharesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sharedWithPrefix: self.sharedWithPrefix,
            status: self.status,
            workloadId: self.workloadId
        )
    }
}

extension WellArchitected.ListWorkloadsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WellArchitected.ListWorkloadsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workloadNamePrefix: self.workloadNamePrefix
        )
    }
}
