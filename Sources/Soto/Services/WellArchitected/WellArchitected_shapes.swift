//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension WellArchitected {
    // MARK: Enums

    public enum AdditionalResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case helpfulResource = "HELPFUL_RESOURCE"
        case improvementPlan = "IMPROVEMENT_PLAN"
        public var description: String { return self.rawValue }
    }

    public enum AnswerReason: String, CustomStringConvertible, Codable, _SotoSendable {
        case architectureConstraints = "ARCHITECTURE_CONSTRAINTS"
        case businessPriorities = "BUSINESS_PRIORITIES"
        case none = "NONE"
        case other = "OTHER"
        case outOfScope = "OUT_OF_SCOPE"
        public var description: String { return self.rawValue }
    }

    public enum CheckFailureReason: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case assumeRoleError = "ASSUME_ROLE_ERROR"
        case premiumSupportRequired = "PREMIUM_SUPPORT_REQUIRED"
        case unknownError = "UNKNOWN_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum CheckProvider: String, CustomStringConvertible, Codable, _SotoSendable {
        case trustedAdvisor = "TRUSTED_ADVISOR"
        public var description: String { return self.rawValue }
    }

    public enum CheckStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case error = "ERROR"
        case fetchFailed = "FETCH_FAILED"
        case notAvailable = "NOT_AVAILABLE"
        case okay = "OKAY"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum ChoiceReason: String, CustomStringConvertible, Codable, _SotoSendable {
        case architectureConstraints = "ARCHITECTURE_CONSTRAINTS"
        case businessPriorities = "BUSINESS_PRIORITIES"
        case none = "NONE"
        case other = "OTHER"
        case outOfScope = "OUT_OF_SCOPE"
        public var description: String { return self.rawValue }
    }

    public enum ChoiceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case notApplicable = "NOT_APPLICABLE"
        case selected = "SELECTED"
        case unselected = "UNSELECTED"
        public var description: String { return self.rawValue }
    }

    public enum DifferenceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleted = "DELETED"
        case new = "NEW"
        case updated = "UPDATED"
        public var description: String { return self.rawValue }
    }

    public enum ImportLensStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case complete = "COMPLETE"
        case error = "ERROR"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum LensStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case current = "CURRENT"
        case deleted = "DELETED"
        case deprecated = "DEPRECATED"
        case notCurrent = "NOT_CURRENT"
        case unshared = "UNSHARED"
        public var description: String { return self.rawValue }
    }

    public enum LensStatusType: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case draft = "DRAFT"
        case published = "PUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum LensType: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsOfficial = "AWS_OFFICIAL"
        case customSelf = "CUSTOM_SELF"
        case customShared = "CUSTOM_SHARED"
        public var description: String { return self.rawValue }
    }

    public enum NotificationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case lensVersionDeprecated = "LENS_VERSION_DEPRECATED"
        case lensVersionUpgraded = "LENS_VERSION_UPGRADED"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationSharingStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PermissionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case contributor = "CONTRIBUTOR"
        case readonly = "READONLY"
        public var description: String { return self.rawValue }
    }

    public enum Risk: String, CustomStringConvertible, Codable, _SotoSendable {
        case high = "HIGH"
        case medium = "MEDIUM"
        case none = "NONE"
        case notApplicable = "NOT_APPLICABLE"
        case unanswered = "UNANSWERED"
        public var description: String { return self.rawValue }
    }

    public enum ShareInvitationAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case accept = "ACCEPT"
        case reject = "REJECT"
        public var description: String { return self.rawValue }
    }

    public enum ShareResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case lens = "LENS"
        case workload = "WORKLOAD"
        public var description: String { return self.rawValue }
    }

    public enum ShareStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case accepted = "ACCEPTED"
        case associated = "ASSOCIATED"
        case associating = "ASSOCIATING"
        case expired = "EXPIRED"
        case failed = "FAILED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        case revoked = "REVOKED"
        public var description: String { return self.rawValue }
    }

    public enum TrustedAdvisorIntegrationStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadEnvironment: String, CustomStringConvertible, Codable, _SotoSendable {
        case preproduction = "PREPRODUCTION"
        case production = "PRODUCTION"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadImprovementStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case complete = "COMPLETE"
        case inProgress = "IN_PROGRESS"
        case notApplicable = "NOT_APPLICABLE"
        case notStarted = "NOT_STARTED"
        case riskAcknowledged = "RISK_ACKNOWLEDGED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AdditionalResources: AWSDecodableShape {
        /// The URLs for additional resources, either helpful resources or improvement plans. Up to five additional URLs can be specified.
        public let content: [ChoiceContent]?
        /// Type of additional resource.
        public let type: AdditionalResourceType?

        public init(content: [ChoiceContent]? = nil, type: AdditionalResourceType? = nil) {
            self.content = content
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case type = "Type"
        }
    }

    public struct Answer: AWSDecodableShape {
        /// A list of selected choices to a question in your workload.
        public let choiceAnswers: [ChoiceAnswer]?
        public let choices: [Choice]?
        /// The helpful resource text to be displayed.
        public let helpfulResourceDisplayText: String?
        public let helpfulResourceUrl: String?
        public let improvementPlanUrl: String?
        public let isApplicable: Bool?
        public let notes: String?
        public let pillarId: String?
        public let questionDescription: String?
        public let questionId: String?
        public let questionTitle: String?
        /// The reason why the question is not applicable to your workload.
        public let reason: AnswerReason?
        public let risk: Risk?
        public let selectedChoices: [String]?

        public init(choiceAnswers: [ChoiceAnswer]? = nil, choices: [Choice]? = nil, helpfulResourceDisplayText: String? = nil, helpfulResourceUrl: String? = nil, improvementPlanUrl: String? = nil, isApplicable: Bool? = nil, notes: String? = nil, pillarId: String? = nil, questionDescription: String? = nil, questionId: String? = nil, questionTitle: String? = nil, reason: AnswerReason? = nil, risk: Risk? = nil, selectedChoices: [String]? = nil) {
            self.choiceAnswers = choiceAnswers
            self.choices = choices
            self.helpfulResourceDisplayText = helpfulResourceDisplayText
            self.helpfulResourceUrl = helpfulResourceUrl
            self.improvementPlanUrl = improvementPlanUrl
            self.isApplicable = isApplicable
            self.notes = notes
            self.pillarId = pillarId
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }

        private enum CodingKeys: String, CodingKey {
            case choiceAnswers = "ChoiceAnswers"
            case choices = "Choices"
            case helpfulResourceDisplayText = "HelpfulResourceDisplayText"
            case helpfulResourceUrl = "HelpfulResourceUrl"
            case improvementPlanUrl = "ImprovementPlanUrl"
            case isApplicable = "IsApplicable"
            case notes = "Notes"
            case pillarId = "PillarId"
            case questionDescription = "QuestionDescription"
            case questionId = "QuestionId"
            case questionTitle = "QuestionTitle"
            case reason = "Reason"
            case risk = "Risk"
            case selectedChoices = "SelectedChoices"
        }
    }

    public struct AnswerSummary: AWSDecodableShape {
        /// A list of selected choices to a question in your workload.
        public let choiceAnswerSummaries: [ChoiceAnswerSummary]?
        public let choices: [Choice]?
        public let isApplicable: Bool?
        public let pillarId: String?
        public let questionId: String?
        public let questionTitle: String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public let reason: AnswerReason?
        public let risk: Risk?
        public let selectedChoices: [String]?

        public init(choiceAnswerSummaries: [ChoiceAnswerSummary]? = nil, choices: [Choice]? = nil, isApplicable: Bool? = nil, pillarId: String? = nil, questionId: String? = nil, questionTitle: String? = nil, reason: AnswerReason? = nil, risk: Risk? = nil, selectedChoices: [String]? = nil) {
            self.choiceAnswerSummaries = choiceAnswerSummaries
            self.choices = choices
            self.isApplicable = isApplicable
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }

        private enum CodingKeys: String, CodingKey {
            case choiceAnswerSummaries = "ChoiceAnswerSummaries"
            case choices = "Choices"
            case isApplicable = "IsApplicable"
            case pillarId = "PillarId"
            case questionId = "QuestionId"
            case questionTitle = "QuestionTitle"
            case reason = "Reason"
            case risk = "Risk"
            case selectedChoices = "SelectedChoices"
        }
    }

    public struct AssociateLensesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let lensAliases: [String]
        public let workloadId: String

        public init(lensAliases: [String], workloadId: String) {
            self.lensAliases = lensAliases
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.lensAliases.forEach {
                try validate($0, name: "lensAliases[]", parent: name, max: 128)
                try validate($0, name: "lensAliases[]", parent: name, min: 1)
            }
            try self.validate(self.lensAliases, name: "lensAliases", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lensAliases = "LensAliases"
        }
    }

    public struct CheckDetail: AWSDecodableShape {
        public let accountId: String?
        public let choiceId: String?
        /// Trusted Advisor check description.
        public let description: String?
        /// Count of flagged resources associated to the check.
        public let flaggedResources: Int?
        /// Trusted Advisor check ID.
        public let id: String?
        /// Well-Architected Lens ARN associated to the check.
        public let lensArn: String?
        /// Trusted Advisor check name.
        public let name: String?
        public let pillarId: String?
        /// Provider of the check related to the best practice.
        public let provider: CheckProvider?
        public let questionId: String?
        /// Reason associated to the check.
        public let reason: CheckFailureReason?
        /// Status associated to the check.
        public let status: CheckStatus?
        public let updatedAt: Date?

        public init(accountId: String? = nil, choiceId: String? = nil, description: String? = nil, flaggedResources: Int? = nil, id: String? = nil, lensArn: String? = nil, name: String? = nil, pillarId: String? = nil, provider: CheckProvider? = nil, questionId: String? = nil, reason: CheckFailureReason? = nil, status: CheckStatus? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.choiceId = choiceId
            self.description = description
            self.flaggedResources = flaggedResources
            self.id = id
            self.lensArn = lensArn
            self.name = name
            self.pillarId = pillarId
            self.provider = provider
            self.questionId = questionId
            self.reason = reason
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case choiceId = "ChoiceId"
            case description = "Description"
            case flaggedResources = "FlaggedResources"
            case id = "Id"
            case lensArn = "LensArn"
            case name = "Name"
            case pillarId = "PillarId"
            case provider = "Provider"
            case questionId = "QuestionId"
            case reason = "Reason"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CheckSummary: AWSDecodableShape {
        /// Account summary associated to the check.
        public let accountSummary: [CheckStatus: Int]?
        public let choiceId: String?
        /// Trusted Advisor check description.
        public let description: String?
        /// Trusted Advisor check ID.
        public let id: String?
        /// Well-Architected Lens ARN associated to the check.
        public let lensArn: String?
        /// Trusted Advisor check name.
        public let name: String?
        public let pillarId: String?
        /// Provider of the check related to the best practice.
        public let provider: CheckProvider?
        public let questionId: String?
        /// Status associated to the check.
        public let status: CheckStatus?
        public let updatedAt: Date?

        public init(accountSummary: [CheckStatus: Int]? = nil, choiceId: String? = nil, description: String? = nil, id: String? = nil, lensArn: String? = nil, name: String? = nil, pillarId: String? = nil, provider: CheckProvider? = nil, questionId: String? = nil, status: CheckStatus? = nil, updatedAt: Date? = nil) {
            self.accountSummary = accountSummary
            self.choiceId = choiceId
            self.description = description
            self.id = id
            self.lensArn = lensArn
            self.name = name
            self.pillarId = pillarId
            self.provider = provider
            self.questionId = questionId
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountSummary = "AccountSummary"
            case choiceId = "ChoiceId"
            case description = "Description"
            case id = "Id"
            case lensArn = "LensArn"
            case name = "Name"
            case pillarId = "PillarId"
            case provider = "Provider"
            case questionId = "QuestionId"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct Choice: AWSDecodableShape {
        /// The additional resources for a choice. A choice can have up to two additional resources: one of type HELPFUL_RESOURCE,  one of type IMPROVEMENT_PLAN, or both.
        public let additionalResources: [AdditionalResources]?
        public let choiceId: String?
        public let description: String?
        /// The choice level helpful resource.
        public let helpfulResource: ChoiceContent?
        /// The choice level improvement plan.
        public let improvementPlan: ChoiceContent?
        public let title: String?

        public init(additionalResources: [AdditionalResources]? = nil, choiceId: String? = nil, description: String? = nil, helpfulResource: ChoiceContent? = nil, improvementPlan: ChoiceContent? = nil, title: String? = nil) {
            self.additionalResources = additionalResources
            self.choiceId = choiceId
            self.description = description
            self.helpfulResource = helpfulResource
            self.improvementPlan = improvementPlan
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case additionalResources = "AdditionalResources"
            case choiceId = "ChoiceId"
            case description = "Description"
            case helpfulResource = "HelpfulResource"
            case improvementPlan = "ImprovementPlan"
            case title = "Title"
        }
    }

    public struct ChoiceAnswer: AWSDecodableShape {
        public let choiceId: String?
        /// The notes associated with a choice.
        public let notes: String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public let reason: ChoiceReason?
        /// The status of a choice.
        public let status: ChoiceStatus?

        public init(choiceId: String? = nil, notes: String? = nil, reason: ChoiceReason? = nil, status: ChoiceStatus? = nil) {
            self.choiceId = choiceId
            self.notes = notes
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case choiceId = "ChoiceId"
            case notes = "Notes"
            case reason = "Reason"
            case status = "Status"
        }
    }

    public struct ChoiceAnswerSummary: AWSDecodableShape {
        public let choiceId: String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public let reason: ChoiceReason?
        /// The status of a choice.
        public let status: ChoiceStatus?

        public init(choiceId: String? = nil, reason: ChoiceReason? = nil, status: ChoiceStatus? = nil) {
            self.choiceId = choiceId
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case choiceId = "ChoiceId"
            case reason = "Reason"
            case status = "Status"
        }
    }

    public struct ChoiceContent: AWSDecodableShape {
        /// The display text for the choice content.
        public let displayText: String?
        /// The URL for the choice content.
        public let url: String?

        public init(displayText: String? = nil, url: String? = nil) {
            self.displayText = displayText
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case displayText = "DisplayText"
            case url = "Url"
        }
    }

    public struct ChoiceImprovementPlan: AWSDecodableShape {
        public let choiceId: String?
        /// The display text for the improvement plan.
        public let displayText: String?
        public let improvementPlanUrl: String?

        public init(choiceId: String? = nil, displayText: String? = nil, improvementPlanUrl: String? = nil) {
            self.choiceId = choiceId
            self.displayText = displayText
            self.improvementPlanUrl = improvementPlanUrl
        }

        private enum CodingKeys: String, CodingKey {
            case choiceId = "ChoiceId"
            case displayText = "DisplayText"
            case improvementPlanUrl = "ImprovementPlanUrl"
        }
    }

    public struct ChoiceUpdate: AWSEncodableShape {
        /// The notes associated with a choice.
        public let notes: String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public let reason: ChoiceReason?
        /// The status of a choice.
        public let status: ChoiceStatus

        public init(notes: String? = nil, reason: ChoiceReason? = nil, status: ChoiceStatus) {
            self.notes = notes
            self.reason = reason
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.notes, name: "notes", parent: name, max: 250)
        }

        private enum CodingKeys: String, CodingKey {
            case notes = "Notes"
            case reason = "Reason"
            case status = "Status"
        }
    }

    public struct CreateLensShareInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias"))
        ]

        public let clientRequestToken: String
        public let lensAlias: String
        public let sharedWith: String

        public init(clientRequestToken: String = CreateLensShareInput.idempotencyToken(), lensAlias: String, sharedWith: String) {
            self.clientRequestToken = clientRequestToken
            self.lensAlias = lensAlias
            self.sharedWith = sharedWith
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.sharedWith, name: "sharedWith", parent: name, max: 2048)
            try self.validate(self.sharedWith, name: "sharedWith", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case sharedWith = "SharedWith"
        }
    }

    public struct CreateLensShareOutput: AWSDecodableShape {
        public let shareId: String?

        public init(shareId: String? = nil) {
            self.shareId = shareId
        }

        private enum CodingKeys: String, CodingKey {
            case shareId = "ShareId"
        }
    }

    public struct CreateLensVersionInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias"))
        ]

        public let clientRequestToken: String
        /// Set to true if this new major lens version.
        public let isMajorVersion: Bool?
        public let lensAlias: String
        /// The version of the lens being created.
        public let lensVersion: String

        public init(clientRequestToken: String = CreateLensVersionInput.idempotencyToken(), isMajorVersion: Bool? = nil, lensAlias: String, lensVersion: String) {
            self.clientRequestToken = clientRequestToken
            self.isMajorVersion = isMajorVersion
            self.lensAlias = lensAlias
            self.lensVersion = lensVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.lensVersion, name: "lensVersion", parent: name, max: 32)
            try self.validate(self.lensVersion, name: "lensVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case isMajorVersion = "IsMajorVersion"
            case lensVersion = "LensVersion"
        }
    }

    public struct CreateLensVersionOutput: AWSDecodableShape {
        /// The ARN for the lens.
        public let lensArn: String?
        /// The version of the lens.
        public let lensVersion: String?

        public init(lensArn: String? = nil, lensVersion: String? = nil) {
            self.lensArn = lensArn
            self.lensVersion = lensVersion
        }

        private enum CodingKeys: String, CodingKey {
            case lensArn = "LensArn"
            case lensVersion = "LensVersion"
        }
    }

    public struct CreateMilestoneInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let clientRequestToken: String
        public let milestoneName: String
        public let workloadId: String

        public init(clientRequestToken: String = CreateMilestoneInput.idempotencyToken(), milestoneName: String, workloadId: String) {
            self.clientRequestToken = clientRequestToken
            self.milestoneName = milestoneName
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.milestoneName, name: "milestoneName", parent: name, max: 100)
            try self.validate(self.milestoneName, name: "milestoneName", parent: name, min: 3)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case milestoneName = "MilestoneName"
        }
    }

    public struct CreateMilestoneOutput: AWSDecodableShape {
        public let milestoneNumber: Int?
        public let workloadId: String?

        public init(milestoneNumber: Int? = nil, workloadId: String? = nil) {
            self.milestoneNumber = milestoneNumber
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case milestoneNumber = "MilestoneNumber"
            case workloadId = "WorkloadId"
        }
    }

    public struct CreateWorkloadInput: AWSEncodableShape {
        public let accountIds: [String]?
        /// List of AppRegistry application ARNs associated to the workload.
        public let applications: [String]?
        public let architecturalDesign: String?
        public let awsRegions: [String]?
        public let clientRequestToken: String
        public let description: String
        /// Well-Architected discovery configuration settings associated to the workload.
        public let discoveryConfig: WorkloadDiscoveryConfig?
        public let environment: WorkloadEnvironment
        public let industry: String?
        public let industryType: String?
        public let lenses: [String]
        public let nonAwsRegions: [String]?
        public let notes: String?
        public let pillarPriorities: [String]?
        public let reviewOwner: String?
        /// The tags to be associated with the workload.
        public let tags: [String: String]?
        public let workloadName: String

        public init(accountIds: [String]? = nil, applications: [String]? = nil, architecturalDesign: String? = nil, awsRegions: [String]? = nil, clientRequestToken: String = CreateWorkloadInput.idempotencyToken(), description: String, discoveryConfig: WorkloadDiscoveryConfig? = nil, environment: WorkloadEnvironment, industry: String? = nil, industryType: String? = nil, lenses: [String], nonAwsRegions: [String]? = nil, notes: String? = nil, pillarPriorities: [String]? = nil, reviewOwner: String? = nil, tags: [String: String]? = nil, workloadName: String) {
            self.accountIds = accountIds
            self.applications = applications
            self.architecturalDesign = architecturalDesign
            self.awsRegions = awsRegions
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.discoveryConfig = discoveryConfig
            self.environment = environment
            self.industry = industry
            self.industryType = industryType
            self.lenses = lenses
            self.nonAwsRegions = nonAwsRegions
            self.notes = notes
            self.pillarPriorities = pillarPriorities
            self.reviewOwner = reviewOwner
            self.tags = tags
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
            try self.applications?.forEach {
                try validate($0, name: "applications[]", parent: name, max: 2084)
                try validate($0, name: "applications[]", parent: name, pattern: "^arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\\d:\\d{12}:/applications/[a-z0-9]+$")
            }
            try self.validate(self.applications, name: "applications", parent: name, max: 1)
            try self.validate(self.architecturalDesign, name: "architecturalDesign", parent: name, max: 2048)
            try self.validate(self.architecturalDesign, name: "architecturalDesign", parent: name, pattern: "^(|(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*)$")
            try self.awsRegions?.forEach {
                try validate($0, name: "awsRegions[]", parent: name, max: 100)
            }
            try self.validate(self.awsRegions, name: "awsRegions", parent: name, max: 50)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 3)
            try self.validate(self.industry, name: "industry", parent: name, max: 100)
            try self.validate(self.industryType, name: "industryType", parent: name, max: 100)
            try self.lenses.forEach {
                try validate($0, name: "lenses[]", parent: name, max: 128)
                try validate($0, name: "lenses[]", parent: name, min: 1)
            }
            try self.nonAwsRegions?.forEach {
                try validate($0, name: "nonAwsRegions[]", parent: name, max: 25)
                try validate($0, name: "nonAwsRegions[]", parent: name, min: 3)
            }
            try self.validate(self.nonAwsRegions, name: "nonAwsRegions", parent: name, max: 5)
            try self.validate(self.notes, name: "notes", parent: name, max: 2084)
            try self.pillarPriorities?.forEach {
                try validate($0, name: "pillarPriorities[]", parent: name, max: 64)
                try validate($0, name: "pillarPriorities[]", parent: name, min: 1)
            }
            try self.validate(self.reviewOwner, name: "reviewOwner", parent: name, max: 255)
            try self.validate(self.reviewOwner, name: "reviewOwner", parent: name, min: 3)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 100)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case applications = "Applications"
            case architecturalDesign = "ArchitecturalDesign"
            case awsRegions = "AwsRegions"
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case discoveryConfig = "DiscoveryConfig"
            case environment = "Environment"
            case industry = "Industry"
            case industryType = "IndustryType"
            case lenses = "Lenses"
            case nonAwsRegions = "NonAwsRegions"
            case notes = "Notes"
            case pillarPriorities = "PillarPriorities"
            case reviewOwner = "ReviewOwner"
            case tags = "Tags"
            case workloadName = "WorkloadName"
        }
    }

    public struct CreateWorkloadOutput: AWSDecodableShape {
        public let workloadArn: String?
        public let workloadId: String?

        public init(workloadArn: String? = nil, workloadId: String? = nil) {
            self.workloadArn = workloadArn
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case workloadArn = "WorkloadArn"
            case workloadId = "WorkloadId"
        }
    }

    public struct CreateWorkloadShareInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let clientRequestToken: String
        public let permissionType: PermissionType
        public let sharedWith: String
        public let workloadId: String

        public init(clientRequestToken: String = CreateWorkloadShareInput.idempotencyToken(), permissionType: PermissionType, sharedWith: String, workloadId: String) {
            self.clientRequestToken = clientRequestToken
            self.permissionType = permissionType
            self.sharedWith = sharedWith
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.sharedWith, name: "sharedWith", parent: name, max: 2048)
            try self.validate(self.sharedWith, name: "sharedWith", parent: name, min: 12)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case permissionType = "PermissionType"
            case sharedWith = "SharedWith"
        }
    }

    public struct CreateWorkloadShareOutput: AWSDecodableShape {
        public let shareId: String?
        public let workloadId: String?

        public init(shareId: String? = nil, workloadId: String? = nil) {
            self.shareId = shareId
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case shareId = "ShareId"
            case workloadId = "WorkloadId"
        }
    }

    public struct DeleteLensInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientRequestToken", location: .querystring("ClientRequestToken")),
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "lensStatus", location: .querystring("LensStatus"))
        ]

        public let clientRequestToken: String
        public let lensAlias: String
        /// The status of the lens to be deleted.
        public let lensStatus: LensStatusType

        public init(clientRequestToken: String = DeleteLensInput.idempotencyToken(), lensAlias: String, lensStatus: LensStatusType) {
            self.clientRequestToken = clientRequestToken
            self.lensAlias = lensAlias
            self.lensStatus = lensStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLensShareInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientRequestToken", location: .querystring("ClientRequestToken")),
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "shareId", location: .uri("ShareId"))
        ]

        public let clientRequestToken: String
        public let lensAlias: String
        public let shareId: String

        public init(clientRequestToken: String = DeleteLensShareInput.idempotencyToken(), lensAlias: String, shareId: String) {
            self.clientRequestToken = clientRequestToken
            self.lensAlias = lensAlias
            self.shareId = shareId
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.shareId, name: "shareId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkloadInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientRequestToken", location: .querystring("ClientRequestToken")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let clientRequestToken: String
        public let workloadId: String

        public init(clientRequestToken: String = DeleteWorkloadInput.idempotencyToken(), workloadId: String) {
            self.clientRequestToken = clientRequestToken
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkloadShareInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientRequestToken", location: .querystring("ClientRequestToken")),
            AWSMemberEncoding(label: "shareId", location: .uri("ShareId")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let clientRequestToken: String
        public let shareId: String
        public let workloadId: String

        public init(clientRequestToken: String = DeleteWorkloadShareInput.idempotencyToken(), shareId: String, workloadId: String) {
            self.clientRequestToken = clientRequestToken
            self.shareId = shareId
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.shareId, name: "shareId", parent: name, pattern: "^[0-9a-f]{32}$")
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateLensesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let lensAliases: [String]
        public let workloadId: String

        public init(lensAliases: [String], workloadId: String) {
            self.lensAliases = lensAliases
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.lensAliases.forEach {
                try validate($0, name: "lensAliases[]", parent: name, max: 128)
                try validate($0, name: "lensAliases[]", parent: name, min: 1)
            }
            try self.validate(self.lensAliases, name: "lensAliases", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lensAliases = "LensAliases"
        }
    }

    public struct ExportLensInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "lensVersion", location: .querystring("LensVersion"))
        ]

        public let lensAlias: String
        /// The lens version to be exported.
        public let lensVersion: String?

        public init(lensAlias: String, lensVersion: String? = nil) {
            self.lensAlias = lensAlias
            self.lensVersion = lensVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.lensVersion, name: "lensVersion", parent: name, max: 32)
            try self.validate(self.lensVersion, name: "lensVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportLensOutput: AWSDecodableShape {
        /// The JSON for the lens.
        public let lensJSON: String?

        public init(lensJSON: String? = nil) {
            self.lensJSON = lensJSON
        }

        private enum CodingKeys: String, CodingKey {
            case lensJSON = "LensJSON"
        }
    }

    public struct GetAnswerInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "milestoneNumber", location: .querystring("MilestoneNumber")),
            AWSMemberEncoding(label: "questionId", location: .uri("QuestionId")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let lensAlias: String
        public let milestoneNumber: Int?
        public let questionId: String
        public let workloadId: String

        public init(lensAlias: String, milestoneNumber: Int? = nil, questionId: String, workloadId: String) {
            self.lensAlias = lensAlias
            self.milestoneNumber = milestoneNumber
            self.questionId = questionId
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, max: 100)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, min: 1)
            try self.validate(self.questionId, name: "questionId", parent: name, max: 128)
            try self.validate(self.questionId, name: "questionId", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnswerOutput: AWSDecodableShape {
        public let answer: Answer?
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        public let milestoneNumber: Int?
        public let workloadId: String?

        public init(answer: Answer? = nil, lensAlias: String? = nil, lensArn: String? = nil, milestoneNumber: Int? = nil, workloadId: String? = nil) {
            self.answer = answer
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.milestoneNumber = milestoneNumber
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case answer = "Answer"
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case milestoneNumber = "MilestoneNumber"
            case workloadId = "WorkloadId"
        }
    }

    public struct GetLensInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "lensVersion", location: .querystring("LensVersion"))
        ]

        public let lensAlias: String
        /// The lens version to be retrieved.
        public let lensVersion: String?

        public init(lensAlias: String, lensVersion: String? = nil) {
            self.lensAlias = lensAlias
            self.lensVersion = lensVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.lensVersion, name: "lensVersion", parent: name, max: 32)
            try self.validate(self.lensVersion, name: "lensVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLensOutput: AWSDecodableShape {
        /// A lens return object.
        public let lens: Lens?

        public init(lens: Lens? = nil) {
            self.lens = lens
        }

        private enum CodingKeys: String, CodingKey {
            case lens = "Lens"
        }
    }

    public struct GetLensReviewInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "milestoneNumber", location: .querystring("MilestoneNumber")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let lensAlias: String
        public let milestoneNumber: Int?
        public let workloadId: String

        public init(lensAlias: String, milestoneNumber: Int? = nil, workloadId: String) {
            self.lensAlias = lensAlias
            self.milestoneNumber = milestoneNumber
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, max: 100)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLensReviewOutput: AWSDecodableShape {
        public let lensReview: LensReview?
        public let milestoneNumber: Int?
        public let workloadId: String?

        public init(lensReview: LensReview? = nil, milestoneNumber: Int? = nil, workloadId: String? = nil) {
            self.lensReview = lensReview
            self.milestoneNumber = milestoneNumber
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case lensReview = "LensReview"
            case milestoneNumber = "MilestoneNumber"
            case workloadId = "WorkloadId"
        }
    }

    public struct GetLensReviewReportInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "milestoneNumber", location: .querystring("MilestoneNumber")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let lensAlias: String
        public let milestoneNumber: Int?
        public let workloadId: String

        public init(lensAlias: String, milestoneNumber: Int? = nil, workloadId: String) {
            self.lensAlias = lensAlias
            self.milestoneNumber = milestoneNumber
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, max: 100)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLensReviewReportOutput: AWSDecodableShape {
        public let lensReviewReport: LensReviewReport?
        public let milestoneNumber: Int?
        public let workloadId: String?

        public init(lensReviewReport: LensReviewReport? = nil, milestoneNumber: Int? = nil, workloadId: String? = nil) {
            self.lensReviewReport = lensReviewReport
            self.milestoneNumber = milestoneNumber
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case lensReviewReport = "LensReviewReport"
            case milestoneNumber = "MilestoneNumber"
            case workloadId = "WorkloadId"
        }
    }

    public struct GetLensVersionDifferenceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "baseLensVersion", location: .querystring("BaseLensVersion")),
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "targetLensVersion", location: .querystring("TargetLensVersion"))
        ]

        /// The base version of the lens.
        public let baseLensVersion: String?
        public let lensAlias: String
        /// The lens version to target a difference for.
        public let targetLensVersion: String?

        public init(baseLensVersion: String? = nil, lensAlias: String, targetLensVersion: String? = nil) {
            self.baseLensVersion = baseLensVersion
            self.lensAlias = lensAlias
            self.targetLensVersion = targetLensVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.baseLensVersion, name: "baseLensVersion", parent: name, max: 32)
            try self.validate(self.baseLensVersion, name: "baseLensVersion", parent: name, min: 1)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.targetLensVersion, name: "targetLensVersion", parent: name, max: 32)
            try self.validate(self.targetLensVersion, name: "targetLensVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLensVersionDifferenceOutput: AWSDecodableShape {
        /// The base version of the lens.
        public let baseLensVersion: String?
        /// The latest version of the lens.
        public let latestLensVersion: String?
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        /// The target lens version for the lens.
        public let targetLensVersion: String?
        public let versionDifferences: VersionDifferences?

        public init(baseLensVersion: String? = nil, latestLensVersion: String? = nil, lensAlias: String? = nil, lensArn: String? = nil, targetLensVersion: String? = nil, versionDifferences: VersionDifferences? = nil) {
            self.baseLensVersion = baseLensVersion
            self.latestLensVersion = latestLensVersion
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.targetLensVersion = targetLensVersion
            self.versionDifferences = versionDifferences
        }

        private enum CodingKeys: String, CodingKey {
            case baseLensVersion = "BaseLensVersion"
            case latestLensVersion = "LatestLensVersion"
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case targetLensVersion = "TargetLensVersion"
            case versionDifferences = "VersionDifferences"
        }
    }

    public struct GetMilestoneInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "milestoneNumber", location: .uri("MilestoneNumber")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let milestoneNumber: Int
        public let workloadId: String

        public init(milestoneNumber: Int = 0, workloadId: String) {
            self.milestoneNumber = milestoneNumber
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, max: 100)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMilestoneOutput: AWSDecodableShape {
        public let milestone: Milestone?
        public let workloadId: String?

        public init(milestone: Milestone? = nil, workloadId: String? = nil) {
            self.milestone = milestone
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case milestone = "Milestone"
            case workloadId = "WorkloadId"
        }
    }

    public struct GetWorkloadInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let workloadId: String

        public init(workloadId: String) {
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkloadOutput: AWSDecodableShape {
        public let workload: Workload?

        public init(workload: Workload? = nil) {
            self.workload = workload
        }

        private enum CodingKeys: String, CodingKey {
            case workload = "Workload"
        }
    }

    public struct ImportLensInput: AWSEncodableShape {
        public let clientRequestToken: String
        /// The JSON representation of a lens.
        public let jsonString: String
        public let lensAlias: String?
        /// Tags to associate to a lens.
        public let tags: [String: String]?

        public init(clientRequestToken: String = ImportLensInput.idempotencyToken(), jsonString: String, lensAlias: String? = nil, tags: [String: String]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.jsonString = jsonString
            self.lensAlias = lensAlias
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.jsonString, name: "jsonString", parent: name, max: 500_000)
            try self.validate(self.jsonString, name: "jsonString", parent: name, min: 2)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case jsonString = "JSONString"
            case lensAlias = "LensAlias"
            case tags = "Tags"
        }
    }

    public struct ImportLensOutput: AWSDecodableShape {
        /// The ARN for the lens.
        public let lensArn: String?
        /// The status of the imported lens.
        public let status: ImportLensStatus?

        public init(lensArn: String? = nil, status: ImportLensStatus? = nil) {
            self.lensArn = lensArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case lensArn = "LensArn"
            case status = "Status"
        }
    }

    public struct ImprovementSummary: AWSDecodableShape {
        /// The improvement plan details.
        public let improvementPlans: [ChoiceImprovementPlan]?
        public let improvementPlanUrl: String?
        public let pillarId: String?
        public let questionId: String?
        public let questionTitle: String?
        public let risk: Risk?

        public init(improvementPlans: [ChoiceImprovementPlan]? = nil, improvementPlanUrl: String? = nil, pillarId: String? = nil, questionId: String? = nil, questionTitle: String? = nil, risk: Risk? = nil) {
            self.improvementPlans = improvementPlans
            self.improvementPlanUrl = improvementPlanUrl
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.risk = risk
        }

        private enum CodingKeys: String, CodingKey {
            case improvementPlans = "ImprovementPlans"
            case improvementPlanUrl = "ImprovementPlanUrl"
            case pillarId = "PillarId"
            case questionId = "QuestionId"
            case questionTitle = "QuestionTitle"
            case risk = "Risk"
        }
    }

    public struct Lens: AWSDecodableShape {
        public let description: String?
        /// The ARN of a lens.
        public let lensArn: String?
        /// The version of a lens.
        public let lensVersion: String?
        public let name: String?
        /// The Amazon Web Services account ID that owns the lens.
        public let owner: String?
        /// The ID assigned to the share invitation.
        public let shareInvitationId: String?
        /// The tags assigned to the lens.
        public let tags: [String: String]?

        public init(description: String? = nil, lensArn: String? = nil, lensVersion: String? = nil, name: String? = nil, owner: String? = nil, shareInvitationId: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.lensArn = lensArn
            self.lensVersion = lensVersion
            self.name = name
            self.owner = owner
            self.shareInvitationId = shareInvitationId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lensArn = "LensArn"
            case lensVersion = "LensVersion"
            case name = "Name"
            case owner = "Owner"
            case shareInvitationId = "ShareInvitationId"
            case tags = "Tags"
        }
    }

    public struct LensReview: AWSDecodableShape {
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        public let lensName: String?
        /// The status of the lens.
        public let lensStatus: LensStatus?
        /// The version of the lens.
        public let lensVersion: String?
        public let nextToken: String?
        public let notes: String?
        public let pillarReviewSummaries: [PillarReviewSummary]?
        public let riskCounts: [Risk: Int]?
        public let updatedAt: Date?

        public init(lensAlias: String? = nil, lensArn: String? = nil, lensName: String? = nil, lensStatus: LensStatus? = nil, lensVersion: String? = nil, nextToken: String? = nil, notes: String? = nil, pillarReviewSummaries: [PillarReviewSummary]? = nil, riskCounts: [Risk: Int]? = nil, updatedAt: Date? = nil) {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.nextToken = nextToken
            self.notes = notes
            self.pillarReviewSummaries = pillarReviewSummaries
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case lensName = "LensName"
            case lensStatus = "LensStatus"
            case lensVersion = "LensVersion"
            case nextToken = "NextToken"
            case notes = "Notes"
            case pillarReviewSummaries = "PillarReviewSummaries"
            case riskCounts = "RiskCounts"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct LensReviewReport: AWSDecodableShape {
        public let base64String: String?
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?

        public init(base64String: String? = nil, lensAlias: String? = nil, lensArn: String? = nil) {
            self.base64String = base64String
            self.lensAlias = lensAlias
            self.lensArn = lensArn
        }

        private enum CodingKeys: String, CodingKey {
            case base64String = "Base64String"
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
        }
    }

    public struct LensReviewSummary: AWSDecodableShape {
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        public let lensName: String?
        /// The status of the lens.
        public let lensStatus: LensStatus?
        /// The version of the lens.
        public let lensVersion: String?
        public let riskCounts: [Risk: Int]?
        public let updatedAt: Date?

        public init(lensAlias: String? = nil, lensArn: String? = nil, lensName: String? = nil, lensStatus: LensStatus? = nil, lensVersion: String? = nil, riskCounts: [Risk: Int]? = nil, updatedAt: Date? = nil) {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case lensName = "LensName"
            case lensStatus = "LensStatus"
            case lensVersion = "LensVersion"
            case riskCounts = "RiskCounts"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct LensShareSummary: AWSDecodableShape {
        public let sharedWith: String?
        public let shareId: String?
        public let status: ShareStatus?
        /// Optional message to compliment the Status field.
        public let statusMessage: String?

        public init(sharedWith: String? = nil, shareId: String? = nil, status: ShareStatus? = nil, statusMessage: String? = nil) {
            self.sharedWith = sharedWith
            self.shareId = shareId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case sharedWith = "SharedWith"
            case shareId = "ShareId"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct LensSummary: AWSDecodableShape {
        public let createdAt: Date?
        public let description: String?
        public let lensAlias: String?
        /// The ARN of the lens.
        public let lensArn: String?
        public let lensName: String?
        /// The status of the lens.
        public let lensStatus: LensStatus?
        /// The type of the lens.
        public let lensType: LensType?
        /// The version of the lens.
        public let lensVersion: String?
        public let owner: String?
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, description: String? = nil, lensAlias: String? = nil, lensArn: String? = nil, lensName: String? = nil, lensStatus: LensStatus? = nil, lensType: LensType? = nil, lensVersion: String? = nil, owner: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensType = lensType
            self.lensVersion = lensVersion
            self.owner = owner
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case lensName = "LensName"
            case lensStatus = "LensStatus"
            case lensType = "LensType"
            case lensVersion = "LensVersion"
            case owner = "Owner"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct LensUpgradeSummary: AWSDecodableShape {
        /// The current version of the lens.
        public let currentLensVersion: String?
        /// The latest version of the lens.
        public let latestLensVersion: String?
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        public let workloadId: String?
        public let workloadName: String?

        public init(currentLensVersion: String? = nil, latestLensVersion: String? = nil, lensAlias: String? = nil, lensArn: String? = nil, workloadId: String? = nil, workloadName: String? = nil) {
            self.currentLensVersion = currentLensVersion
            self.latestLensVersion = latestLensVersion
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case currentLensVersion = "CurrentLensVersion"
            case latestLensVersion = "LatestLensVersion"
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case workloadId = "WorkloadId"
            case workloadName = "WorkloadName"
        }
    }

    public struct ListAnswersInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "milestoneNumber", location: .querystring("MilestoneNumber")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "pillarId", location: .querystring("PillarId")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let lensAlias: String
        /// The maximum number of results to return for this request.
        public let maxResults: Int?
        public let milestoneNumber: Int?
        public let nextToken: String?
        public let pillarId: String?
        public let workloadId: String

        public init(lensAlias: String, maxResults: Int? = nil, milestoneNumber: Int? = nil, nextToken: String? = nil, pillarId: String? = nil, workloadId: String) {
            self.lensAlias = lensAlias
            self.maxResults = maxResults
            self.milestoneNumber = milestoneNumber
            self.nextToken = nextToken
            self.pillarId = pillarId
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, max: 100)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, min: 1)
            try self.validate(self.pillarId, name: "pillarId", parent: name, max: 64)
            try self.validate(self.pillarId, name: "pillarId", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnswersOutput: AWSDecodableShape {
        public let answerSummaries: [AnswerSummary]?
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        public let milestoneNumber: Int?
        public let nextToken: String?
        public let workloadId: String?

        public init(answerSummaries: [AnswerSummary]? = nil, lensAlias: String? = nil, lensArn: String? = nil, milestoneNumber: Int? = nil, nextToken: String? = nil, workloadId: String? = nil) {
            self.answerSummaries = answerSummaries
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.milestoneNumber = milestoneNumber
            self.nextToken = nextToken
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case answerSummaries = "AnswerSummaries"
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case milestoneNumber = "MilestoneNumber"
            case nextToken = "NextToken"
            case workloadId = "WorkloadId"
        }
    }

    public struct ListCheckDetailsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let choiceId: String
        /// Well-Architected Lens ARN.
        public let lensArn: String
        public let maxResults: Int?
        public let nextToken: String?
        public let pillarId: String
        public let questionId: String
        public let workloadId: String

        public init(choiceId: String, lensArn: String, maxResults: Int? = nil, nextToken: String? = nil, pillarId: String, questionId: String, workloadId: String) {
            self.choiceId = choiceId
            self.lensArn = lensArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pillarId = pillarId
            self.questionId = questionId
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.choiceId, name: "choiceId", parent: name, max: 64)
            try self.validate(self.choiceId, name: "choiceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.pillarId, name: "pillarId", parent: name, max: 64)
            try self.validate(self.pillarId, name: "pillarId", parent: name, min: 1)
            try self.validate(self.questionId, name: "questionId", parent: name, max: 128)
            try self.validate(self.questionId, name: "questionId", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case choiceId = "ChoiceId"
            case lensArn = "LensArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pillarId = "PillarId"
            case questionId = "QuestionId"
        }
    }

    public struct ListCheckDetailsOutput: AWSDecodableShape {
        /// The details about the Trusted Advisor checks related to the Well-Architected best practice.
        public let checkDetails: [CheckDetail]?
        public let nextToken: String?

        public init(checkDetails: [CheckDetail]? = nil, nextToken: String? = nil) {
            self.checkDetails = checkDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case checkDetails = "CheckDetails"
            case nextToken = "NextToken"
        }
    }

    public struct ListCheckSummariesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let choiceId: String
        /// Well-Architected Lens ARN.
        public let lensArn: String
        public let maxResults: Int?
        public let nextToken: String?
        public let pillarId: String
        public let questionId: String
        public let workloadId: String

        public init(choiceId: String, lensArn: String, maxResults: Int? = nil, nextToken: String? = nil, pillarId: String, questionId: String, workloadId: String) {
            self.choiceId = choiceId
            self.lensArn = lensArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pillarId = pillarId
            self.questionId = questionId
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.choiceId, name: "choiceId", parent: name, max: 64)
            try self.validate(self.choiceId, name: "choiceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.pillarId, name: "pillarId", parent: name, max: 64)
            try self.validate(self.pillarId, name: "pillarId", parent: name, min: 1)
            try self.validate(self.questionId, name: "questionId", parent: name, max: 128)
            try self.validate(self.questionId, name: "questionId", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case choiceId = "ChoiceId"
            case lensArn = "LensArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pillarId = "PillarId"
            case questionId = "QuestionId"
        }
    }

    public struct ListCheckSummariesOutput: AWSDecodableShape {
        /// List of Trusted Advisor summaries related to the Well-Architected best practice.
        public let checkSummaries: [CheckSummary]?
        public let nextToken: String?

        public init(checkSummaries: [CheckSummary]? = nil, nextToken: String? = nil) {
            self.checkSummaries = checkSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case checkSummaries = "CheckSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListLensReviewImprovementsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "milestoneNumber", location: .querystring("MilestoneNumber")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "pillarId", location: .querystring("PillarId")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let lensAlias: String
        /// The maximum number of results to return for this request.
        public let maxResults: Int?
        public let milestoneNumber: Int?
        public let nextToken: String?
        public let pillarId: String?
        public let workloadId: String

        public init(lensAlias: String, maxResults: Int? = nil, milestoneNumber: Int? = nil, nextToken: String? = nil, pillarId: String? = nil, workloadId: String) {
            self.lensAlias = lensAlias
            self.maxResults = maxResults
            self.milestoneNumber = milestoneNumber
            self.nextToken = nextToken
            self.pillarId = pillarId
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, max: 100)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, min: 1)
            try self.validate(self.pillarId, name: "pillarId", parent: name, max: 64)
            try self.validate(self.pillarId, name: "pillarId", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLensReviewImprovementsOutput: AWSDecodableShape {
        public let improvementSummaries: [ImprovementSummary]?
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        public let milestoneNumber: Int?
        public let nextToken: String?
        public let workloadId: String?

        public init(improvementSummaries: [ImprovementSummary]? = nil, lensAlias: String? = nil, lensArn: String? = nil, milestoneNumber: Int? = nil, nextToken: String? = nil, workloadId: String? = nil) {
            self.improvementSummaries = improvementSummaries
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.milestoneNumber = milestoneNumber
            self.nextToken = nextToken
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case improvementSummaries = "ImprovementSummaries"
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case milestoneNumber = "MilestoneNumber"
            case nextToken = "NextToken"
            case workloadId = "WorkloadId"
        }
    }

    public struct ListLensReviewsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "milestoneNumber", location: .querystring("MilestoneNumber")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let maxResults: Int?
        public let milestoneNumber: Int?
        public let nextToken: String?
        public let workloadId: String

        public init(maxResults: Int? = nil, milestoneNumber: Int? = nil, nextToken: String? = nil, workloadId: String) {
            self.maxResults = maxResults
            self.milestoneNumber = milestoneNumber
            self.nextToken = nextToken
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, max: 100)
            try self.validate(self.milestoneNumber, name: "milestoneNumber", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLensReviewsOutput: AWSDecodableShape {
        public let lensReviewSummaries: [LensReviewSummary]?
        public let milestoneNumber: Int?
        public let nextToken: String?
        public let workloadId: String?

        public init(lensReviewSummaries: [LensReviewSummary]? = nil, milestoneNumber: Int? = nil, nextToken: String? = nil, workloadId: String? = nil) {
            self.lensReviewSummaries = lensReviewSummaries
            self.milestoneNumber = milestoneNumber
            self.nextToken = nextToken
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case lensReviewSummaries = "LensReviewSummaries"
            case milestoneNumber = "MilestoneNumber"
            case nextToken = "NextToken"
            case workloadId = "WorkloadId"
        }
    }

    public struct ListLensSharesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "sharedWithPrefix", location: .querystring("SharedWithPrefix")),
            AWSMemberEncoding(label: "status", location: .querystring("Status"))
        ]

        public let lensAlias: String
        /// The maximum number of results to return for this request.
        public let maxResults: Int?
        public let nextToken: String?
        /// The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the lens is shared.
        public let sharedWithPrefix: String?
        public let status: ShareStatus?

        public init(lensAlias: String, maxResults: Int? = nil, nextToken: String? = nil, sharedWithPrefix: String? = nil, status: ShareStatus? = nil) {
            self.lensAlias = lensAlias
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sharedWithPrefix = sharedWithPrefix
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.sharedWithPrefix, name: "sharedWithPrefix", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLensSharesOutput: AWSDecodableShape {
        /// A list of lens share summaries.
        public let lensShareSummaries: [LensShareSummary]?
        public let nextToken: String?

        public init(lensShareSummaries: [LensShareSummary]? = nil, nextToken: String? = nil) {
            self.lensShareSummaries = lensShareSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lensShareSummaries = "LensShareSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListLensesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensName", location: .querystring("LensName")),
            AWSMemberEncoding(label: "lensStatus", location: .querystring("LensStatus")),
            AWSMemberEncoding(label: "lensType", location: .querystring("LensType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        public let lensName: String?
        /// The status of lenses to be returned.
        public let lensStatus: LensStatusType?
        /// The type of lenses to be returned.
        public let lensType: LensType?
        public let maxResults: Int?
        public let nextToken: String?

        public init(lensName: String? = nil, lensStatus: LensStatusType? = nil, lensType: LensType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensType = lensType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.lensName, name: "lensName", parent: name, max: 128)
            try self.validate(self.lensName, name: "lensName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLensesOutput: AWSDecodableShape {
        public let lensSummaries: [LensSummary]?
        public let nextToken: String?

        public init(lensSummaries: [LensSummary]? = nil, nextToken: String? = nil) {
            self.lensSummaries = lensSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lensSummaries = "LensSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMilestonesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let workloadId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workloadId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMilestonesOutput: AWSDecodableShape {
        public let milestoneSummaries: [MilestoneSummary]?
        public let nextToken: String?
        public let workloadId: String?

        public init(milestoneSummaries: [MilestoneSummary]? = nil, nextToken: String? = nil, workloadId: String? = nil) {
            self.milestoneSummaries = milestoneSummaries
            self.nextToken = nextToken
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case milestoneSummaries = "MilestoneSummaries"
            case nextToken = "NextToken"
            case workloadId = "WorkloadId"
        }
    }

    public struct ListNotificationsInput: AWSEncodableShape {
        /// The maximum number of results to return for this request.
        public let maxResults: Int?
        public let nextToken: String?
        public let workloadId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, workloadId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case workloadId = "WorkloadId"
        }
    }

    public struct ListNotificationsOutput: AWSDecodableShape {
        public let nextToken: String?
        /// List of lens notification summaries in a workload.
        public let notificationSummaries: [NotificationSummary]?

        public init(nextToken: String? = nil, notificationSummaries: [NotificationSummary]? = nil) {
            self.nextToken = nextToken
            self.notificationSummaries = notificationSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case notificationSummaries = "NotificationSummaries"
        }
    }

    public struct ListShareInvitationsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensNamePrefix", location: .querystring("LensNamePrefix")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "shareResourceType", location: .querystring("ShareResourceType")),
            AWSMemberEncoding(label: "workloadNamePrefix", location: .querystring("WorkloadNamePrefix"))
        ]

        /// An optional string added to the beginning of each lens name returned in the results.
        public let lensNamePrefix: String?
        /// The maximum number of results to return for this request.
        public let maxResults: Int?
        public let nextToken: String?
        /// The type of share invitations to be returned.
        public let shareResourceType: ShareResourceType?
        public let workloadNamePrefix: String?

        public init(lensNamePrefix: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, shareResourceType: ShareResourceType? = nil, workloadNamePrefix: String? = nil) {
            self.lensNamePrefix = lensNamePrefix
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.shareResourceType = shareResourceType
            self.workloadNamePrefix = workloadNamePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.lensNamePrefix, name: "lensNamePrefix", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.workloadNamePrefix, name: "workloadNamePrefix", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListShareInvitationsOutput: AWSDecodableShape {
        public let nextToken: String?
        /// List of share invitation summaries in a workload.
        public let shareInvitationSummaries: [ShareInvitationSummary]?

        public init(nextToken: String? = nil, shareInvitationSummaries: [ShareInvitationSummary]? = nil) {
            self.nextToken = nextToken
            self.shareInvitationSummaries = shareInvitationSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case shareInvitationSummaries = "ShareInvitationSummaries"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadArn", location: .uri("WorkloadArn"))
        ]

        public let workloadArn: String

        public init(workloadArn: String) {
            self.workloadArn = workloadArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListWorkloadSharesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "sharedWithPrefix", location: .querystring("SharedWithPrefix")),
            AWSMemberEncoding(label: "status", location: .querystring("Status")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        /// The maximum number of results to return for this request.
        public let maxResults: Int?
        public let nextToken: String?
        /// The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.
        public let sharedWithPrefix: String?
        public let status: ShareStatus?
        public let workloadId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, sharedWithPrefix: String? = nil, status: ShareStatus? = nil, workloadId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sharedWithPrefix = sharedWithPrefix
            self.status = status
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.sharedWithPrefix, name: "sharedWithPrefix", parent: name, max: 100)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkloadSharesOutput: AWSDecodableShape {
        public let nextToken: String?
        public let workloadId: String?
        public let workloadShareSummaries: [WorkloadShareSummary]?

        public init(nextToken: String? = nil, workloadId: String? = nil, workloadShareSummaries: [WorkloadShareSummary]? = nil) {
            self.nextToken = nextToken
            self.workloadId = workloadId
            self.workloadShareSummaries = workloadShareSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workloadId = "WorkloadId"
            case workloadShareSummaries = "WorkloadShareSummaries"
        }
    }

    public struct ListWorkloadsInput: AWSEncodableShape {
        /// The maximum number of results to return for this request.
        public let maxResults: Int?
        public let nextToken: String?
        public let workloadNamePrefix: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, workloadNamePrefix: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workloadNamePrefix = workloadNamePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.workloadNamePrefix, name: "workloadNamePrefix", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case workloadNamePrefix = "WorkloadNamePrefix"
        }
    }

    public struct ListWorkloadsOutput: AWSDecodableShape {
        public let nextToken: String?
        public let workloadSummaries: [WorkloadSummary]?

        public init(nextToken: String? = nil, workloadSummaries: [WorkloadSummary]? = nil) {
            self.nextToken = nextToken
            self.workloadSummaries = workloadSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workloadSummaries = "WorkloadSummaries"
        }
    }

    public struct Milestone: AWSDecodableShape {
        public let milestoneName: String?
        public let milestoneNumber: Int?
        public let recordedAt: Date?
        public let workload: Workload?

        public init(milestoneName: String? = nil, milestoneNumber: Int? = nil, recordedAt: Date? = nil, workload: Workload? = nil) {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workload = workload
        }

        private enum CodingKeys: String, CodingKey {
            case milestoneName = "MilestoneName"
            case milestoneNumber = "MilestoneNumber"
            case recordedAt = "RecordedAt"
            case workload = "Workload"
        }
    }

    public struct MilestoneSummary: AWSDecodableShape {
        public let milestoneName: String?
        public let milestoneNumber: Int?
        public let recordedAt: Date?
        public let workloadSummary: WorkloadSummary?

        public init(milestoneName: String? = nil, milestoneNumber: Int? = nil, recordedAt: Date? = nil, workloadSummary: WorkloadSummary? = nil) {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workloadSummary = workloadSummary
        }

        private enum CodingKeys: String, CodingKey {
            case milestoneName = "MilestoneName"
            case milestoneNumber = "MilestoneNumber"
            case recordedAt = "RecordedAt"
            case workloadSummary = "WorkloadSummary"
        }
    }

    public struct NotificationSummary: AWSDecodableShape {
        /// Summary of lens upgrade.
        public let lensUpgradeSummary: LensUpgradeSummary?
        /// The type of notification.
        public let type: NotificationType?

        public init(lensUpgradeSummary: LensUpgradeSummary? = nil, type: NotificationType? = nil) {
            self.lensUpgradeSummary = lensUpgradeSummary
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case lensUpgradeSummary = "LensUpgradeSummary"
            case type = "Type"
        }
    }

    public struct PillarDifference: AWSDecodableShape {
        /// Indicates the type of change to the pillar.
        public let differenceStatus: DifferenceStatus?
        public let pillarId: String?
        public let pillarName: String?
        /// List of question differences.
        public let questionDifferences: [QuestionDifference]?

        public init(differenceStatus: DifferenceStatus? = nil, pillarId: String? = nil, pillarName: String? = nil, questionDifferences: [QuestionDifference]? = nil) {
            self.differenceStatus = differenceStatus
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.questionDifferences = questionDifferences
        }

        private enum CodingKeys: String, CodingKey {
            case differenceStatus = "DifferenceStatus"
            case pillarId = "PillarId"
            case pillarName = "PillarName"
            case questionDifferences = "QuestionDifferences"
        }
    }

    public struct PillarReviewSummary: AWSDecodableShape {
        public let notes: String?
        public let pillarId: String?
        public let pillarName: String?
        public let riskCounts: [Risk: Int]?

        public init(notes: String? = nil, pillarId: String? = nil, pillarName: String? = nil, riskCounts: [Risk: Int]? = nil) {
            self.notes = notes
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.riskCounts = riskCounts
        }

        private enum CodingKeys: String, CodingKey {
            case notes = "Notes"
            case pillarId = "PillarId"
            case pillarName = "PillarName"
            case riskCounts = "RiskCounts"
        }
    }

    public struct QuestionDifference: AWSDecodableShape {
        /// Indicates the type of change to the question.
        public let differenceStatus: DifferenceStatus?
        public let questionId: String?
        public let questionTitle: String?

        public init(differenceStatus: DifferenceStatus? = nil, questionId: String? = nil, questionTitle: String? = nil) {
            self.differenceStatus = differenceStatus
            self.questionId = questionId
            self.questionTitle = questionTitle
        }

        private enum CodingKeys: String, CodingKey {
            case differenceStatus = "DifferenceStatus"
            case questionId = "QuestionId"
            case questionTitle = "QuestionTitle"
        }
    }

    public struct ShareInvitation: AWSDecodableShape {
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        /// The ID assigned to the share invitation.
        public let shareInvitationId: String?
        /// The resource type of the share invitation.
        public let shareResourceType: ShareResourceType?
        public let workloadId: String?

        public init(lensAlias: String? = nil, lensArn: String? = nil, shareInvitationId: String? = nil, shareResourceType: ShareResourceType? = nil, workloadId: String? = nil) {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case shareInvitationId = "ShareInvitationId"
            case shareResourceType = "ShareResourceType"
            case workloadId = "WorkloadId"
        }
    }

    public struct ShareInvitationSummary: AWSDecodableShape {
        /// The ARN for the lens.
        public let lensArn: String?
        public let lensName: String?
        public let permissionType: PermissionType?
        public let sharedBy: String?
        public let sharedWith: String?
        /// The ID assigned to the share invitation.
        public let shareInvitationId: String?
        /// The resource type of the share invitation.
        public let shareResourceType: ShareResourceType?
        public let workloadId: String?
        public let workloadName: String?

        public init(lensArn: String? = nil, lensName: String? = nil, permissionType: PermissionType? = nil, sharedBy: String? = nil, sharedWith: String? = nil, shareInvitationId: String? = nil, shareResourceType: ShareResourceType? = nil, workloadId: String? = nil, workloadName: String? = nil) {
            self.lensArn = lensArn
            self.lensName = lensName
            self.permissionType = permissionType
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.workloadId = workloadId
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case lensArn = "LensArn"
            case lensName = "LensName"
            case permissionType = "PermissionType"
            case sharedBy = "SharedBy"
            case sharedWith = "SharedWith"
            case shareInvitationId = "ShareInvitationId"
            case shareResourceType = "ShareResourceType"
            case workloadId = "WorkloadId"
            case workloadName = "WorkloadName"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadArn", location: .uri("WorkloadArn"))
        ]

        /// The tags for the resource.
        public let tags: [String: String]
        public let workloadArn: String

        public init(tags: [String: String], workloadArn: String) {
            self.tags = tags
            self.workloadArn = workloadArn
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys")),
            AWSMemberEncoding(label: "workloadArn", location: .uri("WorkloadArn"))
        ]

        /// A list of tag keys. Existing tags of the resource  whose keys are members of this list are removed from the resource.
        public let tagKeys: [String]
        public let workloadArn: String

        public init(tagKeys: [String], workloadArn: String) {
            self.tagKeys = tagKeys
            self.workloadArn = workloadArn
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAnswerInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "questionId", location: .uri("QuestionId")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        /// A list of choices to update on a question in your workload.  The String key  corresponds to the choice ID to be updated.
        public let choiceUpdates: [String: ChoiceUpdate]?
        public let isApplicable: Bool?
        public let lensAlias: String
        public let notes: String?
        public let questionId: String
        /// The reason why a question is not applicable to your workload.
        public let reason: AnswerReason?
        public let selectedChoices: [String]?
        public let workloadId: String

        public init(choiceUpdates: [String: ChoiceUpdate]? = nil, isApplicable: Bool? = nil, lensAlias: String, notes: String? = nil, questionId: String, reason: AnswerReason? = nil, selectedChoices: [String]? = nil, workloadId: String) {
            self.choiceUpdates = choiceUpdates
            self.isApplicable = isApplicable
            self.lensAlias = lensAlias
            self.notes = notes
            self.questionId = questionId
            self.reason = reason
            self.selectedChoices = selectedChoices
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.choiceUpdates?.forEach {
                try validate($0.key, name: "choiceUpdates.key", parent: name, max: 64)
                try validate($0.key, name: "choiceUpdates.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).choiceUpdates[\"\($0.key)\"]")
            }
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.notes, name: "notes", parent: name, max: 2084)
            try self.validate(self.questionId, name: "questionId", parent: name, max: 128)
            try self.validate(self.questionId, name: "questionId", parent: name, min: 1)
            try self.selectedChoices?.forEach {
                try validate($0, name: "selectedChoices[]", parent: name, max: 64)
                try validate($0, name: "selectedChoices[]", parent: name, min: 1)
            }
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case choiceUpdates = "ChoiceUpdates"
            case isApplicable = "IsApplicable"
            case notes = "Notes"
            case reason = "Reason"
            case selectedChoices = "SelectedChoices"
        }
    }

    public struct UpdateAnswerOutput: AWSDecodableShape {
        public let answer: Answer?
        public let lensAlias: String?
        /// The ARN for the lens.
        public let lensArn: String?
        public let workloadId: String?

        public init(answer: Answer? = nil, lensAlias: String? = nil, lensArn: String? = nil, workloadId: String? = nil) {
            self.answer = answer
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case answer = "Answer"
            case lensAlias = "LensAlias"
            case lensArn = "LensArn"
            case workloadId = "WorkloadId"
        }
    }

    public struct UpdateGlobalSettingsInput: AWSEncodableShape {
        /// The status of organization sharing settings.
        public let organizationSharingStatus: OrganizationSharingStatus?

        public init(organizationSharingStatus: OrganizationSharingStatus? = nil) {
            self.organizationSharingStatus = organizationSharingStatus
        }

        private enum CodingKeys: String, CodingKey {
            case organizationSharingStatus = "OrganizationSharingStatus"
        }
    }

    public struct UpdateLensReviewInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let lensAlias: String
        public let lensNotes: String?
        public let pillarNotes: [String: String]?
        public let workloadId: String

        public init(lensAlias: String, lensNotes: String? = nil, pillarNotes: [String: String]? = nil, workloadId: String) {
            self.lensAlias = lensAlias
            self.lensNotes = lensNotes
            self.pillarNotes = pillarNotes
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.lensNotes, name: "lensNotes", parent: name, max: 2084)
            try self.pillarNotes?.forEach {
                try validate($0.key, name: "pillarNotes.key", parent: name, max: 64)
                try validate($0.key, name: "pillarNotes.key", parent: name, min: 1)
                try validate($0.value, name: "pillarNotes[\"\($0.key)\"]", parent: name, max: 2084)
            }
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lensNotes = "LensNotes"
            case pillarNotes = "PillarNotes"
        }
    }

    public struct UpdateLensReviewOutput: AWSDecodableShape {
        public let lensReview: LensReview?
        public let workloadId: String?

        public init(lensReview: LensReview? = nil, workloadId: String? = nil) {
            self.lensReview = lensReview
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case lensReview = "LensReview"
            case workloadId = "WorkloadId"
        }
    }

    public struct UpdateShareInvitationInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "shareInvitationId", location: .uri("ShareInvitationId"))
        ]

        public let shareInvitationAction: ShareInvitationAction
        /// The ID assigned to the share invitation.
        public let shareInvitationId: String

        public init(shareInvitationAction: ShareInvitationAction, shareInvitationId: String) {
            self.shareInvitationAction = shareInvitationAction
            self.shareInvitationId = shareInvitationId
        }

        public func validate(name: String) throws {
            try self.validate(self.shareInvitationId, name: "shareInvitationId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case shareInvitationAction = "ShareInvitationAction"
        }
    }

    public struct UpdateShareInvitationOutput: AWSDecodableShape {
        /// The updated workload or custom lens share invitation.
        public let shareInvitation: ShareInvitation?

        public init(shareInvitation: ShareInvitation? = nil) {
            self.shareInvitation = shareInvitation
        }

        private enum CodingKeys: String, CodingKey {
            case shareInvitation = "ShareInvitation"
        }
    }

    public struct UpdateWorkloadInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let accountIds: [String]?
        /// List of AppRegistry application ARNs to associate to the workload.
        public let applications: [String]?
        public let architecturalDesign: String?
        public let awsRegions: [String]?
        public let description: String?
        /// Well-Architected discovery configuration settings to associate to the workload.
        public let discoveryConfig: WorkloadDiscoveryConfig?
        public let environment: WorkloadEnvironment?
        public let improvementStatus: WorkloadImprovementStatus?
        public let industry: String?
        public let industryType: String?
        /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
        public let isReviewOwnerUpdateAcknowledged: Bool?
        public let nonAwsRegions: [String]?
        public let notes: String?
        public let pillarPriorities: [String]?
        public let reviewOwner: String?
        public let workloadId: String
        public let workloadName: String?

        public init(accountIds: [String]? = nil, applications: [String]? = nil, architecturalDesign: String? = nil, awsRegions: [String]? = nil, description: String? = nil, discoveryConfig: WorkloadDiscoveryConfig? = nil, environment: WorkloadEnvironment? = nil, improvementStatus: WorkloadImprovementStatus? = nil, industry: String? = nil, industryType: String? = nil, isReviewOwnerUpdateAcknowledged: Bool? = nil, nonAwsRegions: [String]? = nil, notes: String? = nil, pillarPriorities: [String]? = nil, reviewOwner: String? = nil, workloadId: String, workloadName: String? = nil) {
            self.accountIds = accountIds
            self.applications = applications
            self.architecturalDesign = architecturalDesign
            self.awsRegions = awsRegions
            self.description = description
            self.discoveryConfig = discoveryConfig
            self.environment = environment
            self.improvementStatus = improvementStatus
            self.industry = industry
            self.industryType = industryType
            self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
            self.nonAwsRegions = nonAwsRegions
            self.notes = notes
            self.pillarPriorities = pillarPriorities
            self.reviewOwner = reviewOwner
            self.workloadId = workloadId
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
            try self.applications?.forEach {
                try validate($0, name: "applications[]", parent: name, max: 2084)
                try validate($0, name: "applications[]", parent: name, pattern: "^arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\\d:\\d{12}:/applications/[a-z0-9]+$")
            }
            try self.validate(self.applications, name: "applications", parent: name, max: 1)
            try self.validate(self.architecturalDesign, name: "architecturalDesign", parent: name, max: 2048)
            try self.validate(self.architecturalDesign, name: "architecturalDesign", parent: name, pattern: "^(|(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*)$")
            try self.awsRegions?.forEach {
                try validate($0, name: "awsRegions[]", parent: name, max: 100)
            }
            try self.validate(self.awsRegions, name: "awsRegions", parent: name, max: 50)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 3)
            try self.validate(self.industry, name: "industry", parent: name, max: 100)
            try self.validate(self.industryType, name: "industryType", parent: name, max: 100)
            try self.nonAwsRegions?.forEach {
                try validate($0, name: "nonAwsRegions[]", parent: name, max: 25)
                try validate($0, name: "nonAwsRegions[]", parent: name, min: 3)
            }
            try self.validate(self.nonAwsRegions, name: "nonAwsRegions", parent: name, max: 5)
            try self.validate(self.notes, name: "notes", parent: name, max: 2084)
            try self.pillarPriorities?.forEach {
                try validate($0, name: "pillarPriorities[]", parent: name, max: 64)
                try validate($0, name: "pillarPriorities[]", parent: name, min: 1)
            }
            try self.validate(self.reviewOwner, name: "reviewOwner", parent: name, max: 255)
            try self.validate(self.reviewOwner, name: "reviewOwner", parent: name, min: 3)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 100)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case applications = "Applications"
            case architecturalDesign = "ArchitecturalDesign"
            case awsRegions = "AwsRegions"
            case description = "Description"
            case discoveryConfig = "DiscoveryConfig"
            case environment = "Environment"
            case improvementStatus = "ImprovementStatus"
            case industry = "Industry"
            case industryType = "IndustryType"
            case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
            case nonAwsRegions = "NonAwsRegions"
            case notes = "Notes"
            case pillarPriorities = "PillarPriorities"
            case reviewOwner = "ReviewOwner"
            case workloadName = "WorkloadName"
        }
    }

    public struct UpdateWorkloadOutput: AWSDecodableShape {
        public let workload: Workload?

        public init(workload: Workload? = nil) {
            self.workload = workload
        }

        private enum CodingKeys: String, CodingKey {
            case workload = "Workload"
        }
    }

    public struct UpdateWorkloadShareInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "shareId", location: .uri("ShareId")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let permissionType: PermissionType
        public let shareId: String
        public let workloadId: String

        public init(permissionType: PermissionType, shareId: String, workloadId: String) {
            self.permissionType = permissionType
            self.shareId = shareId
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.shareId, name: "shareId", parent: name, pattern: "^[0-9a-f]{32}$")
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case permissionType = "PermissionType"
        }
    }

    public struct UpdateWorkloadShareOutput: AWSDecodableShape {
        public let workloadId: String?
        public let workloadShare: WorkloadShare?

        public init(workloadId: String? = nil, workloadShare: WorkloadShare? = nil) {
            self.workloadId = workloadId
            self.workloadShare = workloadShare
        }

        private enum CodingKeys: String, CodingKey {
            case workloadId = "WorkloadId"
            case workloadShare = "WorkloadShare"
        }
    }

    public struct UpgradeLensReviewInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "lensAlias", location: .uri("LensAlias")),
            AWSMemberEncoding(label: "workloadId", location: .uri("WorkloadId"))
        ]

        public let clientRequestToken: String?
        public let lensAlias: String
        public let milestoneName: String
        public let workloadId: String

        public init(clientRequestToken: String? = nil, lensAlias: String, milestoneName: String, workloadId: String) {
            self.clientRequestToken = clientRequestToken
            self.lensAlias = lensAlias
            self.milestoneName = milestoneName
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, max: 128)
            try self.validate(self.lensAlias, name: "lensAlias", parent: name, min: 1)
            try self.validate(self.milestoneName, name: "milestoneName", parent: name, max: 100)
            try self.validate(self.milestoneName, name: "milestoneName", parent: name, min: 3)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case milestoneName = "MilestoneName"
        }
    }

    public struct VersionDifferences: AWSDecodableShape {
        /// The differences between the base and latest versions of the lens.
        public let pillarDifferences: [PillarDifference]?

        public init(pillarDifferences: [PillarDifference]? = nil) {
            self.pillarDifferences = pillarDifferences
        }

        private enum CodingKeys: String, CodingKey {
            case pillarDifferences = "PillarDifferences"
        }
    }

    public struct Workload: AWSDecodableShape {
        public let accountIds: [String]?
        /// List of AppRegistry application ARNs associated to the workload.
        public let applications: [String]?
        public let architecturalDesign: String?
        public let awsRegions: [String]?
        public let description: String?
        /// Discovery configuration associated to the workload.
        public let discoveryConfig: WorkloadDiscoveryConfig?
        public let environment: WorkloadEnvironment?
        public let improvementStatus: WorkloadImprovementStatus?
        public let industry: String?
        public let industryType: String?
        /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
        public let isReviewOwnerUpdateAcknowledged: Bool?
        public let lenses: [String]?
        public let nonAwsRegions: [String]?
        public let notes: String?
        public let owner: String?
        public let pillarPriorities: [String]?
        public let reviewOwner: String?
        public let reviewRestrictionDate: Date?
        public let riskCounts: [Risk: Int]?
        /// The ID assigned to the share invitation.
        public let shareInvitationId: String?
        /// The tags associated with the workload.
        public let tags: [String: String]?
        public let updatedAt: Date?
        public let workloadArn: String?
        public let workloadId: String?
        public let workloadName: String?

        public init(accountIds: [String]? = nil, applications: [String]? = nil, architecturalDesign: String? = nil, awsRegions: [String]? = nil, description: String? = nil, discoveryConfig: WorkloadDiscoveryConfig? = nil, environment: WorkloadEnvironment? = nil, improvementStatus: WorkloadImprovementStatus? = nil, industry: String? = nil, industryType: String? = nil, isReviewOwnerUpdateAcknowledged: Bool? = nil, lenses: [String]? = nil, nonAwsRegions: [String]? = nil, notes: String? = nil, owner: String? = nil, pillarPriorities: [String]? = nil, reviewOwner: String? = nil, reviewRestrictionDate: Date? = nil, riskCounts: [Risk: Int]? = nil, shareInvitationId: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, workloadArn: String? = nil, workloadId: String? = nil, workloadName: String? = nil) {
            self.accountIds = accountIds
            self.applications = applications
            self.architecturalDesign = architecturalDesign
            self.awsRegions = awsRegions
            self.description = description
            self.discoveryConfig = discoveryConfig
            self.environment = environment
            self.improvementStatus = improvementStatus
            self.industry = industry
            self.industryType = industryType
            self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
            self.lenses = lenses
            self.nonAwsRegions = nonAwsRegions
            self.notes = notes
            self.owner = owner
            self.pillarPriorities = pillarPriorities
            self.reviewOwner = reviewOwner
            self.reviewRestrictionDate = reviewRestrictionDate
            self.riskCounts = riskCounts
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case applications = "Applications"
            case architecturalDesign = "ArchitecturalDesign"
            case awsRegions = "AwsRegions"
            case description = "Description"
            case discoveryConfig = "DiscoveryConfig"
            case environment = "Environment"
            case improvementStatus = "ImprovementStatus"
            case industry = "Industry"
            case industryType = "IndustryType"
            case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
            case lenses = "Lenses"
            case nonAwsRegions = "NonAwsRegions"
            case notes = "Notes"
            case owner = "Owner"
            case pillarPriorities = "PillarPriorities"
            case reviewOwner = "ReviewOwner"
            case reviewRestrictionDate = "ReviewRestrictionDate"
            case riskCounts = "RiskCounts"
            case shareInvitationId = "ShareInvitationId"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
            case workloadArn = "WorkloadArn"
            case workloadId = "WorkloadId"
            case workloadName = "WorkloadName"
        }
    }

    public struct WorkloadDiscoveryConfig: AWSEncodableShape & AWSDecodableShape {
        /// Discovery integration status in respect to Trusted Advisor for the workload.
        public let trustedAdvisorIntegrationStatus: TrustedAdvisorIntegrationStatus?

        public init(trustedAdvisorIntegrationStatus: TrustedAdvisorIntegrationStatus? = nil) {
            self.trustedAdvisorIntegrationStatus = trustedAdvisorIntegrationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case trustedAdvisorIntegrationStatus = "TrustedAdvisorIntegrationStatus"
        }
    }

    public struct WorkloadShare: AWSDecodableShape {
        public let permissionType: PermissionType?
        public let sharedBy: String?
        public let sharedWith: String?
        public let shareId: String?
        public let status: ShareStatus?
        public let workloadId: String?
        public let workloadName: String?

        public init(permissionType: PermissionType? = nil, sharedBy: String? = nil, sharedWith: String? = nil, shareId: String? = nil, status: ShareStatus? = nil, workloadId: String? = nil, workloadName: String? = nil) {
            self.permissionType = permissionType
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.shareId = shareId
            self.status = status
            self.workloadId = workloadId
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case permissionType = "PermissionType"
            case sharedBy = "SharedBy"
            case sharedWith = "SharedWith"
            case shareId = "ShareId"
            case status = "Status"
            case workloadId = "WorkloadId"
            case workloadName = "WorkloadName"
        }
    }

    public struct WorkloadShareSummary: AWSDecodableShape {
        public let permissionType: PermissionType?
        public let sharedWith: String?
        public let shareId: String?
        public let status: ShareStatus?
        /// Optional message to compliment the Status field.
        public let statusMessage: String?

        public init(permissionType: PermissionType? = nil, sharedWith: String? = nil, shareId: String? = nil, status: ShareStatus? = nil, statusMessage: String? = nil) {
            self.permissionType = permissionType
            self.sharedWith = sharedWith
            self.shareId = shareId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case permissionType = "PermissionType"
            case sharedWith = "SharedWith"
            case shareId = "ShareId"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct WorkloadSummary: AWSDecodableShape {
        public let improvementStatus: WorkloadImprovementStatus?
        public let lenses: [String]?
        public let owner: String?
        public let riskCounts: [Risk: Int]?
        public let updatedAt: Date?
        public let workloadArn: String?
        public let workloadId: String?
        public let workloadName: String?

        public init(improvementStatus: WorkloadImprovementStatus? = nil, lenses: [String]? = nil, owner: String? = nil, riskCounts: [Risk: Int]? = nil, updatedAt: Date? = nil, workloadArn: String? = nil, workloadId: String? = nil, workloadName: String? = nil) {
            self.improvementStatus = improvementStatus
            self.lenses = lenses
            self.owner = owner
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case improvementStatus = "ImprovementStatus"
            case lenses = "Lenses"
            case owner = "Owner"
            case riskCounts = "RiskCounts"
            case updatedAt = "UpdatedAt"
            case workloadArn = "WorkloadArn"
            case workloadId = "WorkloadId"
            case workloadName = "WorkloadName"
        }
    }
}

// MARK: - Errors

/// Error enum for WellArchitected
public struct WellArchitectedErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize WellArchitected
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The resource already exists.
    public static var conflictException: Self { .init(.conflictException) }
    /// There is a problem with the Well-Architected Tool API service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The user has reached their resource quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The user input is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension WellArchitectedErrorType: Equatable {
    public static func == (lhs: WellArchitectedErrorType, rhs: WellArchitectedErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WellArchitectedErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
