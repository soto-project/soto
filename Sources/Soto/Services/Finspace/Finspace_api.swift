//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Finspace service.
///
/// The FinSpace management service provides the APIs for managing FinSpace environments.
public struct Finspace: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Finspace client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Finspace",
            serviceIdentifier: "finspace",
            serviceProtocol: .restjson,
            apiVersion: "2021-03-12",
            endpoint: endpoint,
            errorType: FinspaceErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Create a new FinSpace environment.
    @available(*, deprecated, message: "This method will be discontinued.")
    @Sendable
    @inlinable
    public func createEnvironment(_ input: CreateEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEnvironmentResponse {
        try await self.client.execute(
            operation: "CreateEnvironment", 
            path: "/environment", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new FinSpace environment.
    ///
    /// Parameters:
    ///   - dataBundles: The list of Amazon Resource Names (ARN) of the data bundles to install. Currently supported data bundle ARNs:    arn:aws:finspace:${Region}::data-bundle/capital-markets-sample - Contains sample Capital Markets datasets, categories and controlled vocabularies.    arn:aws:finspace:${Region}::data-bundle/taq (default) - Contains trades and quotes data in addition to sample Capital Markets data.
    ///   - description: The description of the FinSpace environment to be created.
    ///   - federationMode: Authentication mode for the environment.    FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.    LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
    ///   - federationParameters: Configuration information when authentication mode is FEDERATED.
    ///   - kmsKeyId: The KMS key id to encrypt your data in the FinSpace environment.
    ///   - name: The name of the FinSpace environment to be created.
    ///   - superuserParameters: Configuration information for the superuser.
    ///   - tags: Add tags to your FinSpace environment.
    ///   - logger: Logger use during operation
    @available(*, deprecated, message: "This method will be discontinued.")
    @inlinable
    public func createEnvironment(
        dataBundles: [String]? = nil,
        description: String? = nil,
        federationMode: FederationMode? = nil,
        federationParameters: FederationParameters? = nil,
        kmsKeyId: String? = nil,
        name: String,
        superuserParameters: SuperuserParameters? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateEnvironmentResponse {
        let input = CreateEnvironmentRequest(
            dataBundles: dataBundles, 
            description: description, 
            federationMode: federationMode, 
            federationParameters: federationParameters, 
            kmsKeyId: kmsKeyId, 
            name: name, 
            superuserParameters: superuserParameters, 
            tags: tags
        )
        return try await self.createEnvironment(input, logger: logger)
    }

    ///  Creates a changeset for a kdb database. A changeset allows you to add and delete existing files by using an ordered list of change requests.
    @Sendable
    @inlinable
    public func createKxChangeset(_ input: CreateKxChangesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKxChangesetResponse {
        try await self.client.execute(
            operation: "CreateKxChangeset", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}/changesets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a changeset for a kdb database. A changeset allows you to add and delete existing files by using an ordered list of change requests.
    ///
    /// Parameters:
    ///   - changeRequests: A list of change request objects that are run in order. A change request object consists of changeType , s3Path, and dbPath.  A changeType can have the following values:    PUT – Adds or updates files in a database.   DELETE – Deletes files in a database.   All the change requests require a mandatory dbPath attribute that defines the path within the database directory. All database paths must start with a leading / and end with a trailing /. The s3Path attribute defines the s3 source file path and is required for a PUT change type. The s3path must end with a trailing / if it is a directory and must end without a trailing / if it is a file.  Here are few examples of how you can use the change request object:   This request adds a single sym file at database root location.     { "changeType": "PUT", "s3Path":"s3://bucket/db/sym", "dbPath":"/"}    This request adds files in the given s3Path under the 2020.01.02 partition of the database.  { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/", "dbPath":"/2020.01.02/"}    This request adds files in the given s3Path under the taq table partition of the database.  [ { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/taq/", "dbPath":"/2020.01.02/taq/"}]    This request deletes the 2020.01.02 partition of the database.  [{ "changeType": "DELETE", "dbPath": "/2020.01.02/"} ]    The DELETE request allows you to delete the existing files under the 2020.01.02 partition of the database, and the PUT request adds a new taq table under it.  [ {"changeType": "DELETE", "dbPath":"/2020.01.02/"}, {"changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/taq/", "dbPath":"/2020.01.02/taq/"}]
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - databaseName: The name of the kdb database.
    ///   - environmentId: A unique identifier of the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKxChangeset(
        changeRequests: [ChangeRequest],
        clientToken: String = CreateKxChangesetRequest.idempotencyToken(),
        databaseName: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKxChangesetResponse {
        let input = CreateKxChangesetRequest(
            changeRequests: changeRequests, 
            clientToken: clientToken, 
            databaseName: databaseName, 
            environmentId: environmentId
        )
        return try await self.createKxChangeset(input, logger: logger)
    }

    /// Creates a new kdb cluster.
    @Sendable
    @inlinable
    public func createKxCluster(_ input: CreateKxClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKxClusterResponse {
        try await self.client.execute(
            operation: "CreateKxCluster", 
            path: "/kx/environments/{environmentId}/clusters", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new kdb cluster.
    ///
    /// Parameters:
    ///   - autoScalingConfiguration: The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
    ///   - availabilityZoneId: The availability zone identifiers for the requested regions.
    ///   - azMode: The number of availability zones you want to assign per cluster. This can be one of the following     SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
    ///   - cacheStorageConfigurations: The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
    ///   - capacityConfiguration: A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - clusterDescription: A description of the cluster.
    ///   - clusterName: A unique name for the cluster that you want to create.
    ///   - clusterType: Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.   GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.   Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    ///   - code: The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
    ///   - commandLineArguments: Defines the key-value pairs to make them available inside the cluster.
    ///   - databases: A list of databases that will be available for querying.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - executionRole: An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
    ///   - initializationScript: Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
    ///   - releaseLabel: The version of FinSpace managed kdb to run.
    ///   - savedownStorageConfiguration: The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
    ///   - scalingGroupConfiguration: The structure that stores the configuration details of a scaling group.
    ///   - tags: A list of key-value pairs to label the cluster. You can add up to 50 tags to a cluster.
    ///   - tickerplantLogConfiguration: A configuration to store Tickerplant logs. It consists of
    ///   - vpcConfiguration: Configuration details about the network where the Privatelink endpoint of the cluster resides.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKxCluster(
        autoScalingConfiguration: AutoScalingConfiguration? = nil,
        availabilityZoneId: String? = nil,
        azMode: KxAzMode,
        cacheStorageConfigurations: [KxCacheStorageConfiguration]? = nil,
        capacityConfiguration: CapacityConfiguration? = nil,
        clientToken: String? = CreateKxClusterRequest.idempotencyToken(),
        clusterDescription: String? = nil,
        clusterName: String,
        clusterType: KxClusterType,
        code: CodeConfiguration? = nil,
        commandLineArguments: [KxCommandLineArgument]? = nil,
        databases: [KxDatabaseConfiguration]? = nil,
        environmentId: String,
        executionRole: String? = nil,
        initializationScript: String? = nil,
        releaseLabel: String,
        savedownStorageConfiguration: KxSavedownStorageConfiguration? = nil,
        scalingGroupConfiguration: KxScalingGroupConfiguration? = nil,
        tags: [String: String]? = nil,
        tickerplantLogConfiguration: TickerplantLogConfiguration? = nil,
        vpcConfiguration: VpcConfiguration,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKxClusterResponse {
        let input = CreateKxClusterRequest(
            autoScalingConfiguration: autoScalingConfiguration, 
            availabilityZoneId: availabilityZoneId, 
            azMode: azMode, 
            cacheStorageConfigurations: cacheStorageConfigurations, 
            capacityConfiguration: capacityConfiguration, 
            clientToken: clientToken, 
            clusterDescription: clusterDescription, 
            clusterName: clusterName, 
            clusterType: clusterType, 
            code: code, 
            commandLineArguments: commandLineArguments, 
            databases: databases, 
            environmentId: environmentId, 
            executionRole: executionRole, 
            initializationScript: initializationScript, 
            releaseLabel: releaseLabel, 
            savedownStorageConfiguration: savedownStorageConfiguration, 
            scalingGroupConfiguration: scalingGroupConfiguration, 
            tags: tags, 
            tickerplantLogConfiguration: tickerplantLogConfiguration, 
            vpcConfiguration: vpcConfiguration
        )
        return try await self.createKxCluster(input, logger: logger)
    }

    /// Creates a new kdb database in the environment.
    @Sendable
    @inlinable
    public func createKxDatabase(_ input: CreateKxDatabaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKxDatabaseResponse {
        try await self.client.execute(
            operation: "CreateKxDatabase", 
            path: "/kx/environments/{environmentId}/databases", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new kdb database in the environment.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - databaseName: The name of the kdb database.
    ///   - description: A description of the database.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - tags: A list of key-value pairs to label the kdb database. You can add up to 50 tags to your kdb database
    ///   - logger: Logger use during operation
    @inlinable
    public func createKxDatabase(
        clientToken: String = CreateKxDatabaseRequest.idempotencyToken(),
        databaseName: String,
        description: String? = nil,
        environmentId: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKxDatabaseResponse {
        let input = CreateKxDatabaseRequest(
            clientToken: clientToken, 
            databaseName: databaseName, 
            description: description, 
            environmentId: environmentId, 
            tags: tags
        )
        return try await self.createKxDatabase(input, logger: logger)
    }

    /// Creates a snapshot of kdb database with tiered storage capabilities and a pre-warmed cache, ready for mounting on kdb clusters.  Dataviews are only available for clusters running on a scaling group. They are not supported on dedicated clusters.
    @Sendable
    @inlinable
    public func createKxDataview(_ input: CreateKxDataviewRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKxDataviewResponse {
        try await self.client.execute(
            operation: "CreateKxDataview", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}/dataviews", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a snapshot of kdb database with tiered storage capabilities and a pre-warmed cache, ready for mounting on kdb clusters.  Dataviews are only available for clusters running on a scaling group. They are not supported on dedicated clusters.
    ///
    /// Parameters:
    ///   - autoUpdate: The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
    ///   - availabilityZoneId:  The identifier of the availability zones.
    ///   - azMode: The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    ///   - changesetId: A unique identifier of the changeset that you want to use to ingest data.
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - databaseName: The name of the database where you want to create a dataview.
    ///   - dataviewName: A unique identifier for the dataview.
    ///   - description: A description of the dataview.
    ///   - environmentId: A unique identifier for the kdb environment, where you want to create the dataview.
    ///   - readWrite:  The option to specify whether you want to make the dataview writable to perform database maintenance. The following are some considerations related to writable dataviews.     You cannot create partial writable dataviews. When you create writeable dataviews you must provide the entire database path.   You cannot perform updates on a writeable dataview. Hence, autoUpdate must be set as False if readWrite is True for a dataview.   You must also use a unique volume for creating a writeable dataview. So, if you choose a volume that is already in use by another dataview, the dataview creation fails.   Once you create a dataview as writeable, you cannot change it to read-only. So, you cannot update the readWrite parameter later.
    ///   - segmentConfigurations:  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    ///   - tags: A list of key-value pairs to label the dataview. You can add up to 50 tags to a dataview.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKxDataview(
        autoUpdate: Bool? = nil,
        availabilityZoneId: String? = nil,
        azMode: KxAzMode,
        changesetId: String? = nil,
        clientToken: String = CreateKxDataviewRequest.idempotencyToken(),
        databaseName: String,
        dataviewName: String,
        description: String? = nil,
        environmentId: String,
        readWrite: Bool? = nil,
        segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKxDataviewResponse {
        let input = CreateKxDataviewRequest(
            autoUpdate: autoUpdate, 
            availabilityZoneId: availabilityZoneId, 
            azMode: azMode, 
            changesetId: changesetId, 
            clientToken: clientToken, 
            databaseName: databaseName, 
            dataviewName: dataviewName, 
            description: description, 
            environmentId: environmentId, 
            readWrite: readWrite, 
            segmentConfigurations: segmentConfigurations, 
            tags: tags
        )
        return try await self.createKxDataview(input, logger: logger)
    }

    /// Creates a managed kdb environment for the account.
    @Sendable
    @inlinable
    public func createKxEnvironment(_ input: CreateKxEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKxEnvironmentResponse {
        try await self.client.execute(
            operation: "CreateKxEnvironment", 
            path: "/kx/environments", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a managed kdb environment for the account.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - description: A description for the kdb environment.
    ///   - kmsKeyId: The KMS key ID to encrypt your data in the FinSpace environment.
    ///   - name: The name of the kdb environment that you want to create.
    ///   - tags: A list of key-value pairs to label the kdb environment. You can add up to 50 tags to your kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKxEnvironment(
        clientToken: String? = CreateKxEnvironmentRequest.idempotencyToken(),
        description: String? = nil,
        kmsKeyId: String,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKxEnvironmentResponse {
        let input = CreateKxEnvironmentRequest(
            clientToken: clientToken, 
            description: description, 
            kmsKeyId: kmsKeyId, 
            name: name, 
            tags: tags
        )
        return try await self.createKxEnvironment(input, logger: logger)
    }

    /// Creates a new scaling group.
    @Sendable
    @inlinable
    public func createKxScalingGroup(_ input: CreateKxScalingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKxScalingGroupResponse {
        try await self.client.execute(
            operation: "CreateKxScalingGroup", 
            path: "/kx/environments/{environmentId}/scalingGroups", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new scaling group.
    ///
    /// Parameters:
    ///   - availabilityZoneId: The identifier of the availability zones.
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - environmentId: A unique identifier for the kdb environment, where you want to create the scaling group.
    ///   - hostType:  The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed. You can add one of the following values:    kx.sg.large – The host type with a configuration of 16 GiB memory and 2 vCPUs.    kx.sg.xlarge – The host type with a configuration of 32 GiB memory and 4 vCPUs.    kx.sg.2xlarge – The host type with a configuration of 64 GiB memory and 8 vCPUs.    kx.sg.4xlarge – The host type with a configuration of 108 GiB memory and 16 vCPUs.    kx.sg.8xlarge – The host type with a configuration of 216 GiB memory and 32 vCPUs.    kx.sg.16xlarge – The host type with a configuration of 432 GiB memory and 64 vCPUs.    kx.sg.32xlarge – The host type with a configuration of 864 GiB memory and 128 vCPUs.    kx.sg1.16xlarge – The host type with a configuration of 1949 GiB memory and 64 vCPUs.    kx.sg1.24xlarge – The host type with a configuration of 2948 GiB memory and 96 vCPUs.
    ///   - scalingGroupName: A unique identifier for the kdb scaling group.
    ///   - tags: A list of key-value pairs to label the scaling group. You can add up to 50 tags to a scaling group.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKxScalingGroup(
        availabilityZoneId: String,
        clientToken: String = CreateKxScalingGroupRequest.idempotencyToken(),
        environmentId: String,
        hostType: String,
        scalingGroupName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKxScalingGroupResponse {
        let input = CreateKxScalingGroupRequest(
            availabilityZoneId: availabilityZoneId, 
            clientToken: clientToken, 
            environmentId: environmentId, 
            hostType: hostType, 
            scalingGroupName: scalingGroupName, 
            tags: tags
        )
        return try await self.createKxScalingGroup(input, logger: logger)
    }

    /// Creates a user in FinSpace kdb environment with an associated IAM role.
    @Sendable
    @inlinable
    public func createKxUser(_ input: CreateKxUserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKxUserResponse {
        try await self.client.execute(
            operation: "CreateKxUser", 
            path: "/kx/environments/{environmentId}/users", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a user in FinSpace kdb environment with an associated IAM role.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - environmentId: A unique identifier for the kdb environment where you want to create a user.
    ///   - iamRole: The IAM role ARN that will be associated with the user.
    ///   - tags: A list of key-value pairs to label the user. You can add up to 50 tags to a user.
    ///   - userName: A unique identifier for the user.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKxUser(
        clientToken: String? = CreateKxUserRequest.idempotencyToken(),
        environmentId: String,
        iamRole: String,
        tags: [String: String]? = nil,
        userName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKxUserResponse {
        let input = CreateKxUserRequest(
            clientToken: clientToken, 
            environmentId: environmentId, 
            iamRole: iamRole, 
            tags: tags, 
            userName: userName
        )
        return try await self.createKxUser(input, logger: logger)
    }

    /// Creates a new volume with a specific amount of throughput and storage capacity.
    @Sendable
    @inlinable
    public func createKxVolume(_ input: CreateKxVolumeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKxVolumeResponse {
        try await self.client.execute(
            operation: "CreateKxVolume", 
            path: "/kx/environments/{environmentId}/kxvolumes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new volume with a specific amount of throughput and storage capacity.
    ///
    /// Parameters:
    ///   - availabilityZoneIds: The identifier of the availability zones.
    ///   - azMode: The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - description: A description of the volume.
    ///   - environmentId: A unique identifier for the kdb environment, whose clusters can attach to the volume.
    ///   - nas1Configuration:  Specifies the configuration for the Network attached storage (NAS_1) file system volume. This parameter is required when you choose volumeType as NAS_1.
    ///   - tags: A list of key-value pairs to label the volume. You can add up to 50 tags to a volume.
    ///   - volumeName: A unique identifier for the volume.
    ///   - volumeType:  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type. When you select NAS_1 volume type, you must also provide nas1Configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKxVolume(
        availabilityZoneIds: [String],
        azMode: KxAzMode,
        clientToken: String? = CreateKxVolumeRequest.idempotencyToken(),
        description: String? = nil,
        environmentId: String,
        nas1Configuration: KxNAS1Configuration? = nil,
        tags: [String: String]? = nil,
        volumeName: String,
        volumeType: KxVolumeType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKxVolumeResponse {
        let input = CreateKxVolumeRequest(
            availabilityZoneIds: availabilityZoneIds, 
            azMode: azMode, 
            clientToken: clientToken, 
            description: description, 
            environmentId: environmentId, 
            nas1Configuration: nas1Configuration, 
            tags: tags, 
            volumeName: volumeName, 
            volumeType: volumeType
        )
        return try await self.createKxVolume(input, logger: logger)
    }

    /// Delete an FinSpace environment.
    @available(*, deprecated, message: "This method will be discontinued.")
    @Sendable
    @inlinable
    public func deleteEnvironment(_ input: DeleteEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteEnvironmentResponse {
        try await self.client.execute(
            operation: "DeleteEnvironment", 
            path: "/environment/{environmentId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete an FinSpace environment.
    ///
    /// Parameters:
    ///   - environmentId: The identifier for the FinSpace environment.
    ///   - logger: Logger use during operation
    @available(*, deprecated, message: "This method will be discontinued.")
    @inlinable
    public func deleteEnvironment(
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteEnvironmentResponse {
        let input = DeleteEnvironmentRequest(
            environmentId: environmentId
        )
        return try await self.deleteEnvironment(input, logger: logger)
    }

    /// Deletes a kdb cluster.
    @Sendable
    @inlinable
    public func deleteKxCluster(_ input: DeleteKxClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKxClusterResponse {
        try await self.client.execute(
            operation: "DeleteKxCluster", 
            path: "/kx/environments/{environmentId}/clusters/{clusterName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a kdb cluster.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - clusterName: The name of the cluster that you want to delete.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKxCluster(
        clientToken: String? = DeleteKxClusterRequest.idempotencyToken(),
        clusterName: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKxClusterResponse {
        let input = DeleteKxClusterRequest(
            clientToken: clientToken, 
            clusterName: clusterName, 
            environmentId: environmentId
        )
        return try await self.deleteKxCluster(input, logger: logger)
    }

    /// Deletes the specified nodes from a cluster.
    @Sendable
    @inlinable
    public func deleteKxClusterNode(_ input: DeleteKxClusterNodeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKxClusterNodeResponse {
        try await self.client.execute(
            operation: "DeleteKxClusterNode", 
            path: "/kx/environments/{environmentId}/clusters/{clusterName}/nodes/{nodeId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified nodes from a cluster.
    ///
    /// Parameters:
    ///   - clusterName: The name of the cluster, for which you want to delete the nodes.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - nodeId: A unique identifier for the node that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKxClusterNode(
        clusterName: String,
        environmentId: String,
        nodeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKxClusterNodeResponse {
        let input = DeleteKxClusterNodeRequest(
            clusterName: clusterName, 
            environmentId: environmentId, 
            nodeId: nodeId
        )
        return try await self.deleteKxClusterNode(input, logger: logger)
    }

    /// Deletes the specified database and all of its associated data. This action is irreversible. You must copy any data out of the database before deleting it if the data is to be retained.
    @Sendable
    @inlinable
    public func deleteKxDatabase(_ input: DeleteKxDatabaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKxDatabaseResponse {
        try await self.client.execute(
            operation: "DeleteKxDatabase", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified database and all of its associated data. This action is irreversible. You must copy any data out of the database before deleting it if the data is to be retained.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - databaseName: The name of the kdb database that you want to delete.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKxDatabase(
        clientToken: String = DeleteKxDatabaseRequest.idempotencyToken(),
        databaseName: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKxDatabaseResponse {
        let input = DeleteKxDatabaseRequest(
            clientToken: clientToken, 
            databaseName: databaseName, 
            environmentId: environmentId
        )
        return try await self.deleteKxDatabase(input, logger: logger)
    }

    /// Deletes the specified dataview. Before deleting a dataview, make sure that it is not in use by any cluster.
    @Sendable
    @inlinable
    public func deleteKxDataview(_ input: DeleteKxDataviewRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKxDataviewResponse {
        try await self.client.execute(
            operation: "DeleteKxDataview", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}/dataviews/{dataviewName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified dataview. Before deleting a dataview, make sure that it is not in use by any cluster.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - databaseName: The name of the database whose dataview you want to delete.
    ///   - dataviewName: The name of the dataview that you want to delete.
    ///   - environmentId: A unique identifier for the kdb environment, from where you want to delete the dataview.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKxDataview(
        clientToken: String = DeleteKxDataviewRequest.idempotencyToken(),
        databaseName: String,
        dataviewName: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKxDataviewResponse {
        let input = DeleteKxDataviewRequest(
            clientToken: clientToken, 
            databaseName: databaseName, 
            dataviewName: dataviewName, 
            environmentId: environmentId
        )
        return try await self.deleteKxDataview(input, logger: logger)
    }

    /// Deletes the kdb environment. This action is irreversible. Deleting a kdb environment will remove all the associated data and any services running in it.
    @Sendable
    @inlinable
    public func deleteKxEnvironment(_ input: DeleteKxEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKxEnvironmentResponse {
        try await self.client.execute(
            operation: "DeleteKxEnvironment", 
            path: "/kx/environments/{environmentId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the kdb environment. This action is irreversible. Deleting a kdb environment will remove all the associated data and any services running in it.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKxEnvironment(
        clientToken: String? = DeleteKxEnvironmentRequest.idempotencyToken(),
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKxEnvironmentResponse {
        let input = DeleteKxEnvironmentRequest(
            clientToken: clientToken, 
            environmentId: environmentId
        )
        return try await self.deleteKxEnvironment(input, logger: logger)
    }

    /// Deletes the specified scaling group. This action is irreversible. You cannot delete a scaling group until all the clusters running on it have been deleted.
    @Sendable
    @inlinable
    public func deleteKxScalingGroup(_ input: DeleteKxScalingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKxScalingGroupResponse {
        try await self.client.execute(
            operation: "DeleteKxScalingGroup", 
            path: "/kx/environments/{environmentId}/scalingGroups/{scalingGroupName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified scaling group. This action is irreversible. You cannot delete a scaling group until all the clusters running on it have been deleted.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - environmentId: A unique identifier for the kdb environment, from where you want to delete the dataview.
    ///   - scalingGroupName: A unique identifier for the kdb scaling group.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKxScalingGroup(
        clientToken: String? = DeleteKxScalingGroupRequest.idempotencyToken(),
        environmentId: String,
        scalingGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKxScalingGroupResponse {
        let input = DeleteKxScalingGroupRequest(
            clientToken: clientToken, 
            environmentId: environmentId, 
            scalingGroupName: scalingGroupName
        )
        return try await self.deleteKxScalingGroup(input, logger: logger)
    }

    /// Deletes a user in the specified kdb environment.
    @Sendable
    @inlinable
    public func deleteKxUser(_ input: DeleteKxUserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKxUserResponse {
        try await self.client.execute(
            operation: "DeleteKxUser", 
            path: "/kx/environments/{environmentId}/users/{userName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a user in the specified kdb environment.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - userName: A unique identifier for the user that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKxUser(
        clientToken: String? = DeleteKxUserRequest.idempotencyToken(),
        environmentId: String,
        userName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKxUserResponse {
        let input = DeleteKxUserRequest(
            clientToken: clientToken, 
            environmentId: environmentId, 
            userName: userName
        )
        return try await self.deleteKxUser(input, logger: logger)
    }

    ///  Deletes a volume. You can only delete a volume if it's not attached to a cluster or a dataview. When a volume is deleted, any data on the volume is lost. This action is irreversible.
    @Sendable
    @inlinable
    public func deleteKxVolume(_ input: DeleteKxVolumeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKxVolumeResponse {
        try await self.client.execute(
            operation: "DeleteKxVolume", 
            path: "/kx/environments/{environmentId}/kxvolumes/{volumeName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a volume. You can only delete a volume if it's not attached to a cluster or a dataview. When a volume is deleted, any data on the volume is lost. This action is irreversible.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - environmentId: A unique identifier for the kdb environment, whose clusters can attach to the volume.
    ///   - volumeName: The name of the volume that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKxVolume(
        clientToken: String? = DeleteKxVolumeRequest.idempotencyToken(),
        environmentId: String,
        volumeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKxVolumeResponse {
        let input = DeleteKxVolumeRequest(
            clientToken: clientToken, 
            environmentId: environmentId, 
            volumeName: volumeName
        )
        return try await self.deleteKxVolume(input, logger: logger)
    }

    /// Returns the FinSpace environment object.
    @available(*, deprecated, message: "This method will be discontinued.")
    @Sendable
    @inlinable
    public func getEnvironment(_ input: GetEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEnvironmentResponse {
        try await self.client.execute(
            operation: "GetEnvironment", 
            path: "/environment/{environmentId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the FinSpace environment object.
    ///
    /// Parameters:
    ///   - environmentId: The identifier of the FinSpace environment.
    ///   - logger: Logger use during operation
    @available(*, deprecated, message: "This method will be discontinued.")
    @inlinable
    public func getEnvironment(
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEnvironmentResponse {
        let input = GetEnvironmentRequest(
            environmentId: environmentId
        )
        return try await self.getEnvironment(input, logger: logger)
    }

    /// Returns information about a kdb changeset.
    @Sendable
    @inlinable
    public func getKxChangeset(_ input: GetKxChangesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxChangesetResponse {
        try await self.client.execute(
            operation: "GetKxChangeset", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}/changesets/{changesetId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a kdb changeset.
    ///
    /// Parameters:
    ///   - changesetId: A unique identifier of the changeset for which you want to retrieve data.
    ///   - databaseName: The name of the kdb database.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxChangeset(
        changesetId: String,
        databaseName: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxChangesetResponse {
        let input = GetKxChangesetRequest(
            changesetId: changesetId, 
            databaseName: databaseName, 
            environmentId: environmentId
        )
        return try await self.getKxChangeset(input, logger: logger)
    }

    /// Retrieves information about a kdb cluster.
    @Sendable
    @inlinable
    public func getKxCluster(_ input: GetKxClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxClusterResponse {
        try await self.client.execute(
            operation: "GetKxCluster", 
            path: "/kx/environments/{environmentId}/clusters/{clusterName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a kdb cluster.
    ///
    /// Parameters:
    ///   - clusterName: The name of the cluster that you want to retrieve.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxCluster(
        clusterName: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxClusterResponse {
        let input = GetKxClusterRequest(
            clusterName: clusterName, 
            environmentId: environmentId
        )
        return try await self.getKxCluster(input, logger: logger)
    }

    /// Retrieves a connection string for a user to connect to a kdb cluster. You must call this API using the same role that you have defined while creating a user.
    @Sendable
    @inlinable
    public func getKxConnectionString(_ input: GetKxConnectionStringRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxConnectionStringResponse {
        try await self.client.execute(
            operation: "GetKxConnectionString", 
            path: "/kx/environments/{environmentId}/connectionString", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a connection string for a user to connect to a kdb cluster. You must call this API using the same role that you have defined while creating a user.
    ///
    /// Parameters:
    ///   - clusterName: A name of the kdb cluster.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - userArn:  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxConnectionString(
        clusterName: String,
        environmentId: String,
        userArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxConnectionStringResponse {
        let input = GetKxConnectionStringRequest(
            clusterName: clusterName, 
            environmentId: environmentId, 
            userArn: userArn
        )
        return try await self.getKxConnectionString(input, logger: logger)
    }

    /// Returns database information for the specified environment ID.
    @Sendable
    @inlinable
    public func getKxDatabase(_ input: GetKxDatabaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxDatabaseResponse {
        try await self.client.execute(
            operation: "GetKxDatabase", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns database information for the specified environment ID.
    ///
    /// Parameters:
    ///   - databaseName: The name of the kdb database.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxDatabase(
        databaseName: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxDatabaseResponse {
        let input = GetKxDatabaseRequest(
            databaseName: databaseName, 
            environmentId: environmentId
        )
        return try await self.getKxDatabase(input, logger: logger)
    }

    /// Retrieves details of the dataview.
    @Sendable
    @inlinable
    public func getKxDataview(_ input: GetKxDataviewRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxDataviewResponse {
        try await self.client.execute(
            operation: "GetKxDataview", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}/dataviews/{dataviewName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves details of the dataview.
    ///
    /// Parameters:
    ///   - databaseName: The name of the database where you created the dataview.
    ///   - dataviewName: A unique identifier for the dataview.
    ///   - environmentId: A unique identifier for the kdb environment, from where you want to retrieve the dataview details.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxDataview(
        databaseName: String,
        dataviewName: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxDataviewResponse {
        let input = GetKxDataviewRequest(
            databaseName: databaseName, 
            dataviewName: dataviewName, 
            environmentId: environmentId
        )
        return try await self.getKxDataview(input, logger: logger)
    }

    /// Retrieves all the information for the specified kdb environment.
    @Sendable
    @inlinable
    public func getKxEnvironment(_ input: GetKxEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxEnvironmentResponse {
        try await self.client.execute(
            operation: "GetKxEnvironment", 
            path: "/kx/environments/{environmentId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all the information for the specified kdb environment.
    ///
    /// Parameters:
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxEnvironment(
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxEnvironmentResponse {
        let input = GetKxEnvironmentRequest(
            environmentId: environmentId
        )
        return try await self.getKxEnvironment(input, logger: logger)
    }

    /// Retrieves details of a scaling group.
    @Sendable
    @inlinable
    public func getKxScalingGroup(_ input: GetKxScalingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxScalingGroupResponse {
        try await self.client.execute(
            operation: "GetKxScalingGroup", 
            path: "/kx/environments/{environmentId}/scalingGroups/{scalingGroupName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves details of a scaling group.
    ///
    /// Parameters:
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - scalingGroupName: A unique identifier for the kdb scaling group.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxScalingGroup(
        environmentId: String,
        scalingGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxScalingGroupResponse {
        let input = GetKxScalingGroupRequest(
            environmentId: environmentId, 
            scalingGroupName: scalingGroupName
        )
        return try await self.getKxScalingGroup(input, logger: logger)
    }

    /// Retrieves information about the specified kdb user.
    @Sendable
    @inlinable
    public func getKxUser(_ input: GetKxUserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxUserResponse {
        try await self.client.execute(
            operation: "GetKxUser", 
            path: "/kx/environments/{environmentId}/users/{userName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the specified kdb user.
    ///
    /// Parameters:
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - userName: A unique identifier for the user.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxUser(
        environmentId: String,
        userName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxUserResponse {
        let input = GetKxUserRequest(
            environmentId: environmentId, 
            userName: userName
        )
        return try await self.getKxUser(input, logger: logger)
    }

    /// Retrieves the information about the volume.
    @Sendable
    @inlinable
    public func getKxVolume(_ input: GetKxVolumeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetKxVolumeResponse {
        try await self.client.execute(
            operation: "GetKxVolume", 
            path: "/kx/environments/{environmentId}/kxvolumes/{volumeName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the information about the volume.
    ///
    /// Parameters:
    ///   - environmentId: A unique identifier for the kdb environment, whose clusters can attach to the volume.
    ///   - volumeName: A unique identifier for the volume.
    ///   - logger: Logger use during operation
    @inlinable
    public func getKxVolume(
        environmentId: String,
        volumeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetKxVolumeResponse {
        let input = GetKxVolumeRequest(
            environmentId: environmentId, 
            volumeName: volumeName
        )
        return try await self.getKxVolume(input, logger: logger)
    }

    /// A list of all of your FinSpace environments.
    @available(*, deprecated, message: "This method will be discontinued.")
    @Sendable
    @inlinable
    public func listEnvironments(_ input: ListEnvironmentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEnvironmentsResponse {
        try await self.client.execute(
            operation: "ListEnvironments", 
            path: "/environment", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// A list of all of your FinSpace environments.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token generated by FinSpace that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the nextTokennextToken value from the response object of the previous page call.
    ///   - logger: Logger use during operation
    @available(*, deprecated, message: "This method will be discontinued.")
    @inlinable
    public func listEnvironments(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEnvironmentsResponse {
        let input = ListEnvironmentsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listEnvironments(input, logger: logger)
    }

    /// Returns a list of all the changesets for a database.
    @Sendable
    @inlinable
    public func listKxChangesets(_ input: ListKxChangesetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxChangesetsResponse {
        try await self.client.execute(
            operation: "ListKxChangesets", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}/changesets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the changesets for a database.
    ///
    /// Parameters:
    ///   - databaseName: The name of the kdb database.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxChangesets(
        databaseName: String,
        environmentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxChangesetsResponse {
        let input = ListKxChangesetsRequest(
            databaseName: databaseName, 
            environmentId: environmentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKxChangesets(input, logger: logger)
    }

    /// Lists all the nodes in a kdb cluster.
    @Sendable
    @inlinable
    public func listKxClusterNodes(_ input: ListKxClusterNodesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxClusterNodesResponse {
        try await self.client.execute(
            operation: "ListKxClusterNodes", 
            path: "/kx/environments/{environmentId}/clusters/{clusterName}/nodes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the nodes in a kdb cluster.
    ///
    /// Parameters:
    ///   - clusterName: A unique name for the cluster.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxClusterNodes(
        clusterName: String,
        environmentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxClusterNodesResponse {
        let input = ListKxClusterNodesRequest(
            clusterName: clusterName, 
            environmentId: environmentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKxClusterNodes(input, logger: logger)
    }

    /// Returns a list of clusters.
    @Sendable
    @inlinable
    public func listKxClusters(_ input: ListKxClustersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxClustersResponse {
        try await self.client.execute(
            operation: "ListKxClusters", 
            path: "/kx/environments/{environmentId}/clusters", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of clusters.
    ///
    /// Parameters:
    ///   - clusterType: Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.   GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.   Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxClusters(
        clusterType: KxClusterType? = nil,
        environmentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxClustersResponse {
        let input = ListKxClustersRequest(
            clusterType: clusterType, 
            environmentId: environmentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKxClusters(input, logger: logger)
    }

    /// Returns a list of all the databases in the kdb environment.
    @Sendable
    @inlinable
    public func listKxDatabases(_ input: ListKxDatabasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxDatabasesResponse {
        try await self.client.execute(
            operation: "ListKxDatabases", 
            path: "/kx/environments/{environmentId}/databases", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the databases in the kdb environment.
    ///
    /// Parameters:
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxDatabases(
        environmentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxDatabasesResponse {
        let input = ListKxDatabasesRequest(
            environmentId: environmentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKxDatabases(input, logger: logger)
    }

    /// Returns a list of all the dataviews in the database.
    @Sendable
    @inlinable
    public func listKxDataviews(_ input: ListKxDataviewsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxDataviewsResponse {
        try await self.client.execute(
            operation: "ListKxDataviews", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}/dataviews", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the dataviews in the database.
    ///
    /// Parameters:
    ///   - databaseName: The name of the database where the dataviews were created.
    ///   - environmentId: A unique identifier for the kdb environment, for which you want to retrieve a list of dataviews.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxDataviews(
        databaseName: String,
        environmentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxDataviewsResponse {
        let input = ListKxDataviewsRequest(
            databaseName: databaseName, 
            environmentId: environmentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKxDataviews(input, logger: logger)
    }

    /// Returns a list of kdb environments created in an account.
    @Sendable
    @inlinable
    public func listKxEnvironments(_ input: ListKxEnvironmentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxEnvironmentsResponse {
        try await self.client.execute(
            operation: "ListKxEnvironments", 
            path: "/kx/environments", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of kdb environments created in an account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxEnvironments(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxEnvironmentsResponse {
        let input = ListKxEnvironmentsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKxEnvironments(input, logger: logger)
    }

    /// Returns a list of scaling groups in a kdb environment.
    @Sendable
    @inlinable
    public func listKxScalingGroups(_ input: ListKxScalingGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxScalingGroupsResponse {
        try await self.client.execute(
            operation: "ListKxScalingGroups", 
            path: "/kx/environments/{environmentId}/scalingGroups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of scaling groups in a kdb environment.
    ///
    /// Parameters:
    ///   - environmentId: A unique identifier for the kdb environment, for which you want to retrieve a list of scaling groups.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxScalingGroups(
        environmentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxScalingGroupsResponse {
        let input = ListKxScalingGroupsRequest(
            environmentId: environmentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKxScalingGroups(input, logger: logger)
    }

    /// Lists all the users in a kdb environment.
    @Sendable
    @inlinable
    public func listKxUsers(_ input: ListKxUsersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxUsersResponse {
        try await self.client.execute(
            operation: "ListKxUsers", 
            path: "/kx/environments/{environmentId}/users", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the users in a kdb environment.
    ///
    /// Parameters:
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxUsers(
        environmentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxUsersResponse {
        let input = ListKxUsersRequest(
            environmentId: environmentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKxUsers(input, logger: logger)
    }

    /// Lists all the volumes in a kdb environment.
    @Sendable
    @inlinable
    public func listKxVolumes(_ input: ListKxVolumesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKxVolumesResponse {
        try await self.client.execute(
            operation: "ListKxVolumes", 
            path: "/kx/environments/{environmentId}/kxvolumes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the volumes in a kdb environment.
    ///
    /// Parameters:
    ///   - environmentId: A unique identifier for the kdb environment, whose clusters can attach to the volume.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A token that indicates where a results page should begin.
    ///   - volumeType:  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKxVolumes(
        environmentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        volumeType: KxVolumeType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKxVolumesResponse {
        let input = ListKxVolumesRequest(
            environmentId: environmentId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            volumeType: volumeType
        )
        return try await self.listKxVolumes(input, logger: logger)
    }

    /// A list of all tags for a resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// A list of all tags for a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name of the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Adds metadata tags to a FinSpace resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds metadata tags to a FinSpace resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) for the resource.
    ///   - tags: One or more tags to be assigned to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes metadata tags from a FinSpace resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes metadata tags from a FinSpace resource.
    ///
    /// Parameters:
    ///   - resourceArn: A FinSpace resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
    ///   - tagKeys: The tag keys (names) of one or more tags to be removed.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Update your FinSpace environment.
    @available(*, deprecated, message: "This method will be discontinued.")
    @Sendable
    @inlinable
    public func updateEnvironment(_ input: UpdateEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateEnvironmentResponse {
        try await self.client.execute(
            operation: "UpdateEnvironment", 
            path: "/environment/{environmentId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update your FinSpace environment.
    ///
    /// Parameters:
    ///   - description: The description of the environment.
    ///   - environmentId: The identifier of the FinSpace environment.
    ///   - federationMode: Authentication mode for the environment.    FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.    LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
    ///   - federationParameters: 
    ///   - name: The name of the environment.
    ///   - logger: Logger use during operation
    @available(*, deprecated, message: "This method will be discontinued.")
    @inlinable
    public func updateEnvironment(
        description: String? = nil,
        environmentId: String,
        federationMode: FederationMode? = nil,
        federationParameters: FederationParameters? = nil,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateEnvironmentResponse {
        let input = UpdateEnvironmentRequest(
            description: description, 
            environmentId: environmentId, 
            federationMode: federationMode, 
            federationParameters: federationParameters, 
            name: name
        )
        return try await self.updateEnvironment(input, logger: logger)
    }

    ///  Allows you to update code configuration on a running cluster. By using this API you can update the code, the initialization script path, and the command line arguments for a specific cluster.  The configuration that you want to update will override any existing configurations on the cluster.
    @Sendable
    @inlinable
    public func updateKxClusterCodeConfiguration(_ input: UpdateKxClusterCodeConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKxClusterCodeConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateKxClusterCodeConfiguration", 
            path: "/kx/environments/{environmentId}/clusters/{clusterName}/configuration/code", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Allows you to update code configuration on a running cluster. By using this API you can update the code, the initialization script path, and the command line arguments for a specific cluster.  The configuration that you want to update will override any existing configurations on the cluster.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - clusterName: The name of the cluster.
    ///   - code: 
    ///   - commandLineArguments: Specifies the key-value pairs to make them available inside the cluster. You cannot update this parameter for a NO_RESTART deployment.
    ///   - deploymentConfiguration:  The configuration that allows you to choose how you want to update the code on a cluster.
    ///   - environmentId:  A unique identifier of the kdb environment.
    ///   - initializationScript: Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q. You cannot update this parameter for a NO_RESTART deployment.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKxClusterCodeConfiguration(
        clientToken: String? = UpdateKxClusterCodeConfigurationRequest.idempotencyToken(),
        clusterName: String,
        code: CodeConfiguration,
        commandLineArguments: [KxCommandLineArgument]? = nil,
        deploymentConfiguration: KxClusterCodeDeploymentConfiguration? = nil,
        environmentId: String,
        initializationScript: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKxClusterCodeConfigurationResponse {
        let input = UpdateKxClusterCodeConfigurationRequest(
            clientToken: clientToken, 
            clusterName: clusterName, 
            code: code, 
            commandLineArguments: commandLineArguments, 
            deploymentConfiguration: deploymentConfiguration, 
            environmentId: environmentId, 
            initializationScript: initializationScript
        )
        return try await self.updateKxClusterCodeConfiguration(input, logger: logger)
    }

    /// Updates the databases mounted on a kdb cluster, which includes the changesetId and all the dbPaths to be cached. This API does not allow you to change a database name or add a database if you created a cluster without one.  Using this API you can point a cluster to a different changeset and modify a list of partitions being cached.
    @Sendable
    @inlinable
    public func updateKxClusterDatabases(_ input: UpdateKxClusterDatabasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKxClusterDatabasesResponse {
        try await self.client.execute(
            operation: "UpdateKxClusterDatabases", 
            path: "/kx/environments/{environmentId}/clusters/{clusterName}/configuration/databases", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the databases mounted on a kdb cluster, which includes the changesetId and all the dbPaths to be cached. This API does not allow you to change a database name or add a database if you created a cluster without one.  Using this API you can point a cluster to a different changeset and modify a list of partitions being cached.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - clusterName: A unique name for the cluster that you want to modify.
    ///   - databases:  The structure of databases mounted on the cluster.
    ///   - deploymentConfiguration:  The configuration that allows you to choose how you want to update the databases on a cluster.
    ///   - environmentId: The unique identifier of a kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKxClusterDatabases(
        clientToken: String? = UpdateKxClusterDatabasesRequest.idempotencyToken(),
        clusterName: String,
        databases: [KxDatabaseConfiguration],
        deploymentConfiguration: KxDeploymentConfiguration? = nil,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKxClusterDatabasesResponse {
        let input = UpdateKxClusterDatabasesRequest(
            clientToken: clientToken, 
            clusterName: clusterName, 
            databases: databases, 
            deploymentConfiguration: deploymentConfiguration, 
            environmentId: environmentId
        )
        return try await self.updateKxClusterDatabases(input, logger: logger)
    }

    /// Updates information for the given kdb database.
    @Sendable
    @inlinable
    public func updateKxDatabase(_ input: UpdateKxDatabaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKxDatabaseResponse {
        try await self.client.execute(
            operation: "UpdateKxDatabase", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates information for the given kdb database.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - databaseName: The name of the kdb database.
    ///   - description: A description of the database.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKxDatabase(
        clientToken: String = UpdateKxDatabaseRequest.idempotencyToken(),
        databaseName: String,
        description: String? = nil,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKxDatabaseResponse {
        let input = UpdateKxDatabaseRequest(
            clientToken: clientToken, 
            databaseName: databaseName, 
            description: description, 
            environmentId: environmentId
        )
        return try await self.updateKxDatabase(input, logger: logger)
    }

    /// Updates the specified dataview. The dataviews get automatically updated when any new changesets are ingested. Each update of the dataview creates a new version, including changeset details and cache configurations
    @Sendable
    @inlinable
    public func updateKxDataview(_ input: UpdateKxDataviewRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKxDataviewResponse {
        try await self.client.execute(
            operation: "UpdateKxDataview", 
            path: "/kx/environments/{environmentId}/databases/{databaseName}/dataviews/{dataviewName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified dataview. The dataviews get automatically updated when any new changesets are ingested. Each update of the dataview creates a new version, including changeset details and cache configurations
    ///
    /// Parameters:
    ///   - changesetId: A unique identifier for the changeset.
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - databaseName: The name of the database.
    ///   - dataviewName: The name of the dataview that you want to update.
    ///   - description:  The description for a dataview.
    ///   - environmentId: A unique identifier for the kdb environment, where you want to update the dataview.
    ///   - segmentConfigurations:  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKxDataview(
        changesetId: String? = nil,
        clientToken: String = UpdateKxDataviewRequest.idempotencyToken(),
        databaseName: String,
        dataviewName: String,
        description: String? = nil,
        environmentId: String,
        segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKxDataviewResponse {
        let input = UpdateKxDataviewRequest(
            changesetId: changesetId, 
            clientToken: clientToken, 
            databaseName: databaseName, 
            dataviewName: dataviewName, 
            description: description, 
            environmentId: environmentId, 
            segmentConfigurations: segmentConfigurations
        )
        return try await self.updateKxDataview(input, logger: logger)
    }

    /// Updates information for the given kdb environment.
    @Sendable
    @inlinable
    public func updateKxEnvironment(_ input: UpdateKxEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKxEnvironmentResponse {
        try await self.client.execute(
            operation: "UpdateKxEnvironment", 
            path: "/kx/environments/{environmentId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates information for the given kdb environment.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - description: A description of the kdb environment.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - name: The name of the kdb environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKxEnvironment(
        clientToken: String? = UpdateKxEnvironmentRequest.idempotencyToken(),
        description: String? = nil,
        environmentId: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKxEnvironmentResponse {
        let input = UpdateKxEnvironmentRequest(
            clientToken: clientToken, 
            description: description, 
            environmentId: environmentId, 
            name: name
        )
        return try await self.updateKxEnvironment(input, logger: logger)
    }

    /// Updates environment network to connect to your internal network by using a transit gateway. This API supports request to create a transit gateway attachment from FinSpace VPC to your transit gateway ID and create a custom Route-53 outbound resolvers. Once you send a request to update a network, you cannot change it again. Network update might require termination of any clusters that are running in the existing network.
    @Sendable
    @inlinable
    public func updateKxEnvironmentNetwork(_ input: UpdateKxEnvironmentNetworkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKxEnvironmentNetworkResponse {
        try await self.client.execute(
            operation: "UpdateKxEnvironmentNetwork", 
            path: "/kx/environments/{environmentId}/network", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates environment network to connect to your internal network by using a transit gateway. This API supports request to create a transit gateway attachment from FinSpace VPC to your transit gateway ID and create a custom Route-53 outbound resolvers. Once you send a request to update a network, you cannot change it again. Network update might require termination of any clusters that are running in the existing network.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - customDNSConfiguration: A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - transitGatewayConfiguration: Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKxEnvironmentNetwork(
        clientToken: String? = UpdateKxEnvironmentNetworkRequest.idempotencyToken(),
        customDNSConfiguration: [CustomDNSServer]? = nil,
        environmentId: String,
        transitGatewayConfiguration: TransitGatewayConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKxEnvironmentNetworkResponse {
        let input = UpdateKxEnvironmentNetworkRequest(
            clientToken: clientToken, 
            customDNSConfiguration: customDNSConfiguration, 
            environmentId: environmentId, 
            transitGatewayConfiguration: transitGatewayConfiguration
        )
        return try await self.updateKxEnvironmentNetwork(input, logger: logger)
    }

    /// Updates the user details. You can only update the IAM role associated with a user.
    @Sendable
    @inlinable
    public func updateKxUser(_ input: UpdateKxUserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKxUserResponse {
        try await self.client.execute(
            operation: "UpdateKxUser", 
            path: "/kx/environments/{environmentId}/users/{userName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the user details. You can only update the IAM role associated with a user.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - iamRole: The IAM role ARN that is associated with the user.
    ///   - userName: A unique identifier for the user.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKxUser(
        clientToken: String? = UpdateKxUserRequest.idempotencyToken(),
        environmentId: String,
        iamRole: String,
        userName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKxUserResponse {
        let input = UpdateKxUserRequest(
            clientToken: clientToken, 
            environmentId: environmentId, 
            iamRole: iamRole, 
            userName: userName
        )
        return try await self.updateKxUser(input, logger: logger)
    }

    /// Updates the throughput or capacity of a volume. During the update process, the filesystem
    /// might be unavailable for a few minutes. You can retry any operations after the update is complete.
    @Sendable
    @inlinable
    public func updateKxVolume(_ input: UpdateKxVolumeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKxVolumeResponse {
        try await self.client.execute(
            operation: "UpdateKxVolume", 
            path: "/kx/environments/{environmentId}/kxvolumes/{volumeName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the throughput or capacity of a volume. During the update process, the filesystem
    /// might be unavailable for a few minutes. You can retry any operations after the update is complete.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures idempotency. This token expires in 10 minutes.
    ///   - description: A description of the volume.
    ///   - environmentId: A unique identifier for the kdb environment where you created the storage volume.
    ///   - nas1Configuration:  Specifies the configuration for the Network attached storage (NAS_1) file system volume.
    ///   - volumeName: A unique identifier for the volume.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKxVolume(
        clientToken: String? = UpdateKxVolumeRequest.idempotencyToken(),
        description: String? = nil,
        environmentId: String,
        nas1Configuration: KxNAS1Configuration? = nil,
        volumeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKxVolumeResponse {
        let input = UpdateKxVolumeRequest(
            clientToken: clientToken, 
            description: description, 
            environmentId: environmentId, 
            nas1Configuration: nas1Configuration, 
            volumeName: volumeName
        )
        return try await self.updateKxVolume(input, logger: logger)
    }
}

extension Finspace {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Finspace, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Finspace {
    /// Return PaginatorSequence for operation ``listKxChangesets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxChangesetsPaginator(
        _ input: ListKxChangesetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKxChangesetsRequest, ListKxChangesetsResponse> {
        return .init(
            input: input,
            command: self.listKxChangesets,
            inputKey: \ListKxChangesetsRequest.nextToken,
            outputKey: \ListKxChangesetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKxChangesets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - databaseName: The name of the kdb database.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxChangesetsPaginator(
        databaseName: String,
        environmentId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKxChangesetsRequest, ListKxChangesetsResponse> {
        let input = ListKxChangesetsRequest(
            databaseName: databaseName, 
            environmentId: environmentId, 
            maxResults: maxResults
        )
        return self.listKxChangesetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKxClusterNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxClusterNodesPaginator(
        _ input: ListKxClusterNodesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKxClusterNodesRequest, ListKxClusterNodesResponse> {
        return .init(
            input: input,
            command: self.listKxClusterNodes,
            inputKey: \ListKxClusterNodesRequest.nextToken,
            outputKey: \ListKxClusterNodesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKxClusterNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterName: A unique name for the cluster.
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxClusterNodesPaginator(
        clusterName: String,
        environmentId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKxClusterNodesRequest, ListKxClusterNodesResponse> {
        let input = ListKxClusterNodesRequest(
            clusterName: clusterName, 
            environmentId: environmentId, 
            maxResults: maxResults
        )
        return self.listKxClusterNodesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKxDatabases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxDatabasesPaginator(
        _ input: ListKxDatabasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKxDatabasesRequest, ListKxDatabasesResponse> {
        return .init(
            input: input,
            command: self.listKxDatabases,
            inputKey: \ListKxDatabasesRequest.nextToken,
            outputKey: \ListKxDatabasesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKxDatabases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - environmentId: A unique identifier for the kdb environment.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxDatabasesPaginator(
        environmentId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKxDatabasesRequest, ListKxDatabasesResponse> {
        let input = ListKxDatabasesRequest(
            environmentId: environmentId, 
            maxResults: maxResults
        )
        return self.listKxDatabasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKxDataviews(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxDataviewsPaginator(
        _ input: ListKxDataviewsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKxDataviewsRequest, ListKxDataviewsResponse> {
        return .init(
            input: input,
            command: self.listKxDataviews,
            inputKey: \ListKxDataviewsRequest.nextToken,
            outputKey: \ListKxDataviewsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKxDataviews(_:logger:)``.
    ///
    /// - Parameters:
    ///   - databaseName: The name of the database where the dataviews were created.
    ///   - environmentId: A unique identifier for the kdb environment, for which you want to retrieve a list of dataviews.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxDataviewsPaginator(
        databaseName: String,
        environmentId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKxDataviewsRequest, ListKxDataviewsResponse> {
        let input = ListKxDataviewsRequest(
            databaseName: databaseName, 
            environmentId: environmentId, 
            maxResults: maxResults
        )
        return self.listKxDataviewsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKxEnvironments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxEnvironmentsPaginator(
        _ input: ListKxEnvironmentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKxEnvironmentsRequest, ListKxEnvironmentsResponse> {
        return .init(
            input: input,
            command: self.listKxEnvironments,
            inputKey: \ListKxEnvironmentsRequest.nextToken,
            outputKey: \ListKxEnvironmentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKxEnvironments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxEnvironmentsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKxEnvironmentsRequest, ListKxEnvironmentsResponse> {
        let input = ListKxEnvironmentsRequest(
            maxResults: maxResults
        )
        return self.listKxEnvironmentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKxScalingGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxScalingGroupsPaginator(
        _ input: ListKxScalingGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKxScalingGroupsRequest, ListKxScalingGroupsResponse> {
        return .init(
            input: input,
            command: self.listKxScalingGroups,
            inputKey: \ListKxScalingGroupsRequest.nextToken,
            outputKey: \ListKxScalingGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKxScalingGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - environmentId: A unique identifier for the kdb environment, for which you want to retrieve a list of scaling groups.
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKxScalingGroupsPaginator(
        environmentId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKxScalingGroupsRequest, ListKxScalingGroupsResponse> {
        let input = ListKxScalingGroupsRequest(
            environmentId: environmentId, 
            maxResults: maxResults
        )
        return self.listKxScalingGroupsPaginator(input, logger: logger)
    }
}

extension Finspace.ListKxChangesetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Finspace.ListKxChangesetsRequest {
        return .init(
            databaseName: self.databaseName,
            environmentId: self.environmentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Finspace.ListKxClusterNodesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Finspace.ListKxClusterNodesRequest {
        return .init(
            clusterName: self.clusterName,
            environmentId: self.environmentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Finspace.ListKxDatabasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Finspace.ListKxDatabasesRequest {
        return .init(
            environmentId: self.environmentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Finspace.ListKxDataviewsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Finspace.ListKxDataviewsRequest {
        return .init(
            databaseName: self.databaseName,
            environmentId: self.environmentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Finspace.ListKxEnvironmentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Finspace.ListKxEnvironmentsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Finspace.ListKxScalingGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Finspace.ListKxScalingGroupsRequest {
        return .init(
            environmentId: self.environmentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
