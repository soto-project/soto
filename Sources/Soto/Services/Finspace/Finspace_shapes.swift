//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Finspace {
    // MARK: Enums

    public enum AutoScalingMetric: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cpuUtilizationPercentage = "CPU_UTILIZATION_PERCENTAGE"
        public var description: String { return self.rawValue }
    }

    public enum ChangeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case put = "PUT"
        public var description: String { return self.rawValue }
    }

    public enum ChangesetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum DnsStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failedUpdate = "FAILED_UPDATE"
        case none = "NONE"
        case successfullyUpdated = "SUCCESSFULLY_UPDATED"
        case updateRequested = "UPDATE_REQUESTED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createRequested = "CREATE_REQUESTED"
        case created = "CREATED"
        case creating = "CREATING"
        case deleteRequested = "DELETE_REQUESTED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failedCreation = "FAILED_CREATION"
        case failedDeletion = "FAILED_DELETION"
        case failedUpdatingNetwork = "FAILED_UPDATING_NETWORK"
        case retryDeletion = "RETRY_DELETION"
        case suspended = "SUSPENDED"
        case updateNetworkRequested = "UPDATE_NETWORK_REQUESTED"
        case updatingNetwork = "UPDATING_NETWORK"
        public var description: String { return self.rawValue }
    }

    public enum ErrorDetails: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "Missing required permission to perform this request."
        case cancelled = "Cancelled"
        case internalServiceException = "An internal error has occurred."
        case resourceNotFound = "One or more inputs to this request were not found."
        case serviceQuotaExceeded = "Service limits have been exceeded."
        case throttling = "The system temporarily lacks sufficient resources to process the request."
        case userRecoverable = "A user recoverable error has occurred"
        case validation = "The inputs to this request are invalid."
        public var description: String { return self.rawValue }
    }

    public enum FederationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case federated = "FEDERATED"
        case local = "LOCAL"
        public var description: String { return self.rawValue }
    }

    public enum IPAddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ipV4 = "IP_V4"
        public var description: String { return self.rawValue }
    }

    public enum KxAzMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multi = "MULTI"
        case single = "SINGLE"
        public var description: String { return self.rawValue }
    }

    public enum KxClusterCodeDeploymentStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case force = "FORCE"
        case noRestart = "NO_RESTART"
        case rolling = "ROLLING"
        public var description: String { return self.rawValue }
    }

    public enum KxClusterStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        case running = "RUNNING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KxClusterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gateway = "GATEWAY"
        case gp = "GP"
        case hdb = "HDB"
        case rdb = "RDB"
        case tickerplant = "TICKERPLANT"
        public var description: String { return self.rawValue }
    }

    public enum KxDataviewStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KxDeploymentStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case noRestart = "NO_RESTART"
        case rolling = "ROLLING"
        public var description: String { return self.rawValue }
    }

    public enum KxNAS1Type: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hdd12 = "HDD_12"
        case ssd1000 = "SSD_1000"
        case ssd250 = "SSD_250"
        public var description: String { return self.rawValue }
    }

    public enum KxNodeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case provisioning = "PROVISIONING"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum KxSavedownStorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sds01 = "SDS01"
        public var description: String { return self.rawValue }
    }

    public enum KxScalingGroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum KxVolumeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updated = "UPDATED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KxVolumeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nas1 = "NAS_1"
        public var description: String { return self.rawValue }
    }

    public enum RuleAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "allow"
        case deny = "deny"
        public var description: String { return self.rawValue }
    }

    public enum TgwStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failedUpdate = "FAILED_UPDATE"
        case none = "NONE"
        case successfullyUpdated = "SUCCESSFULLY_UPDATED"
        case updateRequested = "UPDATE_REQUESTED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum VolumeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nas1 = "NAS_1"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AutoScalingConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all the nodes in a cluster.
        public let autoScalingMetric: AutoScalingMetric?
        /// The highest number of nodes to scale. This value cannot be greater than 5.
        public let maxNodeCount: Int?
        /// The desired value of the chosen autoScalingMetric. When the metric drops below this value, the cluster will scale in. When the metric goes above this value, the cluster will scale out. You can set the target value between 1 and 100 percent.
        public let metricTarget: Double?
        /// The lowest number of nodes to scale. This value must be at least 1 and less than the maxNodeCount. If the nodes in a cluster belong to multiple availability zones, then minNodeCount must be at least 3.
        public let minNodeCount: Int?
        /// The duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event.
        public let scaleInCooldownSeconds: Double?
        /// The duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.
        public let scaleOutCooldownSeconds: Double?

        public init(autoScalingMetric: AutoScalingMetric? = nil, maxNodeCount: Int? = nil, metricTarget: Double? = nil, minNodeCount: Int? = nil, scaleInCooldownSeconds: Double? = nil, scaleOutCooldownSeconds: Double? = nil) {
            self.autoScalingMetric = autoScalingMetric
            self.maxNodeCount = maxNodeCount
            self.metricTarget = metricTarget
            self.minNodeCount = minNodeCount
            self.scaleInCooldownSeconds = scaleInCooldownSeconds
            self.scaleOutCooldownSeconds = scaleOutCooldownSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.maxNodeCount, name: "maxNodeCount", parent: name, min: 1)
            try self.validate(self.metricTarget, name: "metricTarget", parent: name, max: 100.0)
            try self.validate(self.metricTarget, name: "metricTarget", parent: name, min: 1.0)
            try self.validate(self.minNodeCount, name: "minNodeCount", parent: name, min: 1)
            try self.validate(self.scaleInCooldownSeconds, name: "scaleInCooldownSeconds", parent: name, max: 100000.0)
            try self.validate(self.scaleInCooldownSeconds, name: "scaleInCooldownSeconds", parent: name, min: 0.0)
            try self.validate(self.scaleOutCooldownSeconds, name: "scaleOutCooldownSeconds", parent: name, max: 100000.0)
            try self.validate(self.scaleOutCooldownSeconds, name: "scaleOutCooldownSeconds", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingMetric = "autoScalingMetric"
            case maxNodeCount = "maxNodeCount"
            case metricTarget = "metricTarget"
            case minNodeCount = "minNodeCount"
            case scaleInCooldownSeconds = "scaleInCooldownSeconds"
            case scaleOutCooldownSeconds = "scaleOutCooldownSeconds"
        }
    }

    public struct CapacityConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances running in a cluster.
        public let nodeCount: Int?
        /// The type that determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance. You can only specify one of the following values:    kx.s.large – The node type with a configuration of 12 GiB memory and 2 vCPUs.    kx.s.xlarge – The node type with a configuration of 27 GiB memory and 4 vCPUs.    kx.s.2xlarge – The node type with a configuration of 54 GiB memory and 8 vCPUs.    kx.s.4xlarge – The node type with a configuration of 108 GiB memory and 16 vCPUs.    kx.s.8xlarge – The node type with a configuration of 216 GiB memory and 32 vCPUs.    kx.s.16xlarge – The node type with a configuration of 432 GiB memory and 64 vCPUs.    kx.s.32xlarge – The node type with a configuration of 864 GiB memory and 128 vCPUs.
        public let nodeType: String?

        public init(nodeCount: Int? = nil, nodeType: String? = nil) {
            self.nodeCount = nodeCount
            self.nodeType = nodeType
        }

        public func validate(name: String) throws {
            try self.validate(self.nodeCount, name: "nodeCount", parent: name, min: 1)
            try self.validate(self.nodeType, name: "nodeType", parent: name, max: 32)
            try self.validate(self.nodeType, name: "nodeType", parent: name, min: 1)
            try self.validate(self.nodeType, name: "nodeType", parent: name, pattern: "^[a-zA-Z0-9._]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case nodeCount = "nodeCount"
            case nodeType = "nodeType"
        }
    }

    public struct ChangeRequest: AWSEncodableShape & AWSDecodableShape {
        /// Defines the type of change request. A changeType can have the following values:   PUT – Adds or updates files in a database.   DELETE – Deletes files in a database.
        public let changeType: ChangeType
        /// Defines the path within the database directory.
        public let dbPath: String
        /// Defines the S3 path of the source file that is required to add or update files in a database.
        public let s3Path: String?

        public init(changeType: ChangeType, dbPath: String, s3Path: String? = nil) {
            self.changeType = changeType
            self.dbPath = dbPath
            self.s3Path = s3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.dbPath, name: "dbPath", parent: name, max: 1025)
            try self.validate(self.dbPath, name: "dbPath", parent: name, min: 1)
            try self.validate(self.dbPath, name: "dbPath", parent: name, pattern: "^(\\*)*[\\/\\?\\*]([^\\/]+\\/){0,2}[^\\/]*$")
            try self.validate(self.s3Path, name: "s3Path", parent: name, max: 1093)
            try self.validate(self.s3Path, name: "s3Path", parent: name, min: 9)
            try self.validate(self.s3Path, name: "s3Path", parent: name, pattern: "^s3:\\/\\/[a-z0-9][a-z0-9-.]{1,61}[a-z0-9]\\/([^\\/]+\\/)*[^\\/]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case changeType = "changeType"
            case dbPath = "dbPath"
            case s3Path = "s3Path"
        }
    }

    public struct CodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A unique name for the S3 bucket.
        public let s3Bucket: String?
        /// The full S3 path (excluding bucket) to the .zip file. This file contains the code that is loaded onto the cluster when it's started.
        public let s3Key: String?
        /// The version of an S3 object.
        public let s3ObjectVersion: String?

        public init(s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 255)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: "^[a-zA-Z0-9\\/\\!\\-_\\.\\*'\\(\\)]+$")
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, max: 1000)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
            case s3Key = "s3Key"
            case s3ObjectVersion = "s3ObjectVersion"
        }
    }

    public struct CreateEnvironmentRequest: AWSEncodableShape {
        /// The list of Amazon Resource Names (ARN) of the data bundles to install. Currently supported data bundle ARNs:    arn:aws:finspace:${Region}::data-bundle/capital-markets-sample - Contains sample Capital Markets datasets, categories and controlled vocabularies.    arn:aws:finspace:${Region}::data-bundle/taq (default) - Contains trades and quotes data in addition to sample Capital Markets data.
        public let dataBundles: [String]?
        /// The description of the FinSpace environment to be created.
        public let description: String?
        /// Authentication mode for the environment.    FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.    LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
        public let federationMode: FederationMode?
        /// Configuration information when authentication mode is FEDERATED.
        public let federationParameters: FederationParameters?
        /// The KMS key id to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the FinSpace environment to be created.
        public let name: String
        /// Configuration information for the superuser.
        public let superuserParameters: SuperuserParameters?
        /// Add tags to your FinSpace environment.
        public let tags: [String: String]?

        public init(dataBundles: [String]? = nil, description: String? = nil, federationMode: FederationMode? = nil, federationParameters: FederationParameters? = nil, kmsKeyId: String? = nil, name: String, superuserParameters: SuperuserParameters? = nil, tags: [String: String]? = nil) {
            self.dataBundles = dataBundles
            self.description = description
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.superuserParameters = superuserParameters
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.dataBundles?.forEach {
                try validate($0, name: "dataBundles[]", parent: name, max: 2048)
                try validate($0, name: "dataBundles[]", parent: name, min: 20)
                try validate($0, name: "dataBundles[]", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d*:data-bundle/[0-9A-Za-z_-]{1,128}$")
            }
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.federationParameters?.validate(name: "\(name).federationParameters")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1000)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[a-zA-Z-0-9-:\\/]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$")
            try self.superuserParameters?.validate(name: "\(name).superuserParameters")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataBundles = "dataBundles"
            case description = "description"
            case federationMode = "federationMode"
            case federationParameters = "federationParameters"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case superuserParameters = "superuserParameters"
            case tags = "tags"
        }
    }

    public struct CreateEnvironmentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the FinSpace environment that you created.
        public let environmentArn: String?
        /// The unique identifier for FinSpace environment that you created.
        public let environmentId: String?
        /// The sign-in URL for the web application of the FinSpace environment you created.
        public let environmentUrl: String?

        public init(environmentArn: String? = nil, environmentId: String? = nil, environmentUrl: String? = nil) {
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentUrl = environmentUrl
        }

        private enum CodingKeys: String, CodingKey {
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case environmentUrl = "environmentUrl"
        }
    }

    public struct CreateKxChangesetRequest: AWSEncodableShape {
        /// A list of change request objects that are run in order. A change request object consists of changeType , s3Path, and dbPath.  A changeType can have the following values:    PUT – Adds or updates files in a database.   DELETE – Deletes files in a database.   All the change requests require a mandatory dbPath attribute that defines the path within the database directory. All database paths must start with a leading / and end with a trailing /. The s3Path attribute defines the s3 source file path and is required for a PUT change type. The s3path must end with a trailing / if it is a directory and must end without a trailing / if it is a file.  Here are few examples of how you can use the change request object:   This request adds a single sym file at database root location.     { "changeType": "PUT", "s3Path":"s3://bucket/db/sym", "dbPath":"/"}    This request adds files in the given s3Path under the 2020.01.02 partition of the database.  { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/", "dbPath":"/2020.01.02/"}    This request adds files in the given s3Path under the taq table partition of the database.  [ { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/taq/", "dbPath":"/2020.01.02/taq/"}]    This request deletes the 2020.01.02 partition of the database.  [{ "changeType": "DELETE", "dbPath": "/2020.01.02/"} ]    The DELETE request allows you to delete the existing files under the 2020.01.02 partition of the database, and the PUT request adds a new taq table under it.  [ {"changeType": "DELETE", "dbPath":"/2020.01.02/"}, {"changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/taq/", "dbPath":"/2020.01.02/taq/"}]
        public let changeRequests: [ChangeRequest]
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the kdb database.
        public let databaseName: String
        /// A unique identifier of the kdb environment.
        public let environmentId: String

        public init(changeRequests: [ChangeRequest], clientToken: String = CreateKxChangesetRequest.idempotencyToken(), databaseName: String, environmentId: String) {
            self.changeRequests = changeRequests
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.changeRequests, forKey: .changeRequests)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.changeRequests.forEach {
                try $0.validate(name: "\(name).changeRequests[]")
            }
            try self.validate(self.changeRequests, name: "changeRequests", parent: name, max: 32)
            try self.validate(self.changeRequests, name: "changeRequests", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case changeRequests = "changeRequests"
            case clientToken = "clientToken"
        }
    }

    public struct CreateKxChangesetResponse: AWSDecodableShape {
        /// A list of change requests.
        public let changeRequests: [ChangeRequest]?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the kdb database.
        public let databaseName: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The details of the error that you receive when creating a changeset. It consists of the type of error and the error message.
        public let errorInfo: ErrorInfo?
        /// The timestamp at which the changeset was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// Status of the changeset creation process.   Pending – Changeset creation is pending.   Processing – Changeset creation is running.   Failed – Changeset creation has failed.   Complete – Changeset creation has succeeded.
        public let status: ChangesetStatus?

        public init(changeRequests: [ChangeRequest]? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, databaseName: String? = nil, environmentId: String? = nil, errorInfo: ErrorInfo? = nil, lastModifiedTimestamp: Date? = nil, status: ChangesetStatus? = nil) {
            self.changeRequests = changeRequests
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.environmentId = environmentId
            self.errorInfo = errorInfo
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case changeRequests = "changeRequests"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case environmentId = "environmentId"
            case errorInfo = "errorInfo"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case status = "status"
        }
    }

    public struct CreateKxClusterRequest: AWSEncodableShape {
        /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
        public let autoScalingConfiguration: AutoScalingConfiguration?
        /// The availability zone identifiers for the requested regions.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per cluster. This can be one of the following     SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
        public let azMode: KxAzMode
        /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
        public let cacheStorageConfigurations: [KxCacheStorageConfiguration]?
        /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
        public let capacityConfiguration: CapacityConfiguration?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description of the cluster.
        public let clusterDescription: String?
        /// A unique name for the cluster that you want to create.
        public let clusterName: String
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.   GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.   Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
        public let clusterType: KxClusterType
        /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
        public let code: CodeConfiguration?
        /// Defines the key-value pairs to make them available inside the cluster.
        public let commandLineArguments: [KxCommandLineArgument]?
        /// A list of databases that will be available for querying.
        public let databases: [KxDatabaseConfiguration]?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public let executionRole: String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public let initializationScript: String?
        /// The version of FinSpace managed kdb to run.
        public let releaseLabel: String
        /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
        public let savedownStorageConfiguration: KxSavedownStorageConfiguration?
        /// The structure that stores the configuration details of a scaling group.
        public let scalingGroupConfiguration: KxScalingGroupConfiguration?
        /// A list of key-value pairs to label the cluster. You can add up to 50 tags to a cluster.
        public let tags: [String: String]?
        /// A configuration to store Tickerplant logs. It consists of
        /// a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.
        public let tickerplantLogConfiguration: TickerplantLogConfiguration?
        /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
        public let vpcConfiguration: VpcConfiguration

        public init(autoScalingConfiguration: AutoScalingConfiguration? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode, cacheStorageConfigurations: [KxCacheStorageConfiguration]? = nil, capacityConfiguration: CapacityConfiguration? = nil, clientToken: String? = CreateKxClusterRequest.idempotencyToken(), clusterDescription: String? = nil, clusterName: String, clusterType: KxClusterType, code: CodeConfiguration? = nil, commandLineArguments: [KxCommandLineArgument]? = nil, databases: [KxDatabaseConfiguration]? = nil, environmentId: String, executionRole: String? = nil, initializationScript: String? = nil, releaseLabel: String, savedownStorageConfiguration: KxSavedownStorageConfiguration? = nil, scalingGroupConfiguration: KxScalingGroupConfiguration? = nil, tags: [String: String]? = nil, tickerplantLogConfiguration: TickerplantLogConfiguration? = nil, vpcConfiguration: VpcConfiguration) {
            self.autoScalingConfiguration = autoScalingConfiguration
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.cacheStorageConfigurations = cacheStorageConfigurations
            self.capacityConfiguration = capacityConfiguration
            self.clientToken = clientToken
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.code = code
            self.commandLineArguments = commandLineArguments
            self.databases = databases
            self.environmentId = environmentId
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.releaseLabel = releaseLabel
            self.savedownStorageConfiguration = savedownStorageConfiguration
            self.scalingGroupConfiguration = scalingGroupConfiguration
            self.tags = tags
            self.tickerplantLogConfiguration = tickerplantLogConfiguration
            self.vpcConfiguration = vpcConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.autoScalingConfiguration, forKey: .autoScalingConfiguration)
            try container.encodeIfPresent(self.availabilityZoneId, forKey: .availabilityZoneId)
            try container.encode(self.azMode, forKey: .azMode)
            try container.encodeIfPresent(self.cacheStorageConfigurations, forKey: .cacheStorageConfigurations)
            try container.encodeIfPresent(self.capacityConfiguration, forKey: .capacityConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.clusterDescription, forKey: .clusterDescription)
            try container.encode(self.clusterName, forKey: .clusterName)
            try container.encode(self.clusterType, forKey: .clusterType)
            try container.encodeIfPresent(self.code, forKey: .code)
            try container.encodeIfPresent(self.commandLineArguments, forKey: .commandLineArguments)
            try container.encodeIfPresent(self.databases, forKey: .databases)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.executionRole, forKey: .executionRole)
            try container.encodeIfPresent(self.initializationScript, forKey: .initializationScript)
            try container.encode(self.releaseLabel, forKey: .releaseLabel)
            try container.encodeIfPresent(self.savedownStorageConfiguration, forKey: .savedownStorageConfiguration)
            try container.encodeIfPresent(self.scalingGroupConfiguration, forKey: .scalingGroupConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.tickerplantLogConfiguration, forKey: .tickerplantLogConfiguration)
            try container.encode(self.vpcConfiguration, forKey: .vpcConfiguration)
        }

        public func validate(name: String) throws {
            try self.autoScalingConfiguration?.validate(name: "\(name).autoScalingConfiguration")
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, max: 12)
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, min: 8)
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.cacheStorageConfigurations?.forEach {
                try $0.validate(name: "\(name).cacheStorageConfigurations[]")
            }
            try self.capacityConfiguration?.validate(name: "\(name).capacityConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.clusterDescription, name: "clusterDescription", parent: name, max: 1000)
            try self.validate(self.clusterDescription, name: "clusterDescription", parent: name, min: 1)
            try self.validate(self.clusterDescription, name: "clusterDescription", parent: name, pattern: "^[a-zA-Z0-9\\_\\-\\.\\s]+$")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.code?.validate(name: "\(name).code")
            try self.commandLineArguments?.forEach {
                try $0.validate(name: "\(name).commandLineArguments[]")
            }
            try self.databases?.forEach {
                try $0.validate(name: "\(name).databases[]")
            }
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 1024)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^arn:aws[a-z0-9-]*:iam::\\d{12}:role\\/[\\w-\\/.@+=,]{1,1017}$")
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, max: 255)
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, min: 1)
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, pattern: "^[a-zA-Z0-9\\_\\-\\.\\/\\\\]+$")
            try self.validate(self.releaseLabel, name: "releaseLabel", parent: name, max: 16)
            try self.validate(self.releaseLabel, name: "releaseLabel", parent: name, min: 1)
            try self.validate(self.releaseLabel, name: "releaseLabel", parent: name, pattern: "^[a-zA-Z0-9._-]+$")
            try self.savedownStorageConfiguration?.validate(name: "\(name).savedownStorageConfiguration")
            try self.scalingGroupConfiguration?.validate(name: "\(name).scalingGroupConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.tickerplantLogConfiguration?.validate(name: "\(name).tickerplantLogConfiguration")
            try self.vpcConfiguration.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "autoScalingConfiguration"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case cacheStorageConfigurations = "cacheStorageConfigurations"
            case capacityConfiguration = "capacityConfiguration"
            case clientToken = "clientToken"
            case clusterDescription = "clusterDescription"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case code = "code"
            case commandLineArguments = "commandLineArguments"
            case databases = "databases"
            case executionRole = "executionRole"
            case initializationScript = "initializationScript"
            case releaseLabel = "releaseLabel"
            case savedownStorageConfiguration = "savedownStorageConfiguration"
            case scalingGroupConfiguration = "scalingGroupConfiguration"
            case tags = "tags"
            case tickerplantLogConfiguration = "tickerplantLogConfiguration"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct CreateKxClusterResponse: AWSDecodableShape {
        /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
        public let autoScalingConfiguration: AutoScalingConfiguration?
        ///  The availability zone identifiers for the requested regions.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per cluster. This can be one of the following     SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
        public let azMode: KxAzMode?
        /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
        public let cacheStorageConfigurations: [KxCacheStorageConfiguration]?
        /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
        public let capacityConfiguration: CapacityConfiguration?
        /// A description of the cluster.
        public let clusterDescription: String?
        /// A unique name for the cluster.
        public let clusterName: String?
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.   GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.   Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
        public let clusterType: KxClusterType?
        /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
        public let code: CodeConfiguration?
        /// Defines the key-value pairs to make them available inside the cluster.
        public let commandLineArguments: [KxCommandLineArgument]?
        /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// A list of databases that will be available for querying.
        public let databases: [KxDatabaseConfiguration]?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        ///  An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public let executionRole: String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public let initializationScript: String?
        /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// A version of the FinSpace managed kdb to run.
        public let releaseLabel: String?
        /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
        public let savedownStorageConfiguration: KxSavedownStorageConfiguration?
        /// The structure that stores the configuration details of a scaling group.
        public let scalingGroupConfiguration: KxScalingGroupConfiguration?
        /// The status of cluster creation.   PENDING – The cluster is pending creation.   CREATING – The cluster creation process is in progress.   CREATE_FAILED – The cluster creation process has failed.   RUNNING – The cluster creation process is running.   UPDATING – The cluster is in the process of being updated.   DELETING – The cluster is in the process of being deleted.   DELETED – The cluster has been deleted.   DELETE_FAILED – The cluster failed to delete.
        public let status: KxClusterStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        public let tickerplantLogConfiguration: TickerplantLogConfiguration?
        /// A list of volumes mounted on the cluster.
        public let volumes: [Volume]?
        /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
        public let vpcConfiguration: VpcConfiguration?

        public init(autoScalingConfiguration: AutoScalingConfiguration? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, cacheStorageConfigurations: [KxCacheStorageConfiguration]? = nil, capacityConfiguration: CapacityConfiguration? = nil, clusterDescription: String? = nil, clusterName: String? = nil, clusterType: KxClusterType? = nil, code: CodeConfiguration? = nil, commandLineArguments: [KxCommandLineArgument]? = nil, createdTimestamp: Date? = nil, databases: [KxDatabaseConfiguration]? = nil, environmentId: String? = nil, executionRole: String? = nil, initializationScript: String? = nil, lastModifiedTimestamp: Date? = nil, releaseLabel: String? = nil, savedownStorageConfiguration: KxSavedownStorageConfiguration? = nil, scalingGroupConfiguration: KxScalingGroupConfiguration? = nil, status: KxClusterStatus? = nil, statusReason: String? = nil, tickerplantLogConfiguration: TickerplantLogConfiguration? = nil, volumes: [Volume]? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.autoScalingConfiguration = autoScalingConfiguration
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.cacheStorageConfigurations = cacheStorageConfigurations
            self.capacityConfiguration = capacityConfiguration
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.code = code
            self.commandLineArguments = commandLineArguments
            self.createdTimestamp = createdTimestamp
            self.databases = databases
            self.environmentId = environmentId
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.releaseLabel = releaseLabel
            self.savedownStorageConfiguration = savedownStorageConfiguration
            self.scalingGroupConfiguration = scalingGroupConfiguration
            self.status = status
            self.statusReason = statusReason
            self.tickerplantLogConfiguration = tickerplantLogConfiguration
            self.volumes = volumes
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "autoScalingConfiguration"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case cacheStorageConfigurations = "cacheStorageConfigurations"
            case capacityConfiguration = "capacityConfiguration"
            case clusterDescription = "clusterDescription"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case code = "code"
            case commandLineArguments = "commandLineArguments"
            case createdTimestamp = "createdTimestamp"
            case databases = "databases"
            case environmentId = "environmentId"
            case executionRole = "executionRole"
            case initializationScript = "initializationScript"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case releaseLabel = "releaseLabel"
            case savedownStorageConfiguration = "savedownStorageConfiguration"
            case scalingGroupConfiguration = "scalingGroupConfiguration"
            case status = "status"
            case statusReason = "statusReason"
            case tickerplantLogConfiguration = "tickerplantLogConfiguration"
            case volumes = "volumes"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct CreateKxDatabaseRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the kdb database.
        public let databaseName: String
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// A list of key-value pairs to label the kdb database. You can add up to 50 tags to your kdb database
        public let tags: [String: String]?

        public init(clientToken: String = CreateKxDatabaseRequest.idempotencyToken(), databaseName: String, description: String? = nil, environmentId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            try container.encode(self.databaseName, forKey: .databaseName)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case databaseName = "databaseName"
            case description = "description"
            case tags = "tags"
        }
    }

    public struct CreateKxDatabaseResponse: AWSDecodableShape {
        /// The timestamp at which the database is created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The ARN identifier of the database.
        public let databaseArn: String?
        /// The name of the kdb database.
        public let databaseName: String?
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The last time that the database was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, databaseArn: String? = nil, databaseName: String? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.databaseArn = databaseArn
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "createdTimestamp"
            case databaseArn = "databaseArn"
            case databaseName = "databaseName"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
        }
    }

    public struct CreateKxDataviewRequest: AWSEncodableShape {
        /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
        public let autoUpdate: Bool?
        ///  The identifier of the availability zones.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode
        /// A unique identifier of the changeset that you want to use to ingest data.
        public let changesetId: String?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the database where you want to create a dataview.
        public let databaseName: String
        /// A unique identifier for the dataview.
        public let dataviewName: String
        /// A description of the dataview.
        public let description: String?
        /// A unique identifier for the kdb environment, where you want to create the dataview.
        public let environmentId: String
        ///  The option to specify whether you want to make the dataview writable to perform database maintenance. The following are some considerations related to writable dataviews.     You cannot create partial writable dataviews. When you create writeable dataviews you must provide the entire database path.   You cannot perform updates on a writeable dataview. Hence, autoUpdate must be set as False if readWrite is True for a dataview.   You must also use a unique volume for creating a writeable dataview. So, if you choose a volume that is already in use by another dataview, the dataview creation fails.   Once you create a dataview as writeable, you cannot change it to read-only. So, you cannot update the readWrite parameter later.
        public let readWrite: Bool?
        ///  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public let segmentConfigurations: [KxDataviewSegmentConfiguration]?
        /// A list of key-value pairs to label the dataview. You can add up to 50 tags to a dataview.
        public let tags: [String: String]?

        public init(autoUpdate: Bool? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode, changesetId: String? = nil, clientToken: String = CreateKxDataviewRequest.idempotencyToken(), databaseName: String, dataviewName: String, description: String? = nil, environmentId: String, readWrite: Bool? = nil, segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil, tags: [String: String]? = nil) {
            self.autoUpdate = autoUpdate
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.changesetId = changesetId
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.description = description
            self.environmentId = environmentId
            self.readWrite = readWrite
            self.segmentConfigurations = segmentConfigurations
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.autoUpdate, forKey: .autoUpdate)
            try container.encodeIfPresent(self.availabilityZoneId, forKey: .availabilityZoneId)
            try container.encode(self.azMode, forKey: .azMode)
            try container.encodeIfPresent(self.changesetId, forKey: .changesetId)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.databaseName, key: "databaseName")
            try container.encode(self.dataviewName, forKey: .dataviewName)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.readWrite, forKey: .readWrite)
            try container.encodeIfPresent(self.segmentConfigurations, forKey: .segmentConfigurations)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, max: 12)
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, min: 8)
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.changesetId, name: "changesetId", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, max: 63)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, min: 3)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.segmentConfigurations?.forEach {
                try $0.validate(name: "\(name).segmentConfigurations[]")
            }
            try self.validate(self.segmentConfigurations, name: "segmentConfigurations", parent: name, max: 50)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoUpdate = "autoUpdate"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case changesetId = "changesetId"
            case clientToken = "clientToken"
            case dataviewName = "dataviewName"
            case description = "description"
            case readWrite = "readWrite"
            case segmentConfigurations = "segmentConfigurations"
            case tags = "tags"
        }
    }

    public struct CreateKxDataviewResponse: AWSDecodableShape {
        /// The option to select whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.
        public let autoUpdate: Bool?
        ///  The identifier of the availability zones.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the database where you want to create a dataview.
        public let databaseName: String?
        /// A unique identifier for the dataview.
        public let dataviewName: String?
        /// A description of the dataview.
        public let description: String?
        /// A unique identifier for the kdb environment, where you want to create the dataview.
        public let environmentId: String?
        /// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// Returns True if the dataview is created as writeable and False otherwise.
        public let readWrite: Bool?
        ///  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public let segmentConfigurations: [KxDataviewSegmentConfiguration]?
        /// The status of dataview creation.    CREATING – The dataview creation is in progress.    UPDATING – The dataview is in the process of being updated.    ACTIVE – The dataview is active.
        public let status: KxDataviewStatus?

        public init(autoUpdate: Bool? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, databaseName: String? = nil, dataviewName: String? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil, readWrite: Bool? = nil, segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil, status: KxDataviewStatus? = nil) {
            self.autoUpdate = autoUpdate
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.readWrite = readWrite
            self.segmentConfigurations = segmentConfigurations
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case autoUpdate = "autoUpdate"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case dataviewName = "dataviewName"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case readWrite = "readWrite"
            case segmentConfigurations = "segmentConfigurations"
            case status = "status"
        }
    }

    public struct CreateKxEnvironmentRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description for the kdb environment.
        public let description: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String
        /// The name of the kdb environment that you want to create.
        public let name: String
        /// A list of key-value pairs to label the kdb environment. You can add up to 50 tags to your kdb environment.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateKxEnvironmentRequest.idempotencyToken(), description: String? = nil, kmsKeyId: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1000)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^arn:aws:kms:.*:\\d+:.*$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateKxEnvironmentResponse: AWSDecodableShape {
        /// The timestamp at which the kdb environment was created in FinSpace.
        public let creationTimestamp: Date?
        /// A description for the kdb environment.
        public let description: String?
        /// The ARN identifier of the environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the kdb environment.
        public let status: EnvironmentStatus?

        public init(creationTimestamp: Date? = nil, description: String? = nil, environmentArn: String? = nil, environmentId: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil) {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "creationTimestamp"
            case description = "description"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateKxScalingGroupRequest: AWSEncodableShape {
        /// The identifier of the availability zones.
        public let availabilityZoneId: String
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// A unique identifier for the kdb environment, where you want to create the scaling group.
        public let environmentId: String
        ///  The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed. You can add one of the following values:    kx.sg.4xlarge – The host type with a configuration of 108 GiB memory and 16 vCPUs.    kx.sg.8xlarge – The host type with a configuration of 216 GiB memory and 32 vCPUs.    kx.sg.16xlarge – The host type with a configuration of 432 GiB memory and 64 vCPUs.    kx.sg.32xlarge – The host type with a configuration of 864 GiB memory and 128 vCPUs.    kx.sg1.16xlarge – The host type with a configuration of 1949 GiB memory and 64 vCPUs.    kx.sg1.24xlarge – The host type with a configuration of 2948 GiB memory and 96 vCPUs.
        public let hostType: String
        /// A unique identifier for the kdb scaling group.
        public let scalingGroupName: String
        /// A list of key-value pairs to label the scaling group. You can add up to 50 tags to a scaling group.
        public let tags: [String: String]?

        public init(availabilityZoneId: String, clientToken: String = CreateKxScalingGroupRequest.idempotencyToken(), environmentId: String, hostType: String, scalingGroupName: String, tags: [String: String]? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.clientToken = clientToken
            self.environmentId = environmentId
            self.hostType = hostType
            self.scalingGroupName = scalingGroupName
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.availabilityZoneId, forKey: .availabilityZoneId)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encode(self.hostType, forKey: .hostType)
            try container.encode(self.scalingGroupName, forKey: .scalingGroupName)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, max: 12)
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, min: 8)
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.hostType, name: "hostType", parent: name, max: 32)
            try self.validate(self.hostType, name: "hostType", parent: name, min: 1)
            try self.validate(self.hostType, name: "hostType", parent: name, pattern: "^[a-zA-Z0-9._]+$")
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, max: 63)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, min: 3)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "availabilityZoneId"
            case clientToken = "clientToken"
            case hostType = "hostType"
            case scalingGroupName = "scalingGroupName"
            case tags = "tags"
        }
    }

    public struct CreateKxScalingGroupResponse: AWSDecodableShape {
        /// The identifier of the availability zones.
        public let availabilityZoneId: String?
        ///  The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// A unique identifier for the kdb environment, where you create the scaling group.
        public let environmentId: String?
        ///  The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed.
        public let hostType: String?
        /// The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// A unique identifier for the kdb scaling group.
        public let scalingGroupName: String?
        /// The status of scaling group.   CREATING – The scaling group creation is in progress.   CREATE_FAILED – The scaling group creation has failed.   ACTIVE – The scaling group is active.   UPDATING – The scaling group is in the process of being updated.   UPDATE_FAILED – The update action failed.   DELETING – The scaling group is in the process of being deleted.   DELETE_FAILED – The system failed to delete the scaling group.   DELETED – The scaling group is successfully deleted.
        public let status: KxScalingGroupStatus?

        public init(availabilityZoneId: String? = nil, createdTimestamp: Date? = nil, environmentId: String? = nil, hostType: String? = nil, lastModifiedTimestamp: Date? = nil, scalingGroupName: String? = nil, status: KxScalingGroupStatus? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.createdTimestamp = createdTimestamp
            self.environmentId = environmentId
            self.hostType = hostType
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.scalingGroupName = scalingGroupName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "availabilityZoneId"
            case createdTimestamp = "createdTimestamp"
            case environmentId = "environmentId"
            case hostType = "hostType"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case scalingGroupName = "scalingGroupName"
            case status = "status"
        }
    }

    public struct CreateKxUserRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique identifier for the kdb environment where you want to create a user.
        public let environmentId: String
        /// The IAM role ARN that will be associated with the user.
        public let iamRole: String
        /// A list of key-value pairs to label the user. You can add up to 50 tags to a user.
        public let tags: [String: String]?
        /// A unique identifier for the user.
        public let userName: String

        public init(clientToken: String? = CreateKxUserRequest.idempotencyToken(), environmentId: String, iamRole: String, tags: [String: String]? = nil, userName: String) {
            self.clientToken = clientToken
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.tags = tags
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encode(self.iamRole, forKey: .iamRole)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.userName, forKey: .userName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.iamRole, name: "iamRole", parent: name, max: 2048)
            try self.validate(self.iamRole, name: "iamRole", parent: name, min: 20)
            try self.validate(self.iamRole, name: "iamRole", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, max: 50)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[0-9A-Za-z_-]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case iamRole = "iamRole"
            case tags = "tags"
            case userName = "userName"
        }
    }

    public struct CreateKxUserResponse: AWSDecodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The IAM role ARN that will be associated with the user.
        public let iamRole: String?
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String?
        /// A unique identifier for the user.
        public let userName: String?

        public init(environmentId: String? = nil, iamRole: String? = nil, userArn: String? = nil, userName: String? = nil) {
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.userArn = userArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case iamRole = "iamRole"
            case userArn = "userArn"
            case userName = "userName"
        }
    }

    public struct CreateKxVolumeRequest: AWSEncodableShape {
        /// The identifier of the availability zones.
        public let availabilityZoneIds: [String]
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description of the volume.
        public let description: String?
        /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
        public let environmentId: String
        ///  Specifies the configuration for the Network attached storage (NAS_1) file system volume. This parameter is required when you choose volumeType as NAS_1.
        public let nas1Configuration: KxNAS1Configuration?
        /// A list of key-value pairs to label the volume. You can add up to 50 tags to a volume.
        public let tags: [String: String]?
        /// A unique identifier for the volume.
        public let volumeName: String
        ///  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type. When you select NAS_1 volume type, you must also provide nas1Configuration.
        public let volumeType: KxVolumeType

        public init(availabilityZoneIds: [String], azMode: KxAzMode, clientToken: String? = CreateKxVolumeRequest.idempotencyToken(), description: String? = nil, environmentId: String, nas1Configuration: KxNAS1Configuration? = nil, tags: [String: String]? = nil, volumeName: String, volumeType: KxVolumeType) {
            self.availabilityZoneIds = availabilityZoneIds
            self.azMode = azMode
            self.clientToken = clientToken
            self.description = description
            self.environmentId = environmentId
            self.nas1Configuration = nas1Configuration
            self.tags = tags
            self.volumeName = volumeName
            self.volumeType = volumeType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.availabilityZoneIds, forKey: .availabilityZoneIds)
            try container.encode(self.azMode, forKey: .azMode)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.nas1Configuration, forKey: .nas1Configuration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.volumeName, forKey: .volumeName)
            try container.encode(self.volumeType, forKey: .volumeType)
        }

        public func validate(name: String) throws {
            try self.availabilityZoneIds.forEach {
                try validate($0, name: "availabilityZoneIds[]", parent: name, max: 12)
                try validate($0, name: "availabilityZoneIds[]", parent: name, min: 8)
                try validate($0, name: "availabilityZoneIds[]", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.nas1Configuration?.validate(name: "\(name).nas1Configuration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.volumeName, name: "volumeName", parent: name, max: 63)
            try self.validate(self.volumeName, name: "volumeName", parent: name, min: 3)
            try self.validate(self.volumeName, name: "volumeName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case azMode = "azMode"
            case clientToken = "clientToken"
            case description = "description"
            case nas1Configuration = "nas1Configuration"
            case tags = "tags"
            case volumeName = "volumeName"
            case volumeType = "volumeType"
        }
    }

    public struct CreateKxVolumeResponse: AWSDecodableShape {
        /// The identifier of the availability zones.
        public let availabilityZoneIds: [String]?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode?
        /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// A description of the volume.
        public let description: String?
        /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
        public let environmentId: String?
        ///  Specifies the configuration for the Network attached storage (NAS_1) file system volume.
        public let nas1Configuration: KxNAS1Configuration?
        /// The status of volume creation.   CREATING – The volume creation is in progress.   CREATE_FAILED – The volume creation has failed.   ACTIVE – The volume is active.   UPDATING – The volume is in the process of being updated.   UPDATE_FAILED – The update action failed.   UPDATED – The volume is successfully updated.   DELETING – The volume is in the process of being deleted.   DELETE_FAILED – The system failed to delete the volume.   DELETED – The volume is successfully deleted.
        public let status: KxVolumeStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        /// The ARN identifier of the volume.
        public let volumeArn: String?
        /// A unique identifier for the volume.
        public let volumeName: String?
        ///  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public let volumeType: KxVolumeType?

        public init(availabilityZoneIds: [String]? = nil, azMode: KxAzMode? = nil, createdTimestamp: Date? = nil, description: String? = nil, environmentId: String? = nil, nas1Configuration: KxNAS1Configuration? = nil, status: KxVolumeStatus? = nil, statusReason: String? = nil, volumeArn: String? = nil, volumeName: String? = nil, volumeType: KxVolumeType? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.azMode = azMode
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.environmentId = environmentId
            self.nas1Configuration = nas1Configuration
            self.status = status
            self.statusReason = statusReason
            self.volumeArn = volumeArn
            self.volumeName = volumeName
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case azMode = "azMode"
            case createdTimestamp = "createdTimestamp"
            case description = "description"
            case environmentId = "environmentId"
            case nas1Configuration = "nas1Configuration"
            case status = "status"
            case statusReason = "statusReason"
            case volumeArn = "volumeArn"
            case volumeName = "volumeName"
            case volumeType = "volumeType"
        }
    }

    public struct CustomDNSServer: AWSEncodableShape & AWSDecodableShape {
        /// The IP address of the DNS server.
        public let customDNSServerIP: String
        /// The name of the DNS server.
        public let customDNSServerName: String

        public init(customDNSServerIP: String, customDNSServerName: String) {
            self.customDNSServerIP = customDNSServerIP
            self.customDNSServerName = customDNSServerName
        }

        public func validate(name: String) throws {
            try self.validate(self.customDNSServerIP, name: "customDNSServerIP", parent: name, pattern: "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$")
            try self.validate(self.customDNSServerName, name: "customDNSServerName", parent: name, max: 255)
            try self.validate(self.customDNSServerName, name: "customDNSServerName", parent: name, min: 3)
            try self.validate(self.customDNSServerName, name: "customDNSServerName", parent: name, pattern: "^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$")
        }

        private enum CodingKeys: String, CodingKey {
            case customDNSServerIP = "customDNSServerIP"
            case customDNSServerName = "customDNSServerName"
        }
    }

    public struct DeleteEnvironmentRequest: AWSEncodableShape {
        /// The identifier for the FinSpace environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxClusterNodeRequest: AWSEncodableShape {
        /// The name of the cluster, for which you want to delete the nodes.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// A unique identifier for the node that you want to delete.
        public let nodeId: String

        public init(clusterName: String, environmentId: String, nodeId: String) {
            self.clusterName = clusterName
            self.environmentId = environmentId
            self.nodeId = nodeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.nodeId, key: "nodeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 40)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxClusterNodeResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxClusterRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The name of the cluster that you want to delete.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clientToken: String? = DeleteKxClusterRequest.idempotencyToken(), clusterName: String, environmentId: String) {
            self.clientToken = clientToken
            self.clusterName = clusterName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxClusterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxDatabaseRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the kdb database that you want to delete.
        public let databaseName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clientToken: String = DeleteKxDatabaseRequest.idempotencyToken(), databaseName: String, environmentId: String) {
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxDatabaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxDataviewRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the database whose dataview you want to delete.
        public let databaseName: String
        /// The name of the dataview that you want to delete.
        public let dataviewName: String
        /// A unique identifier for the kdb environment, from where you want to delete the dataview.
        public let environmentId: String

        public init(clientToken: String = DeleteKxDataviewRequest.idempotencyToken(), databaseName: String, dataviewName: String, environmentId: String) {
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.dataviewName, key: "dataviewName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, max: 63)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, min: 3)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxDataviewResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxEnvironmentRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clientToken: String? = DeleteKxEnvironmentRequest.idempotencyToken(), environmentId: String) {
            self.clientToken = clientToken
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxScalingGroupRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique identifier for the kdb environment, from where you want to delete the dataview.
        public let environmentId: String
        /// A unique identifier for the kdb scaling group.
        public let scalingGroupName: String

        public init(clientToken: String? = DeleteKxScalingGroupRequest.idempotencyToken(), environmentId: String, scalingGroupName: String) {
            self.clientToken = clientToken
            self.environmentId = environmentId
            self.scalingGroupName = scalingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.scalingGroupName, key: "scalingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, max: 63)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, min: 3)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxScalingGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxUserRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// A unique identifier for the user that you want to delete.
        public let userName: String

        public init(clientToken: String? = DeleteKxUserRequest.idempotencyToken(), environmentId: String, userName: String) {
            self.clientToken = clientToken
            self.environmentId = environmentId
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.userName, key: "userName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.userName, name: "userName", parent: name, max: 50)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[0-9A-Za-z_-]{1,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxVolumeRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
        public let environmentId: String
        /// The name of the volume that you want to delete.
        public let volumeName: String

        public init(clientToken: String? = DeleteKxVolumeRequest.idempotencyToken(), environmentId: String, volumeName: String) {
            self.clientToken = clientToken
            self.environmentId = environmentId
            self.volumeName = volumeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.volumeName, key: "volumeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.volumeName, name: "volumeName", parent: name, max: 63)
            try self.validate(self.volumeName, name: "volumeName", parent: name, min: 3)
            try self.validate(self.volumeName, name: "volumeName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxVolumeResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Environment: AWSDecodableShape {
        /// The ID of the AWS account in which the FinSpace environment is created.
        public let awsAccountId: String?
        /// The AWS account ID of the dedicated service account associated with your FinSpace environment.
        public let dedicatedServiceAccountId: String?
        /// The description of the FinSpace environment.
        public let description: String?
        /// The Amazon Resource Name (ARN) of your FinSpace environment.
        public let environmentArn: String?
        /// The identifier of the FinSpace environment.
        public let environmentId: String?
        /// The sign-in URL for the web application of your FinSpace environment.
        public let environmentUrl: String?
        /// The authentication mode for the environment.
        public let federationMode: FederationMode?
        /// Configuration information when authentication mode is FEDERATED.
        public let federationParameters: FederationParameters?
        /// The KMS key id used to encrypt in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the FinSpace environment.
        public let name: String?
        /// The URL of the integrated FinSpace notebook environment in your web application.
        public let sageMakerStudioDomainUrl: String?
        /// The current status of creation of the FinSpace environment.
        public let status: EnvironmentStatus?

        public init(awsAccountId: String? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, environmentArn: String? = nil, environmentId: String? = nil, environmentUrl: String? = nil, federationMode: FederationMode? = nil, federationParameters: FederationParameters? = nil, kmsKeyId: String? = nil, name: String? = nil, sageMakerStudioDomainUrl: String? = nil, status: EnvironmentStatus? = nil) {
            self.awsAccountId = awsAccountId
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentUrl = environmentUrl
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.sageMakerStudioDomainUrl = sageMakerStudioDomainUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case environmentUrl = "environmentUrl"
            case federationMode = "federationMode"
            case federationParameters = "federationParameters"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case sageMakerStudioDomainUrl = "sageMakerStudioDomainUrl"
            case status = "status"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// Specifies the type of error.
        public let errorType: ErrorDetails?

        public init(errorMessage: String? = nil, errorType: ErrorDetails? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case errorType = "errorType"
        }
    }

    public struct FederationParameters: AWSEncodableShape & AWSDecodableShape {
        /// The redirect or sign-in URL that should be entered into the SAML 2.0 compliant identity provider configuration (IdP).
        public let applicationCallBackURL: String?
        /// SAML attribute name and value. The name must always be Email and the value should be set to the attribute definition in which user email is set. For example, name would be Email and value http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress. Please check your SAML 2.0 compliant identity provider (IdP) documentation for details.
        public let attributeMap: [String: String]?
        /// Name of the identity provider (IdP).
        public let federationProviderName: String?
        /// The Uniform Resource Name (URN). Also referred as Service Provider URN or Audience URI or Service Provider Entity ID.
        public let federationURN: String?
        /// SAML 2.0 Metadata document from identity provider (IdP).
        public let samlMetadataDocument: String?
        /// Provide the metadata URL from your SAML 2.0 compliant identity provider (IdP).
        public let samlMetadataURL: String?

        public init(applicationCallBackURL: String? = nil, attributeMap: [String: String]? = nil, federationProviderName: String? = nil, federationURN: String? = nil, samlMetadataDocument: String? = nil, samlMetadataURL: String? = nil) {
            self.applicationCallBackURL = applicationCallBackURL
            self.attributeMap = attributeMap
            self.federationProviderName = federationProviderName
            self.federationURN = federationURN
            self.samlMetadataDocument = samlMetadataDocument
            self.samlMetadataURL = samlMetadataURL
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationCallBackURL, name: "applicationCallBackURL", parent: name, max: 1000)
            try self.validate(self.applicationCallBackURL, name: "applicationCallBackURL", parent: name, min: 1)
            try self.validate(self.applicationCallBackURL, name: "applicationCallBackURL", parent: name, pattern: "^https?://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
            try self.attributeMap?.forEach {
                try validate($0.key, name: "attributeMap.key", parent: name, max: 32)
                try validate($0.key, name: "attributeMap.key", parent: name, min: 1)
                try validate($0.key, name: "attributeMap.key", parent: name, pattern: ".*")
                try validate($0.value, name: "attributeMap[\"\($0.key)\"]", parent: name, max: 1000)
                try validate($0.value, name: "attributeMap[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "attributeMap[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.federationProviderName, name: "federationProviderName", parent: name, max: 32)
            try self.validate(self.federationProviderName, name: "federationProviderName", parent: name, min: 1)
            try self.validate(self.federationProviderName, name: "federationProviderName", parent: name, pattern: "^[^_\\p{Z}][\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}][^_\\p{Z}]+$")
            try self.validate(self.federationURN, name: "federationURN", parent: name, max: 255)
            try self.validate(self.federationURN, name: "federationURN", parent: name, min: 1)
            try self.validate(self.federationURN, name: "federationURN", parent: name, pattern: "^[A-Za-z0-9._\\-:\\/#\\+]+$")
            try self.validate(self.samlMetadataDocument, name: "samlMetadataDocument", parent: name, max: 10000000)
            try self.validate(self.samlMetadataDocument, name: "samlMetadataDocument", parent: name, min: 1000)
            try self.validate(self.samlMetadataDocument, name: "samlMetadataDocument", parent: name, pattern: ".*")
            try self.validate(self.samlMetadataURL, name: "samlMetadataURL", parent: name, max: 1000)
            try self.validate(self.samlMetadataURL, name: "samlMetadataURL", parent: name, min: 1)
            try self.validate(self.samlMetadataURL, name: "samlMetadataURL", parent: name, pattern: "^https?://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCallBackURL = "applicationCallBackURL"
            case attributeMap = "attributeMap"
            case federationProviderName = "federationProviderName"
            case federationURN = "federationURN"
            case samlMetadataDocument = "samlMetadataDocument"
            case samlMetadataURL = "samlMetadataURL"
        }
    }

    public struct GetEnvironmentRequest: AWSEncodableShape {
        /// The identifier of the FinSpace environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentResponse: AWSDecodableShape {
        /// The name of the FinSpace environment.
        public let environment: Environment?

        public init(environment: Environment? = nil) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct GetKxChangesetRequest: AWSEncodableShape {
        /// A unique identifier of the changeset for which you want to retrieve data.
        public let changesetId: String
        /// The name of the kdb database.
        public let databaseName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(changesetId: String, databaseName: String, environmentId: String) {
            self.changesetId = changesetId
            self.databaseName = databaseName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.changesetId, key: "changesetId")
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.changesetId, name: "changesetId", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxChangesetResponse: AWSDecodableShape {
        /// Beginning time from which the changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let activeFromTimestamp: Date?
        /// A list of change request objects that are run in order.
        public let changeRequests: [ChangeRequest]?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the kdb database.
        public let databaseName: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Provides details in the event of a failed flow, including the error type and the related error message.
        public let errorInfo: ErrorInfo?
        /// The timestamp at which the changeset was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// Status of the changeset creation process.   Pending – Changeset creation is pending.   Processing – Changeset creation is running.   Failed – Changeset creation has failed.   Complete – Changeset creation has succeeded.
        public let status: ChangesetStatus?

        public init(activeFromTimestamp: Date? = nil, changeRequests: [ChangeRequest]? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, databaseName: String? = nil, environmentId: String? = nil, errorInfo: ErrorInfo? = nil, lastModifiedTimestamp: Date? = nil, status: ChangesetStatus? = nil) {
            self.activeFromTimestamp = activeFromTimestamp
            self.changeRequests = changeRequests
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.environmentId = environmentId
            self.errorInfo = errorInfo
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case activeFromTimestamp = "activeFromTimestamp"
            case changeRequests = "changeRequests"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case environmentId = "environmentId"
            case errorInfo = "errorInfo"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case status = "status"
        }
    }

    public struct GetKxClusterRequest: AWSEncodableShape {
        /// The name of the cluster that you want to retrieve.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clusterName: String, environmentId: String) {
            self.clusterName = clusterName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxClusterResponse: AWSDecodableShape {
        /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
        public let autoScalingConfiguration: AutoScalingConfiguration?
        ///  The availability zone identifiers for the requested regions.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per cluster. This can be one of the following     SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
        public let azMode: KxAzMode?
        /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
        public let cacheStorageConfigurations: [KxCacheStorageConfiguration]?
        /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.
        public let capacityConfiguration: CapacityConfiguration?
        /// A description of the cluster.
        public let clusterDescription: String?
        /// A unique name for the cluster.
        public let clusterName: String?
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.   GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.   Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
        public let clusterType: KxClusterType?
        /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
        public let code: CodeConfiguration?
        /// Defines key-value pairs to make them available inside the cluster.
        public let commandLineArguments: [KxCommandLineArgument]?
        /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        ///  A list of databases mounted on the cluster.
        public let databases: [KxDatabaseConfiguration]?
        ///  An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public let executionRole: String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public let initializationScript: String?
        /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// The version of FinSpace managed kdb to run.
        public let releaseLabel: String?
        /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
        public let savedownStorageConfiguration: KxSavedownStorageConfiguration?
        public let scalingGroupConfiguration: KxScalingGroupConfiguration?
        /// The status of cluster creation.   PENDING – The cluster is pending creation.   CREATING – The cluster creation process is in progress.   CREATE_FAILED – The cluster creation process has failed.   RUNNING – The cluster creation process is running.   UPDATING – The cluster is in the process of being updated.   DELETING – The cluster is in the process of being deleted.   DELETED – The cluster has been deleted.   DELETE_FAILED – The cluster failed to delete.
        public let status: KxClusterStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        public let tickerplantLogConfiguration: TickerplantLogConfiguration?
        /// A list of volumes attached to the cluster.
        public let volumes: [Volume]?
        /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
        public let vpcConfiguration: VpcConfiguration?

        public init(autoScalingConfiguration: AutoScalingConfiguration? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, cacheStorageConfigurations: [KxCacheStorageConfiguration]? = nil, capacityConfiguration: CapacityConfiguration? = nil, clusterDescription: String? = nil, clusterName: String? = nil, clusterType: KxClusterType? = nil, code: CodeConfiguration? = nil, commandLineArguments: [KxCommandLineArgument]? = nil, createdTimestamp: Date? = nil, databases: [KxDatabaseConfiguration]? = nil, executionRole: String? = nil, initializationScript: String? = nil, lastModifiedTimestamp: Date? = nil, releaseLabel: String? = nil, savedownStorageConfiguration: KxSavedownStorageConfiguration? = nil, scalingGroupConfiguration: KxScalingGroupConfiguration? = nil, status: KxClusterStatus? = nil, statusReason: String? = nil, tickerplantLogConfiguration: TickerplantLogConfiguration? = nil, volumes: [Volume]? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.autoScalingConfiguration = autoScalingConfiguration
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.cacheStorageConfigurations = cacheStorageConfigurations
            self.capacityConfiguration = capacityConfiguration
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.code = code
            self.commandLineArguments = commandLineArguments
            self.createdTimestamp = createdTimestamp
            self.databases = databases
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.releaseLabel = releaseLabel
            self.savedownStorageConfiguration = savedownStorageConfiguration
            self.scalingGroupConfiguration = scalingGroupConfiguration
            self.status = status
            self.statusReason = statusReason
            self.tickerplantLogConfiguration = tickerplantLogConfiguration
            self.volumes = volumes
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "autoScalingConfiguration"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case cacheStorageConfigurations = "cacheStorageConfigurations"
            case capacityConfiguration = "capacityConfiguration"
            case clusterDescription = "clusterDescription"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case code = "code"
            case commandLineArguments = "commandLineArguments"
            case createdTimestamp = "createdTimestamp"
            case databases = "databases"
            case executionRole = "executionRole"
            case initializationScript = "initializationScript"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case releaseLabel = "releaseLabel"
            case savedownStorageConfiguration = "savedownStorageConfiguration"
            case scalingGroupConfiguration = "scalingGroupConfiguration"
            case status = "status"
            case statusReason = "statusReason"
            case tickerplantLogConfiguration = "tickerplantLogConfiguration"
            case volumes = "volumes"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct GetKxConnectionStringRequest: AWSEncodableShape {
        /// A name of the kdb cluster.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String

        public init(clusterName: String, environmentId: String, userArn: String) {
            self.clusterName = clusterName
            self.environmentId = environmentId
            self.userArn = userArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.userArn, key: "userArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.userArn, name: "userArn", parent: name, max: 2048)
            try self.validate(self.userArn, name: "userArn", parent: name, min: 20)
            try self.validate(self.userArn, name: "userArn", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d+:kxEnvironment/[0-9A-Za-z_-]{1,128}/kxUser/[0-9A-Za-z_-]{1,128}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxConnectionStringResponse: AWSDecodableShape {
        /// The signed connection string that you can use to connect to clusters.
        public let signedConnectionString: String?

        public init(signedConnectionString: String? = nil) {
            self.signedConnectionString = signedConnectionString
        }

        private enum CodingKeys: String, CodingKey {
            case signedConnectionString = "signedConnectionString"
        }
    }

    public struct GetKxDatabaseRequest: AWSEncodableShape {
        /// The name of the kdb database.
        public let databaseName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(databaseName: String, environmentId: String) {
            self.databaseName = databaseName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxDatabaseResponse: AWSDecodableShape {
        /// The timestamp at which the database is created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The ARN identifier of the database.
        public let databaseArn: String?
        /// The name of the kdb database for which the information is retrieved.
        public let databaseName: String?
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// A unique identifier for the changeset.
        public let lastCompletedChangesetId: String?
        /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// The total number of bytes in the database.
        public let numBytes: Int64?
        /// The total number of changesets in the database.
        public let numChangesets: Int?
        /// The total number of files in the database.
        public let numFiles: Int?

        public init(createdTimestamp: Date? = nil, databaseArn: String? = nil, databaseName: String? = nil, description: String? = nil, environmentId: String? = nil, lastCompletedChangesetId: String? = nil, lastModifiedTimestamp: Date? = nil, numBytes: Int64? = nil, numChangesets: Int? = nil, numFiles: Int? = nil) {
            self.createdTimestamp = createdTimestamp
            self.databaseArn = databaseArn
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
            self.lastCompletedChangesetId = lastCompletedChangesetId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.numBytes = numBytes
            self.numChangesets = numChangesets
            self.numFiles = numFiles
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "createdTimestamp"
            case databaseArn = "databaseArn"
            case databaseName = "databaseName"
            case description = "description"
            case environmentId = "environmentId"
            case lastCompletedChangesetId = "lastCompletedChangesetId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case numBytes = "numBytes"
            case numChangesets = "numChangesets"
            case numFiles = "numFiles"
        }
    }

    public struct GetKxDataviewRequest: AWSEncodableShape {
        /// The name of the database where you created the dataview.
        public let databaseName: String
        /// A unique identifier for the dataview.
        public let dataviewName: String
        /// A unique identifier for the kdb environment, from where you want to retrieve the dataview details.
        public let environmentId: String

        public init(databaseName: String, dataviewName: String, environmentId: String) {
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.dataviewName, key: "dataviewName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, max: 63)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, min: 3)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxDataviewResponse: AWSDecodableShape {
        ///  The current active changeset versions of the database on the given dataview.
        public let activeVersions: [KxDataviewActiveVersion]?
        /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when new changesets are ingested. The default value is false.
        public let autoUpdate: Bool?
        ///  The identifier of the availability zones.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode?
        /// A unique identifier of the changeset that you want to use to ingest data.
        public let changesetId: String?
        /// The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the database where you created the dataview.
        public let databaseName: String?
        /// A unique identifier for the dataview.
        public let dataviewName: String?
        /// A description of the dataview.
        public let description: String?
        /// A unique identifier for the kdb environment, from where you want to retrieve the dataview details.
        public let environmentId: String?
        ///  The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// Returns True if the dataview is created as writeable and False otherwise.
        public let readWrite: Bool?
        ///  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public let segmentConfigurations: [KxDataviewSegmentConfiguration]?
        ///  The status of dataview creation.    CREATING – The dataview creation is in progress.    UPDATING – The dataview is in the process of being updated.    ACTIVE – The dataview is active.
        public let status: KxDataviewStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?

        public init(activeVersions: [KxDataviewActiveVersion]? = nil, autoUpdate: Bool? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, databaseName: String? = nil, dataviewName: String? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil, readWrite: Bool? = nil, segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil, status: KxDataviewStatus? = nil, statusReason: String? = nil) {
            self.activeVersions = activeVersions
            self.autoUpdate = autoUpdate
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.readWrite = readWrite
            self.segmentConfigurations = segmentConfigurations
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case activeVersions = "activeVersions"
            case autoUpdate = "autoUpdate"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case dataviewName = "dataviewName"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case readWrite = "readWrite"
            case segmentConfigurations = "segmentConfigurations"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct GetKxEnvironmentRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxEnvironmentResponse: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneIds: [String]?
        /// The unique identifier of the AWS account that is used to create the kdb environment.
        public let awsAccountId: String?
        /// The Amazon Resource Name (ARN) of the certificate authority of the  kdb environment.
        public let certificateAuthorityArn: String?
        /// The timestamp at which the kdb environment was created in FinSpace.
        public let creationTimestamp: Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public let dedicatedServiceAccountId: String?
        /// A description for the kdb environment.
        public let description: String?
        /// The status of DNS configuration.
        public let dnsStatus: DnsStatus?
        /// The ARN identifier of the environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the kdb environment.
        public let status: EnvironmentStatus?
        /// The status of the network configuration.
        public let tgwStatus: TgwStatus?
        public let transitGatewayConfiguration: TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was updated.
        public let updateTimestamp: Date?

        public init(availabilityZoneIds: [String]? = nil, awsAccountId: String? = nil, certificateAuthorityArn: String? = nil, creationTimestamp: Date? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, dnsStatus: DnsStatus? = nil, environmentArn: String? = nil, environmentId: String? = nil, errorMessage: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil, tgwStatus: TgwStatus? = nil, transitGatewayConfiguration: TransitGatewayConfiguration? = nil, updateTimestamp: Date? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.certificateAuthorityArn = certificateAuthorityArn
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case awsAccountId = "awsAccountId"
            case certificateAuthorityArn = "certificateAuthorityArn"
            case creationTimestamp = "creationTimestamp"
            case customDNSConfiguration = "customDNSConfiguration"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case dnsStatus = "dnsStatus"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
            case tgwStatus = "tgwStatus"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
            case updateTimestamp = "updateTimestamp"
        }
    }

    public struct GetKxScalingGroupRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// A unique identifier for the kdb scaling group.
        public let scalingGroupName: String

        public init(environmentId: String, scalingGroupName: String) {
            self.environmentId = environmentId
            self.scalingGroupName = scalingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.scalingGroupName, key: "scalingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, max: 63)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, min: 3)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxScalingGroupResponse: AWSDecodableShape {
        /// The identifier of the availability zones.
        public let availabilityZoneId: String?
        ///  The list of Managed kdb clusters that are currently active in the given scaling group.
        public let clusters: [String]?
        ///  The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        ///  The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed. It can have one of the following values:    kx.sg.4xlarge – The host type with a configuration of 108 GiB memory and 16 vCPUs.    kx.sg.8xlarge – The host type with a configuration of 216 GiB memory and 32 vCPUs.    kx.sg.16xlarge – The host type with a configuration of 432 GiB memory and 64 vCPUs.    kx.sg.32xlarge – The host type with a configuration of 864 GiB memory and 128 vCPUs.    kx.sg1.16xlarge – The host type with a configuration of 1949 GiB memory and 64 vCPUs.    kx.sg1.24xlarge – The host type with a configuration of 2948 GiB memory and 96 vCPUs.
        public let hostType: String?
        ///  The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        ///  The ARN identifier for the scaling group.
        public let scalingGroupArn: String?
        /// A unique identifier for the kdb scaling group.
        public let scalingGroupName: String?
        /// The status of scaling group.   CREATING – The scaling group creation is in progress.   CREATE_FAILED – The scaling group creation has failed.   ACTIVE – The scaling group is active.   UPDATING – The scaling group is in the process of being updated.   UPDATE_FAILED – The update action failed.   DELETING – The scaling group is in the process of being deleted.   DELETE_FAILED – The system failed to delete the scaling group.   DELETED – The scaling group is successfully deleted.
        public let status: KxScalingGroupStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?

        public init(availabilityZoneId: String? = nil, clusters: [String]? = nil, createdTimestamp: Date? = nil, hostType: String? = nil, lastModifiedTimestamp: Date? = nil, scalingGroupArn: String? = nil, scalingGroupName: String? = nil, status: KxScalingGroupStatus? = nil, statusReason: String? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.clusters = clusters
            self.createdTimestamp = createdTimestamp
            self.hostType = hostType
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.scalingGroupArn = scalingGroupArn
            self.scalingGroupName = scalingGroupName
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "availabilityZoneId"
            case clusters = "clusters"
            case createdTimestamp = "createdTimestamp"
            case hostType = "hostType"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case scalingGroupArn = "scalingGroupArn"
            case scalingGroupName = "scalingGroupName"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct GetKxUserRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// A unique identifier for the user.
        public let userName: String

        public init(environmentId: String, userName: String) {
            self.environmentId = environmentId
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.userName, key: "userName")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.userName, name: "userName", parent: name, max: 50)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[0-9A-Za-z_-]{1,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxUserResponse: AWSDecodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The IAM role ARN that is associated with the user.
        public let iamRole: String?
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String?
        /// A unique identifier for the user.
        public let userName: String?

        public init(environmentId: String? = nil, iamRole: String? = nil, userArn: String? = nil, userName: String? = nil) {
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.userArn = userArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case iamRole = "iamRole"
            case userArn = "userArn"
            case userName = "userName"
        }
    }

    public struct GetKxVolumeRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
        public let environmentId: String
        /// A unique identifier for the volume.
        public let volumeName: String

        public init(environmentId: String, volumeName: String) {
            self.environmentId = environmentId
            self.volumeName = volumeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.volumeName, key: "volumeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.volumeName, name: "volumeName", parent: name, max: 63)
            try self.validate(self.volumeName, name: "volumeName", parent: name, min: 3)
            try self.validate(self.volumeName, name: "volumeName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxVolumeResponse: AWSDecodableShape {
        /// A list of cluster identifiers that a volume is attached to.
        public let attachedClusters: [KxAttachedCluster]?
        /// The identifier of the availability zones.
        public let availabilityZoneIds: [String]?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode?
        /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// A description of the volume.
        public let description: String?
        /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
        public let environmentId: String?
        /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        ///  Specifies the configuration for the Network attached storage (NAS_1) file system volume.
        public let nas1Configuration: KxNAS1Configuration?
        /// The status of volume creation.   CREATING – The volume creation is in progress.   CREATE_FAILED – The volume creation has failed.   ACTIVE – The volume is active.   UPDATING – The volume is in the process of being updated.   UPDATE_FAILED – The update action failed.   UPDATED – The volume is successfully updated.   DELETING – The volume is in the process of being deleted.   DELETE_FAILED – The system failed to delete the volume.   DELETED – The volume is successfully deleted.
        public let status: KxVolumeStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        /// The ARN identifier of the volume.
        public let volumeArn: String?
        /// A unique identifier for the volume.
        public let volumeName: String?
        ///  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public let volumeType: KxVolumeType?

        public init(attachedClusters: [KxAttachedCluster]? = nil, availabilityZoneIds: [String]? = nil, azMode: KxAzMode? = nil, createdTimestamp: Date? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil, nas1Configuration: KxNAS1Configuration? = nil, status: KxVolumeStatus? = nil, statusReason: String? = nil, volumeArn: String? = nil, volumeName: String? = nil, volumeType: KxVolumeType? = nil) {
            self.attachedClusters = attachedClusters
            self.availabilityZoneIds = availabilityZoneIds
            self.azMode = azMode
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.nas1Configuration = nas1Configuration
            self.status = status
            self.statusReason = statusReason
            self.volumeArn = volumeArn
            self.volumeName = volumeName
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case attachedClusters = "attachedClusters"
            case availabilityZoneIds = "availabilityZoneIds"
            case azMode = "azMode"
            case createdTimestamp = "createdTimestamp"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case nas1Configuration = "nas1Configuration"
            case status = "status"
            case statusReason = "statusReason"
            case volumeArn = "volumeArn"
            case volumeName = "volumeName"
            case volumeType = "volumeType"
        }
    }

    public struct IcmpTypeCode: AWSEncodableShape & AWSDecodableShape {
        ///  The ICMP code. A value of -1 means all codes for the specified ICMP type.
        public let code: Int
        /// The ICMP type. A value of -1 means all types.
        public let type: Int

        public init(code: Int, type: Int) {
            self.code = code
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case type = "type"
        }
    }

    public struct KxAttachedCluster: AWSDecodableShape {
        /// A unique name for the attached cluster.
        public let clusterName: String?
        /// The status of the attached cluster.   PENDING – The cluster is pending creation.   CREATING – The cluster creation process is in progress.   CREATE_FAILED – The cluster creation process has failed.   RUNNING – The cluster creation process is running.   UPDATING – The cluster is in the process of being updated.   DELETING – The cluster is in the process of being deleted.   DELETED – The cluster has been deleted.   DELETE_FAILED – The cluster failed to delete.
        public let clusterStatus: KxClusterStatus?
        /// Specifies the type of cluster. The volume for TP and RDB cluster types will be used for TP logs.
        public let clusterType: KxClusterType?

        public init(clusterName: String? = nil, clusterStatus: KxClusterStatus? = nil, clusterType: KxClusterType? = nil) {
            self.clusterName = clusterName
            self.clusterStatus = clusterStatus
            self.clusterType = clusterType
        }

        private enum CodingKeys: String, CodingKey {
            case clusterName = "clusterName"
            case clusterStatus = "clusterStatus"
            case clusterType = "clusterType"
        }
    }

    public struct KxCacheStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The size of cache in Gigabytes.
        public let size: Int
        /// The type of cache storage. The valid values are:    CACHE_1000 – This type provides at least 1000 MB/s disk access throughput.    CACHE_250 – This type provides at least 250 MB/s disk access throughput.    CACHE_12 – This type provides at least 12 MB/s disk access throughput.    For cache type CACHE_1000 and CACHE_250 you can select cache size as 1200 GB or increments of 2400 GB. For cache type CACHE_12 you can select the cache size in increments of 6000 GB.
        public let type: String

        public init(size: Int, type: String) {
            self.size = size
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, max: 10)
            try self.validate(self.type, name: "type", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case size = "size"
            case type = "type"
        }
    }

    public struct KxChangesetListEntry: AWSDecodableShape {
        /// Beginning time from which the changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let activeFromTimestamp: Date?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The timestamp at which the changeset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        ///  Status of the changeset.   Pending – Changeset creation is pending.   Processing – Changeset creation is running.   Failed – Changeset creation has failed.   Complete – Changeset creation has succeeded.
        public let status: ChangesetStatus?

        public init(activeFromTimestamp: Date? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, lastModifiedTimestamp: Date? = nil, status: ChangesetStatus? = nil) {
            self.activeFromTimestamp = activeFromTimestamp
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case activeFromTimestamp = "activeFromTimestamp"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case status = "status"
        }
    }

    public struct KxCluster: AWSDecodableShape {
        ///  The availability zone identifiers for the requested regions.
        public let availabilityZoneId: String?
        /// The number of availability zones assigned per cluster. This can be one of the following:    SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
        public let azMode: KxAzMode?
        /// A description of the cluster.
        public let clusterDescription: String?
        /// A unique name for the cluster.
        public let clusterName: String?
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.   GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.   Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
        public let clusterType: KxClusterType?
        /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        ///  An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public let executionRole: String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public let initializationScript: String?
        /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// A version of the FinSpace managed kdb to run.
        public let releaseLabel: String?
        /// The status of a cluster.   PENDING – The cluster is pending creation.   CREATING –The cluster creation process is in progress.   CREATE_FAILED– The cluster creation process has failed.   RUNNING – The cluster creation process is running.   UPDATING – The cluster is in the process of being updated.   DELETING – The cluster is in the process of being deleted.   DELETED – The cluster has been deleted.   DELETE_FAILED – The cluster failed to delete.
        public let status: KxClusterStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        /// A list of volumes attached to the cluster.
        public let volumes: [Volume]?

        public init(availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, clusterDescription: String? = nil, clusterName: String? = nil, clusterType: KxClusterType? = nil, createdTimestamp: Date? = nil, executionRole: String? = nil, initializationScript: String? = nil, lastModifiedTimestamp: Date? = nil, releaseLabel: String? = nil, status: KxClusterStatus? = nil, statusReason: String? = nil, volumes: [Volume]? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.createdTimestamp = createdTimestamp
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.releaseLabel = releaseLabel
            self.status = status
            self.statusReason = statusReason
            self.volumes = volumes
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case clusterDescription = "clusterDescription"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case createdTimestamp = "createdTimestamp"
            case executionRole = "executionRole"
            case initializationScript = "initializationScript"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case releaseLabel = "releaseLabel"
            case status = "status"
            case statusReason = "statusReason"
            case volumes = "volumes"
        }
    }

    public struct KxClusterCodeDeploymentConfiguration: AWSEncodableShape {
        ///  The type of deployment that you want on a cluster.     ROLLING – This options updates the cluster by stopping the exiting q process and starting a new q process with updated configuration.   NO_RESTART – This option updates the cluster without stopping the running q process. It is only available for GP type cluster. This option is quicker as it reduces the turn around time to update configuration on a cluster.  With this deployment mode, you cannot update the initializationScript and commandLineArguments parameters.   FORCE – This option updates the cluster by immediately stopping all the running processes before starting up new ones with the updated configuration.
        public let deploymentStrategy: KxClusterCodeDeploymentStrategy

        public init(deploymentStrategy: KxClusterCodeDeploymentStrategy) {
            self.deploymentStrategy = deploymentStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentStrategy = "deploymentStrategy"
        }
    }

    public struct KxCommandLineArgument: AWSEncodableShape & AWSDecodableShape {
        /// The name of the key.
        public let key: String?
        /// The value of the key.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?![Aa][Ww][Ss])(s|([a-zA-Z][a-zA-Z0-9_]+))|(AWS_ZIP_DEFAULT)$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9_:./,]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct KxDatabaseCacheConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of disk cache. This parameter is used to map the database path to cache storage. The valid values are:   CACHE_1000 – This type provides at least 1000 MB/s disk access throughput.
        public let cacheType: String
        ///  The name of the dataview to be used for caching historical data on disk.
        public let dataviewName: String?
        /// Specifies the portions of database that will be loaded into the cache for access.
        public let dbPaths: [String]

        public init(cacheType: String, dataviewName: String? = nil, dbPaths: [String]) {
            self.cacheType = cacheType
            self.dataviewName = dataviewName
            self.dbPaths = dbPaths
        }

        public func validate(name: String) throws {
            try self.validate(self.cacheType, name: "cacheType", parent: name, max: 10)
            try self.validate(self.cacheType, name: "cacheType", parent: name, min: 8)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, max: 63)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, min: 3)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.dbPaths.forEach {
                try validate($0, name: "dbPaths[]", parent: name, max: 1025)
                try validate($0, name: "dbPaths[]", parent: name, min: 1)
                try validate($0, name: "dbPaths[]", parent: name, pattern: "^(\\*)*[\\/\\?\\*]([^\\/]+\\/){0,2}[^\\/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cacheType = "cacheType"
            case dataviewName = "dataviewName"
            case dbPaths = "dbPaths"
        }
    }

    public struct KxDatabaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration details for the disk cache used to increase performance reading from a kdb database mounted to the cluster.
        public let cacheConfigurations: [KxDatabaseCacheConfiguration]?
        /// A unique identifier of the changeset that is associated with the cluster.
        public let changesetId: String?
        /// The name of the kdb database. When this parameter is specified in the structure, S3 with the whole database is included by default.
        public let databaseName: String
        ///  The configuration of the dataview to be used with specified cluster.
        public let dataviewConfiguration: KxDataviewConfiguration?
        ///  The name of the dataview to be used for caching historical data on disk.
        public let dataviewName: String?

        public init(cacheConfigurations: [KxDatabaseCacheConfiguration]? = nil, changesetId: String? = nil, databaseName: String, dataviewConfiguration: KxDataviewConfiguration? = nil, dataviewName: String? = nil) {
            self.cacheConfigurations = cacheConfigurations
            self.changesetId = changesetId
            self.databaseName = databaseName
            self.dataviewConfiguration = dataviewConfiguration
            self.dataviewName = dataviewName
        }

        public func validate(name: String) throws {
            try self.cacheConfigurations?.forEach {
                try $0.validate(name: "\(name).cacheConfigurations[]")
            }
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.changesetId, name: "changesetId", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.dataviewConfiguration?.validate(name: "\(name).dataviewConfiguration")
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, max: 63)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, min: 3)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case cacheConfigurations = "cacheConfigurations"
            case changesetId = "changesetId"
            case databaseName = "databaseName"
            case dataviewConfiguration = "dataviewConfiguration"
            case dataviewName = "dataviewName"
        }
    }

    public struct KxDatabaseListEntry: AWSDecodableShape {
        /// The timestamp at which the database was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the kdb database.
        public let databaseName: String?
        /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, databaseName: String? = nil, lastModifiedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
        }
    }

    public struct KxDataviewActiveVersion: AWSDecodableShape {
        ///  The list of clusters that are currently using this dataview.
        public let attachedClusters: [String]?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the dataview version was active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        ///  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public let segmentConfigurations: [KxDataviewSegmentConfiguration]?
        /// A unique identifier of the active version.
        public let versionId: String?

        public init(attachedClusters: [String]? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil, versionId: String? = nil) {
            self.attachedClusters = attachedClusters
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.segmentConfigurations = segmentConfigurations
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case attachedClusters = "attachedClusters"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case segmentConfigurations = "segmentConfigurations"
            case versionId = "versionId"
        }
    }

    public struct KxDataviewConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The unique identifier of the dataview.
        public let dataviewName: String?
        ///  The version of the dataview corresponding to a given changeset.
        public let dataviewVersionId: String?
        /// The db path and volume configuration for the segmented database.
        public let segmentConfigurations: [KxDataviewSegmentConfiguration]?

        public init(changesetId: String? = nil, dataviewName: String? = nil, dataviewVersionId: String? = nil, segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil) {
            self.changesetId = changesetId
            self.dataviewName = dataviewName
            self.dataviewVersionId = dataviewVersionId
            self.segmentConfigurations = segmentConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.changesetId, name: "changesetId", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, max: 63)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, min: 3)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.dataviewVersionId, name: "dataviewVersionId", parent: name, max: 26)
            try self.validate(self.dataviewVersionId, name: "dataviewVersionId", parent: name, min: 1)
            try self.segmentConfigurations?.forEach {
                try $0.validate(name: "\(name).segmentConfigurations[]")
            }
            try self.validate(self.segmentConfigurations, name: "segmentConfigurations", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case changesetId = "changesetId"
            case dataviewName = "dataviewName"
            case dataviewVersionId = "dataviewVersionId"
            case segmentConfigurations = "segmentConfigurations"
        }
    }

    public struct KxDataviewListEntry: AWSDecodableShape {
        ///  The active changeset versions for the given dataview entry.
        public let activeVersions: [KxDataviewActiveVersion]?
        ///  The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.
        public let autoUpdate: Bool?
        ///  The identifier of the availability zones.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the dataview list entry was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// A unique identifier of the database.
        public let databaseName: String?
        /// A unique identifier of the dataview.
        public let dataviewName: String?
        /// A description for the dataview list entry.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The last time that the dataview list was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        ///  Returns True if the dataview is created as writeable and False otherwise.
        public let readWrite: Bool?
        ///  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public let segmentConfigurations: [KxDataviewSegmentConfiguration]?
        ///  The status of a given dataview entry.
        public let status: KxDataviewStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?

        public init(activeVersions: [KxDataviewActiveVersion]? = nil, autoUpdate: Bool? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, databaseName: String? = nil, dataviewName: String? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil, readWrite: Bool? = nil, segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil, status: KxDataviewStatus? = nil, statusReason: String? = nil) {
            self.activeVersions = activeVersions
            self.autoUpdate = autoUpdate
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.readWrite = readWrite
            self.segmentConfigurations = segmentConfigurations
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case activeVersions = "activeVersions"
            case autoUpdate = "autoUpdate"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case dataviewName = "dataviewName"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case readWrite = "readWrite"
            case segmentConfigurations = "segmentConfigurations"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct KxDataviewSegmentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The database path of the data that you want to place on each selected volume for the segment. Each segment must have a unique database path for each volume.
        public let dbPaths: [String]
        /// Enables on-demand caching on the selected database path when a particular file or a column of the database is accessed. When on demand caching is True, dataviews perform minimal loading of files on the filesystem as needed. When it is set to False, everything is cached. The default value is False.
        public let onDemand: Bool?
        /// The name of the volume where you want to add data.
        public let volumeName: String

        public init(dbPaths: [String], onDemand: Bool? = nil, volumeName: String) {
            self.dbPaths = dbPaths
            self.onDemand = onDemand
            self.volumeName = volumeName
        }

        public func validate(name: String) throws {
            try self.dbPaths.forEach {
                try validate($0, name: "dbPaths[]", parent: name, max: 1025)
                try validate($0, name: "dbPaths[]", parent: name, min: 1)
                try validate($0, name: "dbPaths[]", parent: name, pattern: "^(\\*)*[\\/\\?\\*]([^\\/]+\\/){0,2}[^\\/]*$")
            }
            try self.validate(self.dbPaths, name: "dbPaths", parent: name, max: 30)
            try self.validate(self.dbPaths, name: "dbPaths", parent: name, min: 1)
            try self.validate(self.volumeName, name: "volumeName", parent: name, max: 63)
            try self.validate(self.volumeName, name: "volumeName", parent: name, min: 3)
            try self.validate(self.volumeName, name: "volumeName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case dbPaths = "dbPaths"
            case onDemand = "onDemand"
            case volumeName = "volumeName"
        }
    }

    public struct KxDeploymentConfiguration: AWSEncodableShape {
        ///  The type of deployment that you want on a cluster.     ROLLING – This options updates the cluster by stopping the exiting q process and starting a new q process with updated configuration.   NO_RESTART – This option updates the cluster without stopping the running q process. It is only available for HDB type cluster. This option is quicker as it reduces the turn around time to update configuration on a cluster.  With this deployment mode, you cannot update the initializationScript and commandLineArguments parameters.
        public let deploymentStrategy: KxDeploymentStrategy

        public init(deploymentStrategy: KxDeploymentStrategy) {
            self.deploymentStrategy = deploymentStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentStrategy = "deploymentStrategy"
        }
    }

    public struct KxEnvironment: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneIds: [String]?
        /// The unique identifier of the AWS account in which you create the kdb environment.
        public let awsAccountId: String?
        /// The Amazon Resource Name (ARN) of the certificate authority:
        public let certificateAuthorityArn: String?
        /// The timestamp at which the kdb environment was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let creationTimestamp: Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public let dedicatedServiceAccountId: String?
        /// A description of the kdb environment.
        public let description: String?
        /// The status of DNS configuration.
        public let dnsStatus: DnsStatus?
        /// The Amazon Resource Name (ARN) of your kdb environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// The unique identifier of the KMS key.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the environment creation.    CREATE_REQUESTED – Environment creation has been requested.   CREATING – Environment is in the process of being created.   FAILED_CREATION – Environment creation has failed.   CREATED – Environment is successfully created and is currently active.   DELETE REQUESTED – Environment deletion has been requested.   DELETING – Environment is in the process of being deleted.   RETRY_DELETION – Initial environment deletion failed, system is reattempting delete.   DELETED – Environment has been deleted.   FAILED_DELETION – Environment deletion has failed.
        public let status: EnvironmentStatus?
        /// The status of the network configuration.
        public let tgwStatus: TgwStatus?
        /// Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
        public let transitGatewayConfiguration: TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was modified in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let updateTimestamp: Date?

        public init(availabilityZoneIds: [String]? = nil, awsAccountId: String? = nil, certificateAuthorityArn: String? = nil, creationTimestamp: Date? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, dnsStatus: DnsStatus? = nil, environmentArn: String? = nil, environmentId: String? = nil, errorMessage: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil, tgwStatus: TgwStatus? = nil, transitGatewayConfiguration: TransitGatewayConfiguration? = nil, updateTimestamp: Date? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.certificateAuthorityArn = certificateAuthorityArn
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case awsAccountId = "awsAccountId"
            case certificateAuthorityArn = "certificateAuthorityArn"
            case creationTimestamp = "creationTimestamp"
            case customDNSConfiguration = "customDNSConfiguration"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case dnsStatus = "dnsStatus"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
            case tgwStatus = "tgwStatus"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
            case updateTimestamp = "updateTimestamp"
        }
    }

    public struct KxNAS1Configuration: AWSEncodableShape & AWSDecodableShape {
        ///  The size of the network attached storage. For storage type SSD_1000 and SSD_250 you can select the minimum size as 1200 GB or increments of 2400 GB. For storage type HDD_12 you can select the minimum size as 6000 GB or increments of 6000 GB.
        public let size: Int?
        /// The type of the network attached storage.
        public let type: KxNAS1Type?

        public init(size: Int? = nil, type: KxNAS1Type? = nil) {
            self.size = size
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.size, name: "size", parent: name, min: 1200)
        }

        private enum CodingKeys: String, CodingKey {
            case size = "size"
            case type = "type"
        }
    }

    public struct KxNode: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneId: String?
        /// The time when a particular node is started.  The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let launchTime: Date?
        /// A unique identifier for the node.
        public let nodeId: String?
        ///  Specifies the status of the cluster nodes.       RUNNING – The node is actively serving.    PROVISIONING – The node is being prepared.
        public let status: KxNodeStatus?

        public init(availabilityZoneId: String? = nil, launchTime: Date? = nil, nodeId: String? = nil, status: KxNodeStatus? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.launchTime = launchTime
            self.nodeId = nodeId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "availabilityZoneId"
            case launchTime = "launchTime"
            case nodeId = "nodeId"
            case status = "status"
        }
    }

    public struct KxSavedownStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The size of temporary storage in gibibytes.
        public let size: Int?
        /// The type of writeable storage space for temporarily storing your savedown data. The valid values are:   SDS01 – This type represents 3000 IOPS and io2 ebs volume type.
        public let type: KxSavedownStorageType?
        ///  The name of the kdb volume that you want to use as writeable save-down storage for clusters.
        public let volumeName: String?

        public init(size: Int? = nil, type: KxSavedownStorageType? = nil, volumeName: String? = nil) {
            self.size = size
            self.type = type
            self.volumeName = volumeName
        }

        public func validate(name: String) throws {
            try self.validate(self.size, name: "size", parent: name, max: 16000)
            try self.validate(self.size, name: "size", parent: name, min: 10)
            try self.validate(self.volumeName, name: "volumeName", parent: name, max: 63)
            try self.validate(self.volumeName, name: "volumeName", parent: name, min: 3)
            try self.validate(self.volumeName, name: "volumeName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case size = "size"
            case type = "type"
            case volumeName = "volumeName"
        }
    }

    public struct KxScalingGroup: AWSDecodableShape {
        /// The identifier of the availability zones.
        public let availabilityZoneId: String?
        ///  The list of clusters currently active in a given scaling group.
        public let clusters: [String]?
        ///  The timestamp at which the scaling group was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        ///  The memory and CPU capabilities of the scaling group host on which FinSpace Managed kdb clusters will be placed. You can add one of the following values:    kx.sg.4xlarge – The host type with a configuration of 108 GiB memory and 16 vCPUs.    kx.sg.8xlarge – The host type with a configuration of 216 GiB memory and 32 vCPUs.    kx.sg.16xlarge – The host type with a configuration of 432 GiB memory and 64 vCPUs.    kx.sg.32xlarge – The host type with a configuration of 864 GiB memory and 128 vCPUs.    kx.sg1.16xlarge – The host type with a configuration of 1949 GiB memory and 64 vCPUs.    kx.sg1.24xlarge – The host type with a configuration of 2948 GiB memory and 96 vCPUs.
        public let hostType: String?
        ///  The last time that the scaling group was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// A unique identifier for the kdb scaling group.
        public let scalingGroupName: String?
        /// The status of scaling groups.
        public let status: KxScalingGroupStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?

        public init(availabilityZoneId: String? = nil, clusters: [String]? = nil, createdTimestamp: Date? = nil, hostType: String? = nil, lastModifiedTimestamp: Date? = nil, scalingGroupName: String? = nil, status: KxScalingGroupStatus? = nil, statusReason: String? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.clusters = clusters
            self.createdTimestamp = createdTimestamp
            self.hostType = hostType
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.scalingGroupName = scalingGroupName
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "availabilityZoneId"
            case clusters = "clusters"
            case createdTimestamp = "createdTimestamp"
            case hostType = "hostType"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case scalingGroupName = "scalingGroupName"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct KxScalingGroupConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The number of vCPUs that you want to reserve for each node of this kdb cluster on the scaling group host.
        public let cpu: Double?
        ///  An optional hard limit on the amount of memory a kdb cluster can use.
        public let memoryLimit: Int?
        ///  A reservation of the minimum amount of memory that should be available on the scaling group for a kdb cluster to be successfully placed in a scaling group.
        public let memoryReservation: Int
        ///  The number of kdb cluster nodes.
        public let nodeCount: Int
        /// A unique identifier for the kdb scaling group.
        public let scalingGroupName: String

        public init(cpu: Double? = nil, memoryLimit: Int? = nil, memoryReservation: Int, nodeCount: Int, scalingGroupName: String) {
            self.cpu = cpu
            self.memoryLimit = memoryLimit
            self.memoryReservation = memoryReservation
            self.nodeCount = nodeCount
            self.scalingGroupName = scalingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.cpu, name: "cpu", parent: name, min: 0.1)
            try self.validate(self.memoryLimit, name: "memoryLimit", parent: name, min: 6)
            try self.validate(self.memoryReservation, name: "memoryReservation", parent: name, min: 6)
            try self.validate(self.nodeCount, name: "nodeCount", parent: name, min: 1)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, max: 63)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, min: 3)
            try self.validate(self.scalingGroupName, name: "scalingGroupName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case cpu = "cpu"
            case memoryLimit = "memoryLimit"
            case memoryReservation = "memoryReservation"
            case nodeCount = "nodeCount"
            case scalingGroupName = "scalingGroupName"
        }
    }

    public struct KxUser: AWSDecodableShape {
        /// The timestamp at which the kdb user was created.
        public let createTimestamp: Date?
        /// The IAM role ARN that is associated with the user.
        public let iamRole: String?
        /// The timestamp at which the kdb user was updated.
        public let updateTimestamp: Date?
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String?
        /// A unique identifier for the user.
        public let userName: String?

        public init(createTimestamp: Date? = nil, iamRole: String? = nil, updateTimestamp: Date? = nil, userArn: String? = nil, userName: String? = nil) {
            self.createTimestamp = createTimestamp
            self.iamRole = iamRole
            self.updateTimestamp = updateTimestamp
            self.userArn = userArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case createTimestamp = "createTimestamp"
            case iamRole = "iamRole"
            case updateTimestamp = "updateTimestamp"
            case userArn = "userArn"
            case userName = "userName"
        }
    }

    public struct KxVolume: AWSDecodableShape {
        /// The identifier of the availability zones.
        public let availabilityZoneIds: [String]?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode?
        /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// A description of the volume.
        public let description: String?
        /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// The status of volume.   CREATING – The volume creation is in progress.   CREATE_FAILED – The volume creation has failed.   ACTIVE – The volume is active.   UPDATING – The volume is in the process of being updated.   UPDATE_FAILED – The update action failed.   UPDATED – The volume is successfully updated.   DELETING – The volume is in the process of being deleted.   DELETE_FAILED – The system failed to delete the volume.   DELETED – The volume is successfully deleted.
        public let status: KxVolumeStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        /// A unique identifier for the volume.
        public let volumeName: String?
        ///  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public let volumeType: KxVolumeType?

        public init(availabilityZoneIds: [String]? = nil, azMode: KxAzMode? = nil, createdTimestamp: Date? = nil, description: String? = nil, lastModifiedTimestamp: Date? = nil, status: KxVolumeStatus? = nil, statusReason: String? = nil, volumeName: String? = nil, volumeType: KxVolumeType? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.azMode = azMode
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
            self.statusReason = statusReason
            self.volumeName = volumeName
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case azMode = "azMode"
            case createdTimestamp = "createdTimestamp"
            case description = "description"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case status = "status"
            case statusReason = "statusReason"
            case volumeName = "volumeName"
            case volumeType = "volumeType"
        }
    }

    public struct ListEnvironmentsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token generated by FinSpace that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the nextTokennextToken value from the response object of the previous page call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentsResponse: AWSDecodableShape {
        /// A list of all of your FinSpace environments.
        public let environments: [Environment]?
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?

        public init(environments: [Environment]? = nil, nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments = "environments"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxChangesetsRequest: AWSEncodableShape {
        /// The name of the kdb database.
        public let databaseName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(databaseName: String, environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.databaseName = databaseName
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxChangesetsResponse: AWSDecodableShape {
        /// A list of changesets for a database.
        public let kxChangesets: [KxChangesetListEntry]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(kxChangesets: [KxChangesetListEntry]? = nil, nextToken: String? = nil) {
            self.kxChangesets = kxChangesets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kxChangesets = "kxChangesets"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxClusterNodesRequest: AWSEncodableShape {
        /// A unique name for the cluster.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(clusterName: String, environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterName = clusterName
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxClusterNodesResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// A list of nodes associated with the cluster.
        public let nodes: [KxNode]?

        public init(nextToken: String? = nil, nodes: [KxNode]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodes = "nodes"
        }
    }

    public struct ListKxClustersRequest: AWSEncodableShape {
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.   GP – A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.   Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
        public let clusterType: KxClusterType?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(clusterType: KxClusterType? = nil, environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterType = clusterType
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clusterType, key: "clusterType")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxClustersResponse: AWSDecodableShape {
        /// Lists the cluster details.
        public let kxClusterSummaries: [KxCluster]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(kxClusterSummaries: [KxCluster]? = nil, nextToken: String? = nil) {
            self.kxClusterSummaries = kxClusterSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kxClusterSummaries = "kxClusterSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxDatabasesRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxDatabasesResponse: AWSDecodableShape {
        /// A list of databases in the kdb environment.
        public let kxDatabases: [KxDatabaseListEntry]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(kxDatabases: [KxDatabaseListEntry]? = nil, nextToken: String? = nil) {
            self.kxDatabases = kxDatabases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kxDatabases = "kxDatabases"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxDataviewsRequest: AWSEncodableShape {
        /// The name of the database where the dataviews were created.
        public let databaseName: String
        /// A unique identifier for the kdb environment, for which you want to retrieve a list of dataviews.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(databaseName: String, environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.databaseName = databaseName
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxDataviewsResponse: AWSDecodableShape {
        ///  The list of kdb dataviews that are currently active for the given database.
        public let kxDataviews: [KxDataviewListEntry]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(kxDataviews: [KxDataviewListEntry]? = nil, nextToken: String? = nil) {
            self.kxDataviews = kxDataviews
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kxDataviews = "kxDataviews"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxEnvironmentsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxEnvironmentsResponse: AWSDecodableShape {
        /// A list of environments in an account.
        public let environments: [KxEnvironment]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(environments: [KxEnvironment]? = nil, nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments = "environments"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxScalingGroupsRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment, for which you want to retrieve a list of scaling groups.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxScalingGroupsResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// A list of scaling groups available in a kdb environment.
        public let scalingGroups: [KxScalingGroup]?

        public init(nextToken: String? = nil, scalingGroups: [KxScalingGroup]? = nil) {
            self.nextToken = nextToken
            self.scalingGroups = scalingGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scalingGroups = "scalingGroups"
        }
    }

    public struct ListKxUsersRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxUsersResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// A list of users in a kdb environment.
        public let users: [KxUser]?

        public init(nextToken: String? = nil, users: [KxUser]? = nil) {
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case users = "users"
        }
    }

    public struct ListKxVolumesRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment, whose clusters can attach to the volume.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        ///  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public let volumeType: KxVolumeType?

        public init(environmentId: String, maxResults: Int? = nil, nextToken: String? = nil, volumeType: KxVolumeType? = nil) {
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.volumeType = volumeType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.volumeType, key: "volumeType")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxVolumesResponse: AWSDecodableShape {
        /// A summary of volumes.
        public let kxVolumeSummaries: [KxVolume]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(kxVolumeSummaries: [KxVolume]? = nil, nextToken: String? = nil) {
            self.kxVolumeSummaries = kxVolumeSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kxVolumeSummaries = "kxVolumeSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d+:(environment|kxEnvironment)/[0-9A-Za-z_-]{1,128}(/(kxCluster|kxUser|kxVolume|kxScalingGroup)/[a-zA-Z0-9_-]{1,255}|/(kxDatabase/[a-zA-Z0-9_-]{1,255}(/kxDataview/[a-zA-Z0-9_-]{1,255})?))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of all tags for a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct NetworkACLEntry: AWSEncodableShape & AWSDecodableShape {
        ///  The IPv4 network range to allow or deny, in CIDR notation. For example, 172.16.0.0/24. We modify the specified CIDR block to its canonical form. For example, if you specify 100.68.0.18/18, we modify it to 100.68.0.0/18.
        public let cidrBlock: String
        ///  Defines the ICMP protocol that consists of the ICMP type and code.
        public let icmpTypeCode: IcmpTypeCode?
        ///  The range of ports the rule applies to.
        public let portRange: PortRange?
        ///  The protocol number. A value of -1 means all the protocols.
        public let `protocol`: String
        ///  Indicates whether to allow or deny the traffic that matches the rule.
        public let ruleAction: RuleAction
        ///  The rule number for the entry. For example 100. All the network ACL entries are processed in ascending order by rule number.
        public let ruleNumber: Int

        public init(cidrBlock: String, icmpTypeCode: IcmpTypeCode? = nil, portRange: PortRange? = nil, protocol: String, ruleAction: RuleAction, ruleNumber: Int) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.portRange = portRange
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.ruleNumber = ruleNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, max: 18)
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, min: 1)
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "^(?:\\d{1,3}\\.){3}\\d{1,3}(?:\\/(?:3[0-2]|[12]\\d|\\d))$")
            try self.portRange?.validate(name: "\(name).portRange")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, max: 5)
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, min: 1)
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "^-1|[0-9]+$")
            try self.validate(self.ruleNumber, name: "ruleNumber", parent: name, max: 32766)
            try self.validate(self.ruleNumber, name: "ruleNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlock = "cidrBlock"
            case icmpTypeCode = "icmpTypeCode"
            case portRange = "portRange"
            case `protocol` = "protocol"
            case ruleAction = "ruleAction"
            case ruleNumber = "ruleNumber"
        }
    }

    public struct PortRange: AWSEncodableShape & AWSDecodableShape {
        ///  The first port in the range.
        public let from: Int
        ///  The last port in the range.
        public let to: Int

        public init(from: Int, to: Int) {
            self.from = from
            self.to = to
        }

        public func validate(name: String) throws {
            try self.validate(self.from, name: "from", parent: name, max: 65535)
            try self.validate(self.from, name: "from", parent: name, min: 0)
            try self.validate(self.to, name: "to", parent: name, max: 65535)
            try self.validate(self.to, name: "to", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case from = "from"
            case to = "to"
        }
    }

    public struct SuperuserParameters: AWSEncodableShape {
        /// The email address of the superuser.
        public let emailAddress: String
        /// The first name of the superuser.
        public let firstName: String
        /// The last name of the superuser.
        public let lastName: String

        public init(emailAddress: String, firstName: String, lastName: String) {
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
        }

        public func validate(name: String) throws {
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 128)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+[.]+[A-Za-z]+$")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 50)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "^[a-zA-Z0-9]{1,50}$")
            try self.validate(self.lastName, name: "lastName", parent: name, max: 50)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "^[a-zA-Z0-9]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddress = "emailAddress"
            case firstName = "firstName"
            case lastName = "lastName"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the resource.
        public let resourceArn: String
        /// One or more tags to be assigned to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d+:(environment|kxEnvironment)/[0-9A-Za-z_-]{1,128}(/(kxCluster|kxUser|kxVolume|kxScalingGroup)/[a-zA-Z0-9_-]{1,255}|/(kxDatabase/[a-zA-Z0-9_-]{1,255}(/kxDataview/[a-zA-Z0-9_-]{1,255})?))?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TickerplantLogConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the volumes for tickerplant logs.
        public let tickerplantLogVolumes: [String]?

        public init(tickerplantLogVolumes: [String]? = nil) {
            self.tickerplantLogVolumes = tickerplantLogVolumes
        }

        public func validate(name: String) throws {
            try self.tickerplantLogVolumes?.forEach {
                try validate($0, name: "tickerplantLogVolumes[]", parent: name, max: 63)
                try validate($0, name: "tickerplantLogVolumes[]", parent: name, min: 3)
                try validate($0, name: "tickerplantLogVolumes[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tickerplantLogVolumes = "tickerplantLogVolumes"
        }
    }

    public struct TransitGatewayConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The rules that define how you manage the outbound traffic from kdb network to your internal network.
        public let attachmentNetworkAclConfiguration: [NetworkACLEntry]?
        /// The routing CIDR on behalf of kdb environment. It could be any "/26 range in the 100.64.0.0 CIDR space. After providing, it will be added to the customer's transit gateway routing table so that the traffics could be routed to kdb network.
        public let routableCIDRSpace: String
        /// The identifier of the transit gateway created by the customer to connect outbound traffics from kdb network to your internal network.
        public let transitGatewayID: String

        public init(attachmentNetworkAclConfiguration: [NetworkACLEntry]? = nil, routableCIDRSpace: String, transitGatewayID: String) {
            self.attachmentNetworkAclConfiguration = attachmentNetworkAclConfiguration
            self.routableCIDRSpace = routableCIDRSpace
            self.transitGatewayID = transitGatewayID
        }

        public func validate(name: String) throws {
            try self.attachmentNetworkAclConfiguration?.forEach {
                try $0.validate(name: "\(name).attachmentNetworkAclConfiguration[]")
            }
            try self.validate(self.attachmentNetworkAclConfiguration, name: "attachmentNetworkAclConfiguration", parent: name, max: 100)
            try self.validate(self.attachmentNetworkAclConfiguration, name: "attachmentNetworkAclConfiguration", parent: name, min: 1)
            try self.validate(self.transitGatewayID, name: "transitGatewayID", parent: name, max: 32)
            try self.validate(self.transitGatewayID, name: "transitGatewayID", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentNetworkAclConfiguration = "attachmentNetworkAclConfiguration"
            case routableCIDRSpace = "routableCIDRSpace"
            case transitGatewayID = "transitGatewayID"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// A FinSpace resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
        public let resourceArn: String
        /// The tag keys (names) of one or more tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d+:(environment|kxEnvironment)/[0-9A-Za-z_-]{1,128}(/(kxCluster|kxUser|kxVolume|kxScalingGroup)/[a-zA-Z0-9_-]{1,255}|/(kxDatabase/[a-zA-Z0-9_-]{1,255}(/kxDataview/[a-zA-Z0-9_-]{1,255})?))?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEnvironmentRequest: AWSEncodableShape {
        /// The description of the environment.
        public let description: String?
        /// The identifier of the FinSpace environment.
        public let environmentId: String
        /// Authentication mode for the environment.    FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.    LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
        public let federationMode: FederationMode?
        public let federationParameters: FederationParameters?
        /// The name of the environment.
        public let name: String?

        public init(description: String? = nil, environmentId: String, federationMode: FederationMode? = nil, federationParameters: FederationParameters? = nil, name: String? = nil) {
            self.description = description
            self.environmentId = environmentId
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.federationMode, forKey: .federationMode)
            try container.encodeIfPresent(self.federationParameters, forKey: .federationParameters)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.federationParameters?.validate(name: "\(name).federationParameters")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case federationMode = "federationMode"
            case federationParameters = "federationParameters"
            case name = "name"
        }
    }

    public struct UpdateEnvironmentResponse: AWSDecodableShape {
        /// Returns the FinSpace environment object.
        public let environment: Environment?

        public init(environment: Environment? = nil) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct UpdateKxClusterCodeConfigurationRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The name of the cluster.
        public let clusterName: String
        public let code: CodeConfiguration
        /// Specifies the key-value pairs to make them available inside the cluster. You cannot update this parameter for a NO_RESTART deployment.
        public let commandLineArguments: [KxCommandLineArgument]?
        ///  The configuration that allows you to choose how you want to update the code on a cluster.
        public let deploymentConfiguration: KxClusterCodeDeploymentConfiguration?
        ///  A unique identifier of the kdb environment.
        public let environmentId: String
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q. You cannot update this parameter for a NO_RESTART deployment.
        public let initializationScript: String?

        public init(clientToken: String? = UpdateKxClusterCodeConfigurationRequest.idempotencyToken(), clusterName: String, code: CodeConfiguration, commandLineArguments: [KxCommandLineArgument]? = nil, deploymentConfiguration: KxClusterCodeDeploymentConfiguration? = nil, environmentId: String, initializationScript: String? = nil) {
            self.clientToken = clientToken
            self.clusterName = clusterName
            self.code = code
            self.commandLineArguments = commandLineArguments
            self.deploymentConfiguration = deploymentConfiguration
            self.environmentId = environmentId
            self.initializationScript = initializationScript
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.clusterName, key: "clusterName")
            try container.encode(self.code, forKey: .code)
            try container.encodeIfPresent(self.commandLineArguments, forKey: .commandLineArguments)
            try container.encodeIfPresent(self.deploymentConfiguration, forKey: .deploymentConfiguration)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.initializationScript, forKey: .initializationScript)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.code.validate(name: "\(name).code")
            try self.commandLineArguments?.forEach {
                try $0.validate(name: "\(name).commandLineArguments[]")
            }
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, max: 255)
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, min: 1)
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, pattern: "^[a-zA-Z0-9\\_\\-\\.\\/\\\\]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case code = "code"
            case commandLineArguments = "commandLineArguments"
            case deploymentConfiguration = "deploymentConfiguration"
            case initializationScript = "initializationScript"
        }
    }

    public struct UpdateKxClusterCodeConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateKxClusterDatabasesRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique name for the cluster that you want to modify.
        public let clusterName: String
        ///  The structure of databases mounted on the cluster.
        public let databases: [KxDatabaseConfiguration]
        ///  The configuration that allows you to choose how you want to update the databases on a cluster.
        public let deploymentConfiguration: KxDeploymentConfiguration?
        /// The unique identifier of a kdb environment.
        public let environmentId: String

        public init(clientToken: String? = UpdateKxClusterDatabasesRequest.idempotencyToken(), clusterName: String, databases: [KxDatabaseConfiguration], deploymentConfiguration: KxDeploymentConfiguration? = nil, environmentId: String) {
            self.clientToken = clientToken
            self.clusterName = clusterName
            self.databases = databases
            self.deploymentConfiguration = deploymentConfiguration
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.clusterName, key: "clusterName")
            try container.encode(self.databases, forKey: .databases)
            try container.encodeIfPresent(self.deploymentConfiguration, forKey: .deploymentConfiguration)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.databases.forEach {
                try $0.validate(name: "\(name).databases[]")
            }
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case databases = "databases"
            case deploymentConfiguration = "deploymentConfiguration"
        }
    }

    public struct UpdateKxClusterDatabasesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateKxDatabaseRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the kdb database.
        public let databaseName: String
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clientToken: String = UpdateKxDatabaseRequest.idempotencyToken(), databaseName: String, description: String? = nil, environmentId: String) {
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.databaseName, key: "databaseName")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct UpdateKxDatabaseResponse: AWSDecodableShape {
        /// The name of the kdb database.
        public let databaseName: String?
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?

        public init(databaseName: String? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil) {
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
        }
    }

    public struct UpdateKxDataviewRequest: AWSEncodableShape {
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the database.
        public let databaseName: String
        /// The name of the dataview that you want to update.
        public let dataviewName: String
        ///  The description for a dataview.
        public let description: String?
        /// A unique identifier for the kdb environment, where you want to update the dataview.
        public let environmentId: String
        ///  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public let segmentConfigurations: [KxDataviewSegmentConfiguration]?

        public init(changesetId: String? = nil, clientToken: String = UpdateKxDataviewRequest.idempotencyToken(), databaseName: String, dataviewName: String, description: String? = nil, environmentId: String, segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil) {
            self.changesetId = changesetId
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.description = description
            self.environmentId = environmentId
            self.segmentConfigurations = segmentConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.changesetId, forKey: .changesetId)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.dataviewName, key: "dataviewName")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.segmentConfigurations, forKey: .segmentConfigurations)
        }

        public func validate(name: String) throws {
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.changesetId, name: "changesetId", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, max: 63)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, min: 3)
            try self.validate(self.dataviewName, name: "dataviewName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.segmentConfigurations?.forEach {
                try $0.validate(name: "\(name).segmentConfigurations[]")
            }
            try self.validate(self.segmentConfigurations, name: "segmentConfigurations", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case changesetId = "changesetId"
            case clientToken = "clientToken"
            case description = "description"
            case segmentConfigurations = "segmentConfigurations"
        }
    }

    public struct UpdateKxDataviewResponse: AWSDecodableShape {
        ///  The current active changeset versions of the database on the given dataview.
        public let activeVersions: [KxDataviewActiveVersion]?
        /// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when new changesets are ingested. The default value is false.
        public let autoUpdate: Bool?
        ///  The identifier of the availability zones.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        ///  The timestamp at which the dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the database.
        public let databaseName: String?
        ///  The name of the database under which the dataview was created.
        public let dataviewName: String?
        /// A description of the dataview.
        public let description: String?
        /// A unique identifier for the kdb environment, where you want to update the dataview.
        public let environmentId: String?
        ///  The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// Returns True if the dataview is created as writeable and False otherwise.
        public let readWrite: Bool?
        ///  The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.
        public let segmentConfigurations: [KxDataviewSegmentConfiguration]?
        ///  The status of dataview creation.    CREATING – The dataview creation is in progress.    UPDATING – The dataview is in the process of being updated.    ACTIVE – The dataview is active.
        public let status: KxDataviewStatus?

        public init(activeVersions: [KxDataviewActiveVersion]? = nil, autoUpdate: Bool? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, databaseName: String? = nil, dataviewName: String? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil, readWrite: Bool? = nil, segmentConfigurations: [KxDataviewSegmentConfiguration]? = nil, status: KxDataviewStatus? = nil) {
            self.activeVersions = activeVersions
            self.autoUpdate = autoUpdate
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.dataviewName = dataviewName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.readWrite = readWrite
            self.segmentConfigurations = segmentConfigurations
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case activeVersions = "activeVersions"
            case autoUpdate = "autoUpdate"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case dataviewName = "dataviewName"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case readWrite = "readWrite"
            case segmentConfigurations = "segmentConfigurations"
            case status = "status"
        }
    }

    public struct UpdateKxEnvironmentNetworkRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
        public let transitGatewayConfiguration: TransitGatewayConfiguration?

        public init(clientToken: String? = UpdateKxEnvironmentNetworkRequest.idempotencyToken(), customDNSConfiguration: [CustomDNSServer]? = nil, environmentId: String, transitGatewayConfiguration: TransitGatewayConfiguration? = nil) {
            self.clientToken = clientToken
            self.customDNSConfiguration = customDNSConfiguration
            self.environmentId = environmentId
            self.transitGatewayConfiguration = transitGatewayConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.customDNSConfiguration, forKey: .customDNSConfiguration)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.transitGatewayConfiguration, forKey: .transitGatewayConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.customDNSConfiguration?.forEach {
                try $0.validate(name: "\(name).customDNSConfiguration[]")
            }
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.transitGatewayConfiguration?.validate(name: "\(name).transitGatewayConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customDNSConfiguration = "customDNSConfiguration"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
        }
    }

    public struct UpdateKxEnvironmentNetworkResponse: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneIds: [String]?
        /// The unique identifier of the AWS account that is used to create the kdb environment.
        public let awsAccountId: String?
        /// The timestamp at which the kdb environment was created in FinSpace.
        public let creationTimestamp: Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public let dedicatedServiceAccountId: String?
        /// The description of the environment.
        public let description: String?
        /// The status of DNS configuration.
        public let dnsStatus: DnsStatus?
        /// The ARN identifier of the environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the kdb environment.
        public let status: EnvironmentStatus?
        /// The status of the network configuration.
        public let tgwStatus: TgwStatus?
        public let transitGatewayConfiguration: TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was updated.
        public let updateTimestamp: Date?

        public init(availabilityZoneIds: [String]? = nil, awsAccountId: String? = nil, creationTimestamp: Date? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, dnsStatus: DnsStatus? = nil, environmentArn: String? = nil, environmentId: String? = nil, errorMessage: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil, tgwStatus: TgwStatus? = nil, transitGatewayConfiguration: TransitGatewayConfiguration? = nil, updateTimestamp: Date? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case awsAccountId = "awsAccountId"
            case creationTimestamp = "creationTimestamp"
            case customDNSConfiguration = "customDNSConfiguration"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case dnsStatus = "dnsStatus"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
            case tgwStatus = "tgwStatus"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
            case updateTimestamp = "updateTimestamp"
        }
    }

    public struct UpdateKxEnvironmentRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description of the kdb environment.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The name of the kdb environment.
        public let name: String?

        public init(clientToken: String? = UpdateKxEnvironmentRequest.idempotencyToken(), description: String? = nil, environmentId: String, name: String? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.environmentId = environmentId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateKxEnvironmentResponse: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneIds: [String]?
        /// The unique identifier of the AWS account that is used to create the kdb environment.
        public let awsAccountId: String?
        /// The timestamp at which the kdb environment was created in FinSpace.
        public let creationTimestamp: Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public let dedicatedServiceAccountId: String?
        /// The description of the environment.
        public let description: String?
        /// The status of DNS configuration.
        public let dnsStatus: DnsStatus?
        /// The ARN identifier of the environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the kdb environment.
        public let status: EnvironmentStatus?
        /// The status of the network configuration.
        public let tgwStatus: TgwStatus?
        public let transitGatewayConfiguration: TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was updated.
        public let updateTimestamp: Date?

        public init(availabilityZoneIds: [String]? = nil, awsAccountId: String? = nil, creationTimestamp: Date? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, dnsStatus: DnsStatus? = nil, environmentArn: String? = nil, environmentId: String? = nil, errorMessage: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil, tgwStatus: TgwStatus? = nil, transitGatewayConfiguration: TransitGatewayConfiguration? = nil, updateTimestamp: Date? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case awsAccountId = "awsAccountId"
            case creationTimestamp = "creationTimestamp"
            case customDNSConfiguration = "customDNSConfiguration"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case dnsStatus = "dnsStatus"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
            case tgwStatus = "tgwStatus"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
            case updateTimestamp = "updateTimestamp"
        }
    }

    public struct UpdateKxUserRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The IAM role ARN that is associated with the user.
        public let iamRole: String
        /// A unique identifier for the user.
        public let userName: String

        public init(clientToken: String? = UpdateKxUserRequest.idempotencyToken(), environmentId: String, iamRole: String, userName: String) {
            self.clientToken = clientToken
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encode(self.iamRole, forKey: .iamRole)
            request.encodePath(self.userName, key: "userName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.iamRole, name: "iamRole", parent: name, max: 2048)
            try self.validate(self.iamRole, name: "iamRole", parent: name, min: 20)
            try self.validate(self.iamRole, name: "iamRole", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.userName, name: "userName", parent: name, max: 50)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[0-9A-Za-z_-]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case iamRole = "iamRole"
        }
    }

    public struct UpdateKxUserResponse: AWSDecodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The IAM role ARN that is associated with the user.
        public let iamRole: String?
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String?
        /// A unique identifier for the user.
        public let userName: String?

        public init(environmentId: String? = nil, iamRole: String? = nil, userArn: String? = nil, userName: String? = nil) {
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.userArn = userArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case iamRole = "iamRole"
            case userArn = "userArn"
            case userName = "userName"
        }
    }

    public struct UpdateKxVolumeRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description of the volume.
        public let description: String?
        /// A unique identifier for the kdb environment where you created the storage volume.
        public let environmentId: String
        ///  Specifies the configuration for the Network attached storage (NAS_1) file system volume.
        public let nas1Configuration: KxNAS1Configuration?
        /// A unique identifier for the volume.
        public let volumeName: String

        public init(clientToken: String? = UpdateKxVolumeRequest.idempotencyToken(), description: String? = nil, environmentId: String, nas1Configuration: KxNAS1Configuration? = nil, volumeName: String) {
            self.clientToken = clientToken
            self.description = description
            self.environmentId = environmentId
            self.nas1Configuration = nas1Configuration
            self.volumeName = volumeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.nas1Configuration, forKey: .nas1Configuration)
            request.encodePath(self.volumeName, key: "volumeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.nas1Configuration?.validate(name: "\(name).nas1Configuration")
            try self.validate(self.volumeName, name: "volumeName", parent: name, max: 63)
            try self.validate(self.volumeName, name: "volumeName", parent: name, min: 3)
            try self.validate(self.volumeName, name: "volumeName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case nas1Configuration = "nas1Configuration"
        }
    }

    public struct UpdateKxVolumeResponse: AWSDecodableShape {
        /// Specifies the clusters that a volume is attached to.
        public let attachedClusters: [KxAttachedCluster]?
        /// The identifier of the availability zones.
        public let availabilityZoneIds: [String]?
        /// The number of availability zones you want to assign per volume. Currently, FinSpace only supports SINGLE for volumes. This places dataview in a single AZ.
        public let azMode: KxAzMode?
        /// The timestamp at which the volume was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The description for the volume.
        public let description: String?
        /// A unique identifier for the kdb environment where you want to update the volume.
        public let environmentId: String?
        /// The last time that the volume was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        ///  Specifies the configuration for the Network attached storage (NAS_1) file system volume.
        public let nas1Configuration: KxNAS1Configuration?
        /// The status of the volume.   CREATING – The volume creation is in progress.   CREATE_FAILED – The volume creation has failed.   ACTIVE – The volume is active.   UPDATING – The volume is in the process of being updated.   UPDATE_FAILED – The update action failed.   UPDATED – The volume is successfully updated.   DELETING – The volume is in the process of being deleted.   DELETE_FAILED – The system failed to delete the volume.   DELETED – The volume is successfully deleted.
        public let status: KxVolumeStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        /// The ARN identifier of the volume.
        public let volumeArn: String?
        /// A unique identifier for the volume that you want to update.
        public let volumeName: String?
        ///  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public let volumeType: KxVolumeType?

        public init(attachedClusters: [KxAttachedCluster]? = nil, availabilityZoneIds: [String]? = nil, azMode: KxAzMode? = nil, createdTimestamp: Date? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil, nas1Configuration: KxNAS1Configuration? = nil, status: KxVolumeStatus? = nil, statusReason: String? = nil, volumeArn: String? = nil, volumeName: String? = nil, volumeType: KxVolumeType? = nil) {
            self.attachedClusters = attachedClusters
            self.availabilityZoneIds = availabilityZoneIds
            self.azMode = azMode
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.nas1Configuration = nas1Configuration
            self.status = status
            self.statusReason = statusReason
            self.volumeArn = volumeArn
            self.volumeName = volumeName
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case attachedClusters = "attachedClusters"
            case availabilityZoneIds = "availabilityZoneIds"
            case azMode = "azMode"
            case createdTimestamp = "createdTimestamp"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case nas1Configuration = "nas1Configuration"
            case status = "status"
            case statusReason = "statusReason"
            case volumeArn = "volumeArn"
            case volumeName = "volumeName"
            case volumeType = "volumeType"
        }
    }

    public struct Volume: AWSDecodableShape {
        /// A unique identifier for the volume.
        public let volumeName: String?
        ///  The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.
        public let volumeType: VolumeType?

        public init(volumeName: String? = nil, volumeType: VolumeType? = nil) {
            self.volumeName = volumeName
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case volumeName = "volumeName"
            case volumeType = "volumeType"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The IP address type for cluster network configuration parameters. The following type is available:   IP_V4 – IP address version 4
        public let ipAddressType: IPAddressType?
        /// The  unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster.
        public let securityGroupIds: [String]?
        /// The identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster.
        public let subnetIds: [String]?
        /// The identifier of the VPC endpoint.
        public let vpcId: String?

        public init(ipAddressType: IPAddressType? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.ipAddressType = ipAddressType
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-([a-z0-9]{8}$|[a-z0-9]{17}$)$")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 1024)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-([a-z0-9]{8}$|[a-z0-9]{17}$)$")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 1024)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-([a-z0-9]{8}$|[a-z0-9]{17}$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressType = "ipAddressType"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }
}

// MARK: - Errors

/// Error enum for Finspace
public struct FinspaceErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Finspace
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was a conflict with this action, and it could not be completed.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request is invalid. Something is wrong with the input to the request.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// A service limit or quota is exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The specified resource group already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// One or more resources can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  You have exceeded your service quota. To perform the requested action,  remove some of the relevant resources, or use Service Quotas to request a service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension FinspaceErrorType: Equatable {
    public static func == (lhs: FinspaceErrorType, rhs: FinspaceErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension FinspaceErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
