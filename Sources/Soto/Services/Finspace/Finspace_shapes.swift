//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Finspace {
    // MARK: Enums

    public enum AutoScalingMetric: String, CustomStringConvertible, Codable, Sendable {
        case cpuUtilizationPercentage = "CPU_UTILIZATION_PERCENTAGE"
        public var description: String { return self.rawValue }
    }

    public enum ChangeType: String, CustomStringConvertible, Codable, Sendable {
        case delete = "DELETE"
        case put = "PUT"
        public var description: String { return self.rawValue }
    }

    public enum ChangesetStatus: String, CustomStringConvertible, Codable, Sendable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum DnsStatus: String, CustomStringConvertible, Codable, Sendable {
        case failedUpdate = "FAILED_UPDATE"
        case none = "NONE"
        case successfullyUpdated = "SUCCESSFULLY_UPDATED"
        case updateRequested = "UPDATE_REQUESTED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentStatus: String, CustomStringConvertible, Codable, Sendable {
        case createRequested = "CREATE_REQUESTED"
        case created = "CREATED"
        case creating = "CREATING"
        case deleteRequested = "DELETE_REQUESTED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failedCreation = "FAILED_CREATION"
        case failedDeletion = "FAILED_DELETION"
        case failedUpdatingNetwork = "FAILED_UPDATING_NETWORK"
        case retryDeletion = "RETRY_DELETION"
        case suspended = "SUSPENDED"
        case updateNetworkRequested = "UPDATE_NETWORK_REQUESTED"
        case updatingNetwork = "UPDATING_NETWORK"
        public var description: String { return self.rawValue }
    }

    public enum ErrorDetails: String, CustomStringConvertible, Codable, Sendable {
        case accessDenied = "Missing required permission to perform this request."
        case cancelled = "Cancelled"
        case internalServiceException = "An internal error has occurred."
        case resourceNotFound = "One or more inputs to this request were not found."
        case serviceQuotaExceeded = "Service limits have been exceeded."
        case throttling = "The system temporarily lacks sufficient resources to process the request."
        case userRecoverable = "A user recoverable error has occurred"
        case validation = "The inputs to this request are invalid."
        public var description: String { return self.rawValue }
    }

    public enum FederationMode: String, CustomStringConvertible, Codable, Sendable {
        case federated = "FEDERATED"
        case local = "LOCAL"
        public var description: String { return self.rawValue }
    }

    public enum IPAddressType: String, CustomStringConvertible, Codable, Sendable {
        case ipV4 = "IP_V4"
        public var description: String { return self.rawValue }
    }

    public enum KxAzMode: String, CustomStringConvertible, Codable, Sendable {
        case multi = "MULTI"
        case single = "SINGLE"
        public var description: String { return self.rawValue }
    }

    public enum KxClusterStatus: String, CustomStringConvertible, Codable, Sendable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        case running = "RUNNING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KxClusterType: String, CustomStringConvertible, Codable, Sendable {
        case gateway = "GATEWAY"
        case hdb = "HDB"
        case rdb = "RDB"
        public var description: String { return self.rawValue }
    }

    public enum KxSavedownStorageType: String, CustomStringConvertible, Codable, Sendable {
        case sds01 = "SDS01"
        public var description: String { return self.rawValue }
    }

    public enum TgwStatus: String, CustomStringConvertible, Codable, Sendable {
        case failedUpdate = "FAILED_UPDATE"
        case none = "NONE"
        case successfullyUpdated = "SUCCESSFULLY_UPDATED"
        case updateRequested = "UPDATE_REQUESTED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AutoScalingConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all the nodes in a cluster.
        public let autoScalingMetric: AutoScalingMetric?
        /// The highest number of nodes to scale. This value cannot be greater than 5.
        public let maxNodeCount: Int?
        /// The desired value of the chosen autoScalingMetric. When the metric drops below this value, the cluster will scale in. When the metric goes above this value, the cluster will scale out. You can set the target value between 1 and 100 percent.
        public let metricTarget: Double?
        /// The lowest number of nodes to scale. This value must be at least 1 and less than the maxNodeCount. If the nodes in a cluster belong to multiple availability zones, then minNodeCount must be at least 3.
        public let minNodeCount: Int?
        /// The duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event.
        public let scaleInCooldownSeconds: Double?
        /// The duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.
        public let scaleOutCooldownSeconds: Double?

        public init(autoScalingMetric: AutoScalingMetric? = nil, maxNodeCount: Int? = nil, metricTarget: Double? = nil, minNodeCount: Int? = nil, scaleInCooldownSeconds: Double? = nil, scaleOutCooldownSeconds: Double? = nil) {
            self.autoScalingMetric = autoScalingMetric
            self.maxNodeCount = maxNodeCount
            self.metricTarget = metricTarget
            self.minNodeCount = minNodeCount
            self.scaleInCooldownSeconds = scaleInCooldownSeconds
            self.scaleOutCooldownSeconds = scaleOutCooldownSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.maxNodeCount, name: "maxNodeCount", parent: name, max: 5)
            try self.validate(self.maxNodeCount, name: "maxNodeCount", parent: name, min: 1)
            try self.validate(self.metricTarget, name: "metricTarget", parent: name, max: 100.0)
            try self.validate(self.metricTarget, name: "metricTarget", parent: name, min: 1.0)
            try self.validate(self.minNodeCount, name: "minNodeCount", parent: name, max: 5)
            try self.validate(self.minNodeCount, name: "minNodeCount", parent: name, min: 1)
            try self.validate(self.scaleInCooldownSeconds, name: "scaleInCooldownSeconds", parent: name, max: 100000.0)
            try self.validate(self.scaleInCooldownSeconds, name: "scaleInCooldownSeconds", parent: name, min: 0.0)
            try self.validate(self.scaleOutCooldownSeconds, name: "scaleOutCooldownSeconds", parent: name, max: 100000.0)
            try self.validate(self.scaleOutCooldownSeconds, name: "scaleOutCooldownSeconds", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingMetric = "autoScalingMetric"
            case maxNodeCount = "maxNodeCount"
            case metricTarget = "metricTarget"
            case minNodeCount = "minNodeCount"
            case scaleInCooldownSeconds = "scaleInCooldownSeconds"
            case scaleOutCooldownSeconds = "scaleOutCooldownSeconds"
        }
    }

    public struct CapacityConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances running in a cluster.
        public let nodeCount: Int?
        /// The type that determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance. You can only specify one of the following values:    kx.s.large – The node type with a configuration of 12 GiB memory and 2 vCPUs.    kx.s.xlarge – The node type with a configuration of 27 GiB memory and 4 vCPUs.    kx.s.2xlarge – The node type with a configuration of 54 GiB memory and 8 vCPUs.    kx.s.4xlarge – The node type with a configuration of 108 GiB memory and 16 vCPUs.    kx.s.8xlarge – The node type with a configuration of 216 GiB memory and 32 vCPUs.    kx.s.16xlarge – The node type with a configuration of 432 GiB memory and 64 vCPUs.    kx.s.32xlarge – The node type with a configuration of 864 GiB memory and 128 vCPUs.
        public let nodeType: String?

        public init(nodeCount: Int? = nil, nodeType: String? = nil) {
            self.nodeCount = nodeCount
            self.nodeType = nodeType
        }

        public func validate(name: String) throws {
            try self.validate(self.nodeCount, name: "nodeCount", parent: name, max: 5)
            try self.validate(self.nodeCount, name: "nodeCount", parent: name, min: 1)
            try self.validate(self.nodeType, name: "nodeType", parent: name, max: 32)
            try self.validate(self.nodeType, name: "nodeType", parent: name, min: 1)
            try self.validate(self.nodeType, name: "nodeType", parent: name, pattern: "^[a-zA-Z0-9._]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case nodeCount = "nodeCount"
            case nodeType = "nodeType"
        }
    }

    public struct ChangeRequest: AWSEncodableShape & AWSDecodableShape {
        /// Defines the type of change request. A changeType can have the following values:   PUT – Adds or updates files in a database.   DELETE – Deletes files in a database.
        public let changeType: ChangeType
        /// Defines the path within the database directory.
        public let dbPath: String
        /// Defines the S3 path of the source file that is required to add or update files in a database.
        public let s3Path: String?

        public init(changeType: ChangeType, dbPath: String, s3Path: String? = nil) {
            self.changeType = changeType
            self.dbPath = dbPath
            self.s3Path = s3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.dbPath, name: "dbPath", parent: name, max: 1025)
            try self.validate(self.dbPath, name: "dbPath", parent: name, min: 1)
            try self.validate(self.dbPath, name: "dbPath", parent: name, pattern: "^\\/([^\\/]+\\/){0,2}[^\\/]*$")
            try self.validate(self.s3Path, name: "s3Path", parent: name, max: 1093)
            try self.validate(self.s3Path, name: "s3Path", parent: name, min: 9)
            try self.validate(self.s3Path, name: "s3Path", parent: name, pattern: "^s3:\\/\\/[a-z0-9][a-z0-9-]{1,61}[a-z0-9]\\/([^\\/]+\\/)*[^\\/]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case changeType = "changeType"
            case dbPath = "dbPath"
            case s3Path = "s3Path"
        }
    }

    public struct CodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A unique name for the S3 bucket.
        public let s3Bucket: String?
        /// The full S3 path (excluding bucket) to the .zip file. This file contains the code that is loaded onto the cluster when it's started.
        public let s3Key: String?
        /// The version of an S3 object.
        public let s3ObjectVersion: String?

        public init(s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 255)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: "^[a-zA-Z0-9\\/\\!\\-_\\.\\*'\\(\\)]+$")
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, max: 1000)
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
            case s3Key = "s3Key"
            case s3ObjectVersion = "s3ObjectVersion"
        }
    }

    public struct CreateEnvironmentRequest: AWSEncodableShape {
        /// The list of Amazon Resource Names (ARN) of the data bundles to install. Currently supported data bundle ARNs:    arn:aws:finspace:${Region}::data-bundle/capital-markets-sample - Contains sample Capital Markets datasets, categories and controlled vocabularies.    arn:aws:finspace:${Region}::data-bundle/taq (default) - Contains trades and quotes data in addition to sample Capital Markets data.
        public let dataBundles: [String]?
        /// The description of the FinSpace environment to be created.
        public let description: String?
        /// Authentication mode for the environment.    FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.    LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
        public let federationMode: FederationMode?
        /// Configuration information when authentication mode is FEDERATED.
        public let federationParameters: FederationParameters?
        /// The KMS key id to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the FinSpace environment to be created.
        public let name: String
        /// Configuration information for the superuser.
        public let superuserParameters: SuperuserParameters?
        /// Add tags to your FinSpace environment.
        public let tags: [String: String]?

        public init(dataBundles: [String]? = nil, description: String? = nil, federationMode: FederationMode? = nil, federationParameters: FederationParameters? = nil, kmsKeyId: String? = nil, name: String, superuserParameters: SuperuserParameters? = nil, tags: [String: String]? = nil) {
            self.dataBundles = dataBundles
            self.description = description
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.superuserParameters = superuserParameters
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.dataBundles?.forEach {
                try validate($0, name: "dataBundles[]", parent: name, max: 2048)
                try validate($0, name: "dataBundles[]", parent: name, min: 20)
                try validate($0, name: "dataBundles[]", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d*:data-bundle/[0-9A-Za-z_-]{1,128}$")
            }
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.federationParameters?.validate(name: "\(name).federationParameters")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1000)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[a-zA-Z-0-9-:\\/]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$")
            try self.superuserParameters?.validate(name: "\(name).superuserParameters")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataBundles = "dataBundles"
            case description = "description"
            case federationMode = "federationMode"
            case federationParameters = "federationParameters"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case superuserParameters = "superuserParameters"
            case tags = "tags"
        }
    }

    public struct CreateEnvironmentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the FinSpace environment that you created.
        public let environmentArn: String?
        /// The unique identifier for FinSpace environment that you created.
        public let environmentId: String?
        /// The sign-in URL for the web application of the FinSpace environment you created.
        public let environmentUrl: String?

        public init(environmentArn: String? = nil, environmentId: String? = nil, environmentUrl: String? = nil) {
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentUrl = environmentUrl
        }

        private enum CodingKeys: String, CodingKey {
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case environmentUrl = "environmentUrl"
        }
    }

    public struct CreateKxChangesetRequest: AWSEncodableShape {
        /// A list of change request objects that are run in order. A change request object consists of  changeType , s3Path, and  a dbPath.  A changeType can has the following values:    PUT – Adds or updates files in a database.   DELETE – Deletes files in a database.   All the change requests require a mandatory dbPath attribute that defines the path within the database directory. The s3Path attribute defines the s3 source file path and is required for a PUT change type. Here is an example of how you can use the change request object:  [ { "changeType": "PUT", "s3Path":"s3://bucket/db/2020.01.02/", "dbPath":"/2020.01.02/"},  { "changeType": "PUT", "s3Path":"s3://bucket/db/sym", "dbPath":"/"},  { "changeType": "DELETE", "dbPath": "/2020.01.01/"} ]  In this example, the first request with PUT change type allows you to add files in the given s3Path under the 2020.01.02 partition of the database. The second request with PUT change type allows you to add a single sym file at database root location. The last request with DELETE change type allows you to delete the files under the 2020.01.01 partition of the database.
        public let changeRequests: [ChangeRequest]
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the kdb database.
        public let databaseName: String
        /// A unique identifier of the kdb environment.
        public let environmentId: String

        public init(changeRequests: [ChangeRequest], clientToken: String = CreateKxChangesetRequest.idempotencyToken(), databaseName: String, environmentId: String) {
            self.changeRequests = changeRequests
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.changeRequests, forKey: .changeRequests)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.changeRequests.forEach {
                try $0.validate(name: "\(name).changeRequests[]")
            }
            try self.validate(self.changeRequests, name: "changeRequests", parent: name, max: 32)
            try self.validate(self.changeRequests, name: "changeRequests", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case changeRequests = "changeRequests"
            case clientToken = "clientToken"
        }
    }

    public struct CreateKxChangesetResponse: AWSDecodableShape {
        /// A list of change requests.
        public let changeRequests: [ChangeRequest]?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the kdb database.
        public let databaseName: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The details of the error that you receive when creating a changeset. It consists of the type of error and the error message.
        public let errorInfo: ErrorInfo?
        /// The timestamp at which the changeset was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// Status of the changeset creation process.   Pending – Changeset creation is pending.   Processing – Changeset creation is running.   Failed – Changeset creation has failed.   Complete – Changeset creation has succeeded.
        public let status: ChangesetStatus?

        public init(changeRequests: [ChangeRequest]? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, databaseName: String? = nil, environmentId: String? = nil, errorInfo: ErrorInfo? = nil, lastModifiedTimestamp: Date? = nil, status: ChangesetStatus? = nil) {
            self.changeRequests = changeRequests
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.environmentId = environmentId
            self.errorInfo = errorInfo
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case changeRequests = "changeRequests"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case environmentId = "environmentId"
            case errorInfo = "errorInfo"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case status = "status"
        }
    }

    public struct CreateKxClusterRequest: AWSEncodableShape {
        /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
        public let autoScalingConfiguration: AutoScalingConfiguration?
        /// The availability zone identifiers for the requested regions.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per cluster. This can be one of the following     SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
        public let azMode: KxAzMode
        /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
        public let cacheStorageConfigurations: [KxCacheStorageConfiguration]?
        /// A structure for the metadata of a cluster. It includes information about like the CPUs needed, memory of instances, number of instances, and the port used while establishing a connection.
        public let capacityConfiguration: CapacityConfiguration
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description of the cluster.
        public let clusterDescription: String?
        /// A unique name for the cluster that you want to create.
        public let clusterName: String
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.
        public let clusterType: KxClusterType
        /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
        public let code: CodeConfiguration?
        /// Defines the key-value pairs to make them available inside the cluster.
        public let commandLineArguments: [KxCommandLineArgument]?
        /// A list of databases that will be available for querying.
        public let databases: [KxDatabaseConfiguration]?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public let executionRole: String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public let initializationScript: String?
        /// The version of FinSpace managed kdb to run.
        public let releaseLabel: String
        /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
        public let savedownStorageConfiguration: KxSavedownStorageConfiguration?
        /// A list of key-value pairs to label the cluster. You can add up to 50 tags to a cluster.
        public let tags: [String: String]?
        /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
        public let vpcConfiguration: VpcConfiguration?

        public init(autoScalingConfiguration: AutoScalingConfiguration? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode, cacheStorageConfigurations: [KxCacheStorageConfiguration]? = nil, capacityConfiguration: CapacityConfiguration, clientToken: String? = CreateKxClusterRequest.idempotencyToken(), clusterDescription: String? = nil, clusterName: String, clusterType: KxClusterType, code: CodeConfiguration? = nil, commandLineArguments: [KxCommandLineArgument]? = nil, databases: [KxDatabaseConfiguration]? = nil, environmentId: String, executionRole: String? = nil, initializationScript: String? = nil, releaseLabel: String, savedownStorageConfiguration: KxSavedownStorageConfiguration? = nil, tags: [String: String]? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.autoScalingConfiguration = autoScalingConfiguration
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.cacheStorageConfigurations = cacheStorageConfigurations
            self.capacityConfiguration = capacityConfiguration
            self.clientToken = clientToken
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.code = code
            self.commandLineArguments = commandLineArguments
            self.databases = databases
            self.environmentId = environmentId
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.releaseLabel = releaseLabel
            self.savedownStorageConfiguration = savedownStorageConfiguration
            self.tags = tags
            self.vpcConfiguration = vpcConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.autoScalingConfiguration, forKey: .autoScalingConfiguration)
            try container.encodeIfPresent(self.availabilityZoneId, forKey: .availabilityZoneId)
            try container.encode(self.azMode, forKey: .azMode)
            try container.encodeIfPresent(self.cacheStorageConfigurations, forKey: .cacheStorageConfigurations)
            try container.encode(self.capacityConfiguration, forKey: .capacityConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.clusterDescription, forKey: .clusterDescription)
            try container.encode(self.clusterName, forKey: .clusterName)
            try container.encode(self.clusterType, forKey: .clusterType)
            try container.encodeIfPresent(self.code, forKey: .code)
            try container.encodeIfPresent(self.commandLineArguments, forKey: .commandLineArguments)
            try container.encodeIfPresent(self.databases, forKey: .databases)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.executionRole, forKey: .executionRole)
            try container.encodeIfPresent(self.initializationScript, forKey: .initializationScript)
            try container.encode(self.releaseLabel, forKey: .releaseLabel)
            try container.encodeIfPresent(self.savedownStorageConfiguration, forKey: .savedownStorageConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.vpcConfiguration, forKey: .vpcConfiguration)
        }

        public func validate(name: String) throws {
            try self.autoScalingConfiguration?.validate(name: "\(name).autoScalingConfiguration")
            try self.cacheStorageConfigurations?.forEach {
                try $0.validate(name: "\(name).cacheStorageConfigurations[]")
            }
            try self.capacityConfiguration.validate(name: "\(name).capacityConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.clusterDescription, name: "clusterDescription", parent: name, max: 1000)
            try self.validate(self.clusterDescription, name: "clusterDescription", parent: name, min: 1)
            try self.validate(self.clusterDescription, name: "clusterDescription", parent: name, pattern: "^[a-zA-Z0-9\\_\\-\\.\\s]+$")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.code?.validate(name: "\(name).code")
            try self.commandLineArguments?.forEach {
                try $0.validate(name: "\(name).commandLineArguments[]")
            }
            try self.databases?.forEach {
                try $0.validate(name: "\(name).databases[]")
            }
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 1024)
            try self.validate(self.executionRole, name: "executionRole", parent: name, min: 1)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^arn:aws[a-z0-9-]*:iam::\\d{12}:role\\/[\\w-\\/.@+=,]{1,1017}$")
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, max: 255)
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, min: 1)
            try self.validate(self.initializationScript, name: "initializationScript", parent: name, pattern: "^[a-zA-Z0-9\\_\\-\\.\\/\\\\]+$")
            try self.validate(self.releaseLabel, name: "releaseLabel", parent: name, max: 16)
            try self.validate(self.releaseLabel, name: "releaseLabel", parent: name, min: 1)
            try self.validate(self.releaseLabel, name: "releaseLabel", parent: name, pattern: "^[a-zA-Z0-9._-]+$")
            try self.savedownStorageConfiguration?.validate(name: "\(name).savedownStorageConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "autoScalingConfiguration"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case cacheStorageConfigurations = "cacheStorageConfigurations"
            case capacityConfiguration = "capacityConfiguration"
            case clientToken = "clientToken"
            case clusterDescription = "clusterDescription"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case code = "code"
            case commandLineArguments = "commandLineArguments"
            case databases = "databases"
            case executionRole = "executionRole"
            case initializationScript = "initializationScript"
            case releaseLabel = "releaseLabel"
            case savedownStorageConfiguration = "savedownStorageConfiguration"
            case tags = "tags"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct CreateKxClusterResponse: AWSDecodableShape {
        /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
        public let autoScalingConfiguration: AutoScalingConfiguration?
        ///  The availability zone identifiers for the requested regions.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per cluster. This can be one of the following     SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
        public let azMode: KxAzMode?
        /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
        public let cacheStorageConfigurations: [KxCacheStorageConfiguration]?
        /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, number of instances, and the port used while establishing a connection.
        public let capacityConfiguration: CapacityConfiguration?
        /// A description of the cluster.
        public let clusterDescription: String?
        /// A unique name for the cluster.
        public let clusterName: String?
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.
        public let clusterType: KxClusterType?
        /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
        public let code: CodeConfiguration?
        /// Defines the key-value pairs to make them available inside the cluster.
        public let commandLineArguments: [KxCommandLineArgument]?
        /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// A list of databases that will be available for querying.
        public let databases: [KxDatabaseConfiguration]?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        ///  An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public let executionRole: String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public let initializationScript: String?
        /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// A version of the FinSpace managed kdb to run.
        public let releaseLabel: String?
        /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
        public let savedownStorageConfiguration: KxSavedownStorageConfiguration?
        /// The status of cluster creation.   PENDING – The cluster is pending creation.   CREATING – The cluster creation process is in progress.   CREATE_FAILED – The cluster creation process has failed.   RUNNING – The cluster creation process is running.   UPDATING – The cluster is in the process of being updated.   DELETING – The cluster is in the process of being deleted.   DELETED – The cluster has been deleted.   DELETE_FAILED – The cluster failed to delete.
        public let status: KxClusterStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
        public let vpcConfiguration: VpcConfiguration?

        public init(autoScalingConfiguration: AutoScalingConfiguration? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, cacheStorageConfigurations: [KxCacheStorageConfiguration]? = nil, capacityConfiguration: CapacityConfiguration? = nil, clusterDescription: String? = nil, clusterName: String? = nil, clusterType: KxClusterType? = nil, code: CodeConfiguration? = nil, commandLineArguments: [KxCommandLineArgument]? = nil, createdTimestamp: Date? = nil, databases: [KxDatabaseConfiguration]? = nil, environmentId: String? = nil, executionRole: String? = nil, initializationScript: String? = nil, lastModifiedTimestamp: Date? = nil, releaseLabel: String? = nil, savedownStorageConfiguration: KxSavedownStorageConfiguration? = nil, status: KxClusterStatus? = nil, statusReason: String? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.autoScalingConfiguration = autoScalingConfiguration
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.cacheStorageConfigurations = cacheStorageConfigurations
            self.capacityConfiguration = capacityConfiguration
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.code = code
            self.commandLineArguments = commandLineArguments
            self.createdTimestamp = createdTimestamp
            self.databases = databases
            self.environmentId = environmentId
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.releaseLabel = releaseLabel
            self.savedownStorageConfiguration = savedownStorageConfiguration
            self.status = status
            self.statusReason = statusReason
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "autoScalingConfiguration"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case cacheStorageConfigurations = "cacheStorageConfigurations"
            case capacityConfiguration = "capacityConfiguration"
            case clusterDescription = "clusterDescription"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case code = "code"
            case commandLineArguments = "commandLineArguments"
            case createdTimestamp = "createdTimestamp"
            case databases = "databases"
            case environmentId = "environmentId"
            case executionRole = "executionRole"
            case initializationScript = "initializationScript"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case releaseLabel = "releaseLabel"
            case savedownStorageConfiguration = "savedownStorageConfiguration"
            case status = "status"
            case statusReason = "statusReason"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct CreateKxDatabaseRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the kdb database.
        public let databaseName: String
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// A list of key-value pairs to label the kdb database. You can add up to 50 tags to your kdb database
        public let tags: [String: String]?

        public init(clientToken: String = CreateKxDatabaseRequest.idempotencyToken(), databaseName: String, description: String? = nil, environmentId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            try container.encode(self.databaseName, forKey: .databaseName)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case databaseName = "databaseName"
            case description = "description"
            case tags = "tags"
        }
    }

    public struct CreateKxDatabaseResponse: AWSDecodableShape {
        /// The timestamp at which the database is created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The ARN identifier of the database.
        public let databaseArn: String?
        /// The name of the kdb database.
        public let databaseName: String?
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The last time that the database was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, databaseArn: String? = nil, databaseName: String? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.databaseArn = databaseArn
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "createdTimestamp"
            case databaseArn = "databaseArn"
            case databaseName = "databaseName"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
        }
    }

    public struct CreateKxEnvironmentRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description for the kdb environment.
        public let description: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String
        /// The name of the kdb environment that you want to create.
        public let name: String
        /// A list of key-value pairs to label the kdb environment. You can add up to 50 tags to your kdb environment.
        public let tags: [String: String]?

        public init(clientToken: String? = nil, description: String? = nil, kmsKeyId: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1000)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^arn:aws:kms:.*:\\d+:.*$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateKxEnvironmentResponse: AWSDecodableShape {
        /// The timestamp at which the kdb environment was created in FinSpace.
        public let creationTimestamp: Date?
        /// A description for the kdb environment.
        public let description: String?
        /// The ARN identifier of the environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the kdb environment.
        public let status: EnvironmentStatus?

        public init(creationTimestamp: Date? = nil, description: String? = nil, environmentArn: String? = nil, environmentId: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil) {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "creationTimestamp"
            case description = "description"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateKxUserRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique identifier for the kdb environment where you want to create a user.
        public let environmentId: String
        /// The IAM role ARN that will be associated with the user.
        public let iamRole: String
        /// A list of key-value pairs to label the user. You can add up to 50 tags to a user.
        public let tags: [String: String]?
        /// A unique identifier for the user.
        public let userName: String

        public init(clientToken: String? = nil, environmentId: String, iamRole: String, tags: [String: String]? = nil, userName: String) {
            self.clientToken = clientToken
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.tags = tags
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encode(self.iamRole, forKey: .iamRole)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.userName, forKey: .userName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.iamRole, name: "iamRole", parent: name, max: 2048)
            try self.validate(self.iamRole, name: "iamRole", parent: name, min: 20)
            try self.validate(self.iamRole, name: "iamRole", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, max: 50)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[0-9A-Za-z_-]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case iamRole = "iamRole"
            case tags = "tags"
            case userName = "userName"
        }
    }

    public struct CreateKxUserResponse: AWSDecodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The IAM role ARN that will be associated with the user.
        public let iamRole: String?
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String?
        /// A unique identifier for the user.
        public let userName: String?

        public init(environmentId: String? = nil, iamRole: String? = nil, userArn: String? = nil, userName: String? = nil) {
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.userArn = userArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case iamRole = "iamRole"
            case userArn = "userArn"
            case userName = "userName"
        }
    }

    public struct CustomDNSServer: AWSEncodableShape & AWSDecodableShape {
        /// The IP address of the DNS server.
        public let customDNSServerIP: String
        /// The name of the DNS server.
        public let customDNSServerName: String

        public init(customDNSServerIP: String, customDNSServerName: String) {
            self.customDNSServerIP = customDNSServerIP
            self.customDNSServerName = customDNSServerName
        }

        public func validate(name: String) throws {
            try self.validate(self.customDNSServerIP, name: "customDNSServerIP", parent: name, pattern: "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$")
            try self.validate(self.customDNSServerName, name: "customDNSServerName", parent: name, max: 255)
            try self.validate(self.customDNSServerName, name: "customDNSServerName", parent: name, min: 3)
            try self.validate(self.customDNSServerName, name: "customDNSServerName", parent: name, pattern: "^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$")
        }

        private enum CodingKeys: String, CodingKey {
            case customDNSServerIP = "customDNSServerIP"
            case customDNSServerName = "customDNSServerName"
        }
    }

    public struct DeleteEnvironmentRequest: AWSEncodableShape {
        /// The identifier for the FinSpace environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxClusterRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The name of the cluster that you want to delete.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clientToken: String? = DeleteKxClusterRequest.idempotencyToken(), clusterName: String, environmentId: String) {
            self.clientToken = clientToken
            self.clusterName = clusterName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxClusterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxDatabaseRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the kdb database that you want to delete.
        public let databaseName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clientToken: String = DeleteKxDatabaseRequest.idempotencyToken(), databaseName: String, environmentId: String) {
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxDatabaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxEnvironmentRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKxUserRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// A unique identifier for the user that you want to delete.
        public let userName: String

        public init(environmentId: String, userName: String) {
            self.environmentId = environmentId
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.userName, key: "userName")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.userName, name: "userName", parent: name, max: 50)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[0-9A-Za-z_-]{1,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKxUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Environment: AWSDecodableShape {
        /// The ID of the AWS account in which the FinSpace environment is created.
        public let awsAccountId: String?
        /// The AWS account ID of the dedicated service account associated with your FinSpace environment.
        public let dedicatedServiceAccountId: String?
        /// The description of the FinSpace environment.
        public let description: String?
        /// The Amazon Resource Name (ARN) of your FinSpace environment.
        public let environmentArn: String?
        /// The identifier of the FinSpace environment.
        public let environmentId: String?
        /// The sign-in URL for the web application of your FinSpace environment.
        public let environmentUrl: String?
        /// The authentication mode for the environment.
        public let federationMode: FederationMode?
        /// Configuration information when authentication mode is FEDERATED.
        public let federationParameters: FederationParameters?
        /// The KMS key id used to encrypt in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the FinSpace environment.
        public let name: String?
        /// The URL of the integrated FinSpace notebook environment in your web application.
        public let sageMakerStudioDomainUrl: String?
        /// The current status of creation of the FinSpace environment.
        public let status: EnvironmentStatus?

        public init(awsAccountId: String? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, environmentArn: String? = nil, environmentId: String? = nil, environmentUrl: String? = nil, federationMode: FederationMode? = nil, federationParameters: FederationParameters? = nil, kmsKeyId: String? = nil, name: String? = nil, sageMakerStudioDomainUrl: String? = nil, status: EnvironmentStatus? = nil) {
            self.awsAccountId = awsAccountId
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentUrl = environmentUrl
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.sageMakerStudioDomainUrl = sageMakerStudioDomainUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case environmentUrl = "environmentUrl"
            case federationMode = "federationMode"
            case federationParameters = "federationParameters"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case sageMakerStudioDomainUrl = "sageMakerStudioDomainUrl"
            case status = "status"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// Specifies the type of error.
        public let errorType: ErrorDetails?

        public init(errorMessage: String? = nil, errorType: ErrorDetails? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case errorType = "errorType"
        }
    }

    public struct FederationParameters: AWSEncodableShape & AWSDecodableShape {
        /// The redirect or sign-in URL that should be entered into the SAML 2.0 compliant identity provider configuration (IdP).
        public let applicationCallBackURL: String?
        /// SAML attribute name and value. The name must always be Email and the value should be set to the attribute definition in which user email is set. For example, name would be Email and value http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress. Please check your SAML 2.0 compliant identity provider (IdP) documentation for details.
        public let attributeMap: [String: String]?
        /// Name of the identity provider (IdP).
        public let federationProviderName: String?
        /// The Uniform Resource Name (URN). Also referred as Service Provider URN or Audience URI or Service Provider Entity ID.
        public let federationURN: String?
        /// SAML 2.0 Metadata document from identity provider (IdP).
        public let samlMetadataDocument: String?
        /// Provide the metadata URL from your SAML 2.0 compliant identity provider (IdP).
        public let samlMetadataURL: String?

        public init(applicationCallBackURL: String? = nil, attributeMap: [String: String]? = nil, federationProviderName: String? = nil, federationURN: String? = nil, samlMetadataDocument: String? = nil, samlMetadataURL: String? = nil) {
            self.applicationCallBackURL = applicationCallBackURL
            self.attributeMap = attributeMap
            self.federationProviderName = federationProviderName
            self.federationURN = federationURN
            self.samlMetadataDocument = samlMetadataDocument
            self.samlMetadataURL = samlMetadataURL
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationCallBackURL, name: "applicationCallBackURL", parent: name, max: 1000)
            try self.validate(self.applicationCallBackURL, name: "applicationCallBackURL", parent: name, min: 1)
            try self.validate(self.applicationCallBackURL, name: "applicationCallBackURL", parent: name, pattern: "^https?://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
            try self.attributeMap?.forEach {
                try validate($0.key, name: "attributeMap.key", parent: name, max: 32)
                try validate($0.key, name: "attributeMap.key", parent: name, min: 1)
                try validate($0.key, name: "attributeMap.key", parent: name, pattern: ".*")
                try validate($0.value, name: "attributeMap[\"\($0.key)\"]", parent: name, max: 1000)
                try validate($0.value, name: "attributeMap[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "attributeMap[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.federationProviderName, name: "federationProviderName", parent: name, max: 32)
            try self.validate(self.federationProviderName, name: "federationProviderName", parent: name, min: 1)
            try self.validate(self.federationProviderName, name: "federationProviderName", parent: name, pattern: "^[^_\\p{Z}][\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}][^_\\p{Z}]+$")
            try self.validate(self.federationURN, name: "federationURN", parent: name, max: 255)
            try self.validate(self.federationURN, name: "federationURN", parent: name, min: 1)
            try self.validate(self.federationURN, name: "federationURN", parent: name, pattern: "^[A-Za-z0-9._\\-:\\/#\\+]+$")
            try self.validate(self.samlMetadataDocument, name: "samlMetadataDocument", parent: name, max: 10000000)
            try self.validate(self.samlMetadataDocument, name: "samlMetadataDocument", parent: name, min: 1000)
            try self.validate(self.samlMetadataDocument, name: "samlMetadataDocument", parent: name, pattern: ".*")
            try self.validate(self.samlMetadataURL, name: "samlMetadataURL", parent: name, max: 1000)
            try self.validate(self.samlMetadataURL, name: "samlMetadataURL", parent: name, min: 1)
            try self.validate(self.samlMetadataURL, name: "samlMetadataURL", parent: name, pattern: "^https?://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCallBackURL = "applicationCallBackURL"
            case attributeMap = "attributeMap"
            case federationProviderName = "federationProviderName"
            case federationURN = "federationURN"
            case samlMetadataDocument = "samlMetadataDocument"
            case samlMetadataURL = "samlMetadataURL"
        }
    }

    public struct GetEnvironmentRequest: AWSEncodableShape {
        /// The identifier of the FinSpace environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentResponse: AWSDecodableShape {
        /// The name of the FinSpace environment.
        public let environment: Environment?

        public init(environment: Environment? = nil) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct GetKxChangesetRequest: AWSEncodableShape {
        /// A unique identifier of the changeset for which you want to retrieve data.
        public let changesetId: String
        /// The name of the kdb database.
        public let databaseName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(changesetId: String, databaseName: String, environmentId: String) {
            self.changesetId = changesetId
            self.databaseName = databaseName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.changesetId, key: "changesetId")
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxChangesetResponse: AWSDecodableShape {
        /// Beginning time from which the changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let activeFromTimestamp: Date?
        /// A list of change request objects that are run in order.
        public let changeRequests: [ChangeRequest]?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the kdb database.
        public let databaseName: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Provides details in the event of a failed flow, including the error type and the related error message.
        public let errorInfo: ErrorInfo?
        /// The timestamp at which the changeset was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// Status of the changeset creation process.   Pending – Changeset creation is pending.   Processing – Changeset creation is running.   Failed – Changeset creation has failed.   Complete – Changeset creation has succeeded.
        public let status: ChangesetStatus?

        public init(activeFromTimestamp: Date? = nil, changeRequests: [ChangeRequest]? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, databaseName: String? = nil, environmentId: String? = nil, errorInfo: ErrorInfo? = nil, lastModifiedTimestamp: Date? = nil, status: ChangesetStatus? = nil) {
            self.activeFromTimestamp = activeFromTimestamp
            self.changeRequests = changeRequests
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.environmentId = environmentId
            self.errorInfo = errorInfo
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case activeFromTimestamp = "activeFromTimestamp"
            case changeRequests = "changeRequests"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case environmentId = "environmentId"
            case errorInfo = "errorInfo"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case status = "status"
        }
    }

    public struct GetKxClusterRequest: AWSEncodableShape {
        /// The name of the cluster that you want to retrieve.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clusterName: String, environmentId: String) {
            self.clusterName = clusterName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxClusterResponse: AWSDecodableShape {
        /// The configuration based on which FinSpace will scale in or scale out nodes in your cluster.
        public let autoScalingConfiguration: AutoScalingConfiguration?
        ///  The availability zone identifiers for the requested regions.
        public let availabilityZoneId: String?
        /// The number of availability zones you want to assign per cluster. This can be one of the following     SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
        public let azMode: KxAzMode?
        /// The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.
        public let cacheStorageConfigurations: [KxCacheStorageConfiguration]?
        /// A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, number of instances, and the port used while establishing a connection.
        public let capacityConfiguration: CapacityConfiguration?
        /// A description of the cluster.
        public let clusterDescription: String?
        /// A unique name for the cluster.
        public let clusterName: String?
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.
        public let clusterType: KxClusterType?
        /// The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster.
        public let code: CodeConfiguration?
        /// Defines key-value pairs to make them available inside the cluster.
        public let commandLineArguments: [KxCommandLineArgument]?
        /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        ///  A list of databases mounted on the cluster.
        public let databases: [KxDatabaseConfiguration]?
        ///  An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public let executionRole: String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public let initializationScript: String?
        /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// The version of FinSpace managed kdb to run.
        public let releaseLabel: String?
        /// The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.
        public let savedownStorageConfiguration: KxSavedownStorageConfiguration?
        /// The status of cluster creation.   PENDING – The cluster is pending creation.   CREATING – The cluster creation process is in progress.   CREATE_FAILED – The cluster creation process has failed.   RUNNING – The cluster creation process is running.   UPDATING – The cluster is in the process of being updated.   DELETING – The cluster is in the process of being deleted.   DELETED – The cluster has been deleted.   DELETE_FAILED – The cluster failed to delete.
        public let status: KxClusterStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?
        /// Configuration details about the network where the Privatelink endpoint of the cluster resides.
        public let vpcConfiguration: VpcConfiguration?

        public init(autoScalingConfiguration: AutoScalingConfiguration? = nil, availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, cacheStorageConfigurations: [KxCacheStorageConfiguration]? = nil, capacityConfiguration: CapacityConfiguration? = nil, clusterDescription: String? = nil, clusterName: String? = nil, clusterType: KxClusterType? = nil, code: CodeConfiguration? = nil, commandLineArguments: [KxCommandLineArgument]? = nil, createdTimestamp: Date? = nil, databases: [KxDatabaseConfiguration]? = nil, executionRole: String? = nil, initializationScript: String? = nil, lastModifiedTimestamp: Date? = nil, releaseLabel: String? = nil, savedownStorageConfiguration: KxSavedownStorageConfiguration? = nil, status: KxClusterStatus? = nil, statusReason: String? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.autoScalingConfiguration = autoScalingConfiguration
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.cacheStorageConfigurations = cacheStorageConfigurations
            self.capacityConfiguration = capacityConfiguration
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.code = code
            self.commandLineArguments = commandLineArguments
            self.createdTimestamp = createdTimestamp
            self.databases = databases
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.releaseLabel = releaseLabel
            self.savedownStorageConfiguration = savedownStorageConfiguration
            self.status = status
            self.statusReason = statusReason
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "autoScalingConfiguration"
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case cacheStorageConfigurations = "cacheStorageConfigurations"
            case capacityConfiguration = "capacityConfiguration"
            case clusterDescription = "clusterDescription"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case code = "code"
            case commandLineArguments = "commandLineArguments"
            case createdTimestamp = "createdTimestamp"
            case databases = "databases"
            case executionRole = "executionRole"
            case initializationScript = "initializationScript"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case releaseLabel = "releaseLabel"
            case savedownStorageConfiguration = "savedownStorageConfiguration"
            case status = "status"
            case statusReason = "statusReason"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct GetKxConnectionStringRequest: AWSEncodableShape {
        /// A name of the kdb cluster.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String

        public init(clusterName: String, environmentId: String, userArn: String) {
            self.clusterName = clusterName
            self.environmentId = environmentId
            self.userArn = userArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.userArn, key: "userArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.userArn, name: "userArn", parent: name, max: 2048)
            try self.validate(self.userArn, name: "userArn", parent: name, min: 20)
            try self.validate(self.userArn, name: "userArn", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d+:kxEnvironment/[0-9A-Za-z_-]{1,128}/kxUser/[0-9A-Za-z_-]{1,128}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxConnectionStringResponse: AWSDecodableShape {
        /// The signed connection string that you can use to connect to clusters.
        public let signedConnectionString: String?

        public init(signedConnectionString: String? = nil) {
            self.signedConnectionString = signedConnectionString
        }

        private enum CodingKeys: String, CodingKey {
            case signedConnectionString = "signedConnectionString"
        }
    }

    public struct GetKxDatabaseRequest: AWSEncodableShape {
        /// The name of the kdb database.
        public let databaseName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(databaseName: String, environmentId: String) {
            self.databaseName = databaseName
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxDatabaseResponse: AWSDecodableShape {
        /// The timestamp at which the database is created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The ARN identifier of the database.
        public let databaseArn: String?
        /// The name of the kdb database for which the information is retrieved.
        public let databaseName: String?
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// A unique identifier for the changeset.
        public let lastCompletedChangesetId: String?
        /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// The total number of bytes in the database.
        public let numBytes: Int64?
        /// The total number of changesets in the database.
        public let numChangesets: Int?
        /// The total number of files in the database.
        public let numFiles: Int?

        public init(createdTimestamp: Date? = nil, databaseArn: String? = nil, databaseName: String? = nil, description: String? = nil, environmentId: String? = nil, lastCompletedChangesetId: String? = nil, lastModifiedTimestamp: Date? = nil, numBytes: Int64? = nil, numChangesets: Int? = nil, numFiles: Int? = nil) {
            self.createdTimestamp = createdTimestamp
            self.databaseArn = databaseArn
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
            self.lastCompletedChangesetId = lastCompletedChangesetId
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.numBytes = numBytes
            self.numChangesets = numChangesets
            self.numFiles = numFiles
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "createdTimestamp"
            case databaseArn = "databaseArn"
            case databaseName = "databaseName"
            case description = "description"
            case environmentId = "environmentId"
            case lastCompletedChangesetId = "lastCompletedChangesetId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case numBytes = "numBytes"
            case numChangesets = "numChangesets"
            case numFiles = "numFiles"
        }
    }

    public struct GetKxEnvironmentRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxEnvironmentResponse: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneIds: [String]?
        /// The unique identifier of the AWS account that is used to create the kdb environment.
        public let awsAccountId: String?
        /// The Amazon Resource Name (ARN) of the certificate authority of the  kdb environment.
        public let certificateAuthorityArn: String?
        /// The timestamp at which the kdb environment was created in FinSpace.
        public let creationTimestamp: Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public let dedicatedServiceAccountId: String?
        /// A description for the kdb environment.
        public let description: String?
        /// The status of DNS configuration.
        public let dnsStatus: DnsStatus?
        /// The ARN identifier of the environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the kdb environment.
        public let status: EnvironmentStatus?
        /// The status of the network configuration.
        public let tgwStatus: TgwStatus?
        public let transitGatewayConfiguration: TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was updated.
        public let updateTimestamp: Date?

        public init(availabilityZoneIds: [String]? = nil, awsAccountId: String? = nil, certificateAuthorityArn: String? = nil, creationTimestamp: Date? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, dnsStatus: DnsStatus? = nil, environmentArn: String? = nil, environmentId: String? = nil, errorMessage: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil, tgwStatus: TgwStatus? = nil, transitGatewayConfiguration: TransitGatewayConfiguration? = nil, updateTimestamp: Date? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.certificateAuthorityArn = certificateAuthorityArn
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case awsAccountId = "awsAccountId"
            case certificateAuthorityArn = "certificateAuthorityArn"
            case creationTimestamp = "creationTimestamp"
            case customDNSConfiguration = "customDNSConfiguration"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case dnsStatus = "dnsStatus"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
            case tgwStatus = "tgwStatus"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
            case updateTimestamp = "updateTimestamp"
        }
    }

    public struct GetKxUserRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// A unique identifier for the user.
        public let userName: String

        public init(environmentId: String, userName: String) {
            self.environmentId = environmentId
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodePath(self.userName, key: "userName")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.userName, name: "userName", parent: name, max: 50)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[0-9A-Za-z_-]{1,50}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKxUserResponse: AWSDecodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The IAM role ARN that is associated with the user.
        public let iamRole: String?
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String?
        /// A unique identifier for the user.
        public let userName: String?

        public init(environmentId: String? = nil, iamRole: String? = nil, userArn: String? = nil, userName: String? = nil) {
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.userArn = userArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case iamRole = "iamRole"
            case userArn = "userArn"
            case userName = "userName"
        }
    }

    public struct KxCacheStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The size of cache in Gigabytes.
        public let size: Int
        /// The type of cache storage . The valid values are:    CACHE_1000 – This type provides at least 1000 MB/s disk access throughput.
        public let type: String

        public init(size: Int, type: String) {
            self.size = size
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.size, name: "size", parent: name, max: 33600)
            try self.validate(self.size, name: "size", parent: name, min: 1200)
            try self.validate(self.type, name: "type", parent: name, max: 10)
            try self.validate(self.type, name: "type", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case size = "size"
            case type = "type"
        }
    }

    public struct KxChangesetListEntry: AWSDecodableShape {
        /// Beginning time from which the changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let activeFromTimestamp: Date?
        /// A unique identifier for the changeset.
        public let changesetId: String?
        /// The timestamp at which the changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The timestamp at which the changeset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        ///  Status of the changeset.   Pending – Changeset creation is pending.   Processing – Changeset creation is running.   Failed – Changeset creation has failed.   Complete – Changeset creation has succeeded.
        public let status: ChangesetStatus?

        public init(activeFromTimestamp: Date? = nil, changesetId: String? = nil, createdTimestamp: Date? = nil, lastModifiedTimestamp: Date? = nil, status: ChangesetStatus? = nil) {
            self.activeFromTimestamp = activeFromTimestamp
            self.changesetId = changesetId
            self.createdTimestamp = createdTimestamp
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case activeFromTimestamp = "activeFromTimestamp"
            case changesetId = "changesetId"
            case createdTimestamp = "createdTimestamp"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case status = "status"
        }
    }

    public struct KxCluster: AWSDecodableShape {
        ///  The availability zone identifiers for the requested regions.
        public let availabilityZoneId: String?
        /// The number of availability zones assigned per cluster. This can be one of the following     SINGLE – Assigns one availability zone per cluster.    MULTI – Assigns all the availability zones per cluster.
        public let azMode: KxAzMode?
        /// A description of the cluster.
        public let clusterDescription: String?
        /// A unique name for the cluster.
        public let clusterName: String?
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.
        public let clusterType: KxClusterType?
        /// The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        ///  An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.
        public let executionRole: String?
        /// Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.
        public let initializationScript: String?
        /// The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?
        /// A version of the FinSpace managed kdb to run.
        public let releaseLabel: String?
        /// The status of a cluster.   PENDING – The cluster is pending creation.   CREATING –The cluster creation process is in progress.   CREATE_FAILED– The cluster creation process has failed.   RUNNING – The cluster creation process is running.   UPDATING – The cluster is in the process of being updated.   DELETING – The cluster is in the process of being deleted.   DELETED – The cluster has been deleted.   DELETE_FAILED – The cluster failed to delete.
        public let status: KxClusterStatus?
        /// The error message when a failed state occurs.
        public let statusReason: String?

        public init(availabilityZoneId: String? = nil, azMode: KxAzMode? = nil, clusterDescription: String? = nil, clusterName: String? = nil, clusterType: KxClusterType? = nil, createdTimestamp: Date? = nil, executionRole: String? = nil, initializationScript: String? = nil, lastModifiedTimestamp: Date? = nil, releaseLabel: String? = nil, status: KxClusterStatus? = nil, statusReason: String? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.azMode = azMode
            self.clusterDescription = clusterDescription
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.createdTimestamp = createdTimestamp
            self.executionRole = executionRole
            self.initializationScript = initializationScript
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.releaseLabel = releaseLabel
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "availabilityZoneId"
            case azMode = "azMode"
            case clusterDescription = "clusterDescription"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case createdTimestamp = "createdTimestamp"
            case executionRole = "executionRole"
            case initializationScript = "initializationScript"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
            case releaseLabel = "releaseLabel"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct KxCommandLineArgument: AWSEncodableShape & AWSDecodableShape {
        /// The name of the key.
        public let key: String?
        /// The value of the key.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 50)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?![Aa][Ww][Ss])(s|([a-zA-Z][a-zA-Z0-9_]+))$")
            try self.validate(self.value, name: "value", parent: name, max: 50)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_:.]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct KxDatabaseCacheConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of disk cache. This parameter is used to map the database path to cache storage. The valid values are:   CACHE_1000 – This type provides at least 1000 MB/s disk access throughput.
        public let cacheType: String
        /// Specifies the portions of database that will be loaded into the cache for access.
        public let dbPaths: [String]

        public init(cacheType: String, dbPaths: [String]) {
            self.cacheType = cacheType
            self.dbPaths = dbPaths
        }

        public func validate(name: String) throws {
            try self.validate(self.cacheType, name: "cacheType", parent: name, max: 10)
            try self.validate(self.cacheType, name: "cacheType", parent: name, min: 8)
            try self.dbPaths.forEach {
                try validate($0, name: "dbPaths[]", parent: name, max: 1025)
                try validate($0, name: "dbPaths[]", parent: name, min: 1)
                try validate($0, name: "dbPaths[]", parent: name, pattern: "^\\/([^\\/]+\\/){0,2}[^\\/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cacheType = "cacheType"
            case dbPaths = "dbPaths"
        }
    }

    public struct KxDatabaseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration details for the disk cache used to increase performance reading from a kdb database mounted to the cluster.
        public let cacheConfigurations: [KxDatabaseCacheConfiguration]?
        /// A unique identifier of the changeset that is associated with the cluster.
        public let changesetId: String?
        /// The name of the kdb database. When this parameter is specified in the structure, S3 with the whole database is included by default.
        public let databaseName: String

        public init(cacheConfigurations: [KxDatabaseCacheConfiguration]? = nil, changesetId: String? = nil, databaseName: String) {
            self.cacheConfigurations = cacheConfigurations
            self.changesetId = changesetId
            self.databaseName = databaseName
        }

        public func validate(name: String) throws {
            try self.cacheConfigurations?.forEach {
                try $0.validate(name: "\(name).cacheConfigurations[]")
            }
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case cacheConfigurations = "cacheConfigurations"
            case changesetId = "changesetId"
            case databaseName = "databaseName"
        }
    }

    public struct KxDatabaseListEntry: AWSDecodableShape {
        /// The timestamp at which the database was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createdTimestamp: Date?
        /// The name of the kdb database.
        public let databaseName: String?
        /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, databaseName: String? = nil, lastModifiedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.databaseName = databaseName
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "createdTimestamp"
            case databaseName = "databaseName"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
        }
    }

    public struct KxEnvironment: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneIds: [String]?
        /// The unique identifier of the AWS account in which you create the kdb environment.
        public let awsAccountId: String?
        /// The Amazon Resource Name (ARN) of the certificate authority:
        public let certificateAuthorityArn: String?
        /// The timestamp at which the kdb environment was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let creationTimestamp: Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public let dedicatedServiceAccountId: String?
        /// A description of the kdb environment.
        public let description: String?
        /// The status of DNS configuration.
        public let dnsStatus: DnsStatus?
        /// The Amazon Resource Name (ARN) of your kdb environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// The unique identifier of the KMS key.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the environment creation.    CREATE_REQUESTED – Environment creation has been requested.   CREATING – Environment is in the process of being created.   FAILED_CREATION – Environment creation has failed.   CREATED – Environment is successfully created and is currently active.   DELETE REQUESTED – Environment deletion has been requested.   DELETING – Environment is in the process of being deleted.   RETRY_DELETION – Initial environment deletion failed, system is reattempting delete.   DELETED – Environment has been deleted.   FAILED_DELETION – Environment deletion has failed.
        public let status: EnvironmentStatus?
        /// The status of the network configuration.
        public let tgwStatus: TgwStatus?
        /// Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
        public let transitGatewayConfiguration: TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was modified in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let updateTimestamp: Date?

        public init(availabilityZoneIds: [String]? = nil, awsAccountId: String? = nil, certificateAuthorityArn: String? = nil, creationTimestamp: Date? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, dnsStatus: DnsStatus? = nil, environmentArn: String? = nil, environmentId: String? = nil, errorMessage: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil, tgwStatus: TgwStatus? = nil, transitGatewayConfiguration: TransitGatewayConfiguration? = nil, updateTimestamp: Date? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.certificateAuthorityArn = certificateAuthorityArn
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case awsAccountId = "awsAccountId"
            case certificateAuthorityArn = "certificateAuthorityArn"
            case creationTimestamp = "creationTimestamp"
            case customDNSConfiguration = "customDNSConfiguration"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case dnsStatus = "dnsStatus"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
            case tgwStatus = "tgwStatus"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
            case updateTimestamp = "updateTimestamp"
        }
    }

    public struct KxNode: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneId: String?
        /// The time when a particular node is started.  The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let launchTime: Date?
        /// A unique identifier for the node.
        public let nodeId: String?

        public init(availabilityZoneId: String? = nil, launchTime: Date? = nil, nodeId: String? = nil) {
            self.availabilityZoneId = availabilityZoneId
            self.launchTime = launchTime
            self.nodeId = nodeId
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneId = "availabilityZoneId"
            case launchTime = "launchTime"
            case nodeId = "nodeId"
        }
    }

    public struct KxSavedownStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The size of temporary storage in bytes.
        public let size: Int
        /// The type of writeable storage space for temporarily storing your savedown data. The valid values are:   SDS01 – This type represents 3000 IOPS and io2 ebs volume type.
        public let type: KxSavedownStorageType

        public init(size: Int, type: KxSavedownStorageType) {
            self.size = size
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.size, name: "size", parent: name, max: 16000)
            try self.validate(self.size, name: "size", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case size = "size"
            case type = "type"
        }
    }

    public struct KxUser: AWSDecodableShape {
        /// The timestamp at which the kdb user was created.
        public let createTimestamp: Date?
        /// The IAM role ARN that is associated with the user.
        public let iamRole: String?
        /// The timestamp at which the kdb user was updated.
        public let updateTimestamp: Date?
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String?
        /// A unique identifier for the user.
        public let userName: String?

        public init(createTimestamp: Date? = nil, iamRole: String? = nil, updateTimestamp: Date? = nil, userArn: String? = nil, userName: String? = nil) {
            self.createTimestamp = createTimestamp
            self.iamRole = iamRole
            self.updateTimestamp = updateTimestamp
            self.userArn = userArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case createTimestamp = "createTimestamp"
            case iamRole = "iamRole"
            case updateTimestamp = "updateTimestamp"
            case userArn = "userArn"
            case userName = "userName"
        }
    }

    public struct ListEnvironmentsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token generated by FinSpace that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the nextTokennextToken value from the response object of the previous page call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentsResponse: AWSDecodableShape {
        /// A list of all of your FinSpace environments.
        public let environments: [Environment]?
        /// A token that you can use in a subsequent call to retrieve the next set of results.
        public let nextToken: String?

        public init(environments: [Environment]? = nil, nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments = "environments"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxChangesetsRequest: AWSEncodableShape {
        /// The name of the kdb database.
        public let databaseName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(databaseName: String, environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.databaseName = databaseName
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.databaseName, key: "databaseName")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxChangesetsResponse: AWSDecodableShape {
        /// A list of changesets for a database.
        public let kxChangesets: [KxChangesetListEntry]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(kxChangesets: [KxChangesetListEntry]? = nil, nextToken: String? = nil) {
            self.kxChangesets = kxChangesets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kxChangesets = "kxChangesets"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxClusterNodesRequest: AWSEncodableShape {
        /// A unique name for the cluster.
        public let clusterName: String
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(clusterName: String, environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterName = clusterName
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterName, key: "clusterName")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxClusterNodesResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// A list of nodes associated with the cluster.
        public let nodes: [KxNode]?

        public init(nextToken: String? = nil, nodes: [KxNode]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodes = "nodes"
        }
    }

    public struct ListKxClustersRequest: AWSEncodableShape {
        /// Specifies the type of KDB database that is being created. The following types are available:    HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.   RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.   GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.
        public let clusterType: KxClusterType?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(clusterType: KxClusterType? = nil, environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterType = clusterType
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clusterType, key: "clusterType")
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxClustersResponse: AWSDecodableShape {
        /// Lists the cluster details.
        public let kxClusterSummaries: [KxCluster]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(kxClusterSummaries: [KxCluster]? = nil, nextToken: String? = nil) {
            self.kxClusterSummaries = kxClusterSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kxClusterSummaries = "kxClusterSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxDatabasesRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxDatabasesResponse: AWSDecodableShape {
        /// A list of databases in the kdb environment.
        public let kxDatabases: [KxDatabaseListEntry]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(kxDatabases: [KxDatabaseListEntry]? = nil, nextToken: String? = nil) {
            self.kxDatabases = kxDatabases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kxDatabases = "kxDatabases"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxEnvironmentsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxEnvironmentsResponse: AWSDecodableShape {
        /// A list of environments in an account.
        public let environments: [KxEnvironment]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(environments: [KxEnvironment]? = nil, nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments = "environments"
            case nextToken = "nextToken"
        }
    }

    public struct ListKxUsersRequest: AWSEncodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKxUsersResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// A list of users in a kdb environment.
        public let users: [KxUser]?

        public init(nextToken: String? = nil, users: [KxUser]? = nil) {
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case users = "users"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d+:(environment|kxEnvironment)/[0-9A-Za-z_-]{1,128}(/(kxDatabase|kxCluster|kxUser)/[a-zA-Z0-9_-]{1,255})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of all tags for a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct SuperuserParameters: AWSEncodableShape {
        /// The email address of the superuser.
        public let emailAddress: String
        /// The first name of the superuser.
        public let firstName: String
        /// The last name of the superuser.
        public let lastName: String

        public init(emailAddress: String, firstName: String, lastName: String) {
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
        }

        public func validate(name: String) throws {
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 128)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+[.]+[A-Za-z]+$")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 50)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "^[a-zA-Z0-9]{1,50}$")
            try self.validate(self.lastName, name: "lastName", parent: name, max: 50)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "^[a-zA-Z0-9]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddress = "emailAddress"
            case firstName = "firstName"
            case lastName = "lastName"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the resource.
        public let resourceArn: String
        /// One or more tags to be assigned to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d+:(environment|kxEnvironment)/[0-9A-Za-z_-]{1,128}(/(kxDatabase|kxCluster|kxUser)/[a-zA-Z0-9_-]{1,255})?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9+-=._:@ ]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TransitGatewayConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The routing CIDR on behalf of kdb environment. It could be any "/26 range in the 100.64.0.0 CIDR space. After providing, it will be added to the customer's transit gateway routing table so that the traffics could be routed to kdb network.
        public let routableCIDRSpace: String
        /// The identifier of the transit gateway created by the customer to connect outbound traffics from kdb network to your internal network.
        public let transitGatewayID: String

        public init(routableCIDRSpace: String, transitGatewayID: String) {
            self.routableCIDRSpace = routableCIDRSpace
            self.transitGatewayID = transitGatewayID
        }

        public func validate(name: String) throws {
            try self.validate(self.routableCIDRSpace, name: "routableCIDRSpace", parent: name, pattern: "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/26$")
            try self.validate(self.transitGatewayID, name: "transitGatewayID", parent: name, max: 32)
            try self.validate(self.transitGatewayID, name: "transitGatewayID", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case routableCIDRSpace = "routableCIDRSpace"
            case transitGatewayID = "transitGatewayID"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// A FinSpace resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
        public let resourceArn: String
        /// The tag keys (names) of one or more tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:finspace:[A-Za-z0-9_/.-]{0,63}:\\d+:(environment|kxEnvironment)/[0-9A-Za-z_-]{1,128}(/(kxDatabase|kxCluster|kxUser)/[a-zA-Z0-9_-]{1,255})?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEnvironmentRequest: AWSEncodableShape {
        /// The description of the environment.
        public let description: String?
        /// The identifier of the FinSpace environment.
        public let environmentId: String
        /// Authentication mode for the environment.    FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.    LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
        public let federationMode: FederationMode?
        public let federationParameters: FederationParameters?
        /// The name of the environment.
        public let name: String?

        public init(description: String? = nil, environmentId: String, federationMode: FederationMode? = nil, federationParameters: FederationParameters? = nil, name: String? = nil) {
            self.description = description
            self.environmentId = environmentId
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.federationMode, forKey: .federationMode)
            try container.encodeIfPresent(self.federationParameters, forKey: .federationParameters)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.federationParameters?.validate(name: "\(name).federationParameters")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case federationMode = "federationMode"
            case federationParameters = "federationParameters"
            case name = "name"
        }
    }

    public struct UpdateEnvironmentResponse: AWSDecodableShape {
        /// Returns the FinSpace environment object.
        public let environment: Environment?

        public init(environment: Environment? = nil) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct UpdateKxClusterDatabasesRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique name for the cluster that you want to modify.
        public let clusterName: String
        ///  The structure of databases mounted on the cluster.
        public let databases: [KxDatabaseConfiguration]
        /// The unique identifier of a kdb environment.
        public let environmentId: String

        public init(clientToken: String? = nil, clusterName: String, databases: [KxDatabaseConfiguration], environmentId: String) {
            self.clientToken = clientToken
            self.clusterName = clusterName
            self.databases = databases
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.clusterName, key: "clusterName")
            try container.encode(self.databases, forKey: .databases)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 63)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 3)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.databases.forEach {
                try $0.validate(name: "\(name).databases[]")
            }
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case databases = "databases"
        }
    }

    public struct UpdateKxClusterDatabasesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateKxDatabaseRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String
        /// The name of the kdb database.
        public let databaseName: String
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String

        public init(clientToken: String = UpdateKxDatabaseRequest.idempotencyToken(), databaseName: String, description: String? = nil, environmentId: String) {
            self.clientToken = clientToken
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.databaseName, key: "databaseName")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 63)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 3)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 32)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct UpdateKxDatabaseResponse: AWSDecodableShape {
        /// The name of the kdb database.
        public let databaseName: String?
        /// A description of the database.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The last time that the database was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTimestamp: Date?

        public init(databaseName: String? = nil, description: String? = nil, environmentId: String? = nil, lastModifiedTimestamp: Date? = nil) {
            self.databaseName = databaseName
            self.description = description
            self.environmentId = environmentId
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case description = "description"
            case environmentId = "environmentId"
            case lastModifiedTimestamp = "lastModifiedTimestamp"
        }
    }

    public struct UpdateKxEnvironmentNetworkRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// Specifies the transit gateway and network configuration to connect the kdb environment to an internal network.
        public let transitGatewayConfiguration: TransitGatewayConfiguration?

        public init(clientToken: String? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, environmentId: String, transitGatewayConfiguration: TransitGatewayConfiguration? = nil) {
            self.clientToken = clientToken
            self.customDNSConfiguration = customDNSConfiguration
            self.environmentId = environmentId
            self.transitGatewayConfiguration = transitGatewayConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.customDNSConfiguration, forKey: .customDNSConfiguration)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.transitGatewayConfiguration, forKey: .transitGatewayConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.customDNSConfiguration?.forEach {
                try $0.validate(name: "\(name).customDNSConfiguration[]")
            }
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.transitGatewayConfiguration?.validate(name: "\(name).transitGatewayConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customDNSConfiguration = "customDNSConfiguration"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
        }
    }

    public struct UpdateKxEnvironmentNetworkResponse: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneIds: [String]?
        /// The unique identifier of the AWS account that is used to create the kdb environment.
        public let awsAccountId: String?
        /// The timestamp at which the kdb environment was created in FinSpace.
        public let creationTimestamp: Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public let dedicatedServiceAccountId: String?
        /// The description of the environment.
        public let description: String?
        /// The status of DNS configuration.
        public let dnsStatus: DnsStatus?
        /// The ARN identifier of the environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the kdb environment.
        public let status: EnvironmentStatus?
        /// The status of the network configuration.
        public let tgwStatus: TgwStatus?
        public let transitGatewayConfiguration: TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was updated.
        public let updateTimestamp: Date?

        public init(availabilityZoneIds: [String]? = nil, awsAccountId: String? = nil, creationTimestamp: Date? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, dnsStatus: DnsStatus? = nil, environmentArn: String? = nil, environmentId: String? = nil, errorMessage: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil, tgwStatus: TgwStatus? = nil, transitGatewayConfiguration: TransitGatewayConfiguration? = nil, updateTimestamp: Date? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case awsAccountId = "awsAccountId"
            case creationTimestamp = "creationTimestamp"
            case customDNSConfiguration = "customDNSConfiguration"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case dnsStatus = "dnsStatus"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
            case tgwStatus = "tgwStatus"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
            case updateTimestamp = "updateTimestamp"
        }
    }

    public struct UpdateKxEnvironmentRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description of the kdb environment.
        public let description: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The name of the kdb environment.
        public let name: String?

        public init(clientToken: String? = nil, description: String? = nil, environmentId: String, name: String? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.environmentId = environmentId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9. ]{1,1000}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateKxEnvironmentResponse: AWSDecodableShape {
        /// The identifier of the availability zones where subnets for the environment are created.
        public let availabilityZoneIds: [String]?
        /// The unique identifier of the AWS account that is used to create the kdb environment.
        public let awsAccountId: String?
        /// The timestamp at which the kdb environment was created in FinSpace.
        public let creationTimestamp: Date?
        /// A list of DNS server name and server IP. This is used to set up Route-53 outbound resolvers.
        public let customDNSConfiguration: [CustomDNSServer]?
        /// A unique identifier for the AWS environment infrastructure account.
        public let dedicatedServiceAccountId: String?
        /// The description of the environment.
        public let description: String?
        /// The status of DNS configuration.
        public let dnsStatus: DnsStatus?
        /// The ARN identifier of the environment.
        public let environmentArn: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// Specifies the error message that appears if a flow fails.
        public let errorMessage: String?
        /// The KMS key ID to encrypt your data in the FinSpace environment.
        public let kmsKeyId: String?
        /// The name of the kdb environment.
        public let name: String?
        /// The status of the kdb environment.
        public let status: EnvironmentStatus?
        /// The status of the network configuration.
        public let tgwStatus: TgwStatus?
        public let transitGatewayConfiguration: TransitGatewayConfiguration?
        /// The timestamp at which the kdb environment was updated.
        public let updateTimestamp: Date?

        public init(availabilityZoneIds: [String]? = nil, awsAccountId: String? = nil, creationTimestamp: Date? = nil, customDNSConfiguration: [CustomDNSServer]? = nil, dedicatedServiceAccountId: String? = nil, description: String? = nil, dnsStatus: DnsStatus? = nil, environmentArn: String? = nil, environmentId: String? = nil, errorMessage: String? = nil, kmsKeyId: String? = nil, name: String? = nil, status: EnvironmentStatus? = nil, tgwStatus: TgwStatus? = nil, transitGatewayConfiguration: TransitGatewayConfiguration? = nil, updateTimestamp: Date? = nil) {
            self.availabilityZoneIds = availabilityZoneIds
            self.awsAccountId = awsAccountId
            self.creationTimestamp = creationTimestamp
            self.customDNSConfiguration = customDNSConfiguration
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.dnsStatus = dnsStatus
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tgwStatus = tgwStatus
            self.transitGatewayConfiguration = transitGatewayConfiguration
            self.updateTimestamp = updateTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneIds = "availabilityZoneIds"
            case awsAccountId = "awsAccountId"
            case creationTimestamp = "creationTimestamp"
            case customDNSConfiguration = "customDNSConfiguration"
            case dedicatedServiceAccountId = "dedicatedServiceAccountId"
            case description = "description"
            case dnsStatus = "dnsStatus"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case status = "status"
            case tgwStatus = "tgwStatus"
            case transitGatewayConfiguration = "transitGatewayConfiguration"
            case updateTimestamp = "updateTimestamp"
        }
    }

    public struct UpdateKxUserRequest: AWSEncodableShape {
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A unique identifier for the kdb environment.
        public let environmentId: String
        /// The IAM role ARN that is associated with the user.
        public let iamRole: String
        /// A unique identifier for the user.
        public let userName: String

        public init(clientToken: String? = nil, environmentId: String, iamRole: String, userName: String) {
            self.clientToken = clientToken
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encode(self.iamRole, forKey: .iamRole)
            request.encodePath(self.userName, key: "userName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9]{1,26}$")
            try self.validate(self.iamRole, name: "iamRole", parent: name, max: 2048)
            try self.validate(self.iamRole, name: "iamRole", parent: name, min: 20)
            try self.validate(self.iamRole, name: "iamRole", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.userName, name: "userName", parent: name, max: 50)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[0-9A-Za-z_-]{1,50}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case iamRole = "iamRole"
        }
    }

    public struct UpdateKxUserResponse: AWSDecodableShape {
        /// A unique identifier for the kdb environment.
        public let environmentId: String?
        /// The IAM role ARN that is associated with the user.
        public let iamRole: String?
        ///  The Amazon Resource Name (ARN) that identifies the user. For more information about ARNs and how to use ARNs in policies, see IAM Identifiers in the IAM User Guide.
        public let userArn: String?
        /// A unique identifier for the user.
        public let userName: String?

        public init(environmentId: String? = nil, iamRole: String? = nil, userArn: String? = nil, userName: String? = nil) {
            self.environmentId = environmentId
            self.iamRole = iamRole
            self.userArn = userArn
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case iamRole = "iamRole"
            case userArn = "userArn"
            case userName = "userName"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The IP address type for cluster network configuration parameters. The following type is available:   IP_V4 – IP address version 4
        public let ipAddressType: IPAddressType?
        /// The  unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster.
        public let securityGroupIds: [String]?
        /// The identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster.
        public let subnetIds: [String]?
        /// The identifier of the VPC endpoint.
        public let vpcId: String?

        public init(ipAddressType: IPAddressType? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.ipAddressType = ipAddressType
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-([a-z0-9]{8}$|[a-z0-9]{17}$)$")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 1024)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-([a-z0-9]{8}$|[a-z0-9]{17}$)$")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 1024)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-([a-z0-9]{8}$|[a-z0-9]{17}$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressType = "ipAddressType"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }
}

// MARK: - Errors

/// Error enum for Finspace
public struct FinspaceErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Finspace
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was a conflict with this action, and it could not be completed.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request is invalid. Something is wrong with the input to the request.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// A service limit or quota is exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The specified resource group already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// One or more resources can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  You have exceeded your service quota. To perform the requested action,  remove some of the relevant resources, or use Service Quotas to request a service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension FinspaceErrorType: Equatable {
    public static func == (lhs: FinspaceErrorType, rhs: FinspaceErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension FinspaceErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
