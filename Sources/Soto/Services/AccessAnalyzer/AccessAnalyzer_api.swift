//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS AccessAnalyzer service.
///
/// Identity and Access Management Access Analyzer helps you to set, verify, and refine your IAM policies by providing a suite of capabilities. Its features include findings for external and unused access, basic and custom policy checks for validating policies, and policy generation to generate fine-grained policies. To start using IAM Access Analyzer to identify external or unused access, you first need to create an analyzer.  External access analyzers help identify potential risks of accessing resources by enabling you to identify any resource policies that grant access to an external principal. It does this by using logic-based reasoning to analyze resource-based policies in your Amazon Web Services environment. An external principal can be another Amazon Web Services account, a root user, an IAM user or role, a federated user, an Amazon Web Services service, or an anonymous user. You can also use IAM Access Analyzer to preview public and cross-account access to your resources before deploying permissions changes.  Unused access analyzers help identify potential identity access risks by enabling you to identify unused IAM roles, unused access keys, unused console passwords, and IAM principals with unused service and action-level permissions. Beyond findings, IAM Access Analyzer provides basic and custom policy checks to validate IAM policies before deploying permissions changes. You can use policy generation to refine permissions by attaching a policy generated using access activity logged in CloudTrail logs.  This guide describes the IAM Access Analyzer operations that you can call programmatically. For general information about IAM Access Analyzer, see Identity and Access Management Access Analyzer in the IAM User Guide.
public struct AccessAnalyzer: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the AccessAnalyzer client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "AccessAnalyzer",
            serviceIdentifier: "access-analyzer",
            serviceProtocol: .restjson,
            apiVersion: "2019-11-01",
            endpoint: endpoint,
            serviceEndpoints: Self.serviceEndpoints,
            variantEndpoints: Self.variantEndpoints,
            errorType: AccessAnalyzerErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }


    /// custom endpoints for regions
    static var serviceEndpoints: [String: String] {[
        "us-gov-east-1": "access-analyzer.us-gov-east-1.amazonaws.com",
        "us-gov-west-1": "access-analyzer.us-gov-west-1.amazonaws.com"
    ]}


    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "ca-central-1": "access-analyzer-fips.ca-central-1.amazonaws.com",
            "ca-west-1": "access-analyzer-fips.ca-west-1.amazonaws.com",
            "us-east-1": "access-analyzer-fips.us-east-1.amazonaws.com",
            "us-east-2": "access-analyzer-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "access-analyzer.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "access-analyzer.us-gov-west-1.amazonaws.com",
            "us-west-1": "access-analyzer-fips.us-west-1.amazonaws.com",
            "us-west-2": "access-analyzer-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Retroactively applies the archive rule to existing findings that meet the archive rule criteria.
    @Sendable
    @inlinable
    public func applyArchiveRule(_ input: ApplyArchiveRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "ApplyArchiveRule", 
            path: "/archive-rule", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retroactively applies the archive rule to existing findings that meet the archive rule criteria.
    ///
    /// Parameters:
    ///   - analyzerArn: The Amazon resource name (ARN) of the analyzer.
    ///   - clientToken: A client token.
    ///   - ruleName: The name of the rule to apply.
    ///   - logger: Logger use during operation
    @inlinable
    public func applyArchiveRule(
        analyzerArn: String,
        clientToken: String? = ApplyArchiveRuleRequest.idempotencyToken(),
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = ApplyArchiveRuleRequest(
            analyzerArn: analyzerArn, 
            clientToken: clientToken, 
            ruleName: ruleName
        )
        return try await self.applyArchiveRule(input, logger: logger)
    }

    /// Cancels the requested policy generation.
    @Sendable
    @inlinable
    public func cancelPolicyGeneration(_ input: CancelPolicyGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelPolicyGenerationResponse {
        try await self.client.execute(
            operation: "CancelPolicyGeneration", 
            path: "/policy/generation/{jobId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels the requested policy generation.
    ///
    /// Parameters:
    ///   - jobId: The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelPolicyGeneration(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelPolicyGenerationResponse {
        let input = CancelPolicyGenerationRequest(
            jobId: jobId
        )
        return try await self.cancelPolicyGeneration(input, logger: logger)
    }

    /// Checks whether the specified access isn't allowed by a policy.
    @Sendable
    @inlinable
    public func checkAccessNotGranted(_ input: CheckAccessNotGrantedRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CheckAccessNotGrantedResponse {
        try await self.client.execute(
            operation: "CheckAccessNotGranted", 
            path: "/policy/check-access-not-granted", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Checks whether the specified access isn't allowed by a policy.
    ///
    /// Parameters:
    ///   - access: An access object containing the permissions that shouldn't be granted by the specified policy. If only actions are specified, IAM Access Analyzer checks for access to peform at least one of the actions on any resource in the policy. If only resources are specified, then IAM Access Analyzer checks for access to perform any action on at least one of the resources. If both actions and resources are specified, IAM Access Analyzer checks for access to perform at least one of the specified actions on at least one of the specified resources.
    ///   - policyDocument: The JSON policy document to use as the content for the policy.
    ///   - policyType: The type of policy. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets.
    ///   - logger: Logger use during operation
    @inlinable
    public func checkAccessNotGranted(
        access: [Access],
        policyDocument: String,
        policyType: AccessCheckPolicyType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CheckAccessNotGrantedResponse {
        let input = CheckAccessNotGrantedRequest(
            access: access, 
            policyDocument: policyDocument, 
            policyType: policyType
        )
        return try await self.checkAccessNotGranted(input, logger: logger)
    }

    /// Checks whether new access is allowed for an updated policy when compared to the existing policy. You can find examples for reference policies and learn how to set up and run a custom policy check for new access in the IAM Access Analyzer custom policy checks samples repository on GitHub. The reference policies in this repository are meant to be passed to the existingPolicyDocument request parameter.
    @Sendable
    @inlinable
    public func checkNoNewAccess(_ input: CheckNoNewAccessRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CheckNoNewAccessResponse {
        try await self.client.execute(
            operation: "CheckNoNewAccess", 
            path: "/policy/check-no-new-access", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Checks whether new access is allowed for an updated policy when compared to the existing policy. You can find examples for reference policies and learn how to set up and run a custom policy check for new access in the IAM Access Analyzer custom policy checks samples repository on GitHub. The reference policies in this repository are meant to be passed to the existingPolicyDocument request parameter.
    ///
    /// Parameters:
    ///   - existingPolicyDocument: The JSON policy document to use as the content for the existing policy.
    ///   - newPolicyDocument: The JSON policy document to use as the content for the updated policy.
    ///   - policyType: The type of policy to compare. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func checkNoNewAccess(
        existingPolicyDocument: String,
        newPolicyDocument: String,
        policyType: AccessCheckPolicyType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CheckNoNewAccessResponse {
        let input = CheckNoNewAccessRequest(
            existingPolicyDocument: existingPolicyDocument, 
            newPolicyDocument: newPolicyDocument, 
            policyType: policyType
        )
        return try await self.checkNoNewAccess(input, logger: logger)
    }

    /// Checks whether a resource policy can grant public access to the specified resource type.
    @Sendable
    @inlinable
    public func checkNoPublicAccess(_ input: CheckNoPublicAccessRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CheckNoPublicAccessResponse {
        try await self.client.execute(
            operation: "CheckNoPublicAccess", 
            path: "/policy/check-no-public-access", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Checks whether a resource policy can grant public access to the specified resource type.
    ///
    /// Parameters:
    ///   - policyDocument: The JSON policy document to evaluate for public access.
    ///   - resourceType: The type of resource to evaluate for public access. For example, to check for public access to Amazon S3 buckets, you can choose AWS::S3::Bucket for the resource type. For resource types not supported as valid values, IAM Access Analyzer will return an error.
    ///   - logger: Logger use during operation
    @inlinable
    public func checkNoPublicAccess(
        policyDocument: String,
        resourceType: AccessCheckResourceType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CheckNoPublicAccessResponse {
        let input = CheckNoPublicAccessRequest(
            policyDocument: policyDocument, 
            resourceType: resourceType
        )
        return try await self.checkNoPublicAccess(input, logger: logger)
    }

    /// Creates an access preview that allows you to preview IAM Access Analyzer findings for your resource before deploying resource permissions.
    @Sendable
    @inlinable
    public func createAccessPreview(_ input: CreateAccessPreviewRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAccessPreviewResponse {
        try await self.client.execute(
            operation: "CreateAccessPreview", 
            path: "/access-preview", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an access preview that allows you to preview IAM Access Analyzer findings for your resource before deploying resource permissions.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the account analyzer used to generate the access preview. You can only create an access preview for analyzers with an Account type and Active status.
    ///   - clientToken: A client token.
    ///   - configurations: Access control configuration for your resource that is used to generate the access preview. The access preview includes findings for external access allowed to the resource with the proposed access control configuration. The configuration must contain exactly one element.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAccessPreview(
        analyzerArn: String,
        clientToken: String? = CreateAccessPreviewRequest.idempotencyToken(),
        configurations: [String: Configuration],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAccessPreviewResponse {
        let input = CreateAccessPreviewRequest(
            analyzerArn: analyzerArn, 
            clientToken: clientToken, 
            configurations: configurations
        )
        return try await self.createAccessPreview(input, logger: logger)
    }

    /// Creates an analyzer for your account.
    @Sendable
    @inlinable
    public func createAnalyzer(_ input: CreateAnalyzerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAnalyzerResponse {
        try await self.client.execute(
            operation: "CreateAnalyzer", 
            path: "/analyzer", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an analyzer for your account.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the analyzer to create.
    ///   - archiveRules: Specifies the archive rules to add for the analyzer. Archive rules automatically archive findings that meet the criteria you define for the rule.
    ///   - clientToken: A client token.
    ///   - configuration: Specifies the configuration of the analyzer. If the analyzer is an unused access analyzer, the specified scope of unused access is used for the configuration.
    ///   - tags: An array of key-value pairs to apply to the analyzer. You can use the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. For the tag key, you can specify a value that is 1 to 128 characters in length and cannot be prefixed with aws:. For the tag value, you can specify a value that is 0 to 256 characters in length.
    ///   - type: The type of analyzer to create. Only ACCOUNT, ORGANIZATION, ACCOUNT_UNUSED_ACCESS, and ORGANIZATION_UNUSED_ACCESS analyzers are supported. You can create only one analyzer per account per Region. You can create up to 5 analyzers per organization per Region.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAnalyzer(
        analyzerName: String,
        archiveRules: [InlineArchiveRule]? = nil,
        clientToken: String? = CreateAnalyzerRequest.idempotencyToken(),
        configuration: AnalyzerConfiguration? = nil,
        tags: [String: String]? = nil,
        type: `Type`,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAnalyzerResponse {
        let input = CreateAnalyzerRequest(
            analyzerName: analyzerName, 
            archiveRules: archiveRules, 
            clientToken: clientToken, 
            configuration: configuration, 
            tags: tags, 
            type: type
        )
        return try await self.createAnalyzer(input, logger: logger)
    }

    /// Creates an archive rule for the specified analyzer. Archive rules automatically archive new findings that meet the criteria you define when you create the rule. To learn about filter keys that you can use to create an archive rule, see IAM Access Analyzer filter keys in the IAM User Guide.
    @Sendable
    @inlinable
    public func createArchiveRule(_ input: CreateArchiveRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "CreateArchiveRule", 
            path: "/analyzer/{analyzerName}/archive-rule", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an archive rule for the specified analyzer. Archive rules automatically archive new findings that meet the criteria you define when you create the rule. To learn about filter keys that you can use to create an archive rule, see IAM Access Analyzer filter keys in the IAM User Guide.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the created analyzer.
    ///   - clientToken: A client token.
    ///   - filter: The criteria for the rule.
    ///   - ruleName: The name of the rule to create.
    ///   - logger: Logger use during operation
    @inlinable
    public func createArchiveRule(
        analyzerName: String,
        clientToken: String? = CreateArchiveRuleRequest.idempotencyToken(),
        filter: [String: Criterion],
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = CreateArchiveRuleRequest(
            analyzerName: analyzerName, 
            clientToken: clientToken, 
            filter: filter, 
            ruleName: ruleName
        )
        return try await self.createArchiveRule(input, logger: logger)
    }

    /// Deletes the specified analyzer. When you delete an analyzer, IAM Access Analyzer is disabled for the account or organization in the current or specific Region. All findings that were generated by the analyzer are deleted. You cannot undo this action.
    @Sendable
    @inlinable
    public func deleteAnalyzer(_ input: DeleteAnalyzerRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteAnalyzer", 
            path: "/analyzer/{analyzerName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified analyzer. When you delete an analyzer, IAM Access Analyzer is disabled for the account or organization in the current or specific Region. All findings that were generated by the analyzer are deleted. You cannot undo this action.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the analyzer to delete.
    ///   - clientToken: A client token.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAnalyzer(
        analyzerName: String,
        clientToken: String? = DeleteAnalyzerRequest.idempotencyToken(),
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteAnalyzerRequest(
            analyzerName: analyzerName, 
            clientToken: clientToken
        )
        return try await self.deleteAnalyzer(input, logger: logger)
    }

    /// Deletes the specified archive rule.
    @Sendable
    @inlinable
    public func deleteArchiveRule(_ input: DeleteArchiveRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteArchiveRule", 
            path: "/analyzer/{analyzerName}/archive-rule/{ruleName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified archive rule.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the analyzer that associated with the archive rule to delete.
    ///   - clientToken: A client token.
    ///   - ruleName: The name of the rule to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteArchiveRule(
        analyzerName: String,
        clientToken: String? = DeleteArchiveRuleRequest.idempotencyToken(),
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteArchiveRuleRequest(
            analyzerName: analyzerName, 
            clientToken: clientToken, 
            ruleName: ruleName
        )
        return try await self.deleteArchiveRule(input, logger: logger)
    }

    /// Creates a recommendation for an unused permissions finding.
    @Sendable
    @inlinable
    public func generateFindingRecommendation(_ input: GenerateFindingRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "GenerateFindingRecommendation", 
            path: "/recommendation/{id}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a recommendation for an unused permissions finding.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer used to generate the finding recommendation.
    ///   - id: The unique ID for the finding recommendation.
    ///   - logger: Logger use during operation
    @inlinable
    public func generateFindingRecommendation(
        analyzerArn: String,
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GenerateFindingRecommendationRequest(
            analyzerArn: analyzerArn, 
            id: id
        )
        return try await self.generateFindingRecommendation(input, logger: logger)
    }

    /// Retrieves information about an access preview for the specified analyzer.
    @Sendable
    @inlinable
    public func getAccessPreview(_ input: GetAccessPreviewRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAccessPreviewResponse {
        try await self.client.execute(
            operation: "GetAccessPreview", 
            path: "/access-preview/{accessPreviewId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an access preview for the specified analyzer.
    ///
    /// Parameters:
    ///   - accessPreviewId: The unique ID for the access preview.
    ///   - analyzerArn: The ARN of the analyzer used to generate the access preview.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAccessPreview(
        accessPreviewId: String,
        analyzerArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAccessPreviewResponse {
        let input = GetAccessPreviewRequest(
            accessPreviewId: accessPreviewId, 
            analyzerArn: analyzerArn
        )
        return try await self.getAccessPreview(input, logger: logger)
    }

    /// Retrieves information about a resource that was analyzed.
    @Sendable
    @inlinable
    public func getAnalyzedResource(_ input: GetAnalyzedResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnalyzedResourceResponse {
        try await self.client.execute(
            operation: "GetAnalyzedResource", 
            path: "/analyzed-resource", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a resource that was analyzed.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer to retrieve information from.
    ///   - resourceArn: The ARN of the resource to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAnalyzedResource(
        analyzerArn: String,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAnalyzedResourceResponse {
        let input = GetAnalyzedResourceRequest(
            analyzerArn: analyzerArn, 
            resourceArn: resourceArn
        )
        return try await self.getAnalyzedResource(input, logger: logger)
    }

    /// Retrieves information about the specified analyzer.
    @Sendable
    @inlinable
    public func getAnalyzer(_ input: GetAnalyzerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAnalyzerResponse {
        try await self.client.execute(
            operation: "GetAnalyzer", 
            path: "/analyzer/{analyzerName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the specified analyzer.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the analyzer retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAnalyzer(
        analyzerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAnalyzerResponse {
        let input = GetAnalyzerRequest(
            analyzerName: analyzerName
        )
        return try await self.getAnalyzer(input, logger: logger)
    }

    /// Retrieves information about an archive rule. To learn about filter keys that you can use to create an archive rule, see IAM Access Analyzer filter keys in the IAM User Guide.
    @Sendable
    @inlinable
    public func getArchiveRule(_ input: GetArchiveRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetArchiveRuleResponse {
        try await self.client.execute(
            operation: "GetArchiveRule", 
            path: "/analyzer/{analyzerName}/archive-rule/{ruleName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an archive rule. To learn about filter keys that you can use to create an archive rule, see IAM Access Analyzer filter keys in the IAM User Guide.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the analyzer to retrieve rules from.
    ///   - ruleName: The name of the rule to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getArchiveRule(
        analyzerName: String,
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetArchiveRuleResponse {
        let input = GetArchiveRuleRequest(
            analyzerName: analyzerName, 
            ruleName: ruleName
        )
        return try await self.getArchiveRule(input, logger: logger)
    }

    /// Retrieves information about the specified finding. GetFinding and GetFindingV2 both use access-analyzer:GetFinding in the Action element of an IAM policy statement. You must have permission to perform the access-analyzer:GetFinding action.
    @Sendable
    @inlinable
    public func getFinding(_ input: GetFindingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFindingResponse {
        try await self.client.execute(
            operation: "GetFinding", 
            path: "/finding/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the specified finding. GetFinding and GetFindingV2 both use access-analyzer:GetFinding in the Action element of an IAM policy statement. You must have permission to perform the access-analyzer:GetFinding action.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer that generated the finding.
    ///   - id: The ID of the finding to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFinding(
        analyzerArn: String,
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFindingResponse {
        let input = GetFindingRequest(
            analyzerArn: analyzerArn, 
            id: id
        )
        return try await self.getFinding(input, logger: logger)
    }

    /// Retrieves information about a finding recommendation for the specified analyzer.
    @Sendable
    @inlinable
    public func getFindingRecommendation(_ input: GetFindingRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFindingRecommendationResponse {
        try await self.client.execute(
            operation: "GetFindingRecommendation", 
            path: "/recommendation/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a finding recommendation for the specified analyzer.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer used to generate the finding recommendation.
    ///   - id: The unique ID for the finding recommendation.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFindingRecommendation(
        analyzerArn: String,
        id: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFindingRecommendationResponse {
        let input = GetFindingRecommendationRequest(
            analyzerArn: analyzerArn, 
            id: id, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getFindingRecommendation(input, logger: logger)
    }

    /// Retrieves information about the specified finding. GetFinding and GetFindingV2 both use access-analyzer:GetFinding in the Action element of an IAM policy statement. You must have permission to perform the access-analyzer:GetFinding action.
    @Sendable
    @inlinable
    public func getFindingV2(_ input: GetFindingV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFindingV2Response {
        try await self.client.execute(
            operation: "GetFindingV2", 
            path: "/findingv2/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the specified finding. GetFinding and GetFindingV2 both use access-analyzer:GetFinding in the Action element of an IAM policy statement. You must have permission to perform the access-analyzer:GetFinding action.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer that generated the finding.
    ///   - id: The ID of the finding to retrieve.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFindingV2(
        analyzerArn: String,
        id: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFindingV2Response {
        let input = GetFindingV2Request(
            analyzerArn: analyzerArn, 
            id: id, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getFindingV2(input, logger: logger)
    }

    /// Retrieves a list of aggregated finding statistics for an external access or unused access analyzer.
    @Sendable
    @inlinable
    public func getFindingsStatistics(_ input: GetFindingsStatisticsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFindingsStatisticsResponse {
        try await self.client.execute(
            operation: "GetFindingsStatistics", 
            path: "/analyzer/findings/statistics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of aggregated finding statistics for an external access or unused access analyzer.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer used to generate the statistics.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFindingsStatistics(
        analyzerArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFindingsStatisticsResponse {
        let input = GetFindingsStatisticsRequest(
            analyzerArn: analyzerArn
        )
        return try await self.getFindingsStatistics(input, logger: logger)
    }

    /// Retrieves the policy that was generated using StartPolicyGeneration.
    @Sendable
    @inlinable
    public func getGeneratedPolicy(_ input: GetGeneratedPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetGeneratedPolicyResponse {
        try await self.client.execute(
            operation: "GetGeneratedPolicy", 
            path: "/policy/generation/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the policy that was generated using StartPolicyGeneration.
    ///
    /// Parameters:
    ///   - includeResourcePlaceholders: The level of detail that you want to generate. You can specify whether to generate policies with placeholders for resource ARNs for actions that support resource level granularity in policies. For example, in the resource section of a policy, you can receive a placeholder such as "Resource":"arn:aws:s3:::${BucketName}" instead of "*".
    ///   - includeServiceLevelTemplate: The level of detail that you want to generate. You can specify whether to generate service-level policies.  IAM Access Analyzer uses iam:servicelastaccessed to identify services that have been used recently to create this service-level template.
    ///   - jobId: The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
    ///   - logger: Logger use during operation
    @inlinable
    public func getGeneratedPolicy(
        includeResourcePlaceholders: Bool? = nil,
        includeServiceLevelTemplate: Bool? = nil,
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetGeneratedPolicyResponse {
        let input = GetGeneratedPolicyRequest(
            includeResourcePlaceholders: includeResourcePlaceholders, 
            includeServiceLevelTemplate: includeServiceLevelTemplate, 
            jobId: jobId
        )
        return try await self.getGeneratedPolicy(input, logger: logger)
    }

    /// Retrieves a list of access preview findings generated by the specified access preview.
    @Sendable
    @inlinable
    public func listAccessPreviewFindings(_ input: ListAccessPreviewFindingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAccessPreviewFindingsResponse {
        try await self.client.execute(
            operation: "ListAccessPreviewFindings", 
            path: "/access-preview/{accessPreviewId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of access preview findings generated by the specified access preview.
    ///
    /// Parameters:
    ///   - accessPreviewId: The unique ID for the access preview.
    ///   - analyzerArn: The ARN of the analyzer used to generate the access.
    ///   - filter: Criteria to filter the returned findings.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAccessPreviewFindings(
        accessPreviewId: String,
        analyzerArn: String,
        filter: [String: Criterion]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAccessPreviewFindingsResponse {
        let input = ListAccessPreviewFindingsRequest(
            accessPreviewId: accessPreviewId, 
            analyzerArn: analyzerArn, 
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAccessPreviewFindings(input, logger: logger)
    }

    /// Retrieves a list of access previews for the specified analyzer.
    @Sendable
    @inlinable
    public func listAccessPreviews(_ input: ListAccessPreviewsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAccessPreviewsResponse {
        try await self.client.execute(
            operation: "ListAccessPreviews", 
            path: "/access-preview", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of access previews for the specified analyzer.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer used to generate the access preview.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAccessPreviews(
        analyzerArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAccessPreviewsResponse {
        let input = ListAccessPreviewsRequest(
            analyzerArn: analyzerArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAccessPreviews(input, logger: logger)
    }

    /// Retrieves a list of resources of the specified type that have been analyzed by the specified analyzer.
    @Sendable
    @inlinable
    public func listAnalyzedResources(_ input: ListAnalyzedResourcesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnalyzedResourcesResponse {
        try await self.client.execute(
            operation: "ListAnalyzedResources", 
            path: "/analyzed-resource", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of resources of the specified type that have been analyzed by the specified analyzer.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer to retrieve a list of analyzed resources from.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - resourceType: The type of resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAnalyzedResources(
        analyzerArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceType: ResourceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAnalyzedResourcesResponse {
        let input = ListAnalyzedResourcesRequest(
            analyzerArn: analyzerArn, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceType: resourceType
        )
        return try await self.listAnalyzedResources(input, logger: logger)
    }

    /// Retrieves a list of analyzers.
    @Sendable
    @inlinable
    public func listAnalyzers(_ input: ListAnalyzersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAnalyzersResponse {
        try await self.client.execute(
            operation: "ListAnalyzers", 
            path: "/analyzer", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of analyzers.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - type: The type of analyzer.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAnalyzers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        type: `Type`? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAnalyzersResponse {
        let input = ListAnalyzersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            type: type
        )
        return try await self.listAnalyzers(input, logger: logger)
    }

    /// Retrieves a list of archive rules created for the specified analyzer.
    @Sendable
    @inlinable
    public func listArchiveRules(_ input: ListArchiveRulesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListArchiveRulesResponse {
        try await self.client.execute(
            operation: "ListArchiveRules", 
            path: "/analyzer/{analyzerName}/archive-rule", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of archive rules created for the specified analyzer.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the analyzer to retrieve rules from.
    ///   - maxResults: The maximum number of results to return in the request.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listArchiveRules(
        analyzerName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListArchiveRulesResponse {
        let input = ListArchiveRulesRequest(
            analyzerName: analyzerName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listArchiveRules(input, logger: logger)
    }

    /// Retrieves a list of findings generated by the specified analyzer. ListFindings and ListFindingsV2 both use access-analyzer:ListFindings in the Action element of an IAM policy statement. You must have permission to perform the access-analyzer:ListFindings action. To learn about filter keys that you can use to retrieve a list of findings, see IAM Access Analyzer filter keys in the IAM User Guide.
    @Sendable
    @inlinable
    public func listFindings(_ input: ListFindingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFindingsResponse {
        try await self.client.execute(
            operation: "ListFindings", 
            path: "/finding", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of findings generated by the specified analyzer. ListFindings and ListFindingsV2 both use access-analyzer:ListFindings in the Action element of an IAM policy statement. You must have permission to perform the access-analyzer:ListFindings action. To learn about filter keys that you can use to retrieve a list of findings, see IAM Access Analyzer filter keys in the IAM User Guide.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer to retrieve findings from.
    ///   - filter: A filter to match for the findings to return.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - sort: The sort order for the findings returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFindings(
        analyzerArn: String,
        filter: [String: Criterion]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: SortCriteria? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFindingsResponse {
        let input = ListFindingsRequest(
            analyzerArn: analyzerArn, 
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sort: sort
        )
        return try await self.listFindings(input, logger: logger)
    }

    /// Retrieves a list of findings generated by the specified analyzer. ListFindings and ListFindingsV2 both use access-analyzer:ListFindings in the Action element of an IAM policy statement. You must have permission to perform the access-analyzer:ListFindings action. To learn about filter keys that you can use to retrieve a list of findings, see IAM Access Analyzer filter keys in the IAM User Guide.
    @Sendable
    @inlinable
    public func listFindingsV2(_ input: ListFindingsV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFindingsV2Response {
        try await self.client.execute(
            operation: "ListFindingsV2", 
            path: "/findingv2", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of findings generated by the specified analyzer. ListFindings and ListFindingsV2 both use access-analyzer:ListFindings in the Action element of an IAM policy statement. You must have permission to perform the access-analyzer:ListFindings action. To learn about filter keys that you can use to retrieve a list of findings, see IAM Access Analyzer filter keys in the IAM User Guide.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer to retrieve findings from.
    ///   - filter: A filter to match for the findings to return.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - sort: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listFindingsV2(
        analyzerArn: String,
        filter: [String: Criterion]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: SortCriteria? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFindingsV2Response {
        let input = ListFindingsV2Request(
            analyzerArn: analyzerArn, 
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sort: sort
        )
        return try await self.listFindingsV2(input, logger: logger)
    }

    /// Lists all of the policy generations requested in the last seven days.
    @Sendable
    @inlinable
    public func listPolicyGenerations(_ input: ListPolicyGenerationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPolicyGenerationsResponse {
        try await self.client.execute(
            operation: "ListPolicyGenerations", 
            path: "/policy/generation", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the policy generations requested in the last seven days.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - principalArn: The ARN of the IAM entity (user or role) for which you are generating a policy. Use this with ListGeneratedPolicies to filter the results to only include results for a specific principal.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicyGenerations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principalArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPolicyGenerationsResponse {
        let input = ListPolicyGenerationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            principalArn: principalArn
        )
        return try await self.listPolicyGenerations(input, logger: logger)
    }

    /// Retrieves a list of tags applied to the specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of tags applied to the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to retrieve tags from.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Starts the policy generation request.
    @Sendable
    @inlinable
    public func startPolicyGeneration(_ input: StartPolicyGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartPolicyGenerationResponse {
        try await self.client.execute(
            operation: "StartPolicyGeneration", 
            path: "/policy/generation", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts the policy generation request.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    ///   - cloudTrailDetails: A CloudTrailDetails object that contains details about a Trail that you want to analyze to generate policies.
    ///   - policyGenerationDetails: Contains the ARN of the IAM entity (user or role) for which you are generating a policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func startPolicyGeneration(
        clientToken: String? = StartPolicyGenerationRequest.idempotencyToken(),
        cloudTrailDetails: CloudTrailDetails? = nil,
        policyGenerationDetails: PolicyGenerationDetails,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartPolicyGenerationResponse {
        let input = StartPolicyGenerationRequest(
            clientToken: clientToken, 
            cloudTrailDetails: cloudTrailDetails, 
            policyGenerationDetails: policyGenerationDetails
        )
        return try await self.startPolicyGeneration(input, logger: logger)
    }

    /// Immediately starts a scan of the policies applied to the specified resource.
    @Sendable
    @inlinable
    public func startResourceScan(_ input: StartResourceScanRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "StartResourceScan", 
            path: "/resource/scan", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Immediately starts a scan of the policies applied to the specified resource.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer to use to scan the policies applied to the specified resource.
    ///   - resourceArn: The ARN of the resource to scan.
    ///   - resourceOwnerAccount: The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
    ///   - logger: Logger use during operation
    @inlinable
    public func startResourceScan(
        analyzerArn: String,
        resourceArn: String,
        resourceOwnerAccount: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = StartResourceScanRequest(
            analyzerArn: analyzerArn, 
            resourceArn: resourceArn, 
            resourceOwnerAccount: resourceOwnerAccount
        )
        return try await self.startResourceScan(input, logger: logger)
    }

    /// Adds a tag to the specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a tag to the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to add the tag to.
    ///   - tags: The tags to add to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a tag from the specified resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a tag from the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to remove the tag from.
    ///   - tagKeys: The key for the tag to add.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Modifies the configuration of an existing analyzer.
    @Sendable
    @inlinable
    public func updateAnalyzer(_ input: UpdateAnalyzerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAnalyzerResponse {
        try await self.client.execute(
            operation: "UpdateAnalyzer", 
            path: "/analyzer/{analyzerName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the configuration of an existing analyzer.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the analyzer to modify.
    ///   - configuration: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAnalyzer(
        analyzerName: String,
        configuration: AnalyzerConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAnalyzerResponse {
        let input = UpdateAnalyzerRequest(
            analyzerName: analyzerName, 
            configuration: configuration
        )
        return try await self.updateAnalyzer(input, logger: logger)
    }

    /// Updates the criteria and values for the specified archive rule.
    @Sendable
    @inlinable
    public func updateArchiveRule(_ input: UpdateArchiveRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateArchiveRule", 
            path: "/analyzer/{analyzerName}/archive-rule/{ruleName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the criteria and values for the specified archive rule.
    ///
    /// Parameters:
    ///   - analyzerName: The name of the analyzer to update the archive rules for.
    ///   - clientToken: A client token.
    ///   - filter: A filter to match for the rules to update. Only rules that match the filter are updated.
    ///   - ruleName: The name of the rule to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateArchiveRule(
        analyzerName: String,
        clientToken: String? = UpdateArchiveRuleRequest.idempotencyToken(),
        filter: [String: Criterion],
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateArchiveRuleRequest(
            analyzerName: analyzerName, 
            clientToken: clientToken, 
            filter: filter, 
            ruleName: ruleName
        )
        return try await self.updateArchiveRule(input, logger: logger)
    }

    /// Updates the status for the specified findings.
    @Sendable
    @inlinable
    public func updateFindings(_ input: UpdateFindingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateFindings", 
            path: "/finding", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the status for the specified findings.
    ///
    /// Parameters:
    ///   - analyzerArn: The ARN of the analyzer that generated the findings to update.
    ///   - clientToken: A client token.
    ///   - ids: The IDs of the findings to update.
    ///   - resourceArn: The ARN of the resource identified in the finding.
    ///   - status: The state represents the action to take to update the finding Status. Use ARCHIVE to change an Active finding to an Archived finding. Use ACTIVE to change an Archived finding to an Active finding.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFindings(
        analyzerArn: String,
        clientToken: String? = UpdateFindingsRequest.idempotencyToken(),
        ids: [String]? = nil,
        resourceArn: String? = nil,
        status: FindingStatusUpdate,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateFindingsRequest(
            analyzerArn: analyzerArn, 
            clientToken: clientToken, 
            ids: ids, 
            resourceArn: resourceArn, 
            status: status
        )
        return try await self.updateFindings(input, logger: logger)
    }

    /// Requests the validation of a policy and returns a list of findings. The findings help you identify issues and provide actionable recommendations to resolve the issue and enable you to author functional policies that meet security best practices.
    @Sendable
    @inlinable
    public func validatePolicy(_ input: ValidatePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ValidatePolicyResponse {
        try await self.client.execute(
            operation: "ValidatePolicy", 
            path: "/policy/validation", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Requests the validation of a policy and returns a list of findings. The findings help you identify issues and provide actionable recommendations to resolve the issue and enable you to author functional policies that meet security best practices.
    ///
    /// Parameters:
    ///   - locale: The locale to use for localizing the findings.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token used for pagination of results returned.
    ///   - policyDocument: The JSON policy document to use as the content for the policy.
    ///   - policyType: The type of policy to validate. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.  Service control policies (SCPs) are a type of organization policy attached to an Amazon Web Services organization, organizational unit (OU), or an account.
    ///   - validatePolicyResourceType: The type of resource to attach to your resource policy. Specify a value for the policy validation resource type only if the policy type is RESOURCE_POLICY. For example, to validate a resource policy to attach to an Amazon S3 bucket, you can choose AWS::S3::Bucket for the policy validation resource type. For resource types not supported as valid values, IAM Access Analyzer runs policy checks that apply to all resource policies. For example, to validate a resource policy to attach to a KMS key, do not specify a value for the policy validation resource type and IAM Access Analyzer will run policy checks that apply to all resource policies.
    ///   - logger: Logger use during operation
    @inlinable
    public func validatePolicy(
        locale: Locale? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyDocument: String,
        policyType: PolicyType,
        validatePolicyResourceType: ValidatePolicyResourceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ValidatePolicyResponse {
        let input = ValidatePolicyRequest(
            locale: locale, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            policyDocument: policyDocument, 
            policyType: policyType, 
            validatePolicyResourceType: validatePolicyResourceType
        )
        return try await self.validatePolicy(input, logger: logger)
    }
}

extension AccessAnalyzer {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: AccessAnalyzer, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension AccessAnalyzer {
    /// Return PaginatorSequence for operation ``getFindingRecommendation(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getFindingRecommendationPaginator(
        _ input: GetFindingRecommendationRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetFindingRecommendationRequest, GetFindingRecommendationResponse> {
        return .init(
            input: input,
            command: self.getFindingRecommendation,
            inputKey: \GetFindingRecommendationRequest.nextToken,
            outputKey: \GetFindingRecommendationResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getFindingRecommendation(_:logger:)``.
    ///
    /// - Parameters:
    ///   - analyzerArn: The ARN of the analyzer used to generate the finding recommendation.
    ///   - id: The unique ID for the finding recommendation.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - logger: Logger used for logging
    @inlinable
    public func getFindingRecommendationPaginator(
        analyzerArn: String,
        id: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetFindingRecommendationRequest, GetFindingRecommendationResponse> {
        let input = GetFindingRecommendationRequest(
            analyzerArn: analyzerArn, 
            id: id, 
            maxResults: maxResults
        )
        return self.getFindingRecommendationPaginator(input, logger: logger)
    }
}

extension AccessAnalyzer.GetFindingRecommendationRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AccessAnalyzer.GetFindingRecommendationRequest {
        return .init(
            analyzerArn: self.analyzerArn,
            id: self.id,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
