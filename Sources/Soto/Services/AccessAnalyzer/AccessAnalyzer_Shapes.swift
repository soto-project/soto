//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension AccessAnalyzer {
    // MARK: Enums

    public enum AccessPreviewStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case creating = "CREATING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum AccessPreviewStatusReasonCode: String, CustomStringConvertible, Codable {
        case internalError = "INTERNAL_ERROR"
        case invalidConfiguration = "INVALID_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum AclPermission: String, CustomStringConvertible, Codable {
        case fullControl = "FULL_CONTROL"
        case read = "READ"
        case readAcp = "READ_ACP"
        case write = "WRITE"
        case writeAcp = "WRITE_ACP"
        public var description: String { return self.rawValue }
    }

    public enum AnalyzerStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case disabled = "DISABLED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum FindingChangeType: String, CustomStringConvertible, Codable {
        case changed = "CHANGED"
        case new = "NEW"
        case unchanged = "UNCHANGED"
        public var description: String { return self.rawValue }
    }

    public enum FindingSourceType: String, CustomStringConvertible, Codable {
        case bucketAcl = "BUCKET_ACL"
        case policy = "POLICY"
        case s3AccessPoint = "S3_ACCESS_POINT"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatusUpdate: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum JobErrorCode: String, CustomStringConvertible, Codable {
        case authorizationError = "AUTHORIZATION_ERROR"
        case resourceNotFoundError = "RESOURCE_NOT_FOUND_ERROR"
        case serviceError = "SERVICE_ERROR"
        case serviceQuotaExceededError = "SERVICE_QUOTA_EXCEEDED_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum KmsGrantOperation: String, CustomStringConvertible, Codable {
        case creategrant = "CreateGrant"
        case decrypt = "Decrypt"
        case describekey = "DescribeKey"
        case encrypt = "Encrypt"
        case generatedatakey = "GenerateDataKey"
        case generatedatakeypair = "GenerateDataKeyPair"
        case generatedatakeypairwithoutplaintext = "GenerateDataKeyPairWithoutPlaintext"
        case generatedatakeywithoutplaintext = "GenerateDataKeyWithoutPlaintext"
        case getpublickey = "GetPublicKey"
        case reencryptfrom = "ReEncryptFrom"
        case reencryptto = "ReEncryptTo"
        case retiregrant = "RetireGrant"
        case sign = "Sign"
        case verify = "Verify"
        public var description: String { return self.rawValue }
    }

    public enum Locale: String, CustomStringConvertible, Codable {
        case de = "DE"
        case en = "EN"
        case es = "ES"
        case fr = "FR"
        case it = "IT"
        case ja = "JA"
        case ko = "KO"
        case ptBr = "PT_BR"
        case zhCn = "ZH_CN"
        case zhTw = "ZH_TW"
        public var description: String { return self.rawValue }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum PolicyType: String, CustomStringConvertible, Codable {
        case identityPolicy = "IDENTITY_POLICY"
        case resourcePolicy = "RESOURCE_POLICY"
        case serviceControlPolicy = "SERVICE_CONTROL_POLICY"
        public var description: String { return self.rawValue }
    }

    public enum ReasonCode: String, CustomStringConvertible, Codable {
        case awsServiceAccessDisabled = "AWS_SERVICE_ACCESS_DISABLED"
        case delegatedAdministratorDeregistered = "DELEGATED_ADMINISTRATOR_DEREGISTERED"
        case organizationDeleted = "ORGANIZATION_DELETED"
        case serviceLinkedRoleCreationFailed = "SERVICE_LINKED_ROLE_CREATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case awsIamRole = "AWS::IAM::Role"
        case awsKmsKey = "AWS::KMS::Key"
        case awsLambdaFunction = "AWS::Lambda::Function"
        case awsLambdaLayerversion = "AWS::Lambda::LayerVersion"
        case awsS3Bucket = "AWS::S3::Bucket"
        case awsSqsQueue = "AWS::SQS::Queue"
        case awsSecretsmanagerSecret = "AWS::SecretsManager::Secret"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case account = "ACCOUNT"
        case organization = "ORGANIZATION"
        public var description: String { return self.rawValue }
    }

    public enum ValidatePolicyFindingType: String, CustomStringConvertible, Codable {
        case error = "ERROR"
        case securityWarning = "SECURITY_WARNING"
        case suggestion = "SUGGESTION"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum AclGrantee: AWSEncodableShape & AWSDecodableShape {
        /// The value specified is the canonical user ID of an Amazon Web Services account.
        case id(String)
        /// Used for granting permissions to a predefined group.
        case uri(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .id:
                let value = try container.decode(String.self, forKey: .id)
                self = .id(value)
            case .uri:
                let value = try container.decode(String.self, forKey: .uri)
                self = .uri(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .id(let value):
                try container.encode(value, forKey: .id)
            case .uri(let value):
                try container.encode(value, forKey: .uri)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case uri
        }
    }

    public enum Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The access control configuration is for an IAM role.
        case iamRole(IamRoleConfiguration)
        /// The access control configuration is for a KMS key.
        case kmsKey(KmsKeyConfiguration)
        /// The access control configuration is for an Amazon S3 Bucket.
        case s3Bucket(S3BucketConfiguration)
        /// The access control configuration is for a Secrets Manager secret.
        case secretsManagerSecret(SecretsManagerSecretConfiguration)
        /// The access control configuration is for an Amazon SQS queue.
        case sqsQueue(SqsQueueConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .iamRole:
                let value = try container.decode(IamRoleConfiguration.self, forKey: .iamRole)
                self = .iamRole(value)
            case .kmsKey:
                let value = try container.decode(KmsKeyConfiguration.self, forKey: .kmsKey)
                self = .kmsKey(value)
            case .s3Bucket:
                let value = try container.decode(S3BucketConfiguration.self, forKey: .s3Bucket)
                self = .s3Bucket(value)
            case .secretsManagerSecret:
                let value = try container.decode(SecretsManagerSecretConfiguration.self, forKey: .secretsManagerSecret)
                self = .secretsManagerSecret(value)
            case .sqsQueue:
                let value = try container.decode(SqsQueueConfiguration.self, forKey: .sqsQueue)
                self = .sqsQueue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .iamRole(let value):
                try container.encode(value, forKey: .iamRole)
            case .kmsKey(let value):
                try container.encode(value, forKey: .kmsKey)
            case .s3Bucket(let value):
                try container.encode(value, forKey: .s3Bucket)
            case .secretsManagerSecret(let value):
                try container.encode(value, forKey: .secretsManagerSecret)
            case .sqsQueue(let value):
                try container.encode(value, forKey: .sqsQueue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3Bucket(let value):
                try value.validate(name: "\(name).s3Bucket")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case iamRole
            case kmsKey
            case s3Bucket
            case secretsManagerSecret
            case sqsQueue
        }
    }

    public enum NetworkOriginConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the Amazon S3 access point or multi-region access point with an Internet origin.
        case internetConfiguration(InternetConfiguration)
        case vpcConfiguration(VpcConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .internetConfiguration:
                let value = try container.decode(InternetConfiguration.self, forKey: .internetConfiguration)
                self = .internetConfiguration(value)
            case .vpcConfiguration:
                let value = try container.decode(VpcConfiguration.self, forKey: .vpcConfiguration)
                self = .vpcConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .internetConfiguration(let value):
                try container.encode(value, forKey: .internetConfiguration)
            case .vpcConfiguration(let value):
                try container.encode(value, forKey: .vpcConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .vpcConfiguration(let value):
                try value.validate(name: "\(name).vpcConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case internetConfiguration
            case vpcConfiguration
        }
    }

    public enum PathElement: AWSDecodableShape {
        /// Refers to an index in a JSON array.
        case index(Int)
        /// Refers to a key in a JSON object.
        case key(String)
        /// Refers to a substring of a literal string in a JSON object.
        case substring(Substring)
        /// Refers to the value associated with a given key in a JSON object.
        case value(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .index:
                let value = try container.decode(Int.self, forKey: .index)
                self = .index(value)
            case .key:
                let value = try container.decode(String.self, forKey: .key)
                self = .key(value)
            case .substring:
                let value = try container.decode(Substring.self, forKey: .substring)
                self = .substring(value)
            case .value:
                let value = try container.decode(String.self, forKey: .value)
                self = .value(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case index
            case key
            case substring
            case value
        }
    }

    // MARK: Shapes

    public struct AccessPreview: AWSDecodableShape {
        /// The ARN of the analyzer used to generate the access preview.
        public let analyzerArn: String
        /// A map of resource ARNs for the proposed resource configuration.
        public let configurations: [String: Configuration]
        /// The time at which the access preview was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique ID for the access preview.
        public let id: String
        /// The status of the access preview.    Creating - The access preview creation is in progress.    Completed - The access preview is complete. You can preview findings for external access to the resource.    Failed - The access preview creation has failed.
        public let status: AccessPreviewStatus
        /// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a Failed status is returned. This failure can be due to an internal issue with the analysis or due to an invalid resource configuration.
        public let statusReason: AccessPreviewStatusReason?

        public init(analyzerArn: String, configurations: [String: Configuration], createdAt: Date, id: String, status: AccessPreviewStatus, statusReason: AccessPreviewStatusReason? = nil) {
            self.analyzerArn = analyzerArn
            self.configurations = configurations
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case configurations
            case createdAt
            case id
            case status
            case statusReason
        }
    }

    public struct AccessPreviewFinding: AWSDecodableShape {
        /// The action in the analyzed policy statement that an external principal has permission to perform.
        public let action: [String]?
        /// Provides context on how the access preview finding compares to existing access identified in IAM Access Analyzer.    New - The finding is for newly-introduced access.    Unchanged - The preview finding is an existing finding that would remain unchanged.    Changed - The preview finding is an existing finding with a change in status.   For example, a Changed finding with preview status Resolved and existing status Active indicates the existing Active finding would become Resolved as a result of the proposed permissions change.
        public let changeType: FindingChangeType
        /// The condition in the analyzed policy statement that resulted in a finding.
        public let condition: [String: String]?
        /// The time at which the access preview finding was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// An error.
        public let error: String?
        /// The existing ID of the finding in IAM Access Analyzer, provided only for existing findings.
        public let existingFindingId: String?
        /// The existing status of the finding, provided only for existing findings.
        public let existingFindingStatus: FindingStatus?
        /// The ID of the access preview finding. This ID uniquely identifies the element in the list of access preview findings and is not related to the finding ID in Access Analyzer.
        public let id: String
        /// Indicates whether the policy that generated the finding allows public access to the resource.
        public let isPublic: Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public let principal: [String: String]?
        /// The resource that an external principal has access to. This is the resource associated with the access preview.
        public let resource: String?
        /// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
        public let resourceOwnerAccount: String
        /// The type of the resource that can be accessed in the finding.
        public let resourceType: ResourceType
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public let sources: [FindingSource]?
        /// The preview status of the finding. This is what the status of the finding would be after permissions deployment. For example, a Changed finding with preview status Resolved and existing status Active indicates the existing Active finding would become Resolved as a result of the proposed permissions change.
        public let status: FindingStatus

        public init(action: [String]? = nil, changeType: FindingChangeType, condition: [String: String]? = nil, createdAt: Date, error: String? = nil, existingFindingId: String? = nil, existingFindingStatus: FindingStatus? = nil, id: String, isPublic: Bool? = nil, principal: [String: String]? = nil, resource: String? = nil, resourceOwnerAccount: String, resourceType: ResourceType, sources: [FindingSource]? = nil, status: FindingStatus) {
            self.action = action
            self.changeType = changeType
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.existingFindingId = existingFindingId
            self.existingFindingStatus = existingFindingStatus
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case changeType
            case condition
            case createdAt
            case error
            case existingFindingId
            case existingFindingStatus
            case id
            case isPublic
            case principal
            case resource
            case resourceOwnerAccount
            case resourceType
            case sources
            case status
        }
    }

    public struct AccessPreviewStatusReason: AWSDecodableShape {
        /// The reason code for the current status of the access preview.
        public let code: AccessPreviewStatusReasonCode

        public init(code: AccessPreviewStatusReasonCode) {
            self.code = code
        }

        private enum CodingKeys: String, CodingKey {
            case code
        }
    }

    public struct AccessPreviewSummary: AWSDecodableShape {
        /// The ARN of the analyzer used to generate the access preview.
        public let analyzerArn: String
        /// The time at which the access preview was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique ID for the access preview.
        public let id: String
        /// The status of the access preview.    Creating - The access preview creation is in progress.    Completed - The access preview is complete and previews the findings for external access to the resource.    Failed - The access preview creation has failed.
        public let status: AccessPreviewStatus
        public let statusReason: AccessPreviewStatusReason?

        public init(analyzerArn: String, createdAt: Date, id: String, status: AccessPreviewStatus, statusReason: AccessPreviewStatusReason? = nil) {
            self.analyzerArn = analyzerArn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case createdAt
            case id
            case status
            case statusReason
        }
    }

    public struct AnalyzedResource: AWSDecodableShape {
        /// The actions that an external principal is granted permission to use by the policy that generated the finding.
        public let actions: [String]?
        /// The time at which the resource was analyzed.
        @CustomCoding<ISO8601DateCoder>
        public var analyzedAt: Date
        /// The time at which the finding was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// An error message.
        public let error: String?
        /// Indicates whether the policy that generated the finding grants public access to the resource.
        public let isPublic: Bool
        /// The ARN of the resource that was analyzed.
        public let resourceArn: String
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of the resource that was analyzed.
        public let resourceType: ResourceType
        /// Indicates how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
        public let sharedVia: [String]?
        /// The current status of the finding generated from the analyzed resource.
        public let status: FindingStatus?
        /// The time at which the finding was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(actions: [String]? = nil, analyzedAt: Date, createdAt: Date, error: String? = nil, isPublic: Bool, resourceArn: String, resourceOwnerAccount: String, resourceType: ResourceType, sharedVia: [String]? = nil, status: FindingStatus? = nil, updatedAt: Date) {
            self.actions = actions
            self.analyzedAt = analyzedAt
            self.createdAt = createdAt
            self.error = error
            self.isPublic = isPublic
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sharedVia = sharedVia
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case analyzedAt
            case createdAt
            case error
            case isPublic
            case resourceArn
            case resourceOwnerAccount
            case resourceType
            case sharedVia
            case status
            case updatedAt
        }
    }

    public struct AnalyzedResourceSummary: AWSDecodableShape {
        /// The ARN of the analyzed resource.
        public let resourceArn: String
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of resource that was analyzed.
        public let resourceType: ResourceType

        public init(resourceArn: String, resourceOwnerAccount: String, resourceType: ResourceType) {
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn
            case resourceOwnerAccount
            case resourceType
        }
    }

    public struct AnalyzerSummary: AWSDecodableShape {
        /// The ARN of the analyzer.
        public let arn: String
        /// A timestamp for the time at which the analyzer was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The resource that was most recently analyzed by the analyzer.
        public let lastResourceAnalyzed: String?
        /// The time at which the most recently analyzed resource was analyzed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastResourceAnalyzedAt: Date?
        /// The name of the analyzer.
        public let name: String
        /// The status of the analyzer. An Active analyzer successfully monitors supported resources and generates new findings. The analyzer is Disabled when a user action, such as removing trusted access for Identity and Access Management Access Analyzer from Organizations, causes the analyzer to stop generating new findings. The status is Creating when the analyzer creation is in progress and Failed when the analyzer creation has failed.
        public let status: AnalyzerStatus
        /// The statusReason provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a Failed status is returned. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the Amazon Web Services organization.
        public let statusReason: StatusReason?
        /// The tags added to the analyzer.
        public let tags: [String: String]?
        /// The type of analyzer, which corresponds to the zone of trust chosen for the analyzer.
        public let type: `Type`

        public init(arn: String, createdAt: Date, lastResourceAnalyzed: String? = nil, lastResourceAnalyzedAt: Date? = nil, name: String, status: AnalyzerStatus, statusReason: StatusReason? = nil, tags: [String: String]? = nil, type: `Type`) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastResourceAnalyzed = lastResourceAnalyzed
            self.lastResourceAnalyzedAt = lastResourceAnalyzedAt
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case lastResourceAnalyzed
            case lastResourceAnalyzedAt
            case name
            case status
            case statusReason
            case tags
            case type
        }
    }

    public struct ApplyArchiveRuleRequest: AWSEncodableShape {
        /// The Amazon resource name (ARN) of the analyzer.
        public let analyzerArn: String
        /// A client token.
        public let clientToken: String?
        /// The name of the rule to apply.
        public let ruleName: String

        public init(analyzerArn: String, clientToken: String? = ApplyArchiveRuleRequest.idempotencyToken(), ruleName: String) {
            self.analyzerArn = analyzerArn
            self.clientToken = clientToken
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case clientToken
            case ruleName
        }
    }

    public struct ArchiveRuleSummary: AWSDecodableShape {
        /// The time at which the archive rule was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A filter used to define the archive rule.
        public let filter: [String: Criterion]
        /// The name of the archive rule.
        public let ruleName: String
        /// The time at which the archive rule was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(createdAt: Date, filter: [String: Criterion], ruleName: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.filter = filter
            self.ruleName = ruleName
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case filter
            case ruleName
            case updatedAt
        }
    }

    public struct CancelPolicyGenerationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId"))
        ]

        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelPolicyGenerationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CloudTrailDetails: AWSEncodableShape {
        /// The ARN of the service role that IAM Access Analyzer uses to access your CloudTrail trail and service last accessed information.
        public let accessRole: String
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp after this time are not considered to generate a policy. If this is not included in the request, the default value is the current time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp before this time are not considered to generate a policy.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// A Trail object that contains settings for a trail.
        public let trails: [Trail]

        public init(accessRole: String, endTime: Date? = nil, startTime: Date, trails: [Trail]) {
            self.accessRole = accessRole
            self.endTime = endTime
            self.startTime = startTime
            self.trails = trails
        }

        public func validate(name: String) throws {
            try self.validate(self.accessRole, name: "accessRole", parent: name, pattern: "^arn:[^:]*:iam::[^:]*:role/.{1,576}$")
            try self.trails.forEach {
                try $0.validate(name: "\(name).trails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessRole
            case endTime
            case startTime
            case trails
        }
    }

    public struct CloudTrailProperties: AWSDecodableShape {
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp after this time are not considered to generate a policy. If this is not included in the request, the default value is the current time.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp before this time are not considered to generate a policy.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// A TrailProperties object that contains settings for trail properties.
        public let trailProperties: [TrailProperties]

        public init(endTime: Date, startTime: Date, trailProperties: [TrailProperties]) {
            self.endTime = endTime
            self.startTime = startTime
            self.trailProperties = trailProperties
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case startTime
            case trailProperties
        }
    }

    public struct CreateAccessPreviewRequest: AWSEncodableShape {
        /// The ARN of the account analyzer used to generate the access preview. You can only create an access preview for analyzers with an Account type and Active status.
        public let analyzerArn: String
        /// A client token.
        public let clientToken: String?
        /// Access control configuration for your resource that is used to generate the access preview. The access preview includes findings for external access allowed to the resource with the proposed access control configuration. The configuration must contain exactly one element.
        public let configurations: [String: Configuration]

        public init(analyzerArn: String, clientToken: String? = CreateAccessPreviewRequest.idempotencyToken(), configurations: [String: Configuration]) {
            self.analyzerArn = analyzerArn
            self.clientToken = clientToken
            self.configurations = configurations
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.configurations.forEach {
                try $0.value.validate(name: "\(name).configurations[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case clientToken
            case configurations
        }
    }

    public struct CreateAccessPreviewResponse: AWSDecodableShape {
        /// The unique ID for the access preview.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct CreateAnalyzerRequest: AWSEncodableShape {
        /// The name of the analyzer to create.
        public let analyzerName: String
        /// Specifies the archive rules to add for the analyzer. Archive rules automatically archive findings that meet the criteria you define for the rule.
        public let archiveRules: [InlineArchiveRule]?
        /// A client token.
        public let clientToken: String?
        /// The tags to apply to the analyzer.
        public let tags: [String: String]?
        /// The type of analyzer to create. Only ACCOUNT and ORGANIZATION analyzers are supported. You can create only one analyzer per account per Region. You can create up to 5 analyzers per organization per Region.
        public let type: `Type`

        public init(analyzerName: String, archiveRules: [InlineArchiveRule]? = nil, clientToken: String? = CreateAnalyzerRequest.idempotencyToken(), tags: [String: String]? = nil, type: `Type`) {
            self.analyzerName = analyzerName
            self.archiveRules = archiveRules
            self.clientToken = clientToken
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.archiveRules?.forEach {
                try $0.validate(name: "\(name).archiveRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerName
            case archiveRules
            case clientToken
            case tags
            case type
        }
    }

    public struct CreateAnalyzerResponse: AWSDecodableShape {
        /// The ARN of the analyzer that was created by the request.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct CreateArchiveRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerName", location: .uri(locationName: "analyzerName"))
        ]

        /// The name of the created analyzer.
        public let analyzerName: String
        /// A client token.
        public let clientToken: String?
        /// The criteria for the rule.
        public let filter: [String: Criterion]
        /// The name of the rule to create.
        public let ruleName: String

        public init(analyzerName: String, clientToken: String? = CreateArchiveRuleRequest.idempotencyToken(), filter: [String: Criterion], ruleName: String) {
            self.analyzerName = analyzerName
            self.clientToken = clientToken
            self.filter = filter
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.filter.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case filter
            case ruleName
        }
    }

    public struct Criterion: AWSEncodableShape & AWSDecodableShape {
        /// A "contains" operator to match for the filter used to create the rule.
        public let contains: [String]?
        /// An "equals" operator to match for the filter used to create the rule.
        public let eq: [String]?
        /// An "exists" operator to match for the filter used to create the rule.
        public let exists: Bool?
        /// A "not equals" operator to match for the filter used to create the rule.
        public let neq: [String]?

        public init(contains: [String]? = nil, eq: [String]? = nil, exists: Bool? = nil, neq: [String]? = nil) {
            self.contains = contains
            self.eq = eq
            self.exists = exists
            self.neq = neq
        }

        public func validate(name: String) throws {
            try self.validate(self.contains, name: "contains", parent: name, max: 20)
            try self.validate(self.contains, name: "contains", parent: name, min: 1)
            try self.validate(self.eq, name: "eq", parent: name, max: 20)
            try self.validate(self.eq, name: "eq", parent: name, min: 1)
            try self.validate(self.neq, name: "neq", parent: name, max: 20)
            try self.validate(self.neq, name: "neq", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contains
            case eq
            case exists
            case neq
        }
    }

    public struct DeleteAnalyzerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerName", location: .uri(locationName: "analyzerName")),
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken"))
        ]

        /// The name of the analyzer to delete.
        public let analyzerName: String
        /// A client token.
        public let clientToken: String?

        public init(analyzerName: String, clientToken: String? = DeleteAnalyzerRequest.idempotencyToken()) {
            self.analyzerName = analyzerName
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteArchiveRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerName", location: .uri(locationName: "analyzerName")),
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken")),
            AWSMemberEncoding(label: "ruleName", location: .uri(locationName: "ruleName"))
        ]

        /// The name of the analyzer that associated with the archive rule to delete.
        public let analyzerName: String
        /// A client token.
        public let clientToken: String?
        /// The name of the rule to delete.
        public let ruleName: String

        public init(analyzerName: String, clientToken: String? = DeleteArchiveRuleRequest.idempotencyToken(), ruleName: String) {
            self.analyzerName = analyzerName
            self.clientToken = clientToken
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct Finding: AWSDecodableShape {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public let action: [String]?
        /// The time at which the resource was analyzed.
        @CustomCoding<ISO8601DateCoder>
        public var analyzedAt: Date
        /// The condition in the analyzed policy statement that resulted in a finding.
        public let condition: [String: String]
        /// The time at which the finding was generated.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// An error.
        public let error: String?
        /// The ID of the finding.
        public let id: String
        /// Indicates whether the policy that generated the finding allows public access to the resource.
        public let isPublic: Bool?
        /// The external principal that access to a resource within the zone of trust.
        public let principal: [String: String]?
        /// The resource that an external principal has access to.
        public let resource: String?
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of the resource identified in the finding.
        public let resourceType: ResourceType
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public let sources: [FindingSource]?
        /// The current status of the finding.
        public let status: FindingStatus
        /// The time at which the finding was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(action: [String]? = nil, analyzedAt: Date, condition: [String: String], createdAt: Date, error: String? = nil, id: String, isPublic: Bool? = nil, principal: [String: String]? = nil, resource: String? = nil, resourceOwnerAccount: String, resourceType: ResourceType, sources: [FindingSource]? = nil, status: FindingStatus, updatedAt: Date) {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case analyzedAt
            case condition
            case createdAt
            case error
            case id
            case isPublic
            case principal
            case resource
            case resourceOwnerAccount
            case resourceType
            case sources
            case status
            case updatedAt
        }
    }

    public struct FindingSource: AWSDecodableShape {
        /// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
        public let detail: FindingSourceDetail?
        /// Indicates the type of access that generated the finding.
        public let type: FindingSourceType

        public init(detail: FindingSourceDetail? = nil, type: FindingSourceType) {
            self.detail = detail
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case detail
            case type
        }
    }

    public struct FindingSourceDetail: AWSDecodableShape {
        /// The ARN of the access point that generated the finding. The ARN format depends on whether the ARN represents an access point or a multi-region access point.
        public let accessPointArn: String?

        public init(accessPointArn: String? = nil) {
            self.accessPointArn = accessPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointArn
        }
    }

    public struct FindingSummary: AWSDecodableShape {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public let action: [String]?
        /// The time at which the resource-based policy that generated the finding was analyzed.
        @CustomCoding<ISO8601DateCoder>
        public var analyzedAt: Date
        /// The condition in the analyzed policy statement that resulted in a finding.
        public let condition: [String: String]
        /// The time at which the finding was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The error that resulted in an Error finding.
        public let error: String?
        /// The ID of the finding.
        public let id: String
        /// Indicates whether the finding reports a resource that has a policy that allows public access.
        public let isPublic: Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public let principal: [String: String]?
        /// The resource that the external principal has access to.
        public let resource: String?
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of the resource that the external principal has access to.
        public let resourceType: ResourceType
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public let sources: [FindingSource]?
        /// The status of the finding.
        public let status: FindingStatus
        /// The time at which the finding was most recently updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(action: [String]? = nil, analyzedAt: Date, condition: [String: String], createdAt: Date, error: String? = nil, id: String, isPublic: Bool? = nil, principal: [String: String]? = nil, resource: String? = nil, resourceOwnerAccount: String, resourceType: ResourceType, sources: [FindingSource]? = nil, status: FindingStatus, updatedAt: Date) {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case analyzedAt
            case condition
            case createdAt
            case error
            case id
            case isPublic
            case principal
            case resource
            case resourceOwnerAccount
            case resourceType
            case sources
            case status
            case updatedAt
        }
    }

    public struct GeneratedPolicy: AWSDecodableShape {
        /// The text to use as the content for the new policy. The policy is created using the CreatePolicy action.
        public let policy: String

        public init(policy: String) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy
        }
    }

    public struct GeneratedPolicyProperties: AWSDecodableShape {
        /// Lists details about the Trail used to generated policy.
        public let cloudTrailProperties: CloudTrailProperties?
        /// This value is set to true if the generated policy contains all possible actions for a service that IAM Access Analyzer identified from the CloudTrail trail that you specified, and false otherwise.
        public let isComplete: Bool?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        public let principalArn: String

        public init(cloudTrailProperties: CloudTrailProperties? = nil, isComplete: Bool? = nil, principalArn: String) {
            self.cloudTrailProperties = cloudTrailProperties
            self.isComplete = isComplete
            self.principalArn = principalArn
        }

        private enum CodingKeys: String, CodingKey {
            case cloudTrailProperties
            case isComplete
            case principalArn
        }
    }

    public struct GeneratedPolicyResult: AWSDecodableShape {
        /// The text to use as the content for the new policy. The policy is created using the CreatePolicy action.
        public let generatedPolicies: [GeneratedPolicy]?
        /// A GeneratedPolicyProperties object that contains properties of the generated policy.
        public let properties: GeneratedPolicyProperties

        public init(generatedPolicies: [GeneratedPolicy]? = nil, properties: GeneratedPolicyProperties) {
            self.generatedPolicies = generatedPolicies
            self.properties = properties
        }

        private enum CodingKeys: String, CodingKey {
            case generatedPolicies
            case properties
        }
    }

    public struct GetAccessPreviewRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPreviewId", location: .uri(locationName: "accessPreviewId")),
            AWSMemberEncoding(label: "analyzerArn", location: .querystring(locationName: "analyzerArn"))
        ]

        /// The unique ID for the access preview.
        public let accessPreviewId: String
        /// The ARN of the analyzer used to generate the access preview.
        public let analyzerArn: String

        public init(accessPreviewId: String, analyzerArn: String) {
            self.accessPreviewId = accessPreviewId
            self.analyzerArn = analyzerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPreviewId, name: "accessPreviewId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPreviewResponse: AWSDecodableShape {
        /// An object that contains information about the access preview.
        public let accessPreview: AccessPreview

        public init(accessPreview: AccessPreview) {
            self.accessPreview = accessPreview
        }

        private enum CodingKeys: String, CodingKey {
            case accessPreview
        }
    }

    public struct GetAnalyzedResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerArn", location: .querystring(locationName: "analyzerArn")),
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The ARN of the analyzer to retrieve information from.
        public let analyzerArn: String
        /// The ARN of the resource to retrieve information about.
        public let resourceArn: String

        public init(analyzerArn: String, resourceArn: String) {
            self.analyzerArn = analyzerArn
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnalyzedResourceResponse: AWSDecodableShape {
        /// An AnalyzedResource object that contains information that IAM Access Analyzer found when it analyzed the resource.
        public let resource: AnalyzedResource?

        public init(resource: AnalyzedResource? = nil) {
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case resource
        }
    }

    public struct GetAnalyzerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerName", location: .uri(locationName: "analyzerName"))
        ]

        /// The name of the analyzer retrieved.
        public let analyzerName: String

        public init(analyzerName: String) {
            self.analyzerName = analyzerName
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnalyzerResponse: AWSDecodableShape {
        /// An AnalyzerSummary object that contains information about the analyzer.
        public let analyzer: AnalyzerSummary

        public init(analyzer: AnalyzerSummary) {
            self.analyzer = analyzer
        }

        private enum CodingKeys: String, CodingKey {
            case analyzer
        }
    }

    public struct GetArchiveRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerName", location: .uri(locationName: "analyzerName")),
            AWSMemberEncoding(label: "ruleName", location: .uri(locationName: "ruleName"))
        ]

        /// The name of the analyzer to retrieve rules from.
        public let analyzerName: String
        /// The name of the rule to retrieve.
        public let ruleName: String

        public init(analyzerName: String, ruleName: String) {
            self.analyzerName = analyzerName
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetArchiveRuleResponse: AWSDecodableShape {
        public let archiveRule: ArchiveRuleSummary

        public init(archiveRule: ArchiveRuleSummary) {
            self.archiveRule = archiveRule
        }

        private enum CodingKeys: String, CodingKey {
            case archiveRule
        }
    }

    public struct GetFindingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerArn", location: .querystring(locationName: "analyzerArn")),
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        /// The ARN of the analyzer that generated the finding.
        public let analyzerArn: String
        /// The ID of the finding to retrieve.
        public let id: String

        public init(analyzerArn: String, id: String) {
            self.analyzerArn = analyzerArn
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingResponse: AWSDecodableShape {
        /// A finding object that contains finding details.
        public let finding: Finding?

        public init(finding: Finding? = nil) {
            self.finding = finding
        }

        private enum CodingKeys: String, CodingKey {
            case finding
        }
    }

    public struct GetGeneratedPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "includeResourcePlaceholders", location: .querystring(locationName: "includeResourcePlaceholders")),
            AWSMemberEncoding(label: "includeServiceLevelTemplate", location: .querystring(locationName: "includeServiceLevelTemplate")),
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId"))
        ]

        /// The level of detail that you want to generate. You can specify whether to generate policies with placeholders for resource ARNs for actions that support resource level granularity in policies. For example, in the resource section of a policy, you can receive a placeholder such as "Resource":"arn:aws:s3:::${BucketName}" instead of "*".
        public let includeResourcePlaceholders: Bool?
        /// The level of detail that you want to generate. You can specify whether to generate service-level policies.  IAM Access Analyzer uses iam:servicelastaccessed to identify services that have been used recently to create this service-level template.
        public let includeServiceLevelTemplate: Bool?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String

        public init(includeResourcePlaceholders: Bool? = nil, includeServiceLevelTemplate: Bool? = nil, jobId: String) {
            self.includeResourcePlaceholders = includeResourcePlaceholders
            self.includeServiceLevelTemplate = includeServiceLevelTemplate
            self.jobId = jobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGeneratedPolicyResponse: AWSDecodableShape {
        /// A GeneratedPolicyResult object that contains the generated policies and associated details.
        public let generatedPolicyResult: GeneratedPolicyResult
        /// A GeneratedPolicyDetails object that contains details about the generated policy.
        public let jobDetails: JobDetails

        public init(generatedPolicyResult: GeneratedPolicyResult, jobDetails: JobDetails) {
            self.generatedPolicyResult = generatedPolicyResult
            self.jobDetails = jobDetails
        }

        private enum CodingKeys: String, CodingKey {
            case generatedPolicyResult
            case jobDetails
        }
    }

    public struct IamRoleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The proposed trust policy for the IAM role.
        public let trustPolicy: String?

        public init(trustPolicy: String? = nil) {
            self.trustPolicy = trustPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case trustPolicy
        }
    }

    public struct InlineArchiveRule: AWSEncodableShape {
        /// The condition and values for a criterion.
        public let filter: [String: Criterion]
        /// The name of the rule.
        public let ruleName: String

        public init(filter: [String: Criterion], ruleName: String) {
            self.filter = filter
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.filter.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case ruleName
        }
    }

    public struct InternetConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct JobDetails: AWSDecodableShape {
        /// A timestamp of when the job was completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedOn: Date?
        /// The job error for the policy generation request.
        public let jobError: JobError?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String
        /// A timestamp of when the job was started.
        @CustomCoding<ISO8601DateCoder>
        public var startedOn: Date
        /// The status of the job request.
        public let status: JobStatus

        public init(completedOn: Date? = nil, jobError: JobError? = nil, jobId: String, startedOn: Date, status: JobStatus) {
            self.completedOn = completedOn
            self.jobError = jobError
            self.jobId = jobId
            self.startedOn = startedOn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn
            case jobError
            case jobId
            case startedOn
            case status
        }
    }

    public struct JobError: AWSDecodableShape {
        /// The job error code.
        public let code: JobErrorCode
        /// Specific information about the error. For example, which service quota was exceeded or which resource was not found.
        public let message: String

        public init(code: JobErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct KmsGrantConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Use this structure to propose allowing cryptographic operations in the grant only when the operation request includes the specified encryption context.
        public let constraints: KmsGrantConstraints?
        /// The principal that is given permission to perform the operations that the grant permits.
        public let granteePrincipal: String
        ///  The Amazon Web Services account under which the grant was issued. The account is used to propose KMS grants issued by accounts other than the owner of the key.
        public let issuingAccount: String
        /// A list of operations that the grant permits.
        public let operations: [KmsGrantOperation]
        /// The principal that is given permission to retire the grant by using RetireGrant operation.
        public let retiringPrincipal: String?

        public init(constraints: KmsGrantConstraints? = nil, granteePrincipal: String, issuingAccount: String, operations: [KmsGrantOperation], retiringPrincipal: String? = nil) {
            self.constraints = constraints
            self.granteePrincipal = granteePrincipal
            self.issuingAccount = issuingAccount
            self.operations = operations
            self.retiringPrincipal = retiringPrincipal
        }

        private enum CodingKeys: String, CodingKey {
            case constraints
            case granteePrincipal
            case issuingAccount
            case operations
            case retiringPrincipal
        }
    }

    public struct KmsGrantConstraints: AWSEncodableShape & AWSDecodableShape {
        /// A list of key-value pairs that must match the encryption context in the cryptographic operation request. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint.
        public let encryptionContextEquals: [String: String]?
        /// A list of key-value pairs that must be included in the encryption context of the cryptographic operation request. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs.
        public let encryptionContextSubset: [String: String]?

        public init(encryptionContextEquals: [String: String]? = nil, encryptionContextSubset: [String: String]? = nil) {
            self.encryptionContextEquals = encryptionContextEquals
            self.encryptionContextSubset = encryptionContextSubset
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionContextEquals
            case encryptionContextSubset
        }
    }

    public struct KmsKeyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of proposed grant configurations for the KMS key. If the proposed grant configuration is for an existing key, the access preview uses the proposed list of grant configurations in place of the existing grants. Otherwise, the access preview uses the existing grants for the key.
        public let grants: [KmsGrantConfiguration]?
        /// Resource policy configuration for the KMS key. The only valid value for the name of the key policy is default. For more information, see Default key policy.
        public let keyPolicies: [String: String]?

        public init(grants: [KmsGrantConfiguration]? = nil, keyPolicies: [String: String]? = nil) {
            self.grants = grants
            self.keyPolicies = keyPolicies
        }

        private enum CodingKeys: String, CodingKey {
            case grants
            case keyPolicies
        }
    }

    public struct ListAccessPreviewFindingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPreviewId", location: .uri(locationName: "accessPreviewId"))
        ]

        /// The unique ID for the access preview.
        public let accessPreviewId: String
        /// The ARN of the analyzer used to generate the access.
        public let analyzerArn: String
        /// Criteria to filter the returned findings.
        public let filter: [String: Criterion]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(accessPreviewId: String, analyzerArn: String, filter: [String: Criterion]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accessPreviewId = accessPreviewId
            self.analyzerArn = analyzerArn
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPreviewId, name: "accessPreviewId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.filter?.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case filter
            case maxResults
            case nextToken
        }
    }

    public struct ListAccessPreviewFindingsResponse: AWSDecodableShape {
        /// A list of access preview findings that match the specified filter criteria.
        public let findings: [AccessPreviewFinding]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(findings: [AccessPreviewFinding], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings
            case nextToken
        }
    }

    public struct ListAccessPreviewsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerArn", location: .querystring(locationName: "analyzerArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The ARN of the analyzer used to generate the access preview.
        public let analyzerArn: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzerArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.analyzerArn = analyzerArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPreviewsResponse: AWSDecodableShape {
        /// A list of access previews retrieved for the analyzer.
        public let accessPreviews: [AccessPreviewSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(accessPreviews: [AccessPreviewSummary], nextToken: String? = nil) {
            self.accessPreviews = accessPreviews
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPreviews
            case nextToken
        }
    }

    public struct ListAnalyzedResourcesRequest: AWSEncodableShape {
        /// The ARN of the analyzer to retrieve a list of analyzed resources from.
        public let analyzerArn: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The type of resource.
        public let resourceType: ResourceType?

        public init(analyzerArn: String, maxResults: Int? = nil, nextToken: String? = nil, resourceType: ResourceType? = nil) {
            self.analyzerArn = analyzerArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case maxResults
            case nextToken
            case resourceType
        }
    }

    public struct ListAnalyzedResourcesResponse: AWSDecodableShape {
        /// A list of resources that were analyzed.
        public let analyzedResources: [AnalyzedResourceSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzedResources: [AnalyzedResourceSummary], nextToken: String? = nil) {
            self.analyzedResources = analyzedResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedResources
            case nextToken
        }
    }

    public struct ListAnalyzersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "type", location: .querystring(locationName: "type"))
        ]

        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The type of analyzer.
        public let type: `Type`?

        public init(maxResults: Int? = nil, nextToken: String? = nil, type: `Type`? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalyzersResponse: AWSDecodableShape {
        /// The analyzers retrieved.
        public let analyzers: [AnalyzerSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzers: [AnalyzerSummary], nextToken: String? = nil) {
            self.analyzers = analyzers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analyzers
            case nextToken
        }
    }

    public struct ListArchiveRulesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerName", location: .uri(locationName: "analyzerName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The name of the analyzer to retrieve rules from.
        public let analyzerName: String
        /// The maximum number of results to return in the request.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzerName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.analyzerName = analyzerName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListArchiveRulesResponse: AWSDecodableShape {
        /// A list of archive rules created for the specified analyzer.
        public let archiveRules: [ArchiveRuleSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(archiveRules: [ArchiveRuleSummary], nextToken: String? = nil) {
            self.archiveRules = archiveRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case archiveRules
            case nextToken
        }
    }

    public struct ListFindingsRequest: AWSEncodableShape {
        /// The ARN of the analyzer to retrieve findings from.
        public let analyzerArn: String
        /// A filter to match for the findings to return.
        public let filter: [String: Criterion]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The sort order for the findings returned.
        public let sort: SortCriteria?

        public init(analyzerArn: String, filter: [String: Criterion]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: SortCriteria? = nil) {
            self.analyzerArn = analyzerArn
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.filter?.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case filter
            case maxResults
            case nextToken
            case sort
        }
    }

    public struct ListFindingsResponse: AWSDecodableShape {
        /// A list of findings retrieved from the analyzer that match the filter criteria specified, if any.
        public let findings: [FindingSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(findings: [FindingSummary], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings
            case nextToken
        }
    }

    public struct ListPolicyGenerationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "principalArn", location: .querystring(locationName: "principalArn"))
        ]

        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy. Use this with ListGeneratedPolicies to filter the results to only include results for a specific principal.
        public let principalArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, principalArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalArn = principalArn
        }

        public func validate(name: String) throws {
            try self.validate(self.principalArn, name: "principalArn", parent: name, pattern: "^arn:[^:]*:iam::[^:]*:(role|user)/.{1,576}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPolicyGenerationsResponse: AWSDecodableShape {
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// A PolicyGeneration object that contains details about the generated policy.
        public let policyGenerations: [PolicyGeneration]

        public init(nextToken: String? = nil, policyGenerations: [PolicyGeneration]) {
            self.nextToken = nextToken
            self.policyGenerations = policyGenerations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case policyGenerations
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The ARN of the resource to retrieve tags from.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags that are applied to the specified resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct Location: AWSDecodableShape {
        /// A path in a policy, represented as a sequence of path elements.
        public let path: [PathElement]
        /// A span in a policy.
        public let span: Span

        public init(path: [PathElement], span: Span) {
            self.path = path
            self.span = span
        }

        private enum CodingKeys: String, CodingKey {
            case path
            case span
        }
    }

    public struct PolicyGeneration: AWSDecodableShape {
        /// A timestamp of when the policy generation was completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedOn: Date?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        public let principalArn: String
        /// A timestamp of when the policy generation started.
        @CustomCoding<ISO8601DateCoder>
        public var startedOn: Date
        /// The status of the policy generation request.
        public let status: JobStatus

        public init(completedOn: Date? = nil, jobId: String, principalArn: String, startedOn: Date, status: JobStatus) {
            self.completedOn = completedOn
            self.jobId = jobId
            self.principalArn = principalArn
            self.startedOn = startedOn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn
            case jobId
            case principalArn
            case startedOn
            case status
        }
    }

    public struct PolicyGenerationDetails: AWSEncodableShape {
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        public let principalArn: String

        public init(principalArn: String) {
            self.principalArn = principalArn
        }

        public func validate(name: String) throws {
            try self.validate(self.principalArn, name: "principalArn", parent: name, pattern: "^arn:[^:]*:iam::[^:]*:(role|user)/.{1,576}$")
        }

        private enum CodingKeys: String, CodingKey {
            case principalArn
        }
    }

    public struct Position: AWSDecodableShape {
        /// The column of the position, starting from 0.
        public let column: Int
        /// The line of the position, starting from 1.
        public let line: Int
        /// The offset within the policy that corresponds to the position, starting from 0.
        public let offset: Int

        public init(column: Int, line: Int, offset: Int) {
            self.column = column
            self.line = line
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case column
            case line
            case offset
        }
    }

    public struct S3AccessPointConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The access point or multi-region access point policy.
        public let accessPointPolicy: String?
        /// The proposed Internet and VpcConfiguration to apply to this Amazon S3 access point. VpcConfiguration does not apply to multi-region access points. If the access preview is for a new resource and neither is specified, the access preview uses Internet for the network origin. If the access preview is for an existing resource and neither is specified, the access preview uses the exiting network origin.
        public let networkOrigin: NetworkOriginConfiguration?
        /// The proposed S3PublicAccessBlock configuration to apply to this Amazon S3 access point or multi-region access point.
        public let publicAccessBlock: S3PublicAccessBlockConfiguration?

        public init(accessPointPolicy: String? = nil, networkOrigin: NetworkOriginConfiguration? = nil, publicAccessBlock: S3PublicAccessBlockConfiguration? = nil) {
            self.accessPointPolicy = accessPointPolicy
            self.networkOrigin = networkOrigin
            self.publicAccessBlock = publicAccessBlock
        }

        public func validate(name: String) throws {
            try self.networkOrigin?.validate(name: "\(name).networkOrigin")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointPolicy
            case networkOrigin
            case publicAccessBlock
        }
    }

    public struct S3BucketAclGrantConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The grantee to whom you’re assigning access rights.
        public let grantee: AclGrantee
        /// The permissions being granted.
        public let permission: AclPermission

        public init(grantee: AclGrantee, permission: AclPermission) {
            self.grantee = grantee
            self.permission = permission
        }

        private enum CodingKeys: String, CodingKey {
            case grantee
            case permission
        }
    }

    public struct S3BucketConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of Amazon S3 access points or multi-region access points for the bucket. You can propose up to 10 new access points per bucket.
        public let accessPoints: [String: S3AccessPointConfiguration]?
        /// The proposed list of ACL grants for the Amazon S3 bucket. You can propose up to 100 ACL grants per bucket. If the proposed grant configuration is for an existing bucket, the access preview uses the proposed list of grant configurations in place of the existing grants. Otherwise, the access preview uses the existing grants for the bucket.
        public let bucketAclGrants: [S3BucketAclGrantConfiguration]?
        /// The proposed bucket policy for the Amazon S3 bucket.
        public let bucketPolicy: String?
        /// The proposed block public access configuration for the Amazon S3 bucket.
        public let bucketPublicAccessBlock: S3PublicAccessBlockConfiguration?

        public init(accessPoints: [String: S3AccessPointConfiguration]? = nil, bucketAclGrants: [S3BucketAclGrantConfiguration]? = nil, bucketPolicy: String? = nil, bucketPublicAccessBlock: S3PublicAccessBlockConfiguration? = nil) {
            self.accessPoints = accessPoints
            self.bucketAclGrants = bucketAclGrants
            self.bucketPolicy = bucketPolicy
            self.bucketPublicAccessBlock = bucketPublicAccessBlock
        }

        public func validate(name: String) throws {
            try self.accessPoints?.forEach {
                try validate($0.key, name: "accessPoints.key", parent: name, pattern: "^arn:[^:]*:s3:[^:]*:[^:]*:accesspoint/.*$")
                try $0.value.validate(name: "\(name).accessPoints[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints
            case bucketAclGrants
            case bucketPolicy
            case bucketPublicAccessBlock
        }
    }

    public struct S3PublicAccessBlockConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket.
        public let ignorePublicAcls: Bool
        ///  Specifies whether Amazon S3 should restrict public bucket policies for this bucket.
        public let restrictPublicBuckets: Bool

        public init(ignorePublicAcls: Bool, restrictPublicBuckets: Bool) {
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case ignorePublicAcls
            case restrictPublicBuckets
        }
    }

    public struct SecretsManagerSecretConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The proposed ARN, key ID, or alias of the KMS customer master key (CMK).
        public let kmsKeyId: String?
        /// The proposed resource policy defining who can access or manage the secret.
        public let secretPolicy: String?

        public init(kmsKeyId: String? = nil, secretPolicy: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.secretPolicy = secretPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId
            case secretPolicy
        }
    }

    public struct SortCriteria: AWSEncodableShape {
        /// The name of the attribute to sort on.
        public let attributeName: String?
        /// The sort order, ascending or descending.
        public let orderBy: OrderBy?

        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case orderBy
        }
    }

    public struct Span: AWSDecodableShape {
        /// The end position of the span (exclusive).
        public let end: Position
        /// The start position of the span (inclusive).
        public let start: Position

        public init(end: Position, start: Position) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end
            case start
        }
    }

    public struct SqsQueueConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The proposed resource policy for the Amazon SQS queue.
        public let queuePolicy: String?

        public init(queuePolicy: String? = nil) {
            self.queuePolicy = queuePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case queuePolicy
        }
    }

    public struct StartPolicyGenerationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// A CloudTrailDetails object that contains details about a Trail that you want to analyze to generate policies.
        public let cloudTrailDetails: CloudTrailDetails?
        /// Contains the ARN of the IAM entity (user or role) for which you are generating a policy.
        public let policyGenerationDetails: PolicyGenerationDetails

        public init(clientToken: String? = StartPolicyGenerationRequest.idempotencyToken(), cloudTrailDetails: CloudTrailDetails? = nil, policyGenerationDetails: PolicyGenerationDetails) {
            self.clientToken = clientToken
            self.cloudTrailDetails = cloudTrailDetails
            self.policyGenerationDetails = policyGenerationDetails
        }

        public func validate(name: String) throws {
            try self.cloudTrailDetails?.validate(name: "\(name).cloudTrailDetails")
            try self.policyGenerationDetails.validate(name: "\(name).policyGenerationDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case cloudTrailDetails
            case policyGenerationDetails
        }
    }

    public struct StartPolicyGenerationResponse: AWSDecodableShape {
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
        }
    }

    public struct StartResourceScanRequest: AWSEncodableShape {
        /// The ARN of the analyzer to use to scan the policies applied to the specified resource.
        public let analyzerArn: String
        /// The ARN of the resource to scan.
        public let resourceArn: String

        public init(analyzerArn: String, resourceArn: String) {
            self.analyzerArn = analyzerArn
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case resourceArn
        }
    }

    public struct StatusReason: AWSDecodableShape {
        /// The reason code for the current status of the analyzer.
        public let code: ReasonCode

        public init(code: ReasonCode) {
            self.code = code
        }

        private enum CodingKeys: String, CodingKey {
            case code
        }
    }

    public struct Substring: AWSDecodableShape {
        /// The length of the substring.
        public let length: Int
        /// The start index of the substring, starting from 0.
        public let start: Int

        public init(length: Int, start: Int) {
            self.length = length
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case length
            case start
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The ARN of the resource to add the tag to.
        public let resourceArn: String
        /// The tags to add to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Trail: AWSEncodableShape {
        /// Possible values are true or false. If set to true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and generate a policy.
        public let allRegions: Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        public let cloudTrailArn: String
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public let regions: [String]?

        public init(allRegions: Bool? = nil, cloudTrailArn: String, regions: [String]? = nil) {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudTrailArn, name: "cloudTrailArn", parent: name, pattern: "^arn:[^:]*:cloudtrail:[^:]*:[^:]*:trail/.{1,576}$")
        }

        private enum CodingKeys: String, CodingKey {
            case allRegions
            case cloudTrailArn
            case regions
        }
    }

    public struct TrailProperties: AWSDecodableShape {
        /// Possible values are true or false. If set to true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and generate a policy.
        public let allRegions: Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        public let cloudTrailArn: String
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public let regions: [String]?

        public init(allRegions: Bool? = nil, cloudTrailArn: String, regions: [String]? = nil) {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case allRegions
            case cloudTrailArn
            case regions
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The ARN of the resource to remove the tag from.
        public let resourceArn: String
        /// The key for the tag to add.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateArchiveRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analyzerName", location: .uri(locationName: "analyzerName")),
            AWSMemberEncoding(label: "ruleName", location: .uri(locationName: "ruleName"))
        ]

        /// The name of the analyzer to update the archive rules for.
        public let analyzerName: String
        /// A client token.
        public let clientToken: String?
        /// A filter to match for the rules to update. Only rules that match the filter are updated.
        public let filter: [String: Criterion]
        /// The name of the rule to update.
        public let ruleName: String

        public init(analyzerName: String, clientToken: String? = UpdateArchiveRuleRequest.idempotencyToken(), filter: [String: Criterion], ruleName: String) {
            self.analyzerName = analyzerName
            self.clientToken = clientToken
            self.filter = filter
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.filter.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case filter
        }
    }

    public struct UpdateFindingsRequest: AWSEncodableShape {
        /// The ARN of the analyzer that generated the findings to update.
        public let analyzerArn: String
        /// A client token.
        public let clientToken: String?
        /// The IDs of the findings to update.
        public let ids: [String]?
        /// The ARN of the resource identified in the finding.
        public let resourceArn: String?
        /// The state represents the action to take to update the finding Status. Use ARCHIVE to change an Active finding to an Archived finding. Use ACTIVE to change an Archived finding to an Active finding.
        public let status: FindingStatusUpdate

        public init(analyzerArn: String, clientToken: String? = UpdateFindingsRequest.idempotencyToken(), ids: [String]? = nil, resourceArn: String? = nil, status: FindingStatusUpdate) {
            self.analyzerArn = analyzerArn
            self.clientToken = clientToken
            self.ids = ids
            self.resourceArn = resourceArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn
            case clientToken
            case ids
            case resourceArn
            case status
        }
    }

    public struct ValidatePolicyFinding: AWSDecodableShape {
        /// A localized message that explains the finding and provides guidance on how to address it.
        public let findingDetails: String
        /// The impact of the finding. Security warnings report when the policy allows access that we consider overly permissive. Errors report when a part of the policy is not functional. Warnings report non-security issues when a policy does not conform to policy writing best practices. Suggestions recommend stylistic improvements in the policy that do not impact access.
        public let findingType: ValidatePolicyFindingType
        /// The issue code provides an identifier of the issue associated with this finding.
        public let issueCode: String
        /// A link to additional documentation about the type of finding.
        public let learnMoreLink: String
        /// The list of locations in the policy document that are related to the finding. The issue code provides a summary of an issue identified by the finding.
        public let locations: [Location]

        public init(findingDetails: String, findingType: ValidatePolicyFindingType, issueCode: String, learnMoreLink: String, locations: [Location]) {
            self.findingDetails = findingDetails
            self.findingType = findingType
            self.issueCode = issueCode
            self.learnMoreLink = learnMoreLink
            self.locations = locations
        }

        private enum CodingKeys: String, CodingKey {
            case findingDetails
            case findingType
            case issueCode
            case learnMoreLink
            case locations
        }
    }

    public struct ValidatePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The locale to use for localizing the findings.
        public let locale: Locale?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The JSON policy document to use as the content for the policy.
        public let policyDocument: String
        /// The type of policy to validate. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. They also include service-control policies (SCPs) that are attached to an Amazon Web Services organization, organizational unit (OU), or an account. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.
        public let policyType: PolicyType

        public init(locale: Locale? = nil, maxResults: Int? = nil, nextToken: String? = nil, policyDocument: String, policyType: PolicyType) {
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyDocument = policyDocument
            self.policyType = policyType
        }

        private enum CodingKeys: String, CodingKey {
            case locale
            case policyDocument
            case policyType
        }
    }

    public struct ValidatePolicyResponse: AWSDecodableShape {
        /// The list of findings in a policy returned by IAM Access Analyzer based on its suite of policy checks.
        public let findings: [ValidatePolicyFinding]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(findings: [ValidatePolicyFinding], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings
            case nextToken
        }
    }

    public struct VpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  If this field is specified, this access point will only allow connections from the specified VPC ID.
        public let vpcId: String

        public init(vpcId: String) {
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-([0-9a-f]){8}(([0-9a-f]){9})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case vpcId
        }
    }
}
