//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AccessAnalyzer {
    // MARK: Enums

    public enum AccessCheckPolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case identityPolicy = "IDENTITY_POLICY"
        case resourcePolicy = "RESOURCE_POLICY"
        public var description: String { return self.rawValue }
    }

    public enum AccessPreviewStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case creating = "CREATING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum AccessPreviewStatusReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalError = "INTERNAL_ERROR"
        case invalidConfiguration = "INVALID_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum AclPermission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullControl = "FULL_CONTROL"
        case read = "READ"
        case readAcp = "READ_ACP"
        case write = "WRITE"
        case writeAcp = "WRITE_ACP"
        public var description: String { return self.rawValue }
    }

    public enum AnalyzerStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case disabled = "DISABLED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum CheckAccessNotGrantedResult: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fail = "FAIL"
        case pass = "PASS"
        public var description: String { return self.rawValue }
    }

    public enum CheckNoNewAccessResult: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fail = "FAIL"
        case pass = "PASS"
        public var description: String { return self.rawValue }
    }

    public enum FindingChangeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case changed = "CHANGED"
        case new = "NEW"
        case unchanged = "UNCHANGED"
        public var description: String { return self.rawValue }
    }

    public enum FindingSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bucketAcl = "BUCKET_ACL"
        case policy = "POLICY"
        case s3AccessPoint = "S3_ACCESS_POINT"
        case s3AccessPointAccount = "S3_ACCESS_POINT_ACCOUNT"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatusUpdate: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum FindingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case externalAccess = "ExternalAccess"
        case unusedIAMRole = "UnusedIAMRole"
        case unusedIAMUserAccessKey = "UnusedIAMUserAccessKey"
        case unusedIAMUserPassword = "UnusedIAMUserPassword"
        case unusedPermission = "UnusedPermission"
        public var description: String { return self.rawValue }
    }

    public enum JobErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authorizationError = "AUTHORIZATION_ERROR"
        case resourceNotFoundError = "RESOURCE_NOT_FOUND_ERROR"
        case serviceError = "SERVICE_ERROR"
        case serviceQuotaExceededError = "SERVICE_QUOTA_EXCEEDED_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum KmsGrantOperation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createGrant = "CreateGrant"
        case decrypt = "Decrypt"
        case describeKey = "DescribeKey"
        case encrypt = "Encrypt"
        case generateDataKey = "GenerateDataKey"
        case generateDataKeyPair = "GenerateDataKeyPair"
        case generateDataKeyPairWithoutPlaintext = "GenerateDataKeyPairWithoutPlaintext"
        case generateDataKeyWithoutPlaintext = "GenerateDataKeyWithoutPlaintext"
        case getPublicKey = "GetPublicKey"
        case reEncryptFrom = "ReEncryptFrom"
        case reEncryptTo = "ReEncryptTo"
        case retireGrant = "RetireGrant"
        case sign = "Sign"
        case verify = "Verify"
        public var description: String { return self.rawValue }
    }

    public enum Locale: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case de = "DE"
        case en = "EN"
        case es = "ES"
        case fr = "FR"
        case it = "IT"
        case ja = "JA"
        case ko = "KO"
        case ptBr = "PT_BR"
        case zhCn = "ZH_CN"
        case zhTw = "ZH_TW"
        public var description: String { return self.rawValue }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum PolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case identityPolicy = "IDENTITY_POLICY"
        case resourcePolicy = "RESOURCE_POLICY"
        case serviceControlPolicy = "SERVICE_CONTROL_POLICY"
        public var description: String { return self.rawValue }
    }

    public enum ReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsServiceAccessDisabled = "AWS_SERVICE_ACCESS_DISABLED"
        case delegatedAdministratorDeregistered = "DELEGATED_ADMINISTRATOR_DEREGISTERED"
        case organizationDeleted = "ORGANIZATION_DELETED"
        case serviceLinkedRoleCreationFailed = "SERVICE_LINKED_ROLE_CREATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsDynamodbStream = "AWS::DynamoDB::Stream"
        case awsDynamodbTable = "AWS::DynamoDB::Table"
        case awsEC2Snapshot = "AWS::EC2::Snapshot"
        case awsECRRepository = "AWS::ECR::Repository"
        case awsEFSFilesystem = "AWS::EFS::FileSystem"
        case awsIAMRole = "AWS::IAM::Role"
        case awsKMSKey = "AWS::KMS::Key"
        case awsLambdaFunction = "AWS::Lambda::Function"
        case awsLambdaLayerversion = "AWS::Lambda::LayerVersion"
        case awsRDSDbclustersnapshot = "AWS::RDS::DBClusterSnapshot"
        case awsRDSDbsnapshot = "AWS::RDS::DBSnapshot"
        case awsS3Bucket = "AWS::S3::Bucket"
        case awsS3ExpressDirectorybucket = "AWS::S3Express::DirectoryBucket"
        case awsSNSTopic = "AWS::SNS::Topic"
        case awsSQSQueue = "AWS::SQS::Queue"
        case awsSecretsmanagerSecret = "AWS::SecretsManager::Secret"
        public var description: String { return self.rawValue }
    }

    public enum ValidatePolicyFindingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case securityWarning = "SECURITY_WARNING"
        case suggestion = "SUGGESTION"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum ValidatePolicyResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsDynamodbTable = "AWS::DynamoDB::Table"
        case awsIAMAssumerolepolicydocument = "AWS::IAM::AssumeRolePolicyDocument"
        case awsS3Accesspoint = "AWS::S3::AccessPoint"
        case awsS3Bucket = "AWS::S3::Bucket"
        case awsS3Multiregionaccesspoint = "AWS::S3::MultiRegionAccessPoint"
        case awsS3ObjectlambdaAccesspoint = "AWS::S3ObjectLambda::AccessPoint"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        case accountUnusedAccess = "ACCOUNT_UNUSED_ACCESS"
        case organization = "ORGANIZATION"
        case organizationUnusedAccess = "ORGANIZATION_UNUSED_ACCESS"
        public var description: String { return self.rawValue }
    }

    public enum AclGrantee: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The value specified is the canonical user ID of an Amazon Web Services account.
        case id(String)
        /// Used for granting permissions to a predefined group.
        case uri(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .id:
                let value = try container.decode(String.self, forKey: .id)
                self = .id(value)
            case .uri:
                let value = try container.decode(String.self, forKey: .uri)
                self = .uri(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .id(let value):
                try container.encode(value, forKey: .id)
            case .uri(let value):
                try container.encode(value, forKey: .uri)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case uri = "uri"
        }
    }

    public enum Configuration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The access control configuration is for a DynamoDB stream.
        case dynamodbStream(DynamodbStreamConfiguration)
        /// The access control configuration is for a DynamoDB table or index.
        case dynamodbTable(DynamodbTableConfiguration)
        /// The access control configuration is for an Amazon EBS volume snapshot.
        case ebsSnapshot(EbsSnapshotConfiguration)
        /// The access control configuration is for an Amazon ECR repository.
        case ecrRepository(EcrRepositoryConfiguration)
        /// The access control configuration is for an Amazon EFS file system.
        case efsFileSystem(EfsFileSystemConfiguration)
        /// The access control configuration is for an IAM role.
        case iamRole(IamRoleConfiguration)
        /// The access control configuration is for a KMS key.
        case kmsKey(KmsKeyConfiguration)
        /// The access control configuration is for an Amazon RDS DB cluster snapshot.
        case rdsDbClusterSnapshot(RdsDbClusterSnapshotConfiguration)
        /// The access control configuration is for an Amazon RDS DB snapshot.
        case rdsDbSnapshot(RdsDbSnapshotConfiguration)
        /// The access control configuration is for an Amazon S3 bucket.
        case s3Bucket(S3BucketConfiguration)
        /// The access control configuration is for an Amazon S3 directory bucket.
        case s3ExpressDirectoryBucket(S3ExpressDirectoryBucketConfiguration)
        /// The access control configuration is for a Secrets Manager secret.
        case secretsManagerSecret(SecretsManagerSecretConfiguration)
        /// The access control configuration is for an Amazon SNS topic
        case snsTopic(SnsTopicConfiguration)
        /// The access control configuration is for an Amazon SQS queue.
        case sqsQueue(SqsQueueConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .dynamodbStream:
                let value = try container.decode(DynamodbStreamConfiguration.self, forKey: .dynamodbStream)
                self = .dynamodbStream(value)
            case .dynamodbTable:
                let value = try container.decode(DynamodbTableConfiguration.self, forKey: .dynamodbTable)
                self = .dynamodbTable(value)
            case .ebsSnapshot:
                let value = try container.decode(EbsSnapshotConfiguration.self, forKey: .ebsSnapshot)
                self = .ebsSnapshot(value)
            case .ecrRepository:
                let value = try container.decode(EcrRepositoryConfiguration.self, forKey: .ecrRepository)
                self = .ecrRepository(value)
            case .efsFileSystem:
                let value = try container.decode(EfsFileSystemConfiguration.self, forKey: .efsFileSystem)
                self = .efsFileSystem(value)
            case .iamRole:
                let value = try container.decode(IamRoleConfiguration.self, forKey: .iamRole)
                self = .iamRole(value)
            case .kmsKey:
                let value = try container.decode(KmsKeyConfiguration.self, forKey: .kmsKey)
                self = .kmsKey(value)
            case .rdsDbClusterSnapshot:
                let value = try container.decode(RdsDbClusterSnapshotConfiguration.self, forKey: .rdsDbClusterSnapshot)
                self = .rdsDbClusterSnapshot(value)
            case .rdsDbSnapshot:
                let value = try container.decode(RdsDbSnapshotConfiguration.self, forKey: .rdsDbSnapshot)
                self = .rdsDbSnapshot(value)
            case .s3Bucket:
                let value = try container.decode(S3BucketConfiguration.self, forKey: .s3Bucket)
                self = .s3Bucket(value)
            case .s3ExpressDirectoryBucket:
                let value = try container.decode(S3ExpressDirectoryBucketConfiguration.self, forKey: .s3ExpressDirectoryBucket)
                self = .s3ExpressDirectoryBucket(value)
            case .secretsManagerSecret:
                let value = try container.decode(SecretsManagerSecretConfiguration.self, forKey: .secretsManagerSecret)
                self = .secretsManagerSecret(value)
            case .snsTopic:
                let value = try container.decode(SnsTopicConfiguration.self, forKey: .snsTopic)
                self = .snsTopic(value)
            case .sqsQueue:
                let value = try container.decode(SqsQueueConfiguration.self, forKey: .sqsQueue)
                self = .sqsQueue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dynamodbStream(let value):
                try container.encode(value, forKey: .dynamodbStream)
            case .dynamodbTable(let value):
                try container.encode(value, forKey: .dynamodbTable)
            case .ebsSnapshot(let value):
                try container.encode(value, forKey: .ebsSnapshot)
            case .ecrRepository(let value):
                try container.encode(value, forKey: .ecrRepository)
            case .efsFileSystem(let value):
                try container.encode(value, forKey: .efsFileSystem)
            case .iamRole(let value):
                try container.encode(value, forKey: .iamRole)
            case .kmsKey(let value):
                try container.encode(value, forKey: .kmsKey)
            case .rdsDbClusterSnapshot(let value):
                try container.encode(value, forKey: .rdsDbClusterSnapshot)
            case .rdsDbSnapshot(let value):
                try container.encode(value, forKey: .rdsDbSnapshot)
            case .s3Bucket(let value):
                try container.encode(value, forKey: .s3Bucket)
            case .s3ExpressDirectoryBucket(let value):
                try container.encode(value, forKey: .s3ExpressDirectoryBucket)
            case .secretsManagerSecret(let value):
                try container.encode(value, forKey: .secretsManagerSecret)
            case .snsTopic(let value):
                try container.encode(value, forKey: .snsTopic)
            case .sqsQueue(let value):
                try container.encode(value, forKey: .sqsQueue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3Bucket(let value):
                try value.validate(name: "\(name).s3Bucket")
            case .snsTopic(let value):
                try value.validate(name: "\(name).snsTopic")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dynamodbStream = "dynamodbStream"
            case dynamodbTable = "dynamodbTable"
            case ebsSnapshot = "ebsSnapshot"
            case ecrRepository = "ecrRepository"
            case efsFileSystem = "efsFileSystem"
            case iamRole = "iamRole"
            case kmsKey = "kmsKey"
            case rdsDbClusterSnapshot = "rdsDbClusterSnapshot"
            case rdsDbSnapshot = "rdsDbSnapshot"
            case s3Bucket = "s3Bucket"
            case s3ExpressDirectoryBucket = "s3ExpressDirectoryBucket"
            case secretsManagerSecret = "secretsManagerSecret"
            case snsTopic = "snsTopic"
            case sqsQueue = "sqsQueue"
        }
    }

    public enum FindingDetails: AWSDecodableShape, Sendable {
        /// The details for an external access analyzer finding.
        case externalAccessDetails(ExternalAccessDetails)
        /// The details for an unused access analyzer finding with an unused IAM role finding type.
        case unusedIamRoleDetails(UnusedIamRoleDetails)
        /// The details for an unused access analyzer finding with an unused IAM user access key finding type.
        case unusedIamUserAccessKeyDetails(UnusedIamUserAccessKeyDetails)
        /// The details for an unused access analyzer finding with an unused IAM user password finding type.
        case unusedIamUserPasswordDetails(UnusedIamUserPasswordDetails)
        /// The details for an unused access analyzer finding with an unused permission finding type.
        case unusedPermissionDetails(UnusedPermissionDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .externalAccessDetails:
                let value = try container.decode(ExternalAccessDetails.self, forKey: .externalAccessDetails)
                self = .externalAccessDetails(value)
            case .unusedIamRoleDetails:
                let value = try container.decode(UnusedIamRoleDetails.self, forKey: .unusedIamRoleDetails)
                self = .unusedIamRoleDetails(value)
            case .unusedIamUserAccessKeyDetails:
                let value = try container.decode(UnusedIamUserAccessKeyDetails.self, forKey: .unusedIamUserAccessKeyDetails)
                self = .unusedIamUserAccessKeyDetails(value)
            case .unusedIamUserPasswordDetails:
                let value = try container.decode(UnusedIamUserPasswordDetails.self, forKey: .unusedIamUserPasswordDetails)
                self = .unusedIamUserPasswordDetails(value)
            case .unusedPermissionDetails:
                let value = try container.decode(UnusedPermissionDetails.self, forKey: .unusedPermissionDetails)
                self = .unusedPermissionDetails(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case externalAccessDetails = "externalAccessDetails"
            case unusedIamRoleDetails = "unusedIamRoleDetails"
            case unusedIamUserAccessKeyDetails = "unusedIamUserAccessKeyDetails"
            case unusedIamUserPasswordDetails = "unusedIamUserPasswordDetails"
            case unusedPermissionDetails = "unusedPermissionDetails"
        }
    }

    public enum NetworkOriginConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration for the Amazon S3 access point or multi-region access point with an Internet origin.
        case internetConfiguration(InternetConfiguration)
        case vpcConfiguration(VpcConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .internetConfiguration:
                let value = try container.decode(InternetConfiguration.self, forKey: .internetConfiguration)
                self = .internetConfiguration(value)
            case .vpcConfiguration:
                let value = try container.decode(VpcConfiguration.self, forKey: .vpcConfiguration)
                self = .vpcConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .internetConfiguration(let value):
                try container.encode(value, forKey: .internetConfiguration)
            case .vpcConfiguration(let value):
                try container.encode(value, forKey: .vpcConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .vpcConfiguration(let value):
                try value.validate(name: "\(name).vpcConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case internetConfiguration = "internetConfiguration"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public enum PathElement: AWSDecodableShape, Sendable {
        /// Refers to an index in a JSON array.
        case index(Int)
        /// Refers to a key in a JSON object.
        case key(String)
        /// Refers to a substring of a literal string in a JSON object.
        case substring(Substring)
        /// Refers to the value associated with a given key in a JSON object.
        case value(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .index:
                let value = try container.decode(Int.self, forKey: .index)
                self = .index(value)
            case .key:
                let value = try container.decode(String.self, forKey: .key)
                self = .key(value)
            case .substring:
                let value = try container.decode(Substring.self, forKey: .substring)
                self = .substring(value)
            case .value:
                let value = try container.decode(String.self, forKey: .value)
                self = .value(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case index = "index"
            case key = "key"
            case substring = "substring"
            case value = "value"
        }
    }

    // MARK: Shapes

    public struct Access: AWSEncodableShape {
        /// A list of actions for the access permissions. Any strings that can be used as an action in an IAM policy can be used in the list of actions to check.
        public let actions: [String]

        public init(actions: [String]) {
            self.actions = actions
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
        }
    }

    public struct AccessPreview: AWSDecodableShape {
        /// The ARN of the analyzer used to generate the access preview.
        public let analyzerArn: String
        /// A map of resource ARNs for the proposed resource configuration.
        public let configurations: [String: Configuration]
        /// The time at which the access preview was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique ID for the access preview.
        public let id: String
        /// The status of the access preview.    Creating - The access preview creation is in progress.    Completed - The access preview is complete. You can preview findings for external access to the resource.    Failed - The access preview creation has failed.
        public let status: AccessPreviewStatus
        /// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a Failed status is returned. This failure can be due to an internal issue with the analysis or due to an invalid resource configuration.
        public let statusReason: AccessPreviewStatusReason?

        public init(analyzerArn: String, configurations: [String: Configuration], createdAt: Date, id: String, status: AccessPreviewStatus, statusReason: AccessPreviewStatusReason? = nil) {
            self.analyzerArn = analyzerArn
            self.configurations = configurations
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case configurations = "configurations"
            case createdAt = "createdAt"
            case id = "id"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct AccessPreviewFinding: AWSDecodableShape {
        /// The action in the analyzed policy statement that an external principal has permission to perform.
        public let action: [String]?
        /// Provides context on how the access preview finding compares to existing access identified in IAM Access Analyzer.    New - The finding is for newly-introduced access.    Unchanged - The preview finding is an existing finding that would remain unchanged.    Changed - The preview finding is an existing finding with a change in status.   For example, a Changed finding with preview status Resolved and existing status Active indicates the existing Active finding would become Resolved as a result of the proposed permissions change.
        public let changeType: FindingChangeType
        /// The condition in the analyzed policy statement that resulted in a finding.
        public let condition: [String: String]?
        /// The time at which the access preview finding was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// An error.
        public let error: String?
        /// The existing ID of the finding in IAM Access Analyzer, provided only for existing findings.
        public let existingFindingId: String?
        /// The existing status of the finding, provided only for existing findings.
        public let existingFindingStatus: FindingStatus?
        /// The ID of the access preview finding. This ID uniquely identifies the element in the list of access preview findings and is not related to the finding ID in Access Analyzer.
        public let id: String
        /// Indicates whether the policy that generated the finding allows public access to the resource.
        public let isPublic: Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public let principal: [String: String]?
        /// The resource that an external principal has access to. This is the resource associated with the access preview.
        public let resource: String?
        /// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
        public let resourceOwnerAccount: String
        /// The type of the resource that can be accessed in the finding.
        public let resourceType: ResourceType
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public let sources: [FindingSource]?
        /// The preview status of the finding. This is what the status of the finding would be after permissions deployment. For example, a Changed finding with preview status Resolved and existing status Active indicates the existing Active finding would become Resolved as a result of the proposed permissions change.
        public let status: FindingStatus

        public init(action: [String]? = nil, changeType: FindingChangeType, condition: [String: String]? = nil, createdAt: Date, error: String? = nil, existingFindingId: String? = nil, existingFindingStatus: FindingStatus? = nil, id: String, isPublic: Bool? = nil, principal: [String: String]? = nil, resource: String? = nil, resourceOwnerAccount: String, resourceType: ResourceType, sources: [FindingSource]? = nil, status: FindingStatus) {
            self.action = action
            self.changeType = changeType
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.existingFindingId = existingFindingId
            self.existingFindingStatus = existingFindingStatus
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case changeType = "changeType"
            case condition = "condition"
            case createdAt = "createdAt"
            case error = "error"
            case existingFindingId = "existingFindingId"
            case existingFindingStatus = "existingFindingStatus"
            case id = "id"
            case isPublic = "isPublic"
            case principal = "principal"
            case resource = "resource"
            case resourceOwnerAccount = "resourceOwnerAccount"
            case resourceType = "resourceType"
            case sources = "sources"
            case status = "status"
        }
    }

    public struct AccessPreviewStatusReason: AWSDecodableShape {
        /// The reason code for the current status of the access preview.
        public let code: AccessPreviewStatusReasonCode

        public init(code: AccessPreviewStatusReasonCode) {
            self.code = code
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
        }
    }

    public struct AccessPreviewSummary: AWSDecodableShape {
        /// The ARN of the analyzer used to generate the access preview.
        public let analyzerArn: String
        /// The time at which the access preview was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique ID for the access preview.
        public let id: String
        /// The status of the access preview.    Creating - The access preview creation is in progress.    Completed - The access preview is complete and previews the findings for external access to the resource.    Failed - The access preview creation has failed.
        public let status: AccessPreviewStatus
        public let statusReason: AccessPreviewStatusReason?

        public init(analyzerArn: String, createdAt: Date, id: String, status: AccessPreviewStatus, statusReason: AccessPreviewStatusReason? = nil) {
            self.analyzerArn = analyzerArn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case createdAt = "createdAt"
            case id = "id"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct AnalyzedResource: AWSDecodableShape {
        /// The actions that an external principal is granted permission to use by the policy that generated the finding.
        public let actions: [String]?
        /// The time at which the resource was analyzed.
        @CustomCoding<ISO8601DateCoder>
        public var analyzedAt: Date
        /// The time at which the finding was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// An error message.
        public let error: String?
        /// Indicates whether the policy that generated the finding grants public access to the resource.
        public let isPublic: Bool
        /// The ARN of the resource that was analyzed.
        public let resourceArn: String
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of the resource that was analyzed.
        public let resourceType: ResourceType
        /// Indicates how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
        public let sharedVia: [String]?
        /// The current status of the finding generated from the analyzed resource.
        public let status: FindingStatus?
        /// The time at which the finding was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(actions: [String]? = nil, analyzedAt: Date, createdAt: Date, error: String? = nil, isPublic: Bool, resourceArn: String, resourceOwnerAccount: String, resourceType: ResourceType, sharedVia: [String]? = nil, status: FindingStatus? = nil, updatedAt: Date) {
            self.actions = actions
            self.analyzedAt = analyzedAt
            self.createdAt = createdAt
            self.error = error
            self.isPublic = isPublic
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sharedVia = sharedVia
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case analyzedAt = "analyzedAt"
            case createdAt = "createdAt"
            case error = "error"
            case isPublic = "isPublic"
            case resourceArn = "resourceArn"
            case resourceOwnerAccount = "resourceOwnerAccount"
            case resourceType = "resourceType"
            case sharedVia = "sharedVia"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct AnalyzedResourceSummary: AWSDecodableShape {
        /// The ARN of the analyzed resource.
        public let resourceArn: String
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of resource that was analyzed.
        public let resourceType: ResourceType

        public init(resourceArn: String, resourceOwnerAccount: String, resourceType: ResourceType) {
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case resourceOwnerAccount = "resourceOwnerAccount"
            case resourceType = "resourceType"
        }
    }

    public struct AnalyzerSummary: AWSDecodableShape {
        /// The ARN of the analyzer.
        public let arn: String
        /// Specifies whether the analyzer is an external access or unused access analyzer.
        public let configuration: AnalyzerConfiguration?
        /// A timestamp for the time at which the analyzer was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The resource that was most recently analyzed by the analyzer.
        public let lastResourceAnalyzed: String?
        /// The time at which the most recently analyzed resource was analyzed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastResourceAnalyzedAt: Date?
        /// The name of the analyzer.
        public let name: String
        /// The status of the analyzer. An Active analyzer successfully monitors supported resources and generates new findings. The analyzer is Disabled when a user action, such as removing trusted access for Identity and Access Management Access Analyzer from Organizations, causes the analyzer to stop generating new findings. The status is Creating when the analyzer creation is in progress and Failed when the analyzer creation has failed.
        public let status: AnalyzerStatus
        /// The statusReason provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a Failed status is returned. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the Amazon Web Services organization.
        public let statusReason: StatusReason?
        /// The tags added to the analyzer.
        public let tags: [String: String]?
        /// The type of analyzer, which corresponds to the zone of trust chosen for the analyzer.
        public let type: `Type`

        public init(arn: String, configuration: AnalyzerConfiguration? = nil, createdAt: Date, lastResourceAnalyzed: String? = nil, lastResourceAnalyzedAt: Date? = nil, name: String, status: AnalyzerStatus, statusReason: StatusReason? = nil, tags: [String: String]? = nil, type: `Type`) {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.lastResourceAnalyzed = lastResourceAnalyzed
            self.lastResourceAnalyzedAt = lastResourceAnalyzedAt
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case lastResourceAnalyzed = "lastResourceAnalyzed"
            case lastResourceAnalyzedAt = "lastResourceAnalyzedAt"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct ApplyArchiveRuleRequest: AWSEncodableShape {
        /// The Amazon resource name (ARN) of the analyzer.
        public let analyzerArn: String
        /// A client token.
        public let clientToken: String?
        /// The name of the rule to apply.
        public let ruleName: String

        public init(analyzerArn: String, clientToken: String? = ApplyArchiveRuleRequest.idempotencyToken(), ruleName: String) {
            self.analyzerArn = analyzerArn
            self.clientToken = clientToken
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case clientToken = "clientToken"
            case ruleName = "ruleName"
        }
    }

    public struct ArchiveRuleSummary: AWSDecodableShape {
        /// The time at which the archive rule was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A filter used to define the archive rule.
        public let filter: [String: Criterion]
        /// The name of the archive rule.
        public let ruleName: String
        /// The time at which the archive rule was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(createdAt: Date, filter: [String: Criterion], ruleName: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.filter = filter
            self.ruleName = ruleName
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case filter = "filter"
            case ruleName = "ruleName"
            case updatedAt = "updatedAt"
        }
    }

    public struct CancelPolicyGenerationRequest: AWSEncodableShape {
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelPolicyGenerationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CheckAccessNotGrantedRequest: AWSEncodableShape {
        /// An access object containing the permissions that shouldn't be granted by the specified policy.
        public let access: [Access]
        /// The JSON policy document to use as the content for the policy.
        public let policyDocument: String
        /// The type of policy. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.
        public let policyType: AccessCheckPolicyType

        public init(access: [Access], policyDocument: String, policyType: AccessCheckPolicyType) {
            self.access = access
            self.policyDocument = policyDocument
            self.policyType = policyType
        }

        private enum CodingKeys: String, CodingKey {
            case access = "access"
            case policyDocument = "policyDocument"
            case policyType = "policyType"
        }
    }

    public struct CheckAccessNotGrantedResponse: AWSDecodableShape {
        /// The message indicating whether the specified access is allowed.
        public let message: String?
        /// A description of the reasoning of the result.
        public let reasons: [ReasonSummary]?
        /// The result of the check for whether the access is allowed. If the result is PASS, the specified policy doesn't allow any of the specified permissions in the access object. If the result is FAIL, the specified policy might allow some or all of the permissions in the access object.
        public let result: CheckAccessNotGrantedResult?

        public init(message: String? = nil, reasons: [ReasonSummary]? = nil, result: CheckAccessNotGrantedResult? = nil) {
            self.message = message
            self.reasons = reasons
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reasons = "reasons"
            case result = "result"
        }
    }

    public struct CheckNoNewAccessRequest: AWSEncodableShape {
        /// The JSON policy document to use as the content for the existing policy.
        public let existingPolicyDocument: String
        /// The JSON policy document to use as the content for the updated policy.
        public let newPolicyDocument: String
        /// The type of policy to compare. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.
        public let policyType: AccessCheckPolicyType

        public init(existingPolicyDocument: String, newPolicyDocument: String, policyType: AccessCheckPolicyType) {
            self.existingPolicyDocument = existingPolicyDocument
            self.newPolicyDocument = newPolicyDocument
            self.policyType = policyType
        }

        private enum CodingKeys: String, CodingKey {
            case existingPolicyDocument = "existingPolicyDocument"
            case newPolicyDocument = "newPolicyDocument"
            case policyType = "policyType"
        }
    }

    public struct CheckNoNewAccessResponse: AWSDecodableShape {
        /// The message indicating whether the updated policy allows new access.
        public let message: String?
        /// A description of the reasoning of the result.
        public let reasons: [ReasonSummary]?
        /// The result of the check for new access. If the result is PASS, no new access is allowed by the updated policy. If the result is FAIL, the updated policy might allow new access.
        public let result: CheckNoNewAccessResult?

        public init(message: String? = nil, reasons: [ReasonSummary]? = nil, result: CheckNoNewAccessResult? = nil) {
            self.message = message
            self.reasons = reasons
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reasons = "reasons"
            case result = "result"
        }
    }

    public struct CloudTrailDetails: AWSEncodableShape {
        /// The ARN of the service role that IAM Access Analyzer uses to access your CloudTrail trail and service last accessed information.
        public let accessRole: String
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp after this time are not considered to generate a policy. If this is not included in the request, the default value is the current time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp before this time are not considered to generate a policy.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// A Trail object that contains settings for a trail.
        public let trails: [Trail]

        public init(accessRole: String, endTime: Date? = nil, startTime: Date, trails: [Trail]) {
            self.accessRole = accessRole
            self.endTime = endTime
            self.startTime = startTime
            self.trails = trails
        }

        public func validate(name: String) throws {
            try self.validate(self.accessRole, name: "accessRole", parent: name, pattern: "^arn:[^:]*:iam::[^:]*:role/.{1,576}$")
            try self.trails.forEach {
                try $0.validate(name: "\(name).trails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessRole = "accessRole"
            case endTime = "endTime"
            case startTime = "startTime"
            case trails = "trails"
        }
    }

    public struct CloudTrailProperties: AWSDecodableShape {
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp after this time are not considered to generate a policy. If this is not included in the request, the default value is the current time.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp before this time are not considered to generate a policy.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// A TrailProperties object that contains settings for trail properties.
        public let trailProperties: [TrailProperties]

        public init(endTime: Date, startTime: Date, trailProperties: [TrailProperties]) {
            self.endTime = endTime
            self.startTime = startTime
            self.trailProperties = trailProperties
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case startTime = "startTime"
            case trailProperties = "trailProperties"
        }
    }

    public struct CreateAccessPreviewRequest: AWSEncodableShape {
        /// The ARN of the account analyzer used to generate the access preview. You can only create an access preview for analyzers with an Account type and Active status.
        public let analyzerArn: String
        /// A client token.
        public let clientToken: String?
        /// Access control configuration for your resource that is used to generate the access preview. The access preview includes findings for external access allowed to the resource with the proposed access control configuration. The configuration must contain exactly one element.
        public let configurations: [String: Configuration]

        public init(analyzerArn: String, clientToken: String? = CreateAccessPreviewRequest.idempotencyToken(), configurations: [String: Configuration]) {
            self.analyzerArn = analyzerArn
            self.clientToken = clientToken
            self.configurations = configurations
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.configurations.forEach {
                try $0.value.validate(name: "\(name).configurations[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case clientToken = "clientToken"
            case configurations = "configurations"
        }
    }

    public struct CreateAccessPreviewResponse: AWSDecodableShape {
        /// The unique ID for the access preview.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CreateAnalyzerRequest: AWSEncodableShape {
        /// The name of the analyzer to create.
        public let analyzerName: String
        /// Specifies the archive rules to add for the analyzer. Archive rules automatically archive findings that meet the criteria you define for the rule.
        public let archiveRules: [InlineArchiveRule]?
        /// A client token.
        public let clientToken: String?
        /// Specifies the configuration of the analyzer. If the analyzer is an unused access analyzer, the specified scope of unused access is used for the configuration. If the analyzer is an external access analyzer, this field is not used.
        public let configuration: AnalyzerConfiguration?
        /// An array of key-value pairs to apply to the analyzer.
        public let tags: [String: String]?
        /// The type of analyzer to create. Only ACCOUNT, ORGANIZATION, ACCOUNT_UNUSED_ACCESS, and ORGANIZATION_UNUSED_ACCESS analyzers are supported. You can create only one analyzer per account per Region. You can create up to 5 analyzers per organization per Region.
        public let type: `Type`

        public init(analyzerName: String, archiveRules: [InlineArchiveRule]? = nil, clientToken: String? = CreateAnalyzerRequest.idempotencyToken(), configuration: AnalyzerConfiguration? = nil, tags: [String: String]? = nil, type: `Type`) {
            self.analyzerName = analyzerName
            self.archiveRules = archiveRules
            self.clientToken = clientToken
            self.configuration = configuration
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.archiveRules?.forEach {
                try $0.validate(name: "\(name).archiveRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerName = "analyzerName"
            case archiveRules = "archiveRules"
            case clientToken = "clientToken"
            case configuration = "configuration"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateAnalyzerResponse: AWSDecodableShape {
        /// The ARN of the analyzer that was created by the request.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct CreateArchiveRuleRequest: AWSEncodableShape {
        /// The name of the created analyzer.
        public let analyzerName: String
        /// A client token.
        public let clientToken: String?
        /// The criteria for the rule.
        public let filter: [String: Criterion]
        /// The name of the rule to create.
        public let ruleName: String

        public init(analyzerName: String, clientToken: String? = CreateArchiveRuleRequest.idempotencyToken(), filter: [String: Criterion], ruleName: String) {
            self.analyzerName = analyzerName
            self.clientToken = clientToken
            self.filter = filter
            self.ruleName = ruleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analyzerName, key: "analyzerName")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.filter, forKey: .filter)
            try container.encode(self.ruleName, forKey: .ruleName)
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.filter.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case filter = "filter"
            case ruleName = "ruleName"
        }
    }

    public struct Criterion: AWSEncodableShape & AWSDecodableShape {
        /// A "contains" operator to match for the filter used to create the rule.
        public let contains: [String]?
        /// An "equals" operator to match for the filter used to create the rule.
        public let eq: [String]?
        /// An "exists" operator to match for the filter used to create the rule.
        public let exists: Bool?
        /// A "not equals" operator to match for the filter used to create the rule.
        public let neq: [String]?

        public init(contains: [String]? = nil, eq: [String]? = nil, exists: Bool? = nil, neq: [String]? = nil) {
            self.contains = contains
            self.eq = eq
            self.exists = exists
            self.neq = neq
        }

        public func validate(name: String) throws {
            try self.validate(self.contains, name: "contains", parent: name, max: 20)
            try self.validate(self.contains, name: "contains", parent: name, min: 1)
            try self.validate(self.eq, name: "eq", parent: name, max: 20)
            try self.validate(self.eq, name: "eq", parent: name, min: 1)
            try self.validate(self.neq, name: "neq", parent: name, max: 20)
            try self.validate(self.neq, name: "neq", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contains = "contains"
            case eq = "eq"
            case exists = "exists"
            case neq = "neq"
        }
    }

    public struct DeleteAnalyzerRequest: AWSEncodableShape {
        /// The name of the analyzer to delete.
        public let analyzerName: String
        /// A client token.
        public let clientToken: String?

        public init(analyzerName: String, clientToken: String? = DeleteAnalyzerRequest.idempotencyToken()) {
            self.analyzerName = analyzerName
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analyzerName, key: "analyzerName")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteArchiveRuleRequest: AWSEncodableShape {
        /// The name of the analyzer that associated with the archive rule to delete.
        public let analyzerName: String
        /// A client token.
        public let clientToken: String?
        /// The name of the rule to delete.
        public let ruleName: String

        public init(analyzerName: String, clientToken: String? = DeleteArchiveRuleRequest.idempotencyToken(), ruleName: String) {
            self.analyzerName = analyzerName
            self.clientToken = clientToken
            self.ruleName = ruleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analyzerName, key: "analyzerName")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.ruleName, key: "ruleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DynamodbStreamConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The proposed resource policy defining who can access or manage the DynamoDB stream.
        public let streamPolicy: String?

        public init(streamPolicy: String? = nil) {
            self.streamPolicy = streamPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case streamPolicy = "streamPolicy"
        }
    }

    public struct DynamodbTableConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The proposed resource policy defining who can access or manage the DynamoDB table.
        public let tablePolicy: String?

        public init(tablePolicy: String? = nil) {
            self.tablePolicy = tablePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case tablePolicy = "tablePolicy"
        }
    }

    public struct EbsSnapshotConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The groups that have access to the Amazon EBS volume snapshot. If the value all is specified, then the Amazon EBS volume snapshot is public.   If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the groups, then the access preview uses the existing shared groups for the snapshot.   If the access preview is for a new resource and you do not specify the groups, then the access preview considers the snapshot without any groups.   To propose deletion of existing shared groups, you can specify an empty list for groups.
        public let groups: [String]?
        /// The KMS key identifier for an encrypted Amazon EBS volume snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.   If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.   If the access preview is for a new resource and you do not specify the kmsKeyId, the access preview considers the snapshot as unencrypted.
        public let kmsKeyId: String?
        /// The IDs of the Amazon Web Services accounts that have access to the Amazon EBS volume snapshot.   If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the userIds, then the access preview uses the existing shared userIds for the snapshot.   If the access preview is for a new resource and you do not specify the userIds, then the access preview considers the snapshot without any userIds.   To propose deletion of existing shared accountIds, you can specify an empty list for userIds.
        public let userIds: [String]?

        public init(groups: [String]? = nil, kmsKeyId: String? = nil, userIds: [String]? = nil) {
            self.groups = groups
            self.kmsKeyId = kmsKeyId
            self.userIds = userIds
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "groups"
            case kmsKeyId = "kmsKeyId"
            case userIds = "userIds"
        }
    }

    public struct EcrRepositoryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The JSON repository policy text to apply to the Amazon ECR repository. For more information, see Private repository policy examples in the Amazon ECR User Guide.
        public let repositoryPolicy: String?

        public init(repositoryPolicy: String? = nil) {
            self.repositoryPolicy = repositoryPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryPolicy = "repositoryPolicy"
        }
    }

    public struct EfsFileSystemConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The JSON policy definition to apply to the Amazon EFS file system. For more information on the elements that make up a file system policy, see Amazon EFS Resource-based policies.
        public let fileSystemPolicy: String?

        public init(fileSystemPolicy: String? = nil) {
            self.fileSystemPolicy = fileSystemPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemPolicy = "fileSystemPolicy"
        }
    }

    public struct ExternalAccessDetails: AWSDecodableShape {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public let action: [String]?
        /// The condition in the analyzed policy statement that resulted in an external access finding.
        public let condition: [String: String]
        /// Specifies whether the external access finding is public.
        public let isPublic: Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public let principal: [String: String]?
        /// The sources of the external access finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public let sources: [FindingSource]?

        public init(action: [String]? = nil, condition: [String: String], isPublic: Bool? = nil, principal: [String: String]? = nil, sources: [FindingSource]? = nil) {
            self.action = action
            self.condition = condition
            self.isPublic = isPublic
            self.principal = principal
            self.sources = sources
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case condition = "condition"
            case isPublic = "isPublic"
            case principal = "principal"
            case sources = "sources"
        }
    }

    public struct Finding: AWSDecodableShape {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public let action: [String]?
        /// The time at which the resource was analyzed.
        @CustomCoding<ISO8601DateCoder>
        public var analyzedAt: Date
        /// The condition in the analyzed policy statement that resulted in a finding.
        public let condition: [String: String]
        /// The time at which the finding was generated.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// An error.
        public let error: String?
        /// The ID of the finding.
        public let id: String
        /// Indicates whether the policy that generated the finding allows public access to the resource.
        public let isPublic: Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public let principal: [String: String]?
        /// The resource that an external principal has access to.
        public let resource: String?
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of the resource identified in the finding.
        public let resourceType: ResourceType
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public let sources: [FindingSource]?
        /// The current status of the finding.
        public let status: FindingStatus
        /// The time at which the finding was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(action: [String]? = nil, analyzedAt: Date, condition: [String: String], createdAt: Date, error: String? = nil, id: String, isPublic: Bool? = nil, principal: [String: String]? = nil, resource: String? = nil, resourceOwnerAccount: String, resourceType: ResourceType, sources: [FindingSource]? = nil, status: FindingStatus, updatedAt: Date) {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case analyzedAt = "analyzedAt"
            case condition = "condition"
            case createdAt = "createdAt"
            case error = "error"
            case id = "id"
            case isPublic = "isPublic"
            case principal = "principal"
            case resource = "resource"
            case resourceOwnerAccount = "resourceOwnerAccount"
            case resourceType = "resourceType"
            case sources = "sources"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct FindingSource: AWSDecodableShape {
        /// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
        public let detail: FindingSourceDetail?
        /// Indicates the type of access that generated the finding.
        public let type: FindingSourceType

        public init(detail: FindingSourceDetail? = nil, type: FindingSourceType) {
            self.detail = detail
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case detail = "detail"
            case type = "type"
        }
    }

    public struct FindingSourceDetail: AWSDecodableShape {
        /// The account of the cross-account access point that generated the finding.
        public let accessPointAccount: String?
        /// The ARN of the access point that generated the finding. The ARN format depends on whether the ARN represents an access point or a multi-region access point.
        public let accessPointArn: String?

        public init(accessPointAccount: String? = nil, accessPointArn: String? = nil) {
            self.accessPointAccount = accessPointAccount
            self.accessPointArn = accessPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointAccount = "accessPointAccount"
            case accessPointArn = "accessPointArn"
        }
    }

    public struct FindingSummary: AWSDecodableShape {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public let action: [String]?
        /// The time at which the resource-based policy that generated the finding was analyzed.
        @CustomCoding<ISO8601DateCoder>
        public var analyzedAt: Date
        /// The condition in the analyzed policy statement that resulted in a finding.
        public let condition: [String: String]
        /// The time at which the finding was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The error that resulted in an Error finding.
        public let error: String?
        /// The ID of the finding.
        public let id: String
        /// Indicates whether the finding reports a resource that has a policy that allows public access.
        public let isPublic: Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public let principal: [String: String]?
        /// The resource that the external principal has access to.
        public let resource: String?
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of the resource that the external principal has access to.
        public let resourceType: ResourceType
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public let sources: [FindingSource]?
        /// The status of the finding.
        public let status: FindingStatus
        /// The time at which the finding was most recently updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(action: [String]? = nil, analyzedAt: Date, condition: [String: String], createdAt: Date, error: String? = nil, id: String, isPublic: Bool? = nil, principal: [String: String]? = nil, resource: String? = nil, resourceOwnerAccount: String, resourceType: ResourceType, sources: [FindingSource]? = nil, status: FindingStatus, updatedAt: Date) {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case analyzedAt = "analyzedAt"
            case condition = "condition"
            case createdAt = "createdAt"
            case error = "error"
            case id = "id"
            case isPublic = "isPublic"
            case principal = "principal"
            case resource = "resource"
            case resourceOwnerAccount = "resourceOwnerAccount"
            case resourceType = "resourceType"
            case sources = "sources"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct FindingSummaryV2: AWSDecodableShape {
        /// The time at which the resource-based policy or IAM entity that generated the finding was analyzed.
        @CustomCoding<ISO8601DateCoder>
        public var analyzedAt: Date
        /// The time at which the finding was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The error that resulted in an Error finding.
        public let error: String?
        /// The type of the external access or unused access finding.
        public let findingType: FindingType?
        /// The ID of the finding.
        public let id: String
        /// The resource that the external principal has access to.
        public let resource: String?
        /// The Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of the resource that the external principal has access to.
        public let resourceType: ResourceType
        /// The status of the finding.
        public let status: FindingStatus
        /// The time at which the finding was most recently updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(analyzedAt: Date, createdAt: Date, error: String? = nil, findingType: FindingType? = nil, id: String, resource: String? = nil, resourceOwnerAccount: String, resourceType: ResourceType, status: FindingStatus, updatedAt: Date) {
            self.analyzedAt = analyzedAt
            self.createdAt = createdAt
            self.error = error
            self.findingType = findingType
            self.id = id
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedAt = "analyzedAt"
            case createdAt = "createdAt"
            case error = "error"
            case findingType = "findingType"
            case id = "id"
            case resource = "resource"
            case resourceOwnerAccount = "resourceOwnerAccount"
            case resourceType = "resourceType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GeneratedPolicy: AWSDecodableShape {
        /// The text to use as the content for the new policy. The policy is created using the CreatePolicy action.
        public let policy: String

        public init(policy: String) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct GeneratedPolicyProperties: AWSDecodableShape {
        /// Lists details about the Trail used to generated policy.
        public let cloudTrailProperties: CloudTrailProperties?
        /// This value is set to true if the generated policy contains all possible actions for a service that IAM Access Analyzer identified from the CloudTrail trail that you specified, and false otherwise.
        public let isComplete: Bool?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        public let principalArn: String

        public init(cloudTrailProperties: CloudTrailProperties? = nil, isComplete: Bool? = nil, principalArn: String) {
            self.cloudTrailProperties = cloudTrailProperties
            self.isComplete = isComplete
            self.principalArn = principalArn
        }

        private enum CodingKeys: String, CodingKey {
            case cloudTrailProperties = "cloudTrailProperties"
            case isComplete = "isComplete"
            case principalArn = "principalArn"
        }
    }

    public struct GeneratedPolicyResult: AWSDecodableShape {
        /// The text to use as the content for the new policy. The policy is created using the CreatePolicy action.
        public let generatedPolicies: [GeneratedPolicy]?
        /// A GeneratedPolicyProperties object that contains properties of the generated policy.
        public let properties: GeneratedPolicyProperties

        public init(generatedPolicies: [GeneratedPolicy]? = nil, properties: GeneratedPolicyProperties) {
            self.generatedPolicies = generatedPolicies
            self.properties = properties
        }

        private enum CodingKeys: String, CodingKey {
            case generatedPolicies = "generatedPolicies"
            case properties = "properties"
        }
    }

    public struct GetAccessPreviewRequest: AWSEncodableShape {
        /// The unique ID for the access preview.
        public let accessPreviewId: String
        /// The ARN of the analyzer used to generate the access preview.
        public let analyzerArn: String

        public init(accessPreviewId: String, analyzerArn: String) {
            self.accessPreviewId = accessPreviewId
            self.analyzerArn = analyzerArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPreviewId, key: "accessPreviewId")
            request.encodeQuery(self.analyzerArn, key: "analyzerArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPreviewId, name: "accessPreviewId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPreviewResponse: AWSDecodableShape {
        /// An object that contains information about the access preview.
        public let accessPreview: AccessPreview

        public init(accessPreview: AccessPreview) {
            self.accessPreview = accessPreview
        }

        private enum CodingKeys: String, CodingKey {
            case accessPreview = "accessPreview"
        }
    }

    public struct GetAnalyzedResourceRequest: AWSEncodableShape {
        /// The ARN of the analyzer to retrieve information from.
        public let analyzerArn: String
        /// The ARN of the resource to retrieve information about.
        public let resourceArn: String

        public init(analyzerArn: String, resourceArn: String) {
            self.analyzerArn = analyzerArn
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.analyzerArn, key: "analyzerArn")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnalyzedResourceResponse: AWSDecodableShape {
        /// An AnalyzedResource object that contains information that IAM Access Analyzer found when it analyzed the resource.
        public let resource: AnalyzedResource?

        public init(resource: AnalyzedResource? = nil) {
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "resource"
        }
    }

    public struct GetAnalyzerRequest: AWSEncodableShape {
        /// The name of the analyzer retrieved.
        public let analyzerName: String

        public init(analyzerName: String) {
            self.analyzerName = analyzerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analyzerName, key: "analyzerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnalyzerResponse: AWSDecodableShape {
        /// An AnalyzerSummary object that contains information about the analyzer.
        public let analyzer: AnalyzerSummary

        public init(analyzer: AnalyzerSummary) {
            self.analyzer = analyzer
        }

        private enum CodingKeys: String, CodingKey {
            case analyzer = "analyzer"
        }
    }

    public struct GetArchiveRuleRequest: AWSEncodableShape {
        /// The name of the analyzer to retrieve rules from.
        public let analyzerName: String
        /// The name of the rule to retrieve.
        public let ruleName: String

        public init(analyzerName: String, ruleName: String) {
            self.analyzerName = analyzerName
            self.ruleName = ruleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analyzerName, key: "analyzerName")
            request.encodePath(self.ruleName, key: "ruleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetArchiveRuleResponse: AWSDecodableShape {
        public let archiveRule: ArchiveRuleSummary

        public init(archiveRule: ArchiveRuleSummary) {
            self.archiveRule = archiveRule
        }

        private enum CodingKeys: String, CodingKey {
            case archiveRule = "archiveRule"
        }
    }

    public struct GetFindingRequest: AWSEncodableShape {
        /// The ARN of the analyzer that generated the finding.
        public let analyzerArn: String
        /// The ID of the finding to retrieve.
        public let id: String

        public init(analyzerArn: String, id: String) {
            self.analyzerArn = analyzerArn
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.analyzerArn, key: "analyzerArn")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingResponse: AWSDecodableShape {
        /// A finding object that contains finding details.
        public let finding: Finding?

        public init(finding: Finding? = nil) {
            self.finding = finding
        }

        private enum CodingKeys: String, CodingKey {
            case finding = "finding"
        }
    }

    public struct GetFindingV2Request: AWSEncodableShape {
        /// The ARN of the analyzer that generated the finding.
        public let analyzerArn: String
        /// The ID of the finding to retrieve.
        public let id: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzerArn: String, id: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.analyzerArn = analyzerArn
            self.id = id
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.analyzerArn, key: "analyzerArn")
            request.encodePath(self.id, key: "id")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingV2Response: AWSDecodableShape {
        /// The time at which the resource-based policy or IAM entity that generated the finding was analyzed.
        @CustomCoding<ISO8601DateCoder>
        public var analyzedAt: Date
        /// The time at which the finding was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// An error.
        public let error: String?
        /// A localized message that explains the finding and provides guidance on how to address it.
        public let findingDetails: [FindingDetails]
        /// The type of the finding. For external access analyzers, the type is ExternalAccess. For unused access analyzers, the type can be UnusedIAMRole, UnusedIAMUserAccessKey, UnusedIAMUserPassword, or UnusedPermission.
        public let findingType: FindingType?
        /// The ID of the finding to retrieve.
        public let id: String
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The resource that generated the finding.
        public let resource: String?
        /// Tye Amazon Web Services account ID that owns the resource.
        public let resourceOwnerAccount: String
        /// The type of the resource identified in the finding.
        public let resourceType: ResourceType
        /// The status of the finding.
        public let status: FindingStatus
        /// The time at which the finding was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(analyzedAt: Date, createdAt: Date, error: String? = nil, findingDetails: [FindingDetails], findingType: FindingType? = nil, id: String, nextToken: String? = nil, resource: String? = nil, resourceOwnerAccount: String, resourceType: ResourceType, status: FindingStatus, updatedAt: Date) {
            self.analyzedAt = analyzedAt
            self.createdAt = createdAt
            self.error = error
            self.findingDetails = findingDetails
            self.findingType = findingType
            self.id = id
            self.nextToken = nextToken
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedAt = "analyzedAt"
            case createdAt = "createdAt"
            case error = "error"
            case findingDetails = "findingDetails"
            case findingType = "findingType"
            case id = "id"
            case nextToken = "nextToken"
            case resource = "resource"
            case resourceOwnerAccount = "resourceOwnerAccount"
            case resourceType = "resourceType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetGeneratedPolicyRequest: AWSEncodableShape {
        /// The level of detail that you want to generate. You can specify whether to generate policies with placeholders for resource ARNs for actions that support resource level granularity in policies. For example, in the resource section of a policy, you can receive a placeholder such as "Resource":"arn:aws:s3:::${BucketName}" instead of "*".
        public let includeResourcePlaceholders: Bool?
        /// The level of detail that you want to generate. You can specify whether to generate service-level policies.  IAM Access Analyzer uses iam:servicelastaccessed to identify services that have been used recently to create this service-level template.
        public let includeServiceLevelTemplate: Bool?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String

        public init(includeResourcePlaceholders: Bool? = nil, includeServiceLevelTemplate: Bool? = nil, jobId: String) {
            self.includeResourcePlaceholders = includeResourcePlaceholders
            self.includeServiceLevelTemplate = includeServiceLevelTemplate
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.includeResourcePlaceholders, key: "includeResourcePlaceholders")
            request.encodeQuery(self.includeServiceLevelTemplate, key: "includeServiceLevelTemplate")
            request.encodePath(self.jobId, key: "jobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGeneratedPolicyResponse: AWSDecodableShape {
        /// A GeneratedPolicyResult object that contains the generated policies and associated details.
        public let generatedPolicyResult: GeneratedPolicyResult
        /// A GeneratedPolicyDetails object that contains details about the generated policy.
        public let jobDetails: JobDetails

        public init(generatedPolicyResult: GeneratedPolicyResult, jobDetails: JobDetails) {
            self.generatedPolicyResult = generatedPolicyResult
            self.jobDetails = jobDetails
        }

        private enum CodingKeys: String, CodingKey {
            case generatedPolicyResult = "generatedPolicyResult"
            case jobDetails = "jobDetails"
        }
    }

    public struct IamRoleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The proposed trust policy for the IAM role.
        public let trustPolicy: String?

        public init(trustPolicy: String? = nil) {
            self.trustPolicy = trustPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case trustPolicy = "trustPolicy"
        }
    }

    public struct InlineArchiveRule: AWSEncodableShape {
        /// The condition and values for a criterion.
        public let filter: [String: Criterion]
        /// The name of the rule.
        public let ruleName: String

        public init(filter: [String: Criterion], ruleName: String) {
            self.filter = filter
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.filter.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case ruleName = "ruleName"
        }
    }

    public struct InternetConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct JobDetails: AWSDecodableShape {
        /// A timestamp of when the job was completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedOn: Date?
        /// The job error for the policy generation request.
        public let jobError: JobError?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String
        /// A timestamp of when the job was started.
        @CustomCoding<ISO8601DateCoder>
        public var startedOn: Date
        /// The status of the job request.
        public let status: JobStatus

        public init(completedOn: Date? = nil, jobError: JobError? = nil, jobId: String, startedOn: Date, status: JobStatus) {
            self.completedOn = completedOn
            self.jobError = jobError
            self.jobId = jobId
            self.startedOn = startedOn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "completedOn"
            case jobError = "jobError"
            case jobId = "jobId"
            case startedOn = "startedOn"
            case status = "status"
        }
    }

    public struct JobError: AWSDecodableShape {
        /// The job error code.
        public let code: JobErrorCode
        /// Specific information about the error. For example, which service quota was exceeded or which resource was not found.
        public let message: String

        public init(code: JobErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct KmsGrantConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Use this structure to propose allowing cryptographic operations in the grant only when the operation request includes the specified encryption context.
        public let constraints: KmsGrantConstraints?
        /// The principal that is given permission to perform the operations that the grant permits.
        public let granteePrincipal: String
        ///  The Amazon Web Services account under which the grant was issued. The account is used to propose KMS grants issued by accounts other than the owner of the key.
        public let issuingAccount: String
        /// A list of operations that the grant permits.
        public let operations: [KmsGrantOperation]
        /// The principal that is given permission to retire the grant by using RetireGrant operation.
        public let retiringPrincipal: String?

        public init(constraints: KmsGrantConstraints? = nil, granteePrincipal: String, issuingAccount: String, operations: [KmsGrantOperation], retiringPrincipal: String? = nil) {
            self.constraints = constraints
            self.granteePrincipal = granteePrincipal
            self.issuingAccount = issuingAccount
            self.operations = operations
            self.retiringPrincipal = retiringPrincipal
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "constraints"
            case granteePrincipal = "granteePrincipal"
            case issuingAccount = "issuingAccount"
            case operations = "operations"
            case retiringPrincipal = "retiringPrincipal"
        }
    }

    public struct KmsGrantConstraints: AWSEncodableShape & AWSDecodableShape {
        /// A list of key-value pairs that must match the encryption context in the cryptographic operation request. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint.
        public let encryptionContextEquals: [String: String]?
        /// A list of key-value pairs that must be included in the encryption context of the cryptographic operation request. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs.
        public let encryptionContextSubset: [String: String]?

        public init(encryptionContextEquals: [String: String]? = nil, encryptionContextSubset: [String: String]? = nil) {
            self.encryptionContextEquals = encryptionContextEquals
            self.encryptionContextSubset = encryptionContextSubset
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionContextEquals = "encryptionContextEquals"
            case encryptionContextSubset = "encryptionContextSubset"
        }
    }

    public struct KmsKeyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of proposed grant configurations for the KMS key. If the proposed grant configuration is for an existing key, the access preview uses the proposed list of grant configurations in place of the existing grants. Otherwise, the access preview uses the existing grants for the key.
        public let grants: [KmsGrantConfiguration]?
        /// Resource policy configuration for the KMS key. The only valid value for the name of the key policy is default. For more information, see Default key policy.
        public let keyPolicies: [String: String]?

        public init(grants: [KmsGrantConfiguration]? = nil, keyPolicies: [String: String]? = nil) {
            self.grants = grants
            self.keyPolicies = keyPolicies
        }

        private enum CodingKeys: String, CodingKey {
            case grants = "grants"
            case keyPolicies = "keyPolicies"
        }
    }

    public struct ListAccessPreviewFindingsRequest: AWSEncodableShape {
        /// The unique ID for the access preview.
        public let accessPreviewId: String
        /// The ARN of the analyzer used to generate the access.
        public let analyzerArn: String
        /// Criteria to filter the returned findings.
        public let filter: [String: Criterion]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(accessPreviewId: String, analyzerArn: String, filter: [String: Criterion]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accessPreviewId = accessPreviewId
            self.analyzerArn = analyzerArn
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessPreviewId, key: "accessPreviewId")
            try container.encode(self.analyzerArn, forKey: .analyzerArn)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPreviewId, name: "accessPreviewId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.filter?.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAccessPreviewFindingsResponse: AWSDecodableShape {
        /// A list of access preview findings that match the specified filter criteria.
        public let findings: [AccessPreviewFinding]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(findings: [AccessPreviewFinding], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
        }
    }

    public struct ListAccessPreviewsRequest: AWSEncodableShape {
        /// The ARN of the analyzer used to generate the access preview.
        public let analyzerArn: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzerArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.analyzerArn = analyzerArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.analyzerArn, key: "analyzerArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPreviewsResponse: AWSDecodableShape {
        /// A list of access previews retrieved for the analyzer.
        public let accessPreviews: [AccessPreviewSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(accessPreviews: [AccessPreviewSummary], nextToken: String? = nil) {
            self.accessPreviews = accessPreviews
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPreviews = "accessPreviews"
            case nextToken = "nextToken"
        }
    }

    public struct ListAnalyzedResourcesRequest: AWSEncodableShape {
        /// The ARN of the analyzer to retrieve a list of analyzed resources from.
        public let analyzerArn: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The type of resource.
        public let resourceType: ResourceType?

        public init(analyzerArn: String, maxResults: Int? = nil, nextToken: String? = nil, resourceType: ResourceType? = nil) {
            self.analyzerArn = analyzerArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceType = "resourceType"
        }
    }

    public struct ListAnalyzedResourcesResponse: AWSDecodableShape {
        /// A list of resources that were analyzed.
        public let analyzedResources: [AnalyzedResourceSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzedResources: [AnalyzedResourceSummary], nextToken: String? = nil) {
            self.analyzedResources = analyzedResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedResources = "analyzedResources"
            case nextToken = "nextToken"
        }
    }

    public struct ListAnalyzersRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The type of analyzer.
        public let type: `Type`?

        public init(maxResults: Int? = nil, nextToken: String? = nil, type: `Type`? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalyzersResponse: AWSDecodableShape {
        /// The analyzers retrieved.
        public let analyzers: [AnalyzerSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzers: [AnalyzerSummary], nextToken: String? = nil) {
            self.analyzers = analyzers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analyzers = "analyzers"
            case nextToken = "nextToken"
        }
    }

    public struct ListArchiveRulesRequest: AWSEncodableShape {
        /// The name of the analyzer to retrieve rules from.
        public let analyzerName: String
        /// The maximum number of results to return in the request.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(analyzerName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.analyzerName = analyzerName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analyzerName, key: "analyzerName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListArchiveRulesResponse: AWSDecodableShape {
        /// A list of archive rules created for the specified analyzer.
        public let archiveRules: [ArchiveRuleSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(archiveRules: [ArchiveRuleSummary], nextToken: String? = nil) {
            self.archiveRules = archiveRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case archiveRules = "archiveRules"
            case nextToken = "nextToken"
        }
    }

    public struct ListFindingsRequest: AWSEncodableShape {
        /// The ARN of the analyzer to retrieve findings from.
        public let analyzerArn: String
        /// A filter to match for the findings to return.
        public let filter: [String: Criterion]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The sort order for the findings returned.
        public let sort: SortCriteria?

        public init(analyzerArn: String, filter: [String: Criterion]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: SortCriteria? = nil) {
            self.analyzerArn = analyzerArn
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.filter?.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sort = "sort"
        }
    }

    public struct ListFindingsResponse: AWSDecodableShape {
        /// A list of findings retrieved from the analyzer that match the filter criteria specified, if any.
        public let findings: [FindingSummary]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(findings: [FindingSummary], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
        }
    }

    public struct ListFindingsV2Request: AWSEncodableShape {
        /// The ARN of the analyzer to retrieve findings from.
        public let analyzerArn: String
        /// A filter to match for the findings to return.
        public let filter: [String: Criterion]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        public let sort: SortCriteria?

        public init(analyzerArn: String, filter: [String: Criterion]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: SortCriteria? = nil) {
            self.analyzerArn = analyzerArn
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.filter?.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sort = "sort"
        }
    }

    public struct ListFindingsV2Response: AWSDecodableShape {
        /// A list of findings retrieved from the analyzer that match the filter criteria specified, if any.
        public let findings: [FindingSummaryV2]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(findings: [FindingSummaryV2], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
        }
    }

    public struct ListPolicyGenerationsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy. Use this with ListGeneratedPolicies to filter the results to only include results for a specific principal.
        public let principalArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, principalArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalArn = principalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.principalArn, key: "principalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.principalArn, name: "principalArn", parent: name, pattern: "^arn:[^:]*:iam::[^:]*:(role|user)/.{1,576}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPolicyGenerationsResponse: AWSDecodableShape {
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// A PolicyGeneration object that contains details about the generated policy.
        public let policyGenerations: [PolicyGeneration]

        public init(nextToken: String? = nil, policyGenerations: [PolicyGeneration]) {
            self.nextToken = nextToken
            self.policyGenerations = policyGenerations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case policyGenerations = "policyGenerations"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to retrieve tags from.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags that are applied to the specified resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Location: AWSDecodableShape {
        /// A path in a policy, represented as a sequence of path elements.
        public let path: [PathElement]
        /// A span in a policy.
        public let span: Span

        public init(path: [PathElement], span: Span) {
            self.path = path
            self.span = span
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
            case span = "span"
        }
    }

    public struct PolicyGeneration: AWSDecodableShape {
        /// A timestamp of when the policy generation was completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedOn: Date?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        public let principalArn: String
        /// A timestamp of when the policy generation started.
        @CustomCoding<ISO8601DateCoder>
        public var startedOn: Date
        /// The status of the policy generation request.
        public let status: JobStatus

        public init(completedOn: Date? = nil, jobId: String, principalArn: String, startedOn: Date, status: JobStatus) {
            self.completedOn = completedOn
            self.jobId = jobId
            self.principalArn = principalArn
            self.startedOn = startedOn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "completedOn"
            case jobId = "jobId"
            case principalArn = "principalArn"
            case startedOn = "startedOn"
            case status = "status"
        }
    }

    public struct PolicyGenerationDetails: AWSEncodableShape {
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        public let principalArn: String

        public init(principalArn: String) {
            self.principalArn = principalArn
        }

        public func validate(name: String) throws {
            try self.validate(self.principalArn, name: "principalArn", parent: name, pattern: "^arn:[^:]*:iam::[^:]*:(role|user)/.{1,576}$")
        }

        private enum CodingKeys: String, CodingKey {
            case principalArn = "principalArn"
        }
    }

    public struct Position: AWSDecodableShape {
        /// The column of the position, starting from 0.
        public let column: Int
        /// The line of the position, starting from 1.
        public let line: Int
        /// The offset within the policy that corresponds to the position, starting from 0.
        public let offset: Int

        public init(column: Int, line: Int, offset: Int) {
            self.column = column
            self.line = line
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case column = "column"
            case line = "line"
            case offset = "offset"
        }
    }

    public struct RdsDbClusterSnapshotConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The names and values of manual DB cluster snapshot attributes. Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB cluster snapshot. The only valid value for AttributeName for the attribute map is restore
        public let attributes: [String: RdsDbClusterSnapshotAttributeValue]?
        /// The KMS key identifier for an encrypted Amazon RDS DB cluster snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.   If the configuration is for an existing Amazon RDS DB cluster snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.   If the access preview is for a new resource and you do not specify the specify the kmsKeyId, then the access preview considers the snapshot as unencrypted.
        public let kmsKeyId: String?

        public init(attributes: [String: RdsDbClusterSnapshotAttributeValue]? = nil, kmsKeyId: String? = nil) {
            self.attributes = attributes
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct RdsDbSnapshotConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The names and values of manual DB snapshot attributes. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB snapshot. The only valid value for attributeName for the attribute map is restore.
        public let attributes: [String: RdsDbSnapshotAttributeValue]?
        /// The KMS key identifier for an encrypted Amazon RDS DB snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.   If the configuration is for an existing Amazon RDS DB snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.   If the access preview is for a new resource and you do not specify the specify the kmsKeyId, then the access preview considers the snapshot as unencrypted.
        public let kmsKeyId: String?

        public init(attributes: [String: RdsDbSnapshotAttributeValue]? = nil, kmsKeyId: String? = nil) {
            self.attributes = attributes
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct ReasonSummary: AWSDecodableShape {
        /// A description of the reasoning of a result of checking for access.
        public let description: String?
        /// The identifier for the reason statement.
        public let statementId: String?
        /// The index number of the reason statement.
        public let statementIndex: Int?

        public init(description: String? = nil, statementId: String? = nil, statementIndex: Int? = nil) {
            self.description = description
            self.statementId = statementId
            self.statementIndex = statementIndex
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case statementId = "statementId"
            case statementIndex = "statementIndex"
        }
    }

    public struct S3AccessPointConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The access point or multi-region access point policy.
        public let accessPointPolicy: String?
        /// The proposed Internet and VpcConfiguration to apply to this Amazon S3 access point. VpcConfiguration does not apply to multi-region access points. If the access preview is for a new resource and neither is specified, the access preview uses Internet for the network origin. If the access preview is for an existing resource and neither is specified, the access preview uses the exiting network origin.
        public let networkOrigin: NetworkOriginConfiguration?
        /// The proposed S3PublicAccessBlock configuration to apply to this Amazon S3 access point or multi-region access point.
        public let publicAccessBlock: S3PublicAccessBlockConfiguration?

        public init(accessPointPolicy: String? = nil, networkOrigin: NetworkOriginConfiguration? = nil, publicAccessBlock: S3PublicAccessBlockConfiguration? = nil) {
            self.accessPointPolicy = accessPointPolicy
            self.networkOrigin = networkOrigin
            self.publicAccessBlock = publicAccessBlock
        }

        public func validate(name: String) throws {
            try self.networkOrigin?.validate(name: "\(name).networkOrigin")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointPolicy = "accessPointPolicy"
            case networkOrigin = "networkOrigin"
            case publicAccessBlock = "publicAccessBlock"
        }
    }

    public struct S3BucketAclGrantConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The grantee to whom you’re assigning access rights.
        public let grantee: AclGrantee
        /// The permissions being granted.
        public let permission: AclPermission

        public init(grantee: AclGrantee, permission: AclPermission) {
            self.grantee = grantee
            self.permission = permission
        }

        private enum CodingKeys: String, CodingKey {
            case grantee = "grantee"
            case permission = "permission"
        }
    }

    public struct S3BucketConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of Amazon S3 access points or multi-region access points for the bucket. You can propose up to 10 new access points per bucket.
        public let accessPoints: [String: S3AccessPointConfiguration]?
        /// The proposed list of ACL grants for the Amazon S3 bucket. You can propose up to 100 ACL grants per bucket. If the proposed grant configuration is for an existing bucket, the access preview uses the proposed list of grant configurations in place of the existing grants. Otherwise, the access preview uses the existing grants for the bucket.
        public let bucketAclGrants: [S3BucketAclGrantConfiguration]?
        /// The proposed bucket policy for the Amazon S3 bucket.
        public let bucketPolicy: String?
        /// The proposed block public access configuration for the Amazon S3 bucket.
        public let bucketPublicAccessBlock: S3PublicAccessBlockConfiguration?

        public init(accessPoints: [String: S3AccessPointConfiguration]? = nil, bucketAclGrants: [S3BucketAclGrantConfiguration]? = nil, bucketPolicy: String? = nil, bucketPublicAccessBlock: S3PublicAccessBlockConfiguration? = nil) {
            self.accessPoints = accessPoints
            self.bucketAclGrants = bucketAclGrants
            self.bucketPolicy = bucketPolicy
            self.bucketPublicAccessBlock = bucketPublicAccessBlock
        }

        public func validate(name: String) throws {
            try self.accessPoints?.forEach {
                try validate($0.key, name: "accessPoints.key", parent: name, pattern: "^arn:[^:]*:s3:[^:]*:[^:]*:accesspoint/.*$")
                try $0.value.validate(name: "\(name).accessPoints[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessPoints = "accessPoints"
            case bucketAclGrants = "bucketAclGrants"
            case bucketPolicy = "bucketPolicy"
            case bucketPublicAccessBlock = "bucketPublicAccessBlock"
        }
    }

    public struct S3ExpressDirectoryBucketConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The proposed bucket policy for the Amazon S3 directory bucket.
        public let bucketPolicy: String?

        public init(bucketPolicy: String? = nil) {
            self.bucketPolicy = bucketPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case bucketPolicy = "bucketPolicy"
        }
    }

    public struct S3PublicAccessBlockConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket.
        public let ignorePublicAcls: Bool
        ///  Specifies whether Amazon S3 should restrict public bucket policies for this bucket.
        public let restrictPublicBuckets: Bool

        public init(ignorePublicAcls: Bool, restrictPublicBuckets: Bool) {
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case ignorePublicAcls = "ignorePublicAcls"
            case restrictPublicBuckets = "restrictPublicBuckets"
        }
    }

    public struct SecretsManagerSecretConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The proposed ARN, key ID, or alias of the KMS key.
        public let kmsKeyId: String?
        /// The proposed resource policy defining who can access or manage the secret.
        public let secretPolicy: String?

        public init(kmsKeyId: String? = nil, secretPolicy: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.secretPolicy = secretPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
            case secretPolicy = "secretPolicy"
        }
    }

    public struct SnsTopicConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The JSON policy text that defines who can access an Amazon SNS topic. For more information, see Example cases for Amazon SNS access control in the Amazon SNS Developer Guide.
        public let topicPolicy: String?

        public init(topicPolicy: String? = nil) {
            self.topicPolicy = topicPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.topicPolicy, name: "topicPolicy", parent: name, max: 30720)
        }

        private enum CodingKeys: String, CodingKey {
            case topicPolicy = "topicPolicy"
        }
    }

    public struct SortCriteria: AWSEncodableShape {
        /// The name of the attribute to sort on.
        public let attributeName: String?
        /// The sort order, ascending or descending.
        public let orderBy: OrderBy?

        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case orderBy = "orderBy"
        }
    }

    public struct Span: AWSDecodableShape {
        /// The end position of the span (exclusive).
        public let end: Position
        /// The start position of the span (inclusive).
        public let start: Position

        public init(end: Position, start: Position) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct SqsQueueConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The proposed resource policy for the Amazon SQS queue.
        public let queuePolicy: String?

        public init(queuePolicy: String? = nil) {
            self.queuePolicy = queuePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case queuePolicy = "queuePolicy"
        }
    }

    public struct StartPolicyGenerationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// A CloudTrailDetails object that contains details about a Trail that you want to analyze to generate policies.
        public let cloudTrailDetails: CloudTrailDetails?
        /// Contains the ARN of the IAM entity (user or role) for which you are generating a policy.
        public let policyGenerationDetails: PolicyGenerationDetails

        public init(clientToken: String? = StartPolicyGenerationRequest.idempotencyToken(), cloudTrailDetails: CloudTrailDetails? = nil, policyGenerationDetails: PolicyGenerationDetails) {
            self.clientToken = clientToken
            self.cloudTrailDetails = cloudTrailDetails
            self.policyGenerationDetails = policyGenerationDetails
        }

        public func validate(name: String) throws {
            try self.cloudTrailDetails?.validate(name: "\(name).cloudTrailDetails")
            try self.policyGenerationDetails.validate(name: "\(name).policyGenerationDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case cloudTrailDetails = "cloudTrailDetails"
            case policyGenerationDetails = "policyGenerationDetails"
        }
    }

    public struct StartPolicyGenerationResponse: AWSDecodableShape {
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct StartResourceScanRequest: AWSEncodableShape {
        /// The ARN of the analyzer to use to scan the policies applied to the specified resource.
        public let analyzerArn: String
        /// The ARN of the resource to scan.
        public let resourceArn: String
        /// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
        public let resourceOwnerAccount: String?

        public init(analyzerArn: String, resourceArn: String, resourceOwnerAccount: String? = nil) {
            self.analyzerArn = analyzerArn
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case resourceArn = "resourceArn"
            case resourceOwnerAccount = "resourceOwnerAccount"
        }
    }

    public struct StatusReason: AWSDecodableShape {
        /// The reason code for the current status of the analyzer.
        public let code: ReasonCode

        public init(code: ReasonCode) {
            self.code = code
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
        }
    }

    public struct Substring: AWSDecodableShape {
        /// The length of the substring.
        public let length: Int
        /// The start index of the substring, starting from 0.
        public let start: Int

        public init(length: Int, start: Int) {
            self.length = length
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case length = "length"
            case start = "start"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to add the tag to.
        public let resourceArn: String
        /// The tags to add to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Trail: AWSEncodableShape {
        /// Possible values are true or false. If set to true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and generate a policy.
        public let allRegions: Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        public let cloudTrailArn: String
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public let regions: [String]?

        public init(allRegions: Bool? = nil, cloudTrailArn: String, regions: [String]? = nil) {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudTrailArn, name: "cloudTrailArn", parent: name, pattern: "^arn:[^:]*:cloudtrail:[^:]*:[^:]*:trail/.{1,576}$")
        }

        private enum CodingKeys: String, CodingKey {
            case allRegions = "allRegions"
            case cloudTrailArn = "cloudTrailArn"
            case regions = "regions"
        }
    }

    public struct TrailProperties: AWSDecodableShape {
        /// Possible values are true or false. If set to true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and generate a policy.
        public let allRegions: Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        public let cloudTrailArn: String
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public let regions: [String]?

        public init(allRegions: Bool? = nil, cloudTrailArn: String, regions: [String]? = nil) {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case allRegions = "allRegions"
            case cloudTrailArn = "cloudTrailArn"
            case regions = "regions"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to remove the tag from.
        public let resourceArn: String
        /// The key for the tag to add.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UnusedAccessConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The specified access age in days for which to generate findings for unused access. For example, if you specify 90 days, the analyzer will generate findings for IAM entities within the accounts of the selected organization for any access that hasn't been used in 90 or more days since the analyzer's last scan. You can choose a value between 1 and 180 days.
        public let unusedAccessAge: Int?

        public init(unusedAccessAge: Int? = nil) {
            self.unusedAccessAge = unusedAccessAge
        }

        private enum CodingKeys: String, CodingKey {
            case unusedAccessAge = "unusedAccessAge"
        }
    }

    public struct UnusedAction: AWSDecodableShape {
        /// The action for which the unused access finding was generated.
        public let action: String
        /// The time at which the action was last accessed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastAccessed: Date?

        public init(action: String, lastAccessed: Date? = nil) {
            self.action = action
            self.lastAccessed = lastAccessed
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case lastAccessed = "lastAccessed"
        }
    }

    public struct UnusedIamRoleDetails: AWSDecodableShape {
        /// The time at which the role was last accessed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastAccessed: Date?

        public init(lastAccessed: Date? = nil) {
            self.lastAccessed = lastAccessed
        }

        private enum CodingKeys: String, CodingKey {
            case lastAccessed = "lastAccessed"
        }
    }

    public struct UnusedIamUserAccessKeyDetails: AWSDecodableShape {
        /// The ID of the access key for which the unused access finding was generated.
        public let accessKeyId: String
        /// The time at which the access key was last accessed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastAccessed: Date?

        public init(accessKeyId: String, lastAccessed: Date? = nil) {
            self.accessKeyId = accessKeyId
            self.lastAccessed = lastAccessed
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case lastAccessed = "lastAccessed"
        }
    }

    public struct UnusedIamUserPasswordDetails: AWSDecodableShape {
        /// The time at which the password was last accessed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastAccessed: Date?

        public init(lastAccessed: Date? = nil) {
            self.lastAccessed = lastAccessed
        }

        private enum CodingKeys: String, CodingKey {
            case lastAccessed = "lastAccessed"
        }
    }

    public struct UnusedPermissionDetails: AWSDecodableShape {
        /// A list of unused actions for which the unused access finding was generated.
        public let actions: [UnusedAction]?
        /// The time at which the permission last accessed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastAccessed: Date?
        /// The namespace of the Amazon Web Services service that contains the unused actions.
        public let serviceNamespace: String

        public init(actions: [UnusedAction]? = nil, lastAccessed: Date? = nil, serviceNamespace: String) {
            self.actions = actions
            self.lastAccessed = lastAccessed
            self.serviceNamespace = serviceNamespace
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case lastAccessed = "lastAccessed"
            case serviceNamespace = "serviceNamespace"
        }
    }

    public struct UpdateArchiveRuleRequest: AWSEncodableShape {
        /// The name of the analyzer to update the archive rules for.
        public let analyzerName: String
        /// A client token.
        public let clientToken: String?
        /// A filter to match for the rules to update. Only rules that match the filter are updated.
        public let filter: [String: Criterion]
        /// The name of the rule to update.
        public let ruleName: String

        public init(analyzerName: String, clientToken: String? = UpdateArchiveRuleRequest.idempotencyToken(), filter: [String: Criterion], ruleName: String) {
            self.analyzerName = analyzerName
            self.clientToken = clientToken
            self.filter = filter
            self.ruleName = ruleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analyzerName, key: "analyzerName")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.filter, forKey: .filter)
            request.encodePath(self.ruleName, key: "ruleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, max: 255)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, min: 1)
            try self.validate(self.analyzerName, name: "analyzerName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
            try self.filter.forEach {
                try $0.value.validate(name: "\(name).filter[\"\($0.key)\"]")
            }
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 255)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case filter = "filter"
        }
    }

    public struct UpdateFindingsRequest: AWSEncodableShape {
        /// The ARN of the analyzer that generated the findings to update.
        public let analyzerArn: String
        /// A client token.
        public let clientToken: String?
        /// The IDs of the findings to update.
        public let ids: [String]?
        /// The ARN of the resource identified in the finding.
        public let resourceArn: String?
        /// The state represents the action to take to update the finding Status. Use ARCHIVE to change an Active finding to an Archived finding. Use ACTIVE to change an Archived finding to an Active finding.
        public let status: FindingStatusUpdate

        public init(analyzerArn: String, clientToken: String? = UpdateFindingsRequest.idempotencyToken(), ids: [String]? = nil, resourceArn: String? = nil, status: FindingStatusUpdate) {
            self.analyzerArn = analyzerArn
            self.clientToken = clientToken
            self.ids = ids
            self.resourceArn = resourceArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzerArn, name: "analyzerArn", parent: name, pattern: "^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[^:]*:[^:]*:[^:]*:[^:]*:.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerArn = "analyzerArn"
            case clientToken = "clientToken"
            case ids = "ids"
            case resourceArn = "resourceArn"
            case status = "status"
        }
    }

    public struct ValidatePolicyFinding: AWSDecodableShape {
        /// A localized message that explains the finding and provides guidance on how to address it.
        public let findingDetails: String
        /// The impact of the finding. Security warnings report when the policy allows access that we consider overly permissive. Errors report when a part of the policy is not functional. Warnings report non-security issues when a policy does not conform to policy writing best practices. Suggestions recommend stylistic improvements in the policy that do not impact access.
        public let findingType: ValidatePolicyFindingType
        /// The issue code provides an identifier of the issue associated with this finding.
        public let issueCode: String
        /// A link to additional documentation about the type of finding.
        public let learnMoreLink: String
        /// The list of locations in the policy document that are related to the finding. The issue code provides a summary of an issue identified by the finding.
        public let locations: [Location]

        public init(findingDetails: String, findingType: ValidatePolicyFindingType, issueCode: String, learnMoreLink: String, locations: [Location]) {
            self.findingDetails = findingDetails
            self.findingType = findingType
            self.issueCode = issueCode
            self.learnMoreLink = learnMoreLink
            self.locations = locations
        }

        private enum CodingKeys: String, CodingKey {
            case findingDetails = "findingDetails"
            case findingType = "findingType"
            case issueCode = "issueCode"
            case learnMoreLink = "learnMoreLink"
            case locations = "locations"
        }
    }

    public struct ValidatePolicyRequest: AWSEncodableShape {
        /// The locale to use for localizing the findings.
        public let locale: Locale?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned.
        public let nextToken: String?
        /// The JSON policy document to use as the content for the policy.
        public let policyDocument: String
        /// The type of policy to validate. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.  Service control policies (SCPs) are a type of organization policy attached to an Amazon Web Services organization, organizational unit (OU), or an account.
        public let policyType: PolicyType
        /// The type of resource to attach to your resource policy. Specify a value for the policy validation resource type only if the policy type is RESOURCE_POLICY. For example, to validate a resource policy to attach to an Amazon S3 bucket, you can choose AWS::S3::Bucket for the policy validation resource type. For resource types not supported as valid values, IAM Access Analyzer runs policy checks that apply to all resource policies. For example, to validate a resource policy to attach to a KMS key, do not specify a value for the policy validation resource type and IAM Access Analyzer will run policy checks that apply to all resource policies.
        public let validatePolicyResourceType: ValidatePolicyResourceType?

        public init(locale: Locale? = nil, maxResults: Int? = nil, nextToken: String? = nil, policyDocument: String, policyType: PolicyType, validatePolicyResourceType: ValidatePolicyResourceType? = nil) {
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyDocument = policyDocument
            self.policyType = policyType
            self.validatePolicyResourceType = validatePolicyResourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.locale, forKey: .locale)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.policyDocument, forKey: .policyDocument)
            try container.encode(self.policyType, forKey: .policyType)
            try container.encodeIfPresent(self.validatePolicyResourceType, forKey: .validatePolicyResourceType)
        }

        private enum CodingKeys: String, CodingKey {
            case locale = "locale"
            case policyDocument = "policyDocument"
            case policyType = "policyType"
            case validatePolicyResourceType = "validatePolicyResourceType"
        }
    }

    public struct ValidatePolicyResponse: AWSDecodableShape {
        /// The list of findings in a policy returned by IAM Access Analyzer based on its suite of policy checks.
        public let findings: [ValidatePolicyFinding]
        /// A token used for pagination of results returned.
        public let nextToken: String?

        public init(findings: [ValidatePolicyFinding], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  If this field is specified, this access point will only allow connections from the specified VPC ID.
        public let vpcId: String

        public init(vpcId: String) {
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-([0-9a-f]){8}(([0-9a-f]){9})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case vpcId = "vpcId"
        }
    }

    public struct AnalyzerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the configuration of an unused access analyzer for an Amazon Web Services organization or account. External access analyzers do not support any configuration.
        public let unusedAccess: UnusedAccessConfiguration?

        public init(unusedAccess: UnusedAccessConfiguration? = nil) {
            self.unusedAccess = unusedAccess
        }

        private enum CodingKeys: String, CodingKey {
            case unusedAccess = "unusedAccess"
        }
    }

    public struct RdsDbClusterSnapshotAttributeValue: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services account IDs that have access to the manual Amazon RDS DB cluster snapshot. If the value all is specified, then the Amazon RDS DB cluster snapshot is public and can be copied or restored by all Amazon Web Services accounts.   If the configuration is for an existing Amazon RDS DB cluster snapshot and you do not specify the accountIds in RdsDbClusterSnapshotAttributeValue, then the access preview uses the existing shared accountIds for the snapshot.   If the access preview is for a new resource and you do not specify the specify the accountIds in RdsDbClusterSnapshotAttributeValue, then the access preview considers the snapshot without any attributes.   To propose deletion of existing shared accountIds, you can specify an empty list for accountIds in the RdsDbClusterSnapshotAttributeValue.
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct RdsDbSnapshotAttributeValue: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services account IDs that have access to the manual Amazon RDS DB snapshot. If the value all is specified, then the Amazon RDS DB snapshot is public and can be copied or restored by all Amazon Web Services accounts.   If the configuration is for an existing Amazon RDS DB snapshot and you do not specify the accountIds in RdsDbSnapshotAttributeValue, then the access preview uses the existing shared accountIds for the snapshot.   If the access preview is for a new resource and you do not specify the specify the accountIds in RdsDbSnapshotAttributeValue, then the access preview considers the snapshot without any attributes.   To propose deletion of an existing shared accountIds, you can specify an empty list for accountIds in the RdsDbSnapshotAttributeValue.
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }
}

// MARK: - Errors

/// Error enum for AccessAnalyzer
public struct AccessAnalyzerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidParameterException = "InvalidParameterException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unprocessableEntityException = "UnprocessableEntityException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AccessAnalyzer
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A conflict exception error.
    public static var conflictException: Self { .init(.conflictException) }
    /// Internal server error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified parameter is invalid.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The specified resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Service quote met error.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Throttling limit exceeded error.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The specified entity could not be processed.
    public static var unprocessableEntityException: Self { .init(.unprocessableEntityException) }
    /// Validation exception error.
    public static var validationException: Self { .init(.validationException) }
}

extension AccessAnalyzerErrorType: Equatable {
    public static func == (lhs: AccessAnalyzerErrorType, rhs: AccessAnalyzerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AccessAnalyzerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
