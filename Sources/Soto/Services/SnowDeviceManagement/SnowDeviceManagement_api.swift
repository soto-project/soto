//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS SnowDeviceManagement service.
///
/// Amazon Web Services Snow Device Management documentation.
public struct SnowDeviceManagement: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the SnowDeviceManagement client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "SnowDeviceManagement",
            serviceIdentifier: "snow-device-management",
            serviceProtocol: .restjson,
            apiVersion: "2021-08-04",
            endpoint: endpoint,
            errorType: SnowDeviceManagementErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Sends a cancel request for a specified task. You can cancel a task only if it's still in a QUEUED state. Tasks that are already running can't be cancelled.  A task might still run if it's processed from the queue before the CancelTask operation changes the task's state.
    @Sendable
    @inlinable
    public func cancelTask(_ input: CancelTaskInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelTaskOutput {
        try await self.client.execute(
            operation: "CancelTask", 
            path: "/task/{taskId}/cancel", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sends a cancel request for a specified task. You can cancel a task only if it's still in a QUEUED state. Tasks that are already running can't be cancelled.  A task might still run if it's processed from the queue before the CancelTask operation changes the task's state.
    ///
    /// Parameters:
    ///   - taskId: The ID of the task that you are attempting to cancel. You can retrieve a task ID by using the ListTasks operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelTaskOutput {
        let input = CancelTaskInput(
            taskId: taskId
        )
        return try await self.cancelTask(input, logger: logger)
    }

    /// Instructs one or more devices to start a task, such as unlocking or rebooting.
    @Sendable
    @inlinable
    public func createTask(_ input: CreateTaskInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTaskOutput {
        try await self.client.execute(
            operation: "CreateTask", 
            path: "/task", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Instructs one or more devices to start a task, such as unlocking or rebooting.
    ///
    /// Parameters:
    ///   - clientToken: A token ensuring that the action is called only once with the specified details.
    ///   - command: The task to be performed. Only one task is executed on a device at a time.
    ///   - description: A description of the task and its targets.
    ///   - tags: Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    ///   - targets: A list of managed device IDs.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTask(
        clientToken: String? = CreateTaskInput.idempotencyToken(),
        command: Command,
        description: String? = nil,
        tags: [String: String]? = nil,
        targets: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTaskOutput {
        let input = CreateTaskInput(
            clientToken: clientToken, 
            command: command, 
            description: description, 
            tags: tags, 
            targets: targets
        )
        return try await self.createTask(input, logger: logger)
    }

    /// Checks device-specific information, such as the device type, software version, IP addresses, and lock status.
    @Sendable
    @inlinable
    public func describeDevice(_ input: DescribeDeviceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDeviceOutput {
        try await self.client.execute(
            operation: "DescribeDevice", 
            path: "/managed-device/{managedDeviceId}/describe", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Checks device-specific information, such as the device type, software version, IP addresses, and lock status.
    ///
    /// Parameters:
    ///   - managedDeviceId: The ID of the device that you are checking the information of.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDevice(
        managedDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDeviceOutput {
        let input = DescribeDeviceInput(
            managedDeviceId: managedDeviceId
        )
        return try await self.describeDevice(input, logger: logger)
    }

    /// Checks the current state of the Amazon EC2 instances. The output is similar to describeDevice, but the results are sourced from the device cache in the Amazon Web Services Cloud and include a subset of the available fields.
    @Sendable
    @inlinable
    public func describeDeviceEc2Instances(_ input: DescribeDeviceEc2Input, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDeviceEc2Output {
        try await self.client.execute(
            operation: "DescribeDeviceEc2Instances", 
            path: "/managed-device/{managedDeviceId}/resources/ec2/describe", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Checks the current state of the Amazon EC2 instances. The output is similar to describeDevice, but the results are sourced from the device cache in the Amazon Web Services Cloud and include a subset of the available fields.
    ///
    /// Parameters:
    ///   - instanceIds: A list of instance IDs associated with the managed device.
    ///   - managedDeviceId: The ID of the managed device.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDeviceEc2Instances(
        instanceIds: [String],
        managedDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDeviceEc2Output {
        let input = DescribeDeviceEc2Input(
            instanceIds: instanceIds, 
            managedDeviceId: managedDeviceId
        )
        return try await self.describeDeviceEc2Instances(input, logger: logger)
    }

    /// Checks the status of a remote task running on one or more target devices.
    @Sendable
    @inlinable
    public func describeExecution(_ input: DescribeExecutionInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeExecutionOutput {
        try await self.client.execute(
            operation: "DescribeExecution", 
            path: "/task/{taskId}/execution/{managedDeviceId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Checks the status of a remote task running on one or more target devices.
    ///
    /// Parameters:
    ///   - managedDeviceId: The ID of the managed device.
    ///   - taskId: The ID of the task that the action is describing.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeExecution(
        managedDeviceId: String,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeExecutionOutput {
        let input = DescribeExecutionInput(
            managedDeviceId: managedDeviceId, 
            taskId: taskId
        )
        return try await self.describeExecution(input, logger: logger)
    }

    /// Checks the metadata for a given task on a device.
    @Sendable
    @inlinable
    public func describeTask(_ input: DescribeTaskInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTaskOutput {
        try await self.client.execute(
            operation: "DescribeTask", 
            path: "/task/{taskId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Checks the metadata for a given task on a device.
    ///
    /// Parameters:
    ///   - taskId: The ID of the task to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeTaskOutput {
        let input = DescribeTaskInput(
            taskId: taskId
        )
        return try await self.describeTask(input, logger: logger)
    }

    /// Returns a list of the Amazon Web Services resources available for a device. Currently, Amazon EC2 instances are the only supported resource type.
    @Sendable
    @inlinable
    public func listDeviceResources(_ input: ListDeviceResourcesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDeviceResourcesOutput {
        try await self.client.execute(
            operation: "ListDeviceResources", 
            path: "/managed-device/{managedDeviceId}/resources", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of the Amazon Web Services resources available for a device. Currently, Amazon EC2 instances are the only supported resource type.
    ///
    /// Parameters:
    ///   - managedDeviceId: The ID of the managed device that you are listing the resources of.
    ///   - maxResults: The maximum number of resources per page.
    ///   - nextToken: A pagination token to continue to the next page of results.
    ///   - type: A structure used to filter the results by type of resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDeviceResources(
        managedDeviceId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        type: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDeviceResourcesOutput {
        let input = ListDeviceResourcesInput(
            managedDeviceId: managedDeviceId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            type: type
        )
        return try await self.listDeviceResources(input, logger: logger)
    }

    /// Returns a list of all devices on your Amazon Web Services account that have Amazon Web Services Snow Device Management enabled in the Amazon Web Services Region where the command is run.
    @Sendable
    @inlinable
    public func listDevices(_ input: ListDevicesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDevicesOutput {
        try await self.client.execute(
            operation: "ListDevices", 
            path: "/managed-devices", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all devices on your Amazon Web Services account that have Amazon Web Services Snow Device Management enabled in the Amazon Web Services Region where the command is run.
    ///
    /// Parameters:
    ///   - jobId: The ID of the job used to order the device.
    ///   - maxResults: The maximum number of devices to list per page.
    ///   - nextToken: A pagination token to continue to the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDevices(
        jobId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDevicesOutput {
        let input = ListDevicesInput(
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDevices(input, logger: logger)
    }

    /// Returns the status of tasks for one or more target devices.
    @Sendable
    @inlinable
    public func listExecutions(_ input: ListExecutionsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListExecutionsOutput {
        try await self.client.execute(
            operation: "ListExecutions", 
            path: "/executions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the status of tasks for one or more target devices.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of tasks to list per page.
    ///   - nextToken: A pagination token to continue to the next page of tasks.
    ///   - state: A structure used to filter the tasks by their current state.
    ///   - taskId: The ID of the task.
    ///   - logger: Logger use during operation
    @inlinable
    public func listExecutions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        state: ExecutionState? = nil,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListExecutionsOutput {
        let input = ListExecutionsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            state: state, 
            taskId: taskId
        )
        return try await self.listExecutions(input, logger: logger)
    }

    /// Returns a list of tags for a managed device or task.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceOutput {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of tags for a managed device or task.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the device or task.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceOutput {
        let input = ListTagsForResourceInput(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Returns a list of tasks that can be filtered by state.
    @Sendable
    @inlinable
    public func listTasks(_ input: ListTasksInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTasksOutput {
        try await self.client.execute(
            operation: "ListTasks", 
            path: "/tasks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of tasks that can be filtered by state.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of tasks per page.
    ///   - nextToken: A pagination token to continue to the next page of tasks.
    ///   - state: A structure used to filter the list of tasks.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTasks(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        state: TaskState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTasksOutput {
        let input = ListTasksInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            state: state
        )
        return try await self.listTasks(input, logger: logger)
    }

    /// Adds or replaces tags on a device or task.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds or replaces tags on a device or task.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the device or task.
    ///   - tags: Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = TagResourceInput(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a tag from a device or task.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a tag from a device or task.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the device or task.
    ///   - tagKeys: Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UntagResourceInput(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }
}

extension SnowDeviceManagement {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: SnowDeviceManagement, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension SnowDeviceManagement {
    /// Return PaginatorSequence for operation ``listDeviceResources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDeviceResourcesPaginator(
        _ input: ListDeviceResourcesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDeviceResourcesInput, ListDeviceResourcesOutput> {
        return .init(
            input: input,
            command: self.listDeviceResources,
            inputKey: \ListDeviceResourcesInput.nextToken,
            outputKey: \ListDeviceResourcesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDeviceResources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - managedDeviceId: The ID of the managed device that you are listing the resources of.
    ///   - maxResults: The maximum number of resources per page.
    ///   - type: A structure used to filter the results by type of resource.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDeviceResourcesPaginator(
        managedDeviceId: String,
        maxResults: Int? = nil,
        type: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDeviceResourcesInput, ListDeviceResourcesOutput> {
        let input = ListDeviceResourcesInput(
            managedDeviceId: managedDeviceId, 
            maxResults: maxResults, 
            type: type
        )
        return self.listDeviceResourcesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDevices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicesPaginator(
        _ input: ListDevicesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDevicesInput, ListDevicesOutput> {
        return .init(
            input: input,
            command: self.listDevices,
            inputKey: \ListDevicesInput.nextToken,
            outputKey: \ListDevicesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDevices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - jobId: The ID of the job used to order the device.
    ///   - maxResults: The maximum number of devices to list per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicesPaginator(
        jobId: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDevicesInput, ListDevicesOutput> {
        let input = ListDevicesInput(
            jobId: jobId, 
            maxResults: maxResults
        )
        return self.listDevicesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listExecutionsPaginator(
        _ input: ListExecutionsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListExecutionsInput, ListExecutionsOutput> {
        return .init(
            input: input,
            command: self.listExecutions,
            inputKey: \ListExecutionsInput.nextToken,
            outputKey: \ListExecutionsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of tasks to list per page.
    ///   - state: A structure used to filter the tasks by their current state.
    ///   - taskId: The ID of the task.
    ///   - logger: Logger used for logging
    @inlinable
    public func listExecutionsPaginator(
        maxResults: Int? = nil,
        state: ExecutionState? = nil,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListExecutionsInput, ListExecutionsOutput> {
        let input = ListExecutionsInput(
            maxResults: maxResults, 
            state: state, 
            taskId: taskId
        )
        return self.listExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTasksPaginator(
        _ input: ListTasksInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTasksInput, ListTasksOutput> {
        return .init(
            input: input,
            command: self.listTasks,
            inputKey: \ListTasksInput.nextToken,
            outputKey: \ListTasksOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of tasks per page.
    ///   - state: A structure used to filter the list of tasks.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTasksPaginator(
        maxResults: Int? = nil,
        state: TaskState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTasksInput, ListTasksOutput> {
        let input = ListTasksInput(
            maxResults: maxResults, 
            state: state
        )
        return self.listTasksPaginator(input, logger: logger)
    }
}

extension SnowDeviceManagement.ListDeviceResourcesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SnowDeviceManagement.ListDeviceResourcesInput {
        return .init(
            managedDeviceId: self.managedDeviceId,
            maxResults: self.maxResults,
            nextToken: token,
            type: self.type
        )
    }
}

extension SnowDeviceManagement.ListDevicesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SnowDeviceManagement.ListDevicesInput {
        return .init(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SnowDeviceManagement.ListExecutionsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SnowDeviceManagement.ListExecutionsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            state: self.state,
            taskId: self.taskId
        )
    }
}

extension SnowDeviceManagement.ListTasksInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SnowDeviceManagement.ListTasksInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            state: self.state
        )
    }
}
