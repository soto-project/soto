//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension SnowDeviceManagement {
    // MARK: Enums

    public enum AttachmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attached = "ATTACHED"
        case attaching = "ATTACHING"
        case detached = "DETACHED"
        case detaching = "DETACHING"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        case rejected = "REJECTED"
        case succeeded = "SUCCEEDED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum InstanceStateName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pending = "PENDING"
        case running = "RUNNING"
        case shuttingDown = "SHUTTING_DOWN"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum IpAddressAssignment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dhcp = "DHCP"
        case `static` = "STATIC"
        public var description: String { return self.rawValue }
    }

    public enum PhysicalConnectorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case qsfp = "QSFP"
        case rj45 = "RJ45"
        case rj452 = "RJ45_2"
        case sfpPlus = "SFP_PLUS"
        case wifi = "WIFI"
        public var description: String { return self.rawValue }
    }

    public enum TaskState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case completed = "COMPLETED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum UnlockState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case locked = "LOCKED"
        case unlocked = "UNLOCKED"
        case unlocking = "UNLOCKING"
        public var description: String { return self.rawValue }
    }

    public enum Command: AWSEncodableShape, Sendable {
        /// Reboots the device.
        case reboot(Reboot)
        /// Unlocks the device.
        case unlock(Unlock)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .reboot(let value):
                try container.encode(value, forKey: .reboot)
            case .unlock(let value):
                try container.encode(value, forKey: .unlock)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case reboot = "reboot"
            case unlock = "unlock"
        }
    }

    // MARK: Shapes

    public struct CancelTaskInput: AWSEncodableShape {
        /// The ID of the task that you are attempting to cancel. You can retrieve a task ID by using the ListTasks operation.
        public let taskId: String

        public init(taskId: String) {
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.taskId, name: "taskId", parent: name, max: 64)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelTaskOutput: AWSDecodableShape {
        /// The ID of the task that you are attempting to cancel.
        public let taskId: String?

        public init(taskId: String? = nil) {
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case taskId = "taskId"
        }
    }

    public struct Capacity: AWSDecodableShape {
        /// The amount of capacity available for use on the device.
        public let available: Int64?
        /// The name of the type of capacity, such as memory.
        public let name: String?
        /// The total capacity on the device.
        public let total: Int64?
        /// The unit of measure for the type of capacity.
        public let unit: String?
        /// The amount of capacity used on the device.
        public let used: Int64?

        public init(available: Int64? = nil, name: String? = nil, total: Int64? = nil, unit: String? = nil, used: Int64? = nil) {
            self.available = available
            self.name = name
            self.total = total
            self.unit = unit
            self.used = used
        }

        private enum CodingKeys: String, CodingKey {
            case available = "available"
            case name = "name"
            case total = "total"
            case unit = "unit"
            case used = "used"
        }
    }

    public struct CpuOptions: AWSDecodableShape {
        /// The number of cores that the CPU can use.
        public let coreCount: Int?
        /// The number of threads per core in the CPU.
        public let threadsPerCore: Int?

        public init(coreCount: Int? = nil, threadsPerCore: Int? = nil) {
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }

        private enum CodingKeys: String, CodingKey {
            case coreCount = "coreCount"
            case threadsPerCore = "threadsPerCore"
        }
    }

    public struct CreateTaskInput: AWSEncodableShape {
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?
        /// The task to be performed. Only one task is executed on a device at a time.
        public let command: Command
        /// A description of the task and its targets.
        public let description: String?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public let tags: [String: String]?
        /// A list of managed device IDs.
        public let targets: [String]

        public init(clientToken: String? = CreateTaskInput.idempotencyToken(), command: Command, description: String? = nil, tags: [String: String]? = nil, targets: [String]) {
            self.clientToken = clientToken
            self.command = command
            self.description = description
            self.tags = tags
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[A-Za-z0-9 _.,!#]*")
            try self.validate(self.targets, name: "targets", parent: name, max: 10)
            try self.validate(self.targets, name: "targets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case command = "command"
            case description = "description"
            case tags = "tags"
            case targets = "targets"
        }
    }

    public struct CreateTaskOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the task that you created.
        public let taskArn: String?
        /// The ID of the task that you created.
        public let taskId: String?

        public init(taskArn: String? = nil, taskId: String? = nil) {
            self.taskArn = taskArn
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case taskArn = "taskArn"
            case taskId = "taskId"
        }
    }

    public struct DescribeDeviceEc2Input: AWSEncodableShape {
        /// A list of instance IDs associated with the managed device.
        public let instanceIds: [String]
        /// The ID of the managed device.
        public let managedDeviceId: String

        public init(instanceIds: [String], managedDeviceId: String) {
            self.instanceIds = instanceIds
            self.managedDeviceId = managedDeviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.instanceIds, forKey: .instanceIds)
            request.encodePath(self.managedDeviceId, key: "managedDeviceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedDeviceId, name: "managedDeviceId", parent: name, max: 64)
            try self.validate(self.managedDeviceId, name: "managedDeviceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceIds = "instanceIds"
        }
    }

    public struct DescribeDeviceEc2Output: AWSDecodableShape {
        /// A list of structures containing information about each instance.
        public let instances: [InstanceSummary]?

        public init(instances: [InstanceSummary]? = nil) {
            self.instances = instances
        }

        private enum CodingKeys: String, CodingKey {
            case instances = "instances"
        }
    }

    public struct DescribeDeviceInput: AWSEncodableShape {
        /// The ID of the device that you are checking the information of.
        public let managedDeviceId: String

        public init(managedDeviceId: String) {
            self.managedDeviceId = managedDeviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedDeviceId, key: "managedDeviceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedDeviceId, name: "managedDeviceId", parent: name, max: 64)
            try self.validate(self.managedDeviceId, name: "managedDeviceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDeviceOutput: AWSDecodableShape {
        /// The ID of the job used when ordering the device.
        public let associatedWithJob: String?
        /// The hardware specifications of the device.
        public let deviceCapacities: [Capacity]?
        /// The current state of the device.
        public let deviceState: UnlockState?
        /// The type of Amazon Web Services Snow Family device.
        public let deviceType: String?
        /// When the device last contacted the Amazon Web Services Cloud. Indicates that the device is online.
        public let lastReachedOutAt: Date?
        /// When the device last pushed an update to the Amazon Web Services Cloud. Indicates when the device cache was refreshed.
        public let lastUpdatedAt: Date?
        /// The Amazon Resource Name (ARN) of the device.
        public let managedDeviceArn: String?
        /// The ID of the device that you checked the information for.
        public let managedDeviceId: String?
        /// The network interfaces available on the device.
        public let physicalNetworkInterfaces: [PhysicalNetworkInterface]?
        /// The software installed on the device.
        public let software: SoftwareInformation?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public let tags: [String: String]?

        public init(associatedWithJob: String? = nil, deviceCapacities: [Capacity]? = nil, deviceState: UnlockState? = nil, deviceType: String? = nil, lastReachedOutAt: Date? = nil, lastUpdatedAt: Date? = nil, managedDeviceArn: String? = nil, managedDeviceId: String? = nil, physicalNetworkInterfaces: [PhysicalNetworkInterface]? = nil, software: SoftwareInformation? = nil, tags: [String: String]? = nil) {
            self.associatedWithJob = associatedWithJob
            self.deviceCapacities = deviceCapacities
            self.deviceState = deviceState
            self.deviceType = deviceType
            self.lastReachedOutAt = lastReachedOutAt
            self.lastUpdatedAt = lastUpdatedAt
            self.managedDeviceArn = managedDeviceArn
            self.managedDeviceId = managedDeviceId
            self.physicalNetworkInterfaces = physicalNetworkInterfaces
            self.software = software
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case associatedWithJob = "associatedWithJob"
            case deviceCapacities = "deviceCapacities"
            case deviceState = "deviceState"
            case deviceType = "deviceType"
            case lastReachedOutAt = "lastReachedOutAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case managedDeviceArn = "managedDeviceArn"
            case managedDeviceId = "managedDeviceId"
            case physicalNetworkInterfaces = "physicalNetworkInterfaces"
            case software = "software"
            case tags = "tags"
        }
    }

    public struct DescribeExecutionInput: AWSEncodableShape {
        /// The ID of the managed device.
        public let managedDeviceId: String
        /// The ID of the task that the action is describing.
        public let taskId: String

        public init(managedDeviceId: String, taskId: String) {
            self.managedDeviceId = managedDeviceId
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedDeviceId, key: "managedDeviceId")
            request.encodePath(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedDeviceId, name: "managedDeviceId", parent: name, max: 64)
            try self.validate(self.managedDeviceId, name: "managedDeviceId", parent: name, min: 1)
            try self.validate(self.taskId, name: "taskId", parent: name, max: 64)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeExecutionOutput: AWSDecodableShape {
        /// The ID of the execution.
        public let executionId: String?
        /// When the status of the execution was last updated.
        public let lastUpdatedAt: Date?
        /// The ID of the managed device that the task is being executed on.
        public let managedDeviceId: String?
        /// When the execution began.
        public let startedAt: Date?
        /// The current state of the execution.
        public let state: ExecutionState?
        /// The ID of the task being executed on the device.
        public let taskId: String?

        public init(executionId: String? = nil, lastUpdatedAt: Date? = nil, managedDeviceId: String? = nil, startedAt: Date? = nil, state: ExecutionState? = nil, taskId: String? = nil) {
            self.executionId = executionId
            self.lastUpdatedAt = lastUpdatedAt
            self.managedDeviceId = managedDeviceId
            self.startedAt = startedAt
            self.state = state
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
            case lastUpdatedAt = "lastUpdatedAt"
            case managedDeviceId = "managedDeviceId"
            case startedAt = "startedAt"
            case state = "state"
            case taskId = "taskId"
        }
    }

    public struct DescribeTaskInput: AWSEncodableShape {
        /// The ID of the task to be described.
        public let taskId: String

        public init(taskId: String) {
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.taskId, name: "taskId", parent: name, max: 64)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTaskOutput: AWSDecodableShape {
        /// When the task was completed.
        public let completedAt: Date?
        /// When the CreateTask operation was called.
        public let createdAt: Date?
        /// The description provided of the task and managed devices.
        public let description: String?
        /// When the state of the task was last updated.
        public let lastUpdatedAt: Date?
        /// The current state of the task.
        public let state: TaskState?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public let tags: [String: String]?
        /// The managed devices that the task was sent to.
        public let targets: [String]?
        /// The Amazon Resource Name (ARN) of the task.
        public let taskArn: String?
        /// The ID of the task.
        public let taskId: String?

        public init(completedAt: Date? = nil, createdAt: Date? = nil, description: String? = nil, lastUpdatedAt: Date? = nil, state: TaskState? = nil, tags: [String: String]? = nil, targets: [String]? = nil, taskArn: String? = nil, taskId: String? = nil) {
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.state = state
            self.tags = tags
            self.targets = targets
            self.taskArn = taskArn
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case completedAt = "completedAt"
            case createdAt = "createdAt"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case state = "state"
            case tags = "tags"
            case targets = "targets"
            case taskArn = "taskArn"
            case taskId = "taskId"
        }
    }

    public struct DeviceSummary: AWSDecodableShape {
        /// The ID of the job used to order the device.
        public let associatedWithJob: String?
        /// The Amazon Resource Name (ARN) of the device.
        public let managedDeviceArn: String?
        /// The ID of the device.
        public let managedDeviceId: String?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public let tags: [String: String]?

        public init(associatedWithJob: String? = nil, managedDeviceArn: String? = nil, managedDeviceId: String? = nil, tags: [String: String]? = nil) {
            self.associatedWithJob = associatedWithJob
            self.managedDeviceArn = managedDeviceArn
            self.managedDeviceId = managedDeviceId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case associatedWithJob = "associatedWithJob"
            case managedDeviceArn = "managedDeviceArn"
            case managedDeviceId = "managedDeviceId"
            case tags = "tags"
        }
    }

    public struct EbsInstanceBlockDevice: AWSDecodableShape {
        /// When the attachment was initiated.
        public let attachTime: Date?
        /// A value that indicates whether the volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        /// The attachment state.
        public let status: AttachmentStatus?
        /// The ID of the Amazon EBS volume.
        public let volumeId: String?

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, status: AttachmentStatus? = nil, volumeId: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.status = status
            self.volumeId = volumeId
        }

        private enum CodingKeys: String, CodingKey {
            case attachTime = "attachTime"
            case deleteOnTermination = "deleteOnTermination"
            case status = "status"
            case volumeId = "volumeId"
        }
    }

    public struct ExecutionSummary: AWSDecodableShape {
        /// The ID of the execution.
        public let executionId: String?
        /// The ID of the managed device that the task is being executed on.
        public let managedDeviceId: String?
        /// The state of the execution.
        public let state: ExecutionState?
        /// The ID of the task.
        public let taskId: String?

        public init(executionId: String? = nil, managedDeviceId: String? = nil, state: ExecutionState? = nil, taskId: String? = nil) {
            self.executionId = executionId
            self.managedDeviceId = managedDeviceId
            self.state = state
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
            case managedDeviceId = "managedDeviceId"
            case state = "state"
            case taskId = "taskId"
        }
    }

    public struct Instance: AWSDecodableShape {
        /// The Amazon Machine Image (AMI) launch index, which you can use to find this instance in the launch group.
        public let amiLaunchIndex: Int?
        /// Any block device mapping entries for the instance.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The CPU options for the instance.
        public let cpuOptions: CpuOptions?
        /// When the instance was created.
        public let createdAt: Date?
        /// The ID of the AMI used to launch the instance.
        public let imageId: String?
        /// The ID of the instance.
        public let instanceId: String?
        /// The instance type.
        public let instanceType: String?
        /// The private IPv4 address assigned to the instance.
        public let privateIpAddress: String?
        /// The public IPv4 address assigned to the instance.
        public let publicIpAddress: String?
        /// The device name of the root device volume (for example, /dev/sda1).
        public let rootDeviceName: String?
        /// The security groups for the instance.
        public let securityGroups: [SecurityGroupIdentifier]?
        public let state: InstanceState?
        /// When the instance was last updated.
        public let updatedAt: Date?

        public init(amiLaunchIndex: Int? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, cpuOptions: CpuOptions? = nil, createdAt: Date? = nil, imageId: String? = nil, instanceId: String? = nil, instanceType: String? = nil, privateIpAddress: String? = nil, publicIpAddress: String? = nil, rootDeviceName: String? = nil, securityGroups: [SecurityGroupIdentifier]? = nil, state: InstanceState? = nil, updatedAt: Date? = nil) {
            self.amiLaunchIndex = amiLaunchIndex
            self.blockDeviceMappings = blockDeviceMappings
            self.cpuOptions = cpuOptions
            self.createdAt = createdAt
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
            self.rootDeviceName = rootDeviceName
            self.securityGroups = securityGroups
            self.state = state
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case amiLaunchIndex = "amiLaunchIndex"
            case blockDeviceMappings = "blockDeviceMappings"
            case cpuOptions = "cpuOptions"
            case createdAt = "createdAt"
            case imageId = "imageId"
            case instanceId = "instanceId"
            case instanceType = "instanceType"
            case privateIpAddress = "privateIpAddress"
            case publicIpAddress = "publicIpAddress"
            case rootDeviceName = "rootDeviceName"
            case securityGroups = "securityGroups"
            case state = "state"
            case updatedAt = "updatedAt"
        }
    }

    public struct InstanceBlockDeviceMapping: AWSDecodableShape {
        /// The block device name.
        public let deviceName: String?
        /// The parameters used to automatically set up Amazon Elastic Block Store (Amazon EBS) volumes when the instance is launched.
        public let ebs: EbsInstanceBlockDevice?

        public init(deviceName: String? = nil, ebs: EbsInstanceBlockDevice? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "deviceName"
            case ebs = "ebs"
        }
    }

    public struct InstanceState: AWSDecodableShape {
        /// The state of the instance as a 16-bit unsigned integer.  The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values between 256 and 65,535. These numerical values are used for internal purposes and should be ignored.  The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values between 0 and 255.  The valid values for the instance state code are all in the range of the low byte. These values are:     0 : pending     16 : running     32 : shutting-down     48 : terminated     64 : stopping     80 : stopped    You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in decimal.
        public let code: Int?
        /// The current state of the instance.
        public let name: InstanceStateName?

        public init(code: Int? = nil, name: InstanceStateName? = nil) {
            self.code = code
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case name = "name"
        }
    }

    public struct InstanceSummary: AWSDecodableShape {
        /// A structure containing details about the instance.
        public let instance: Instance?
        /// When the instance summary was last updated.
        public let lastUpdatedAt: Date?

        public init(instance: Instance? = nil, lastUpdatedAt: Date? = nil) {
            self.instance = instance
            self.lastUpdatedAt = lastUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case instance = "instance"
            case lastUpdatedAt = "lastUpdatedAt"
        }
    }

    public struct ListDeviceResourcesInput: AWSEncodableShape {
        /// The ID of the managed device that you are listing the resources of.
        public let managedDeviceId: String
        /// The maximum number of resources per page.
        public let maxResults: Int?
        /// A pagination token to continue to the next page of results.
        public let nextToken: String?
        /// A structure used to filter the results by type of resource.
        public let type: String?

        public init(managedDeviceId: String, maxResults: Int? = nil, nextToken: String? = nil, type: String? = nil) {
            self.managedDeviceId = managedDeviceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedDeviceId, key: "managedDeviceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedDeviceId, name: "managedDeviceId", parent: name, max: 64)
            try self.validate(self.managedDeviceId, name: "managedDeviceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[a-zA-Z0-9+/=]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeviceResourcesOutput: AWSDecodableShape {
        /// A pagination token to continue to the next page of results.
        public let nextToken: String?
        /// A structure defining the resource's type, Amazon Resource Name (ARN), and ID.
        public let resources: [ResourceSummary]?

        public init(nextToken: String? = nil, resources: [ResourceSummary]? = nil) {
            self.nextToken = nextToken
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resources = "resources"
        }
    }

    public struct ListDevicesInput: AWSEncodableShape {
        /// The ID of the job used to order the device.
        public let jobId: String?
        /// The maximum number of devices to list per page.
        public let maxResults: Int?
        /// A pagination token to continue to the next page of results.
        public let nextToken: String?

        public init(jobId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[a-zA-Z0-9+/=]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDevicesOutput: AWSDecodableShape {
        /// A list of device structures that contain information about the device.
        public let devices: [DeviceSummary]?
        /// A pagination token to continue to the next page of devices.
        public let nextToken: String?

        public init(devices: [DeviceSummary]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "devices"
            case nextToken = "nextToken"
        }
    }

    public struct ListExecutionsInput: AWSEncodableShape {
        /// The maximum number of tasks to list per page.
        public let maxResults: Int?
        /// A pagination token to continue to the next page of tasks.
        public let nextToken: String?
        /// A structure used to filter the tasks by their current state.
        public let state: ExecutionState?
        /// The ID of the task.
        public let taskId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, state: ExecutionState? = nil, taskId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.state = state
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.state, key: "state")
            request.encodeQuery(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[a-zA-Z0-9+/=]*")
            try self.validate(self.taskId, name: "taskId", parent: name, max: 64)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExecutionsOutput: AWSDecodableShape {
        /// A list of executions. Each execution contains the task ID, the device that the task is executing on, the execution ID, and the status of the execution.
        public let executions: [ExecutionSummary]?
        /// A pagination token to continue to the next page of executions.
        public let nextToken: String?

        public init(executions: [ExecutionSummary]? = nil, nextToken: String? = nil) {
            self.executions = executions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case executions = "executions"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the device or task.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The list of tags for the device or task.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTasksInput: AWSEncodableShape {
        /// The maximum number of tasks per page.
        public let maxResults: Int?
        /// A pagination token to continue to the next page of tasks.
        public let nextToken: String?
        /// A structure used to filter the list of tasks.
        public let state: TaskState?

        public init(maxResults: Int? = nil, nextToken: String? = nil, state: TaskState? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.state, key: "state")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[a-zA-Z0-9+/=]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTasksOutput: AWSDecodableShape {
        /// A pagination token to continue to the next page of tasks.
        public let nextToken: String?
        /// A list of task structures containing details about each task.
        public let tasks: [TaskSummary]?

        public init(nextToken: String? = nil, tasks: [TaskSummary]? = nil) {
            self.nextToken = nextToken
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tasks = "tasks"
        }
    }

    public struct PhysicalNetworkInterface: AWSDecodableShape {
        /// The default gateway of the device.
        public let defaultGateway: String?
        /// The IP address of the device.
        public let ipAddress: String?
        /// A value that describes whether the IP address is dynamic or persistent.
        public let ipAddressAssignment: IpAddressAssignment?
        /// The MAC address of the device.
        public let macAddress: String?
        /// The netmask used to divide the IP address into subnets.
        public let netmask: String?
        /// The physical connector type.
        public let physicalConnectorType: PhysicalConnectorType?
        /// The physical network interface ID.
        public let physicalNetworkInterfaceId: String?

        public init(defaultGateway: String? = nil, ipAddress: String? = nil, ipAddressAssignment: IpAddressAssignment? = nil, macAddress: String? = nil, netmask: String? = nil, physicalConnectorType: PhysicalConnectorType? = nil, physicalNetworkInterfaceId: String? = nil) {
            self.defaultGateway = defaultGateway
            self.ipAddress = ipAddress
            self.ipAddressAssignment = ipAddressAssignment
            self.macAddress = macAddress
            self.netmask = netmask
            self.physicalConnectorType = physicalConnectorType
            self.physicalNetworkInterfaceId = physicalNetworkInterfaceId
        }

        private enum CodingKeys: String, CodingKey {
            case defaultGateway = "defaultGateway"
            case ipAddress = "ipAddress"
            case ipAddressAssignment = "ipAddressAssignment"
            case macAddress = "macAddress"
            case netmask = "netmask"
            case physicalConnectorType = "physicalConnectorType"
            case physicalNetworkInterfaceId = "physicalNetworkInterfaceId"
        }
    }

    public struct Reboot: AWSEncodableShape {
        public init() {}
    }

    public struct ResourceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The ID of the resource.
        public let id: String?
        /// The resource type.
        public let resourceType: String

        public init(arn: String? = nil, id: String? = nil, resourceType: String) {
            self.arn = arn
            self.id = id
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case resourceType = "resourceType"
        }
    }

    public struct SecurityGroupIdentifier: AWSDecodableShape {
        /// The security group ID.
        public let groupId: String?
        /// The security group name.
        public let groupName: String?

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "groupId"
            case groupName = "groupName"
        }
    }

    public struct SoftwareInformation: AWSDecodableShape {
        /// The version of the software currently installed on the device.
        public let installedVersion: String?
        /// The version of the software being installed on the device.
        public let installingVersion: String?
        /// The state of the software that is installed or that is being installed on the device.
        public let installState: String?

        public init(installedVersion: String? = nil, installingVersion: String? = nil, installState: String? = nil) {
            self.installedVersion = installedVersion
            self.installingVersion = installingVersion
            self.installState = installState
        }

        private enum CodingKeys: String, CodingKey {
            case installedVersion = "installedVersion"
            case installingVersion = "installingVersion"
            case installState = "installState"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the device or task.
        public let resourceArn: String
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TaskSummary: AWSDecodableShape {
        /// The state of the task assigned to one or many devices.
        public let state: TaskState?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of the task.
        public let taskArn: String?
        /// The task ID.
        public let taskId: String

        public init(state: TaskState? = nil, tags: [String: String]? = nil, taskArn: String? = nil, taskId: String) {
            self.state = state
            self.tags = tags
            self.taskArn = taskArn
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case tags = "tags"
            case taskArn = "taskArn"
            case taskId = "taskId"
        }
    }

    public struct Unlock: AWSEncodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the device or task.
        public let resourceArn: String
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }
}

// MARK: - Errors

/// Error enum for SnowDeviceManagement
public struct SnowDeviceManagementErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SnowDeviceManagement
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// An unexpected error occurred while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resource that doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension SnowDeviceManagementErrorType: Equatable {
    public static func == (lhs: SnowDeviceManagementErrorType, rhs: SnowDeviceManagementErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SnowDeviceManagementErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
