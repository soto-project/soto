//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MWAAServerless {
    // MARK: Enums

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsManagedKey = "AWS_MANAGED_KEY"
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum EngineVersion: Int, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Engine version 1 of Amazon Managed Workflows for Apache Airflow Serverless
        case one = 1
        public var description: String { return "\(self.rawValue)" }
    }

    public enum RunType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onDemand = "ON_DEMAND"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum TaskInstanceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case deferred = "DEFERRED"
        case failed = "FAILED"
        case none = "NONE"
        case queued = "QUEUED"
        case removed = "REMOVED"
        case restarting = "RESTARTING"
        case running = "RUNNING"
        case scheduled = "SCHEDULED"
        case success = "SUCCESS"
        case timeout = "TIMEOUT"
        case upForReschedule = "UP_FOR_RESCHEDULE"
        case upForRetry = "UP_FOR_RETRY"
        case upstreamFailed = "UPSTREAM_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case success = "SUCCESS"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "DELETING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The unique identifier of the resource.
        public let resourceId: String
        /// The type of the resource.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateWorkflowRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token prevents duplicate workflow creation requests.
        public let clientToken: String?
        /// The Amazon S3 location where the workflow definition file is stored. This must point to a valid YAML file that defines the workflow structure using supported Amazon Web Services operators and tasks. Amazon Managed Workflows for Apache Airflow Serverless takes a snapshot of the definition at creation time, so subsequent changes to the Amazon S3 object will not affect the workflow unless you create a new version. In your YAML definition, include task dependencies, scheduling information, and operator configurations that are compatible with the Amazon Managed Workflows for Apache Airflow Serverless execution environment.
        public let definitionS3Location: DefinitionS3Location
        /// An optional description of the workflow that you can use to provide additional context about the workflow's purpose and functionality.
        public let description: String?
        /// The configuration for encrypting workflow data at rest and in transit. Specifies the encryption type and optional KMS key for customer-managed encryption.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The version of the Amazon Managed Workflows for Apache Airflow Serverless engine that you want to use for this workflow. This determines the feature set, supported operators, and execution environment capabilities available to your workflow. Amazon Managed Workflows for Apache Airflow Serverless maintains backward compatibility across versions while introducing new features and improvements. Currently supports version 1 with plans for additional versions as the service evolves.
        public let engineVersion: EngineVersion?
        /// The configuration for workflow logging. Specifies the CloudWatch log group where workflow execution logs are stored. Amazon Managed Workflows for Apache Airflow Serverless automatically exports worker logs and task-level information to the specified log group in your account using remote logging functionality. This provides comprehensive observability for debugging and monitoring workflow execution across the distributed, serverless environment.
        public let loggingConfiguration: LoggingConfiguration?
        /// The name of the workflow. You must use unique workflow names within your Amazon Web Services account. The service generates a unique identifier that is appended to ensure temporal uniqueness across the account lifecycle.
        public let name: String
        /// Network configuration for the workflow execution environment, including VPC security groups and subnets for secure network access. When specified, Amazon Managed Workflows for Apache Airflow Serverless deploys ECS worker tasks in your customer VPC to provide secure connectivity to your resources. If not specified, tasks run in the service's default worker VPC with network isolation from other customers. This configuration enables secure access to VPC-only resources like RDS databases or private endpoints.
        public let networkConfiguration: NetworkConfiguration?
        /// The Amazon Resource Name (ARN) of the IAM role that Amazon Managed Workflows for Apache Airflow Serverless assumes when executing the workflow. This role must have the necessary permissions to access the required Amazon Web Services services and resources that your workflow tasks will interact with. The role is used for task execution in the isolated, multi-tenant environment and should follow the principle of least privilege. Amazon Managed Workflows for Apache Airflow Serverless validates role access during workflow creation but runtime permission checks are performed by the target services.
        public let roleArn: String
        /// A map of tags to assign to the workflow resource. Tags are key-value pairs that are used for resource organization and cost allocation.
        public let tags: [String: String]?
        /// The trigger mode for the workflow execution.
        public let triggerMode: String?

        @inlinable
        public init(clientToken: String? = CreateWorkflowRequest.idempotencyToken(), definitionS3Location: DefinitionS3Location, description: String? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, engineVersion: EngineVersion? = nil, loggingConfiguration: LoggingConfiguration? = nil, name: String, networkConfiguration: NetworkConfiguration? = nil, roleArn: String, tags: [String: String]? = nil, triggerMode: String? = nil) {
            self.clientToken = clientToken
            self.definitionS3Location = definitionS3Location
            self.description = description
            self.encryptionConfiguration = encryptionConfiguration
            self.engineVersion = engineVersion
            self.loggingConfiguration = loggingConfiguration
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.roleArn = roleArn
            self.tags = tags
            self.triggerMode = triggerMode
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+[a-zA-Z0-9\\.\\-_]*$")
            try self.networkConfiguration?.validate(name: "\(name).networkConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:iam::[0-9]{12}:role(/[a-zA-Z0-9+=,.@_\\-]{1,512})*?/[a-zA-Z0-9+=,.@_\\-]{1,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^.*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.triggerMode, name: "triggerMode", parent: name, max: 255)
            try self.validate(self.triggerMode, name: "triggerMode", parent: name, min: 1)
            try self.validate(self.triggerMode, name: "triggerMode", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case definitionS3Location = "DefinitionS3Location"
            case description = "Description"
            case encryptionConfiguration = "EncryptionConfiguration"
            case engineVersion = "EngineVersion"
            case loggingConfiguration = "LoggingConfiguration"
            case name = "Name"
            case networkConfiguration = "NetworkConfiguration"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case triggerMode = "TriggerMode"
        }
    }

    public struct CreateWorkflowResponse: AWSDecodableShape {
        /// The timestamp when the workflow was created, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// A Boolean flag that indicates whether this workflow version is the latest version of the workflow.
        public let isLatestVersion: Bool?
        /// A unique identifier for this revision of the workflow configuration. This ID changes when the workflow is updated and you can use it for optimistic concurrency control in update operations. The revision ID helps prevent conflicting updates and ensures that updates are applied to the expected version of the workflow configuration.
        public let revisionId: String?
        /// Warning messages generated during workflow creation.
        public let warnings: [String]?
        /// The Amazon Resource Name (ARN) of the newly created workflow. This ARN uniquely identifies the workflow resource.
        public let workflowArn: String
        /// The current status of the workflow. Possible values are READY (workflow is ready to run) and DELETING (workflow is being deleted).
        public let workflowStatus: WorkflowStatus?
        /// The version identifier of the workflow. This is a service-generated alphanumeric string that uniquely identifies this version of the workflow. Amazon Managed Workflows for Apache Airflow Serverless uses a version-first approach where each workflow can have multiple immutable versions, which allows you to maintain different configurations and roll back to previous versions as needed. The version identifier is used in ARNs and API operations to reference specific workflow versions.
        public let workflowVersion: String?

        @inlinable
        public init(createdAt: Date? = nil, isLatestVersion: Bool? = nil, revisionId: String? = nil, warnings: [String]? = nil, workflowArn: String, workflowStatus: WorkflowStatus? = nil, workflowVersion: String? = nil) {
            self.createdAt = createdAt
            self.isLatestVersion = isLatestVersion
            self.revisionId = revisionId
            self.warnings = warnings
            self.workflowArn = workflowArn
            self.workflowStatus = workflowStatus
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case isLatestVersion = "IsLatestVersion"
            case revisionId = "RevisionId"
            case warnings = "Warnings"
            case workflowArn = "WorkflowArn"
            case workflowStatus = "WorkflowStatus"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct DefinitionS3Location: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket that contains the workflow definition file.
        public let bucket: String
        /// The key (name) of the workflow definition file within the S3 bucket.
        public let objectKey: String
        /// Optional. The version ID of the workflow definition file in Amazon S3. If not specified, the latest version is used.
        public let versionId: String?

        @inlinable
        public init(bucket: String, objectKey: String, versionId: String? = nil) {
            self.bucket = bucket
            self.objectKey = objectKey
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case objectKey = "ObjectKey"
            case versionId = "VersionId"
        }
    }

    public struct DeleteWorkflowRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the workflow you want to delete.
        public let workflowArn: String
        /// Optional. The specific version of the workflow to delete. If not specified, all versions of the workflow are deleted.
        public let workflowVersion: String?

        @inlinable
        public init(workflowArn: String, workflowVersion: String? = nil) {
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowArn, key: "WorkflowArn")
            request.encodeQuery(self.workflowVersion, key: "workflowVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, max: 32)
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, min: 32)
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, pattern: "^[a-z0-9]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkflowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted workflow.
        public let workflowArn: String
        /// The version of the workflow that was deleted.
        public let workflowVersion: String?

        @inlinable
        public init(workflowArn: String, workflowVersion: String? = nil) {
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ID or ARN of the Amazon Web Services KMS key to use for encryption. Required when Type is CUSTOMER_MANAGED_KEY.
        public let kmsKeyId: String?
        /// The type of encryption to use. Values are AWS_MANAGED_KEY (Amazon Web Services manages the encryption key) or CUSTOMER_MANAGED_KEY (you provide a KMS key).
        public let type: EncryptionType

        @inlinable
        public init(kmsKeyId: String? = nil, type: EncryptionType) {
            self.kmsKeyId = kmsKeyId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case type = "Type"
        }
    }

    public struct GetTaskInstanceRequest: AWSEncodableShape {
        /// The unique identifier of the workflow run that contains the task instance.
        public let runId: String
        /// The unique identifier of the task instance to retrieve.
        public let taskInstanceId: String
        /// The Amazon Resource Name (ARN) of the workflow that contains the task instance.
        public let workflowArn: String

        @inlinable
        public init(runId: String, taskInstanceId: String, workflowArn: String) {
            self.runId = runId
            self.taskInstanceId = taskInstanceId
            self.workflowArn = workflowArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.runId, key: "RunId")
            request.encodePath(self.taskInstanceId, key: "TaskInstanceId")
            request.encodePath(self.workflowArn, key: "WorkflowArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[a-zA-Z0-9]+[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.taskInstanceId, name: "taskInstanceId", parent: name, max: 255)
            try self.validate(self.taskInstanceId, name: "taskInstanceId", parent: name, min: 1)
            try self.validate(self.taskInstanceId, name: "taskInstanceId", parent: name, pattern: "^[a-zA-Z0-9]+[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTaskInstanceResponse: AWSDecodableShape {
        /// The attempt number for this task instance.
        public let attemptNumber: Int?
        /// The duration of the task instance execution in seconds. This value is null if the task is not complete.
        public let durationInSeconds: Int?
        /// The timestamp when the task instance completed execution, in ISO 8601 date-time format. This value is null if the task is not complete.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The error message if the task instance failed. This value is null if the task completed successfully.
        public let errorMessage: String?
        /// The CloudWatch log stream name for this task instance execution.
        public let logStream: String?
        /// The timestamp when the task instance was last modified, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The name of the Apache Airflow operator used for this task instance.
        public let operatorName: String?
        /// The unique identifier of the workflow run that contains this task instance.
        public let runId: String
        /// The timestamp when the task instance started execution, in ISO 8601 date-time format. This value is null if the task has not started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The current status of the task instance.
        public let status: TaskInstanceStatus?
        /// The unique identifier of the task definition within the workflow.
        public let taskId: String?
        /// The unique identifier of this task instance.
        public let taskInstanceId: String
        /// The Amazon Resource Name (ARN) of the workflow that contains this task instance.
        public let workflowArn: String
        /// The version of the workflow that contains this task instance.
        public let workflowVersion: String?
        /// Cross-communication data exchanged between tasks in the workflow execution.
        public let xcom: [String: String]?

        @inlinable
        public init(attemptNumber: Int? = nil, durationInSeconds: Int? = nil, endedAt: Date? = nil, errorMessage: String? = nil, logStream: String? = nil, modifiedAt: Date? = nil, operatorName: String? = nil, runId: String, startedAt: Date? = nil, status: TaskInstanceStatus? = nil, taskId: String? = nil, taskInstanceId: String, workflowArn: String, workflowVersion: String? = nil, xcom: [String: String]? = nil) {
            self.attemptNumber = attemptNumber
            self.durationInSeconds = durationInSeconds
            self.endedAt = endedAt
            self.errorMessage = errorMessage
            self.logStream = logStream
            self.modifiedAt = modifiedAt
            self.operatorName = operatorName
            self.runId = runId
            self.startedAt = startedAt
            self.status = status
            self.taskId = taskId
            self.taskInstanceId = taskInstanceId
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
            self.xcom = xcom
        }

        private enum CodingKeys: String, CodingKey {
            case attemptNumber = "AttemptNumber"
            case durationInSeconds = "DurationInSeconds"
            case endedAt = "EndedAt"
            case errorMessage = "ErrorMessage"
            case logStream = "LogStream"
            case modifiedAt = "ModifiedAt"
            case operatorName = "OperatorName"
            case runId = "RunId"
            case startedAt = "StartedAt"
            case status = "Status"
            case taskId = "TaskId"
            case taskInstanceId = "TaskInstanceId"
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
            case xcom = "Xcom"
        }
    }

    public struct GetWorkflowRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the workflow you want to retrieve.
        public let workflowArn: String
        /// Optional. The specific version of the workflow to retrieve. If not specified, the latest version is returned.
        public let workflowVersion: String?

        @inlinable
        public init(workflowArn: String, workflowVersion: String? = nil) {
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowArn, key: "WorkflowArn")
            request.encodeQuery(self.workflowVersion, key: "workflowVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, max: 32)
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, min: 32)
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, pattern: "^[a-z0-9]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowResponse: AWSDecodableShape {
        /// The timestamp when the workflow was created, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The Amazon S3 location of the workflow definition file.
        public let definitionS3Location: DefinitionS3Location?
        /// The description of the workflow.
        public let description: String?
        /// The encryption configuration for the workflow.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The version of the Amazon Managed Workflows for Apache Airflow Serverless engine that this workflow uses.
        public let engineVersion: EngineVersion?
        /// The logging configuration for the workflow.
        public let loggingConfiguration: LoggingConfiguration?
        /// The timestamp when the workflow was last modified, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The name of the workflow.
        public let name: String?
        /// The network configuration for the workflow execution environment.
        public let networkConfiguration: NetworkConfiguration?
        /// The Amazon Resource Name (ARN) of the IAM role used for workflow execution.
        public let roleArn: String?
        /// The schedule configuration for the workflow, including cron expressions for automated execution. Amazon Managed Workflows for Apache Airflow Serverless uses EventBridge Scheduler for cost-effective, timezone-aware scheduling. When a workflow includes schedule information in its YAML definition, the service automatically configures the appropriate triggers for automated execution. Only one version of a workflow can have an active schedule at any given time.
        public let scheduleConfiguration: ScheduleConfiguration?
        /// The trigger mode for the workflow execution.
        public let triggerMode: String?
        /// The Amazon Resource Name (ARN) of the workflow.
        public let workflowArn: String
        /// The workflow definition content.
        public let workflowDefinition: String?
        /// The current status of the workflow.
        public let workflowStatus: WorkflowStatus?
        /// The version identifier of the workflow.
        public let workflowVersion: String?

        @inlinable
        public init(createdAt: Date? = nil, definitionS3Location: DefinitionS3Location? = nil, description: String? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, engineVersion: EngineVersion? = nil, loggingConfiguration: LoggingConfiguration? = nil, modifiedAt: Date? = nil, name: String? = nil, networkConfiguration: NetworkConfiguration? = nil, roleArn: String? = nil, scheduleConfiguration: ScheduleConfiguration? = nil, triggerMode: String? = nil, workflowArn: String, workflowDefinition: String? = nil, workflowStatus: WorkflowStatus? = nil, workflowVersion: String? = nil) {
            self.createdAt = createdAt
            self.definitionS3Location = definitionS3Location
            self.description = description
            self.encryptionConfiguration = encryptionConfiguration
            self.engineVersion = engineVersion
            self.loggingConfiguration = loggingConfiguration
            self.modifiedAt = modifiedAt
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.roleArn = roleArn
            self.scheduleConfiguration = scheduleConfiguration
            self.triggerMode = triggerMode
            self.workflowArn = workflowArn
            self.workflowDefinition = workflowDefinition
            self.workflowStatus = workflowStatus
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case definitionS3Location = "DefinitionS3Location"
            case description = "Description"
            case encryptionConfiguration = "EncryptionConfiguration"
            case engineVersion = "EngineVersion"
            case loggingConfiguration = "LoggingConfiguration"
            case modifiedAt = "ModifiedAt"
            case name = "Name"
            case networkConfiguration = "NetworkConfiguration"
            case roleArn = "RoleArn"
            case scheduleConfiguration = "ScheduleConfiguration"
            case triggerMode = "TriggerMode"
            case workflowArn = "WorkflowArn"
            case workflowDefinition = "WorkflowDefinition"
            case workflowStatus = "WorkflowStatus"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct GetWorkflowRunRequest: AWSEncodableShape {
        /// The unique identifier of the workflow run to retrieve.
        public let runId: String
        /// The Amazon Resource Name (ARN) of the workflow that contains the run.
        public let workflowArn: String

        @inlinable
        public init(runId: String, workflowArn: String) {
            self.runId = runId
            self.workflowArn = workflowArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.runId, key: "RunId")
            request.encodePath(self.workflowArn, key: "WorkflowArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[a-zA-Z0-9]+[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowRunResponse: AWSDecodableShape {
        /// Parameters that were overridden for this specific workflow run.
        public let overrideParameters: [String: AWSDocument]?
        /// Detailed information about the workflow run execution, including timing, status, and task instances.
        public let runDetail: WorkflowRunDetail?
        /// The unique identifier of this workflow run.
        public let runId: String?
        /// The type of workflow run. Values are ON_DEMAND (manually triggered) or SCHEDULED (automatically triggered by schedule).
        public let runType: RunType?
        /// The Amazon Resource Name (ARN) of the workflow that contains this run.
        public let workflowArn: String?
        /// The version of the workflow that is used for this run.
        public let workflowVersion: String?

        @inlinable
        public init(overrideParameters: [String: AWSDocument]? = nil, runDetail: WorkflowRunDetail? = nil, runId: String? = nil, runType: RunType? = nil, workflowArn: String? = nil, workflowVersion: String? = nil) {
            self.overrideParameters = overrideParameters
            self.runDetail = runDetail
            self.runId = runId
            self.runType = runType
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case overrideParameters = "OverrideParameters"
            case runDetail = "RunDetail"
            case runId = "RunId"
            case runType = "RunType"
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The number of seconds to wait before retrying the operation.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of tags that are associated with the resource, where each tag consists of a key-value pair.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTaskInstancesRequest: AWSEncodableShape {
        /// The maximum number of task instances to return in a single response.
        public let maxResults: Int?
        /// The pagination token you need to use to retrieve the next set of results. This value is returned from a previous call to ListTaskInstances.
        public let nextToken: String?
        /// The unique identifier of the workflow run for which you want a list of task instances.
        public let runId: String
        /// The Amazon Resource Name (ARN) of the workflow that contains the run.
        public let workflowArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, runId: String, workflowArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.runId = runId
            self.workflowArn = workflowArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.runId, key: "RunId")
            request.encodePath(self.workflowArn, key: "WorkflowArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[a-zA-Z0-9]+[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTaskInstancesResponse: AWSDecodableShape {
        /// The pagination token you need to use to retrieve the next set of results. This value is null if there are no more results.
        public let nextToken: String?
        /// A list of task instance summaries for the specified workflow run.
        public let taskInstances: [TaskInstanceSummary]?

        @inlinable
        public init(nextToken: String? = nil, taskInstances: [TaskInstanceSummary]? = nil) {
            self.nextToken = nextToken
            self.taskInstances = taskInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case taskInstances = "TaskInstances"
        }
    }

    public struct ListWorkflowRunsRequest: AWSEncodableShape {
        /// The maximum number of workflow runs to return in a single response.
        public let maxResults: Int?
        /// The pagination token you need to use to retrieve the next set of results. This value is returned from a previous call to ListWorkflowRuns.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the workflow for which you want a list of runs.
        public let workflowArn: String
        /// Optional. The specific version of the workflow for which you want a list of runs. If not specified, runs for all versions are returned.
        public let workflowVersion: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowArn: String, workflowVersion: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workflowArn, key: "WorkflowArn")
            request.encodeQuery(self.workflowVersion, key: "workflowVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, max: 2048)
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, min: 1)
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkflowRunsResponse: AWSDecodableShape {
        /// The pagination token you need to use to retrieve the next set of results. This value is null if there are no more results.
        public let nextToken: String?
        /// A list of workflow run summaries for the specified workflow.
        public let workflowRuns: [WorkflowRunSummary]?

        @inlinable
        public init(nextToken: String? = nil, workflowRuns: [WorkflowRunSummary]? = nil) {
            self.nextToken = nextToken
            self.workflowRuns = workflowRuns
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workflowRuns = "WorkflowRuns"
        }
    }

    public struct ListWorkflowVersionsRequest: AWSEncodableShape {
        /// The maximum number of workflow versions to return in a single response.
        public let maxResults: Int?
        /// The pagination token you need to use to retrieve the next set of results. This value is returned from a previous call to ListWorkflowVersions.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the workflow for which you want to list versions.
        public let workflowArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowArn = workflowArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workflowArn, key: "WorkflowArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkflowVersionsResponse: AWSDecodableShape {
        /// The pagination token you need to use to retrieve the next set of results. This value is null if there are no more results.
        public let nextToken: String?
        /// A list of workflow version summaries for the specified workflow.
        public let workflowVersions: [WorkflowVersionSummary]?

        @inlinable
        public init(nextToken: String? = nil, workflowVersions: [WorkflowVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.workflowVersions = workflowVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workflowVersions = "WorkflowVersions"
        }
    }

    public struct ListWorkflowsRequest: AWSEncodableShape {
        /// The maximum number of workflows you want to return in a single response.
        public let maxResults: Int?
        /// The pagination token you need to use to retrieve the next set of results. This value is returned from a previous call to ListWorkflows.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkflowsResponse: AWSDecodableShape {
        /// The pagination token you need to use to retrieve the next set of results. This value is null if there are no more results.
        public let nextToken: String?
        /// A list of workflow summaries for all workflows in your account.
        public let workflows: [WorkflowSummary]

        @inlinable
        public init(nextToken: String? = nil, workflows: [WorkflowSummary]) {
            self.nextToken = nextToken
            self.workflows = workflows
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workflows = "Workflows"
        }
    }

    public struct LoggingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the CloudWatch log group where workflow execution logs are stored.
        public let logGroupName: String

        @inlinable
        public init(logGroupName: String) {
            self.logGroupName = logGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName = "LogGroupName"
        }
    }

    public struct NetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of VPC security group IDs to associate with the workflow execution environment.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs where the workflow execution environment is deployed.
        public let subnetIds: [String]?

        @inlinable
        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[a-z0-9]*$")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 255)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[a-z0-9]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The unique identifier of the resource.
        public let resourceId: String
        /// The type of the resource.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RunDetailSummary: AWSDecodableShape {
        /// The timestamp when the workflow run was created, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdOn: Date?
        /// The timestamp when the workflow run completed execution, in ISO 8601 date-time format. This value is null if the run is not complete.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The timestamp when the workflow run started execution, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The current status of the workflow run.
        public let status: WorkflowRunStatus?

        @inlinable
        public init(createdOn: Date? = nil, endedAt: Date? = nil, startedAt: Date? = nil, status: WorkflowRunStatus? = nil) {
            self.createdOn = createdOn
            self.endedAt = endedAt
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case endedAt = "EndedAt"
            case startedAt = "StartedAt"
            case status = "Status"
        }
    }

    public struct ScheduleConfiguration: AWSDecodableShape {
        /// A cron expression that defines when the workflow is automatically executed. Uses standard cron syntax.
        public let cronExpression: String?

        @inlinable
        public init(cronExpression: String? = nil) {
            self.cronExpression = cronExpression
        }

        private enum CodingKeys: String, CodingKey {
            case cronExpression = "CronExpression"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The code of the quota.
        public let quotaCode: String
        /// The unique identifier of the resource.
        public let resourceId: String
        /// The type of resource affected.
        public let resourceType: String
        /// The code for the service.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case serviceCode = "ServiceCode"
        }
    }

    public struct StartWorkflowRunRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token prevents duplicate workflow run requests.
        public let clientToken: String?
        /// Optional parameters to override default workflow parameters for this specific run. These parameters are passed to the workflow during execution and can be used to customize behavior without modifying the workflow definition. Parameters are made available as environment variables to tasks and you can reference them within the YAML workflow definition using standard parameter substitution syntax.
        public let overrideParameters: [String: AWSDocument]?
        /// The Amazon Resource Name (ARN) of the workflow you want to run.
        public let workflowArn: String
        /// Optional. The specific version of the workflow to execute. If not specified, the latest version is used.
        public let workflowVersion: String?

        @inlinable
        public init(clientToken: String? = StartWorkflowRunRequest.idempotencyToken(), overrideParameters: [String: AWSDocument]? = nil, workflowArn: String, workflowVersion: String? = nil) {
            self.clientToken = clientToken
            self.overrideParameters = overrideParameters
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.overrideParameters, forKey: .overrideParameters)
            request.encodePath(self.workflowArn, key: "WorkflowArn")
            try container.encodeIfPresent(self.workflowVersion, forKey: .workflowVersion)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, max: 2048)
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, min: 1)
            try self.validate(self.workflowVersion, name: "workflowVersion", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case overrideParameters = "OverrideParameters"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct StartWorkflowRunResponse: AWSDecodableShape {
        /// The unique identifier of the newly started workflow run.
        public let runId: String?
        /// The timestamp when the workflow run was started, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The initial status of the workflow run. This is typically STARTING when you first create the run.
        public let status: WorkflowRunStatus?

        @inlinable
        public init(runId: String? = nil, startedAt: Date? = nil, status: WorkflowRunStatus? = nil) {
            self.runId = runId
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
            case startedAt = "StartedAt"
            case status = "Status"
        }
    }

    public struct StopWorkflowRunRequest: AWSEncodableShape {
        /// The unique identifier of the workflow run to stop.
        public let runId: String
        /// The Amazon Resource Name (ARN) of the workflow that contains the run you want to stop.
        public let workflowArn: String

        @inlinable
        public init(runId: String, workflowArn: String) {
            self.runId = runId
            self.workflowArn = workflowArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.runId, key: "RunId")
            request.encodePath(self.workflowArn, key: "WorkflowArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[a-zA-Z0-9]+[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopWorkflowRunResponse: AWSDecodableShape {
        /// The unique identifier of the stopped workflow run.
        public let runId: String?
        /// The status of the workflow run after the stop operation. This is typically STOPPING or STOPPED.
        public let status: WorkflowRunStatus?
        /// The Amazon Resource Name (ARN) of the workflow that contains the stopped run.
        public let workflowArn: String?
        /// The version of the workflow that was stopped.
        public let workflowVersion: String?

        @inlinable
        public init(runId: String? = nil, status: WorkflowRunStatus? = nil, workflowArn: String? = nil, workflowVersion: String? = nil) {
            self.runId = runId
            self.status = status
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
            case status = "Status"
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to which to add tags.
        public let resourceArn: String
        /// A map of tags to add to the resource. Each tag consists of a key-value pair.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^.*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskInstanceSummary: AWSDecodableShape {
        /// The duration of the task instance execution in seconds. This value is null if the task is not complete.
        public let durationInSeconds: Int?
        /// The name of the Apache Airflow operator used for this task instance.
        public let operatorName: String?
        /// The unique identifier of the workflow run that contains this task instance.
        public let runId: String?
        /// The current status of the task instance.
        public let status: TaskInstanceStatus?
        /// The unique identifier of this task instance.
        public let taskInstanceId: String?
        /// The Amazon Resource Name (ARN) of the workflow that contains this task instance.
        public let workflowArn: String?
        /// The version of the workflow that contains this task instance.
        public let workflowVersion: String?

        @inlinable
        public init(durationInSeconds: Int? = nil, operatorName: String? = nil, runId: String? = nil, status: TaskInstanceStatus? = nil, taskInstanceId: String? = nil, workflowArn: String? = nil, workflowVersion: String? = nil) {
            self.durationInSeconds = durationInSeconds
            self.operatorName = operatorName
            self.runId = runId
            self.status = status
            self.taskInstanceId = taskInstanceId
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case durationInSeconds = "DurationInSeconds"
            case operatorName = "OperatorName"
            case runId = "RunId"
            case status = "Status"
            case taskInstanceId = "TaskInstanceId"
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The code of the quota.
        public let quotaCode: String
        /// The number of seconds to wait before retrying the operation.
        public let retryAfterSeconds: Int?
        /// The code for the service.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, retryAfterSeconds: Int? = nil, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decode(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decode(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case serviceCode = "ServiceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
        public let resourceArn: String
        /// A list of tag keys to remove from the resource. Only the keys are required; the values are ignored.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWorkflowRequest: AWSEncodableShape {
        /// The Amazon S3 location where the updated workflow definition file is stored.
        public let definitionS3Location: DefinitionS3Location
        /// An updated description for the workflow.
        public let description: String?
        /// The version of the Amazon Managed Workflows for Apache Airflow Serverless engine that you want to use for the updated workflow.
        public let engineVersion: EngineVersion?
        /// Updated logging configuration for the workflow.
        public let loggingConfiguration: LoggingConfiguration?
        /// Updated network configuration for the workflow execution environment.
        public let networkConfiguration: NetworkConfiguration?
        /// The Amazon Resource Name (ARN) of the IAM role that Amazon Managed Workflows for Apache Airflow Serverless assumes when it executes the updated workflow.
        public let roleArn: String
        /// The trigger mode for the workflow execution.
        public let triggerMode: String?
        /// The Amazon Resource Name (ARN) of the workflow you want to update.
        public let workflowArn: String

        @inlinable
        public init(definitionS3Location: DefinitionS3Location, description: String? = nil, engineVersion: EngineVersion? = nil, loggingConfiguration: LoggingConfiguration? = nil, networkConfiguration: NetworkConfiguration? = nil, roleArn: String, triggerMode: String? = nil, workflowArn: String) {
            self.definitionS3Location = definitionS3Location
            self.description = description
            self.engineVersion = engineVersion
            self.loggingConfiguration = loggingConfiguration
            self.networkConfiguration = networkConfiguration
            self.roleArn = roleArn
            self.triggerMode = triggerMode
            self.workflowArn = workflowArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.definitionS3Location, forKey: .definitionS3Location)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.engineVersion, forKey: .engineVersion)
            try container.encodeIfPresent(self.loggingConfiguration, forKey: .loggingConfiguration)
            try container.encodeIfPresent(self.networkConfiguration, forKey: .networkConfiguration)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.triggerMode, forKey: .triggerMode)
            request.encodePath(self.workflowArn, key: "WorkflowArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.networkConfiguration?.validate(name: "\(name).networkConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:iam::[0-9]{12}:role(/[a-zA-Z0-9+=,.@_\\-]{1,512})*?/[a-zA-Z0-9+=,.@_\\-]{1,64}$")
            try self.validate(self.triggerMode, name: "triggerMode", parent: name, max: 255)
            try self.validate(self.triggerMode, name: "triggerMode", parent: name, min: 1)
            try self.validate(self.triggerMode, name: "triggerMode", parent: name, pattern: "^.*$")
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, max: 2048)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, min: 1)
            try self.validate(self.workflowArn, name: "workflowArn", parent: name, pattern: "^arn:aws(?:-(?:cn|us-gov|iso|iso-b|iso-e|iso-f))?:airflow-serverless:([a-z]{2}-[a-z]+-[0-9]{1}):([0-9]{12}):workflow/([a-zA-Z0-9][a-zA-Z0-9\\.\\-_]{0,254}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: String, CodingKey {
            case definitionS3Location = "DefinitionS3Location"
            case description = "Description"
            case engineVersion = "EngineVersion"
            case loggingConfiguration = "LoggingConfiguration"
            case networkConfiguration = "NetworkConfiguration"
            case roleArn = "RoleArn"
            case triggerMode = "TriggerMode"
        }
    }

    public struct UpdateWorkflowResponse: AWSDecodableShape {
        /// The timestamp when the workflow was last modified, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Warning messages generated during workflow update.
        public let warnings: [String]?
        /// The Amazon Resource Name (ARN) of the updated workflow.
        public let workflowArn: String
        /// The version identifier of the updated workflow.
        public let workflowVersion: String?

        @inlinable
        public init(modifiedAt: Date? = nil, warnings: [String]? = nil, workflowArn: String, workflowVersion: String? = nil) {
            self.modifiedAt = modifiedAt
            self.warnings = warnings
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case modifiedAt = "ModifiedAt"
            case warnings = "Warnings"
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The fields that failed validation.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// The reason the request failed validation.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "FieldList"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message that describes why the field failed validation.
        public let message: String
        /// The name of the field that failed validation.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }

    public struct WorkflowRunDetail: AWSDecodableShape {
        /// The timestamp when the workflow run completed execution, in ISO 8601 date-time format. This value is null if the run is not complete.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedOn: Date?
        /// The timestamp when the workflow run was created, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The total duration of the workflow run execution in seconds. This value is null if the run is not complete.
        public let duration: Int?
        /// The error message if the workflow run failed. This value is null if the run completed successfully.
        public let errorMessage: String?
        /// The timestamp when the workflow run was last modified, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The unique identifier of this workflow run.
        public let runId: String?
        /// The current execution state of the workflow run.
        public let runState: WorkflowRunStatus?
        /// The type of workflow run.
        public let runType: RunType?
        /// The timestamp when the workflow run started execution, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedOn: Date?
        /// A list of task instance IDs that are part of this workflow run.
        public let taskInstances: [String]?
        /// The Amazon Resource Name (ARN) of the workflow that contains this run.
        public let workflowArn: String?
        /// The version of the workflow used for this run.
        public let workflowVersion: String?

        @inlinable
        public init(completedOn: Date? = nil, createdAt: Date? = nil, duration: Int? = nil, errorMessage: String? = nil, modifiedAt: Date? = nil, runId: String? = nil, runState: WorkflowRunStatus? = nil, runType: RunType? = nil, startedOn: Date? = nil, taskInstances: [String]? = nil, workflowArn: String? = nil, workflowVersion: String? = nil) {
            self.completedOn = completedOn
            self.createdAt = createdAt
            self.duration = duration
            self.errorMessage = errorMessage
            self.modifiedAt = modifiedAt
            self.runId = runId
            self.runState = runState
            self.runType = runType
            self.startedOn = startedOn
            self.taskInstances = taskInstances
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case createdAt = "CreatedAt"
            case duration = "Duration"
            case errorMessage = "ErrorMessage"
            case modifiedAt = "ModifiedAt"
            case runId = "RunId"
            case runState = "RunState"
            case runType = "RunType"
            case startedOn = "StartedOn"
            case taskInstances = "TaskInstances"
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct WorkflowRunSummary: AWSDecodableShape {
        /// Summary details about the workflow run execution.
        public let runDetailSummary: RunDetailSummary?
        /// The unique identifier of the workflow run.
        public let runId: String?
        /// The type of workflow run.
        public let runType: RunType?
        /// The Amazon Resource Name (ARN) of the workflow that contains this run.
        public let workflowArn: String?
        /// The version of the workflow used for this run.
        public let workflowVersion: String?

        @inlinable
        public init(runDetailSummary: RunDetailSummary? = nil, runId: String? = nil, runType: RunType? = nil, workflowArn: String? = nil, workflowVersion: String? = nil) {
            self.runDetailSummary = runDetailSummary
            self.runId = runId
            self.runType = runType
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case runDetailSummary = "RunDetailSummary"
            case runId = "RunId"
            case runType = "RunType"
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct WorkflowSummary: AWSDecodableShape {
        /// The timestamp when the workflow was created, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the workflow.
        public let description: String?
        /// The timestamp when the workflow was last modified, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The name of the workflow.
        public let name: String?
        /// The trigger mode for the workflow execution.
        public let triggerMode: String?
        /// The Amazon Resource Name (ARN) of the workflow.
        public let workflowArn: String
        /// The current status of the workflow.
        public let workflowStatus: WorkflowStatus?
        /// The version identifier of the workflow.
        public let workflowVersion: String?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, modifiedAt: Date? = nil, name: String? = nil, triggerMode: String? = nil, workflowArn: String, workflowStatus: WorkflowStatus? = nil, workflowVersion: String? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
            self.name = name
            self.triggerMode = triggerMode
            self.workflowArn = workflowArn
            self.workflowStatus = workflowStatus
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case modifiedAt = "ModifiedAt"
            case name = "Name"
            case triggerMode = "TriggerMode"
            case workflowArn = "WorkflowArn"
            case workflowStatus = "WorkflowStatus"
            case workflowVersion = "WorkflowVersion"
        }
    }

    public struct WorkflowVersionSummary: AWSDecodableShape {
        /// The timestamp when the workflow version was created, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The Amazon S3 location of the workflow definition file for this version.
        public let definitionS3Location: DefinitionS3Location?
        /// Boolean flag that indicates whether this is the latest version of the workflow.
        public let isLatestVersion: Bool?
        /// The timestamp when the workflow version was last modified, in ISO 8601 date-time format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The schedule configuration for this workflow version.
        public let scheduleConfiguration: ScheduleConfiguration?
        /// The trigger mode for the workflow execution.
        public let triggerMode: String?
        /// The Amazon Resource Name (ARN) of the workflow that contains this version.
        public let workflowArn: String
        /// The version identifier of the workflow version.
        public let workflowVersion: String

        @inlinable
        public init(createdAt: Date? = nil, definitionS3Location: DefinitionS3Location? = nil, isLatestVersion: Bool? = nil, modifiedAt: Date? = nil, scheduleConfiguration: ScheduleConfiguration? = nil, triggerMode: String? = nil, workflowArn: String, workflowVersion: String) {
            self.createdAt = createdAt
            self.definitionS3Location = definitionS3Location
            self.isLatestVersion = isLatestVersion
            self.modifiedAt = modifiedAt
            self.scheduleConfiguration = scheduleConfiguration
            self.triggerMode = triggerMode
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case definitionS3Location = "DefinitionS3Location"
            case isLatestVersion = "IsLatestVersion"
            case modifiedAt = "ModifiedAt"
            case scheduleConfiguration = "ScheduleConfiguration"
            case triggerMode = "TriggerMode"
            case workflowArn = "WorkflowArn"
            case workflowVersion = "WorkflowVersion"
        }
    }
}

// MARK: - Errors

/// Error enum for MWAAServerless
public struct MWAAServerlessErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case operationTimeoutException = "OperationTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MWAAServerless
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient permission to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// You cannot create a resource that already exists, or the resource is in a state that prevents the requested operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected server-side error occurred during request processing.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The operation timed out.
    public static var operationTimeoutException: Self { .init(.operationTimeoutException) }
    /// The specified resource was not found. You can only access or modify a resource that already exists.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeds the service quota for Amazon Managed Workflows for Apache Airflow Serverless resources. This can occur when you attempt to create more workflows than allowed, exceed concurrent workflow run limits, or surpass task execution limits. Amazon Managed Workflows for Apache Airflow Serverless implements admission control using DynamoDB-based counters to manage resource utilization across the multi-tenant environment. Contact Amazon Web Services Support to request quota increases if you need higher limits for your use case.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied because too many requests were made in a short period, exceeding the service rate limits. Amazon Managed Workflows for Apache Airflow Serverless implements throttling controls to ensure fair resource allocation across all customers in the multi-tenant environment. This helps maintain service stability and performance. If you encounter throttling, implement exponential backoff and retry logic in your applications, or consider distributing your API calls over a longer time period.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The specified request parameters are invalid, missing, or inconsistent with Amazon Managed Workflows for Apache Airflow Serverless service requirements. This can occur when workflow definitions contain unsupported operators, when required IAM permissions are missing, when S3 locations are inaccessible, or when network configurations are invalid. The service validates workflow definitions, execution roles, and resource configurations to ensure compatibility with the managed Airflow environment and security requirements.
    public static var validationException: Self { .init(.validationException) }
}

extension MWAAServerlessErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": MWAAServerless.ConflictException.self,
        "InternalServerException": MWAAServerless.InternalServerException.self,
        "ResourceNotFoundException": MWAAServerless.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": MWAAServerless.ServiceQuotaExceededException.self,
        "ThrottlingException": MWAAServerless.ThrottlingException.self,
        "ValidationException": MWAAServerless.ValidationException.self
    ]
}

extension MWAAServerlessErrorType: Equatable {
    public static func == (lhs: MWAAServerlessErrorType, rhs: MWAAServerlessErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MWAAServerlessErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
