//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension HealthLake {
    // MARK: Enums

    public enum AuthorizationStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsAuth = "AWS_AUTH"
        case smartOnFhir = "SMART_ON_FHIR"
        case smartv1 = "SMART_ON_FHIR_V1"
        public var description: String { return self.rawValue }
    }

    public enum CmkType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aoCmk = "AWS_OWNED_KMS_KEY"
        case cmCmk = "CUSTOMER_MANAGED_KMS_KEY"
        public var description: String { return self.rawValue }
    }

    public enum DatastoreStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nonRetryableError = "NON_RETRYABLE_ERROR"
        case retryableError = "RETRYABLE_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum FHIRVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case r4 = "R4"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelCompleted = "CANCEL_COMPLETED"
        case cancelFailed = "CANCEL_FAILED"
        case cancelInProgress = "CANCEL_IN_PROGRESS"
        case cancelSubmitted = "CANCEL_SUBMITTED"
        case completed = "COMPLETED"
        case completedWithErrors = "COMPLETED_WITH_ERRORS"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum PreloadDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case synthea = "SYNTHEA"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateFHIRDatastoreRequest: AWSEncodableShape {
        /// Optional user provided token used for ensuring idempotency.
        public let clientToken: String?
        /// The user generated name for the data store.
        public let datastoreName: String?
        /// The FHIR version of the data store. The only supported version is R4.
        public let datastoreTypeVersion: FHIRVersion
        /// The configuration of the identity provider that you want to use for your data store.
        public let identityProviderConfiguration: IdentityProviderConfiguration?
        /// Optional parameter to preload data upon creation of the data store. Currently, the only supported preloaded data is synthetic data generated from Synthea.
        public let preloadDataConfig: PreloadDataConfig?
        ///  The server-side encryption key configuration for a customer provided encryption key specified for creating a data store.
        public let sseConfiguration: SseConfiguration?
        ///  Resource tags that are applied to a data store when it is created.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateFHIRDatastoreRequest.idempotencyToken(), datastoreName: String? = nil, datastoreTypeVersion: FHIRVersion, identityProviderConfiguration: IdentityProviderConfiguration? = nil, preloadDataConfig: PreloadDataConfig? = nil, sseConfiguration: SseConfiguration? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.datastoreName = datastoreName
            self.datastoreTypeVersion = datastoreTypeVersion
            self.identityProviderConfiguration = identityProviderConfiguration
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, max: 256)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, min: 1)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.identityProviderConfiguration?.validate(name: "\(name).identityProviderConfiguration")
            try self.sseConfiguration?.validate(name: "\(name).sseConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case datastoreName = "DatastoreName"
            case datastoreTypeVersion = "DatastoreTypeVersion"
            case identityProviderConfiguration = "IdentityProviderConfiguration"
            case preloadDataConfig = "PreloadDataConfig"
            case sseConfiguration = "SseConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateFHIRDatastoreResponse: AWSDecodableShape {
        /// The data store ARN is generated during the creation of the data store and can be found in the output from the initial data store creation call.
        public let datastoreArn: String
        /// The AWS endpoint for the created data store.
        public let datastoreEndpoint: String
        /// The AWS-generated data store id. This id is in the output from the initial data store creation call.
        public let datastoreId: String
        /// The status of the FHIR data store.
        public let datastoreStatus: DatastoreStatus

        @inlinable
        public init(datastoreArn: String, datastoreEndpoint: String, datastoreId: String, datastoreStatus: DatastoreStatus) {
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreStatus = datastoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreArn = "DatastoreArn"
            case datastoreEndpoint = "DatastoreEndpoint"
            case datastoreId = "DatastoreId"
            case datastoreStatus = "DatastoreStatus"
        }
    }

    public struct DatastoreFilter: AWSEncodableShape {
        /// A filter that allows the user to set cutoff dates for records. All data stores created after the specified date will be included in the results.
        public let createdAfter: Date?
        /// A filter that allows the user to set cutoff dates for records. All data stores created before the specified date will be included in the results.
        public let createdBefore: Date?
        /// Allows the user to filter data store results by name.
        public let datastoreName: String?
        /// Allows the user to filter data store results by status.
        public let datastoreStatus: DatastoreStatus?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, datastoreName: String? = nil, datastoreStatus: DatastoreStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, max: 256)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, min: 1)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case datastoreName = "DatastoreName"
            case datastoreStatus = "DatastoreStatus"
        }
    }

    public struct DatastoreProperties: AWSDecodableShape {
        /// The time that a data store was created.
        public let createdAt: Date?
        /// The Amazon Resource Name used in the creation of the data store.
        public let datastoreArn: String
        /// The AWS endpoint for the data store. Each data store will have it's own endpoint with data store ID in the endpoint URL.
        public let datastoreEndpoint: String
        /// The AWS-generated ID number for the data store.
        public let datastoreId: String
        /// The user-generated name for the data store.
        public let datastoreName: String?
        /// The status of the data store.
        public let datastoreStatus: DatastoreStatus
        /// The FHIR version. Only R4 version data is supported.
        public let datastoreTypeVersion: FHIRVersion
        /// The error cause for the current data store operation.
        public let errorCause: ErrorCause?
        /// The identity provider that you selected when you created the data store.
        public let identityProviderConfiguration: IdentityProviderConfiguration?
        /// The preloaded data configuration for the data store. Only data preloaded from Synthea is supported.
        public let preloadDataConfig: PreloadDataConfig?
        ///  The server-side encryption key configuration for a customer provided encryption key (CMK).
        public let sseConfiguration: SseConfiguration?

        @inlinable
        public init(createdAt: Date? = nil, datastoreArn: String, datastoreEndpoint: String, datastoreId: String, datastoreName: String? = nil, datastoreStatus: DatastoreStatus, datastoreTypeVersion: FHIRVersion, errorCause: ErrorCause? = nil, identityProviderConfiguration: IdentityProviderConfiguration? = nil, preloadDataConfig: PreloadDataConfig? = nil, sseConfiguration: SseConfiguration? = nil) {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.datastoreTypeVersion = datastoreTypeVersion
            self.errorCause = errorCause
            self.identityProviderConfiguration = identityProviderConfiguration
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case datastoreArn = "DatastoreArn"
            case datastoreEndpoint = "DatastoreEndpoint"
            case datastoreId = "DatastoreId"
            case datastoreName = "DatastoreName"
            case datastoreStatus = "DatastoreStatus"
            case datastoreTypeVersion = "DatastoreTypeVersion"
            case errorCause = "ErrorCause"
            case identityProviderConfiguration = "IdentityProviderConfiguration"
            case preloadDataConfig = "PreloadDataConfig"
            case sseConfiguration = "SseConfiguration"
        }
    }

    public struct DeleteFHIRDatastoreRequest: AWSEncodableShape {
        ///  The AWS-generated ID for the data store to be deleted.
        public let datastoreId: String

        @inlinable
        public init(datastoreId: String) {
            self.datastoreId = datastoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
        }
    }

    public struct DeleteFHIRDatastoreResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that gives AWS HealthLake access permission.
        public let datastoreArn: String
        /// The AWS endpoint for the data store the user has requested to be deleted.
        public let datastoreEndpoint: String
        /// The AWS-generated ID for the data store to be deleted.
        public let datastoreId: String
        /// The status of the data store that the user has requested to be deleted.
        public let datastoreStatus: DatastoreStatus

        @inlinable
        public init(datastoreArn: String, datastoreEndpoint: String, datastoreId: String, datastoreStatus: DatastoreStatus) {
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreStatus = datastoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreArn = "DatastoreArn"
            case datastoreEndpoint = "DatastoreEndpoint"
            case datastoreId = "DatastoreId"
            case datastoreStatus = "DatastoreStatus"
        }
    }

    public struct DescribeFHIRDatastoreRequest: AWSEncodableShape {
        /// The AWS-generated data store ID.
        public let datastoreId: String

        @inlinable
        public init(datastoreId: String) {
            self.datastoreId = datastoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
        }
    }

    public struct DescribeFHIRDatastoreResponse: AWSDecodableShape {
        /// All properties associated with a data store, including the data store ID, data store ARN, data store name, data store status, when the data store was created, data store type version, and the data store's endpoint.
        public let datastoreProperties: DatastoreProperties

        @inlinable
        public init(datastoreProperties: DatastoreProperties) {
            self.datastoreProperties = datastoreProperties
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreProperties = "DatastoreProperties"
        }
    }

    public struct DescribeFHIRExportJobRequest: AWSEncodableShape {
        /// The AWS generated ID for the data store from which files are being exported from for an export job.
        public let datastoreId: String
        /// The AWS generated ID for an export job.
        public let jobId: String

        @inlinable
        public init(datastoreId: String, jobId: String) {
            self.datastoreId = datastoreId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobId = "JobId"
        }
    }

    public struct DescribeFHIRExportJobResponse: AWSDecodableShape {
        /// Displays the properties of the export job, including the ID, Arn, Name, and the status of the job.
        public let exportJobProperties: ExportJobProperties

        @inlinable
        public init(exportJobProperties: ExportJobProperties) {
            self.exportJobProperties = exportJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobProperties = "ExportJobProperties"
        }
    }

    public struct DescribeFHIRImportJobRequest: AWSEncodableShape {
        /// The AWS-generated ID of the data store.
        public let datastoreId: String
        /// The AWS-generated job ID.
        public let jobId: String

        @inlinable
        public init(datastoreId: String, jobId: String) {
            self.datastoreId = datastoreId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobId = "JobId"
        }
    }

    public struct DescribeFHIRImportJobResponse: AWSDecodableShape {
        /// The properties of the Import job request, including the ID, ARN, name, status of the job, and the progress report of the job.
        public let importJobProperties: ImportJobProperties

        @inlinable
        public init(importJobProperties: ImportJobProperties) {
            self.importJobProperties = importJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case importJobProperties = "ImportJobProperties"
        }
    }

    public struct ErrorCause: AWSDecodableShape {
        /// The error category of the create/delete data store operation. Possible statuses are RETRYABLE_ERROR or NON_RETRYABLE_ERROR.
        public let errorCategory: ErrorCategory?
        /// The text of the error message.
        public let errorMessage: String?

        @inlinable
        public init(errorCategory: ErrorCategory? = nil, errorMessage: String? = nil) {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCategory = "ErrorCategory"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct ExportJobProperties: AWSDecodableShape {
        /// The Amazon Resource Name used during the initiation of the job.
        public let dataAccessRoleArn: String?
        /// The AWS generated ID for the data store from which files are being exported for an export job.
        public let datastoreId: String
        /// The time an export job completed.
        public let endTime: Date?
        /// The AWS generated ID for an export job.
        public let jobId: String
        /// The user generated name for an export job.
        public let jobName: String?
        /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
        public let jobStatus: JobStatus
        /// An explanation of any errors that may have occurred during the export job.
        public let message: String?
        /// The output data configuration that was supplied when the export job was created.
        public let outputDataConfig: OutputDataConfig
        /// The time an export job was initiated.
        public let submitTime: Date

        @inlinable
        public init(dataAccessRoleArn: String? = nil, datastoreId: String, endTime: Date? = nil, jobId: String, jobName: String? = nil, jobStatus: JobStatus, message: String? = nil, outputDataConfig: OutputDataConfig, submitTime: Date) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "DataAccessRoleArn"
            case datastoreId = "DatastoreId"
            case endTime = "EndTime"
            case jobId = "JobId"
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case message = "Message"
            case outputDataConfig = "OutputDataConfig"
            case submitTime = "SubmitTime"
        }
    }

    public struct IdentityProviderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The authorization strategy that you selected when you created the data store.
        public let authorizationStrategy: AuthorizationStrategy
        /// If you enabled fine-grained authorization when you created the data store.
        public let fineGrainedAuthorizationEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the Lambda function that you want to use to decode the access token created by the authorization server.
        public let idpLambdaArn: String?
        /// The JSON metadata elements that you want to use in your identity provider configuration. Required elements are listed based on the launch specification of the SMART application. For more information on all possible elements, see Metadata in SMART's App Launch specification.  authorization_endpoint: The URL to the OAuth2 authorization endpoint.  grant_types_supported:  An array of grant types that are supported at the token endpoint. You must provide at least one grant type option. Valid options are authorization_code and client_credentials.  token_endpoint: The URL to the OAuth2 token endpoint.  capabilities: An array of strings of the SMART capabilities that the authorization server supports.  code_challenge_methods_supported: An array of strings of supported PKCE code challenge methods. You must include the S256 method in the array of PKCE code challenge methods.
        public let metadata: String?

        @inlinable
        public init(authorizationStrategy: AuthorizationStrategy, fineGrainedAuthorizationEnabled: Bool? = nil, idpLambdaArn: String? = nil, metadata: String? = nil) {
            self.authorizationStrategy = authorizationStrategy
            self.fineGrainedAuthorizationEnabled = fineGrainedAuthorizationEnabled
            self.idpLambdaArn = idpLambdaArn
            self.metadata = metadata
        }

        public func validate(name: String) throws {
            try self.validate(self.idpLambdaArn, name: "idpLambdaArn", parent: name, max: 256)
            try self.validate(self.idpLambdaArn, name: "idpLambdaArn", parent: name, min: 49)
            try self.validate(self.idpLambdaArn, name: "idpLambdaArn", parent: name, pattern: "^arn:aws:lambda:[a-z]{2}-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9\\-_\\.]+(:(\\$LATEST|[a-zA-Z0-9\\-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationStrategy = "AuthorizationStrategy"
            case fineGrainedAuthorizationEnabled = "FineGrainedAuthorizationEnabled"
            case idpLambdaArn = "IdpLambdaArn"
            case metadata = "Metadata"
        }
    }

    public struct ImportJobProperties: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that gives AWS HealthLake access to your input data.
        public let dataAccessRoleArn: String?
        /// The datastore id used when the Import job was created.
        public let datastoreId: String
        /// The time that the Import job was completed.
        public let endTime: Date?
        /// The input data configuration that was supplied when the Import job was created.
        public let inputDataConfig: InputDataConfig
        /// The AWS-generated id number for the Import job.
        public let jobId: String
        /// The user-generated name for an Import job.
        public let jobName: String?
        public let jobOutputDataConfig: OutputDataConfig?
        /// Displays the progress of the import job, including total resources scanned, total resources ingested, and total size of data ingested.
        public let jobProgressReport: JobProgressReport?
        /// The job status for an Import job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED_WITH_ERRORS, COMPLETED, FAILED.
        public let jobStatus: JobStatus
        /// An explanation of any errors that may have occurred during the FHIR import job.
        public let message: String?
        /// The time that the Import job was submitted for processing.
        public let submitTime: Date

        @inlinable
        public init(dataAccessRoleArn: String? = nil, datastoreId: String, endTime: Date? = nil, inputDataConfig: InputDataConfig, jobId: String, jobName: String? = nil, jobOutputDataConfig: OutputDataConfig? = nil, jobProgressReport: JobProgressReport? = nil, jobStatus: JobStatus, message: String? = nil, submitTime: Date) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
            self.jobProgressReport = jobProgressReport
            self.jobStatus = jobStatus
            self.message = message
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "DataAccessRoleArn"
            case datastoreId = "DatastoreId"
            case endTime = "EndTime"
            case inputDataConfig = "InputDataConfig"
            case jobId = "JobId"
            case jobName = "JobName"
            case jobOutputDataConfig = "JobOutputDataConfig"
            case jobProgressReport = "JobProgressReport"
            case jobStatus = "JobStatus"
            case message = "Message"
            case submitTime = "SubmitTime"
        }
    }

    public struct JobProgressReport: AWSDecodableShape {
        /// The throughput (in MB/sec) of the import job.
        public let throughput: Double?
        /// The number of files that failed to be read from the input S3 bucket due to customer error.
        public let totalNumberOfFilesReadWithCustomerError: Int64?
        /// The number of files imported so far.
        public let totalNumberOfImportedFiles: Int64?
        /// The number of resources imported so far.
        public let totalNumberOfResourcesImported: Int64?
        /// The number of resources scanned from the input S3 bucket.
        public let totalNumberOfResourcesScanned: Int64?
        /// The number of resources that failed due to customer error.
        public let totalNumberOfResourcesWithCustomerError: Int64?
        /// The number of files scanned from input S3 bucket.
        public let totalNumberOfScannedFiles: Int64?
        /// The size (in MB) of the files scanned from the input S3 bucket.
        public let totalSizeOfScannedFilesInMB: Double?

        @inlinable
        public init(throughput: Double? = nil, totalNumberOfFilesReadWithCustomerError: Int64? = nil, totalNumberOfImportedFiles: Int64? = nil, totalNumberOfResourcesImported: Int64? = nil, totalNumberOfResourcesScanned: Int64? = nil, totalNumberOfResourcesWithCustomerError: Int64? = nil, totalNumberOfScannedFiles: Int64? = nil, totalSizeOfScannedFilesInMB: Double? = nil) {
            self.throughput = throughput
            self.totalNumberOfFilesReadWithCustomerError = totalNumberOfFilesReadWithCustomerError
            self.totalNumberOfImportedFiles = totalNumberOfImportedFiles
            self.totalNumberOfResourcesImported = totalNumberOfResourcesImported
            self.totalNumberOfResourcesScanned = totalNumberOfResourcesScanned
            self.totalNumberOfResourcesWithCustomerError = totalNumberOfResourcesWithCustomerError
            self.totalNumberOfScannedFiles = totalNumberOfScannedFiles
            self.totalSizeOfScannedFilesInMB = totalSizeOfScannedFilesInMB
        }

        private enum CodingKeys: String, CodingKey {
            case throughput = "Throughput"
            case totalNumberOfFilesReadWithCustomerError = "TotalNumberOfFilesReadWithCustomerError"
            case totalNumberOfImportedFiles = "TotalNumberOfImportedFiles"
            case totalNumberOfResourcesImported = "TotalNumberOfResourcesImported"
            case totalNumberOfResourcesScanned = "TotalNumberOfResourcesScanned"
            case totalNumberOfResourcesWithCustomerError = "TotalNumberOfResourcesWithCustomerError"
            case totalNumberOfScannedFiles = "TotalNumberOfScannedFiles"
            case totalSizeOfScannedFilesInMB = "TotalSizeOfScannedFilesInMB"
        }
    }

    public struct KmsEncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The type of customer-managed-key(CMK) used for encryption. The two types of supported CMKs are customer owned CMKs and AWS owned CMKs.
        public let cmkType: CmkType
        ///  The KMS encryption key id/alias used to encrypt the data store contents at rest.
        public let kmsKeyId: String?

        @inlinable
        public init(cmkType: CmkType, kmsKeyId: String? = nil) {
            self.cmkType = cmkType
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 400)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^(arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:kms:)?([a-z]{2}-[a-z]+(-[a-z]+)?-\\d:)?(\\d{12}:)?(((key/)?[a-zA-Z0-9-_]+)|(alias/[a-zA-Z0-9:/_-]+))$")
        }

        private enum CodingKeys: String, CodingKey {
            case cmkType = "CmkType"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct ListFHIRDatastoresRequest: AWSEncodableShape {
        /// Lists all filters associated with a FHIR data store request.
        public let filter: DatastoreFilter?
        /// The maximum number of data stores returned in a single page of a ListFHIRDatastoresRequest call.
        public let maxResults: Int?
        /// Fetches the next page of data stores when results are paginated.
        public let nextToken: String?

        @inlinable
        public init(filter: DatastoreFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListFHIRDatastoresResponse: AWSDecodableShape {
        /// All properties associated with the listed data stores.
        public let datastorePropertiesList: [DatastoreProperties]
        /// Pagination token that can be used to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(datastorePropertiesList: [DatastoreProperties], nextToken: String? = nil) {
            self.datastorePropertiesList = datastorePropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datastorePropertiesList = "DatastorePropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListFHIRExportJobsRequest: AWSEncodableShape {
        ///  This parameter limits the response to the export job with the specified data store ID.
        public let datastoreId: String
        ///  This parameter limits the response to the export job with the specified job name.
        public let jobName: String?
        ///  This parameter limits the response to the export jobs with the specified job status.
        public let jobStatus: JobStatus?
        ///  This parameter limits the number of results returned for a ListFHIRExportJobs to a maximum quantity specified by the user.
        public let maxResults: Int?
        ///  A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
        public let nextToken: String?
        ///  This parameter limits the response to FHIR export jobs submitted after a user specified date.
        public let submittedAfter: Date?
        ///  This parameter limits the response to FHIR export jobs submitted before a user specified date.
        public let submittedBefore: Date?

        @inlinable
        public init(datastoreId: String, jobName: String? = nil, jobStatus: JobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil, submittedAfter: Date? = nil, submittedBefore: Date? = nil) {
            self.datastoreId = datastoreId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.submittedAfter = submittedAfter
            self.submittedBefore = submittedBefore
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case submittedAfter = "SubmittedAfter"
            case submittedBefore = "SubmittedBefore"
        }
    }

    public struct ListFHIRExportJobsResponse: AWSDecodableShape {
        ///  The properties of listed FHIR export jobs, including the ID, ARN, name, and the status of the job.
        public let exportJobPropertiesList: [ExportJobProperties]
        ///  A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
        public let nextToken: String?

        @inlinable
        public init(exportJobPropertiesList: [ExportJobProperties], nextToken: String? = nil) {
            self.exportJobPropertiesList = exportJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobPropertiesList = "ExportJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListFHIRImportJobsRequest: AWSEncodableShape {
        ///  This parameter limits the response to the import job with the specified data store ID.
        public let datastoreId: String
        ///  This parameter limits the response to the import job with the specified job name.
        public let jobName: String?
        ///  This parameter limits the response to the import job with the specified job status.
        public let jobStatus: JobStatus?
        ///  This parameter limits the number of results returned for a ListFHIRImportJobs to a maximum quantity specified by the user.
        public let maxResults: Int?
        ///  A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
        public let nextToken: String?
        ///  This parameter limits the response to FHIR import jobs submitted after a user specified date.
        public let submittedAfter: Date?
        ///  This parameter limits the response to FHIR import jobs submitted before a user specified date.
        public let submittedBefore: Date?

        @inlinable
        public init(datastoreId: String, jobName: String? = nil, jobStatus: JobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil, submittedAfter: Date? = nil, submittedBefore: Date? = nil) {
            self.datastoreId = datastoreId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.submittedAfter = submittedAfter
            self.submittedBefore = submittedBefore
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case submittedAfter = "SubmittedAfter"
            case submittedBefore = "SubmittedBefore"
        }
    }

    public struct ListFHIRImportJobsResponse: AWSDecodableShape {
        ///  The properties of a listed FHIR import jobs, including the ID, ARN, name, the status of the job, and the progress report of the job.
        public let importJobPropertiesList: [ImportJobProperties]
        ///  A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
        public let nextToken: String?

        @inlinable
        public init(importJobPropertiesList: [ImportJobProperties], nextToken: String? = nil) {
            self.importJobPropertiesList = importJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobPropertiesList = "ImportJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name(ARN) of the data store for which tags are being added.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:healthlake:[a-z0-9-]+:\\d{12}:datastore\\/fhir\\/.{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  Returns a list of tags associated with a data store.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct PreloadDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of preloaded data. Only Synthea preloaded data is supported.
        public let preloadDataType: PreloadDataType

        @inlinable
        public init(preloadDataType: PreloadDataType) {
            self.preloadDataType = preloadDataType
        }

        private enum CodingKeys: String, CodingKey {
            case preloadDataType = "PreloadDataType"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        ///  The KMS key ID used to access the S3 bucket.
        public let kmsKeyId: String
        ///  The S3Uri is the user specified S3 location of the FHIR data to be imported into AWS HealthLake.
        public let s3Uri: String

        @inlinable
        public init(kmsKeyId: String, s3Uri: String) {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 400)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^(arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:kms:)?([a-z]{2}-[a-z]+(-[a-z]+)?-\\d:)?(\\d{12}:)?(((key/)?[a-zA-Z0-9-_]+)|(alias/[a-zA-Z0-9:/_-]+))$")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3Uri = "S3Uri"
        }
    }

    public struct SseConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The KMS encryption configuration used to provide details for data encryption.
        public let kmsEncryptionConfig: KmsEncryptionConfig

        @inlinable
        public init(kmsEncryptionConfig: KmsEncryptionConfig) {
            self.kmsEncryptionConfig = kmsEncryptionConfig
        }

        public func validate(name: String) throws {
            try self.kmsEncryptionConfig.validate(name: "\(name).kmsEncryptionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsEncryptionConfig = "KmsEncryptionConfig"
        }
    }

    public struct StartFHIRExportJobRequest: AWSEncodableShape {
        /// An optional user provided token used for ensuring idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name used during the initiation of the job.
        public let dataAccessRoleArn: String
        /// The AWS generated ID for the data store from which files are being exported for an export job.
        public let datastoreId: String
        /// The user generated name for an export job.
        public let jobName: String?
        /// The output data configuration that was supplied when the export job was created.
        public let outputDataConfig: OutputDataConfig

        @inlinable
        public init(clientToken: String? = StartFHIRExportJobRequest.idempotencyToken(), dataAccessRoleArn: String, datastoreId: String, jobName: String? = nil, outputDataConfig: OutputDataConfig) {
            self.clientToken = clientToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.jobName = jobName
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case datastoreId = "DatastoreId"
            case jobName = "JobName"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartFHIRExportJobResponse: AWSDecodableShape {
        /// The AWS generated ID for the data store from which files are being exported for an export job.
        public let datastoreId: String?
        /// The AWS generated ID for an export job.
        public let jobId: String
        /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
        public let jobStatus: JobStatus

        @inlinable
        public init(datastoreId: String? = nil, jobId: String, jobStatus: JobStatus) {
            self.datastoreId = datastoreId
            self.jobId = jobId
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobId = "JobId"
            case jobStatus = "JobStatus"
        }
    }

    public struct StartFHIRImportJobRequest: AWSEncodableShape {
        /// Optional user provided token used for ensuring idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) that gives AWS HealthLake access permission.
        public let dataAccessRoleArn: String
        /// The AWS-generated data store ID.
        public let datastoreId: String
        /// The input properties of the FHIR Import job in the StartFHIRImport job request.
        public let inputDataConfig: InputDataConfig
        /// The name of the FHIR Import job in the StartFHIRImport job request.
        public let jobName: String?
        public let jobOutputDataConfig: OutputDataConfig

        @inlinable
        public init(clientToken: String? = StartFHIRImportJobRequest.idempotencyToken(), dataAccessRoleArn: String, datastoreId: String, inputDataConfig: InputDataConfig, jobName: String? = nil, jobOutputDataConfig: OutputDataConfig) {
            self.clientToken = clientToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.jobOutputDataConfig.validate(name: "\(name).jobOutputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case datastoreId = "DatastoreId"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case jobOutputDataConfig = "JobOutputDataConfig"
        }
    }

    public struct StartFHIRImportJobResponse: AWSDecodableShape {
        /// The AWS-generated data store ID.
        public let datastoreId: String?
        /// The AWS-generated job ID.
        public let jobId: String
        /// The status of an import job.
        public let jobStatus: JobStatus

        @inlinable
        public init(datastoreId: String? = nil, jobId: String, jobStatus: JobStatus) {
            self.datastoreId = datastoreId
            self.jobId = jobId
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobId = "JobId"
            case jobStatus = "JobStatus"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        ///  The key portion of a tag. Tag keys are case sensitive.
        public let key: String
        ///  The value portion of a tag. Tag values are case sensitive.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name(ARN)that gives AWS HealthLake access to the data store which tags are being added to.
        public let resourceARN: String
        ///  The user specified key and value pair tags being added to a data store.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:healthlake:[a-z0-9-]+:\\d{12}:datastore\\/fhir\\/.{32}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name(ARN) of the data store for which tags are being removed.
        public let resourceARN: String
        ///  The keys for the tags to be removed from the HealthLake data store.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:healthlake:[a-z0-9-]+:\\d{12}:datastore\\/fhir\\/.{32}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct InputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3Uri is the user specified S3 location of the FHIR data to be imported into AWS HealthLake.
        public let s3Uri: String?

        @inlinable
        public init(s3Uri: String? = nil) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "S3Uri"
        }
    }

    public struct OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The output data configuration that was supplied when the export job was created.
        public let s3Configuration: S3Configuration?

        @inlinable
        public init(s3Configuration: S3Configuration? = nil) {
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "S3Configuration"
        }
    }
}

// MARK: - Errors

/// Error enum for HealthLake
public struct HealthLakeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize HealthLake
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access is denied. Your account is not authorized to perform this operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The data store is in a transition state and the user requested action can not be performed.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unknown error occurs in the service.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The requested data store was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The user has exceeded their maximum number of allowed calls to the given API.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The user input parameter was invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension HealthLakeErrorType: Equatable {
    public static func == (lhs: HealthLakeErrorType, rhs: HealthLakeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension HealthLakeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
