//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension HealthLake {
    // MARK: Enums

    public enum AuthorizationStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsAuth = "AWS_AUTH"
        case smartOnFhir = "SMART_ON_FHIR"
        case smartv1 = "SMART_ON_FHIR_V1"
        public var description: String { return self.rawValue }
    }

    public enum CmkType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aoCmk = "AWS_OWNED_KMS_KEY"
        case cmCmk = "CUSTOMER_MANAGED_KMS_KEY"
        public var description: String { return self.rawValue }
    }

    public enum DatastoreStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nonRetryableError = "NON_RETRYABLE_ERROR"
        case retryableError = "RETRYABLE_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum FHIRVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case r4 = "R4"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelCompleted = "CANCEL_COMPLETED"
        case cancelFailed = "CANCEL_FAILED"
        case cancelInProgress = "CANCEL_IN_PROGRESS"
        case cancelSubmitted = "CANCEL_SUBMITTED"
        case completed = "COMPLETED"
        case completedWithErrors = "COMPLETED_WITH_ERRORS"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum PreloadDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case synthea = "SYNTHEA"
        public var description: String { return self.rawValue }
    }

    public enum ValidationLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case minimal = "minimal"
        case strict = "strict"
        case structureOnly = "structure-only"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateFHIRDatastoreRequest: AWSEncodableShape {
        /// An optional user-provided token to ensure API idempotency.
        public let clientToken: String?
        /// The data store name (user-generated).
        public let datastoreName: String?
        /// The FHIR release version supported by the data store. Current support is for version R4.
        public let datastoreTypeVersion: FHIRVersion
        /// The identity provider configuration to use for the data store.
        public let identityProviderConfiguration: IdentityProviderConfiguration?
        /// An optional parameter to preload (import) open source Synthea FHIR data upon creation of the data store.
        public let preloadDataConfig: PreloadDataConfig?
        /// The server-side encryption key configuration for a customer-provided encryption key specified for creating a data store.
        public let sseConfiguration: SseConfiguration?
        /// The resource tags applied to a data store when it is created.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateFHIRDatastoreRequest.idempotencyToken(), datastoreName: String? = nil, datastoreTypeVersion: FHIRVersion, identityProviderConfiguration: IdentityProviderConfiguration? = nil, preloadDataConfig: PreloadDataConfig? = nil, sseConfiguration: SseConfiguration? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.datastoreName = datastoreName
            self.datastoreTypeVersion = datastoreTypeVersion
            self.identityProviderConfiguration = identityProviderConfiguration
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, max: 256)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, min: 1)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.identityProviderConfiguration?.validate(name: "\(name).identityProviderConfiguration")
            try self.sseConfiguration?.validate(name: "\(name).sseConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case datastoreName = "DatastoreName"
            case datastoreTypeVersion = "DatastoreTypeVersion"
            case identityProviderConfiguration = "IdentityProviderConfiguration"
            case preloadDataConfig = "PreloadDataConfig"
            case sseConfiguration = "SseConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateFHIRDatastoreResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the data store.
        public let datastoreArn: String
        /// The AWS endpoint created for the data store.
        public let datastoreEndpoint: String
        /// The data store identifier.
        public let datastoreId: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus

        @inlinable
        public init(datastoreArn: String, datastoreEndpoint: String, datastoreId: String, datastoreStatus: DatastoreStatus) {
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreStatus = datastoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreArn = "DatastoreArn"
            case datastoreEndpoint = "DatastoreEndpoint"
            case datastoreId = "DatastoreId"
            case datastoreStatus = "DatastoreStatus"
        }
    }

    public struct DatastoreFilter: AWSEncodableShape {
        /// Filter to set cutoff dates for records. All data stores created after the specified date are included in the results.
        public let createdAfter: Date?
        /// Filter to set cutoff dates for records. All data stores created before the specified date are included in the results.
        public let createdBefore: Date?
        /// Filter data store results by name.
        public let datastoreName: String?
        /// Filter data store results by status.
        public let datastoreStatus: DatastoreStatus?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, datastoreName: String? = nil, datastoreStatus: DatastoreStatus? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, max: 256)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, min: 1)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case datastoreName = "DatastoreName"
            case datastoreStatus = "DatastoreStatus"
        }
    }

    public struct DatastoreProperties: AWSDecodableShape {
        /// The time the data store was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) used in the creation of the data store.
        public let datastoreArn: String
        /// The AWS endpoint for the data store.
        public let datastoreEndpoint: String
        /// The data store identifier.
        public let datastoreId: String
        /// The data store name.
        public let datastoreName: String?
        /// The data store status.
        public let datastoreStatus: DatastoreStatus
        /// The FHIR release version supported by the data store. Current support is for version R4.
        public let datastoreTypeVersion: FHIRVersion
        /// The error cause for the current data store operation.
        public let errorCause: ErrorCause?
        /// The identity provider selected during data store creation.
        public let identityProviderConfiguration: IdentityProviderConfiguration?
        /// The preloaded Synthea data configuration for the data store.
        public let preloadDataConfig: PreloadDataConfig?
        ///  The server-side encryption key configuration for a customer provided encryption key.
        public let sseConfiguration: SseConfiguration?

        @inlinable
        public init(createdAt: Date? = nil, datastoreArn: String, datastoreEndpoint: String, datastoreId: String, datastoreName: String? = nil, datastoreStatus: DatastoreStatus, datastoreTypeVersion: FHIRVersion, errorCause: ErrorCause? = nil, identityProviderConfiguration: IdentityProviderConfiguration? = nil, preloadDataConfig: PreloadDataConfig? = nil, sseConfiguration: SseConfiguration? = nil) {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.datastoreTypeVersion = datastoreTypeVersion
            self.errorCause = errorCause
            self.identityProviderConfiguration = identityProviderConfiguration
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case datastoreArn = "DatastoreArn"
            case datastoreEndpoint = "DatastoreEndpoint"
            case datastoreId = "DatastoreId"
            case datastoreName = "DatastoreName"
            case datastoreStatus = "DatastoreStatus"
            case datastoreTypeVersion = "DatastoreTypeVersion"
            case errorCause = "ErrorCause"
            case identityProviderConfiguration = "IdentityProviderConfiguration"
            case preloadDataConfig = "PreloadDataConfig"
            case sseConfiguration = "SseConfiguration"
        }
    }

    public struct DeleteFHIRDatastoreRequest: AWSEncodableShape {
        ///  The AWS-generated identifier for the data store to be deleted.
        public let datastoreId: String

        @inlinable
        public init(datastoreId: String) {
            self.datastoreId = datastoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
        }
    }

    public struct DeleteFHIRDatastoreResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that grants access permission to AWS HealthLake.
        public let datastoreArn: String
        /// The AWS endpoint of the data store to be deleted.
        public let datastoreEndpoint: String
        /// The AWS-generated ID for the deleted data store.
        public let datastoreId: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus

        @inlinable
        public init(datastoreArn: String, datastoreEndpoint: String, datastoreId: String, datastoreStatus: DatastoreStatus) {
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreStatus = datastoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreArn = "DatastoreArn"
            case datastoreEndpoint = "DatastoreEndpoint"
            case datastoreId = "DatastoreId"
            case datastoreStatus = "DatastoreStatus"
        }
    }

    public struct DescribeFHIRDatastoreRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String

        @inlinable
        public init(datastoreId: String) {
            self.datastoreId = datastoreId
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
        }
    }

    public struct DescribeFHIRDatastoreResponse: AWSDecodableShape {
        /// The data store properties.
        public let datastoreProperties: DatastoreProperties

        @inlinable
        public init(datastoreProperties: DatastoreProperties) {
            self.datastoreProperties = datastoreProperties
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreProperties = "DatastoreProperties"
        }
    }

    public struct DescribeFHIRExportJobRequest: AWSEncodableShape {
        /// The data store identifier from which FHIR data is being exported from.
        public let datastoreId: String
        /// The export job identifier.
        public let jobId: String

        @inlinable
        public init(datastoreId: String, jobId: String) {
            self.datastoreId = datastoreId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobId = "JobId"
        }
    }

    public struct DescribeFHIRExportJobResponse: AWSDecodableShape {
        /// The export job properties.
        public let exportJobProperties: ExportJobProperties

        @inlinable
        public init(exportJobProperties: ExportJobProperties) {
            self.exportJobProperties = exportJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobProperties = "ExportJobProperties"
        }
    }

    public struct DescribeFHIRImportJobRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The import job identifier.
        public let jobId: String

        @inlinable
        public init(datastoreId: String, jobId: String) {
            self.datastoreId = datastoreId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobId = "JobId"
        }
    }

    public struct DescribeFHIRImportJobResponse: AWSDecodableShape {
        /// The import job properties.
        public let importJobProperties: ImportJobProperties

        @inlinable
        public init(importJobProperties: ImportJobProperties) {
            self.importJobProperties = importJobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case importJobProperties = "ImportJobProperties"
        }
    }

    public struct ErrorCause: AWSDecodableShape {
        /// The error category for ErrorCause.
        public let errorCategory: ErrorCategory?
        /// The error message text for ErrorCause.
        public let errorMessage: String?

        @inlinable
        public init(errorCategory: ErrorCategory? = nil, errorMessage: String? = nil) {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCategory = "ErrorCategory"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct ExportJobProperties: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) used during the initiation of the export job.
        public let dataAccessRoleArn: String?
        /// The data store identifier from which files are being exported.
        public let datastoreId: String
        /// The time the export job completed.
        public let endTime: Date?
        /// The export job identifier.
        public let jobId: String
        /// The export job name.
        public let jobName: String?
        /// The export job status.
        public let jobStatus: JobStatus
        /// An explanation of any errors that might have occurred during the export job.
        public let message: String?
        /// The output data configuration supplied when the export job was created.
        public let outputDataConfig: OutputDataConfig
        /// The time the export job was initiated.
        public let submitTime: Date

        @inlinable
        public init(dataAccessRoleArn: String? = nil, datastoreId: String, endTime: Date? = nil, jobId: String, jobName: String? = nil, jobStatus: JobStatus, message: String? = nil, outputDataConfig: OutputDataConfig, submitTime: Date) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "DataAccessRoleArn"
            case datastoreId = "DatastoreId"
            case endTime = "EndTime"
            case jobId = "JobId"
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case message = "Message"
            case outputDataConfig = "OutputDataConfig"
            case submitTime = "SubmitTime"
        }
    }

    public struct IdentityProviderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The authorization strategy selected when the HealthLake data store is created.  HealthLake provides support for both SMART on FHIR V1 and V2 as described below.    SMART_ON_FHIR_V1 – Support for only SMART on FHIR V1, which includes read (read/search) and write (create/update/delete) permissions.    SMART_ON_FHIR – Support for both SMART on FHIR V1 and V2, which includes create, read, update, delete, and search permissions.    AWS_AUTH – The default HealthLake authorization strategy; not affiliated with SMART on FHIR.
        public let authorizationStrategy: AuthorizationStrategy
        /// The parameter to enable SMART on FHIR fine-grained authorization for the data store.
        public let fineGrainedAuthorizationEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the Lambda function to use to decode the access token created by the authorization server.
        public let idpLambdaArn: String?
        /// The JSON metadata elements to use in your identity provider configuration. Required elements are listed based on the launch specification of the SMART application. For more information on all possible elements, see Metadata in SMART's App Launch specification.  authorization_endpoint: The URL to the OAuth2 authorization endpoint.  grant_types_supported: An array of grant types that are supported at the token endpoint. You must provide at least one grant type option. Valid options are authorization_code and client_credentials.  token_endpoint: The URL to the OAuth2 token endpoint.  capabilities: An array of strings of the SMART capabilities that the authorization server supports.  code_challenge_methods_supported: An array of strings of supported PKCE code challenge methods. You must include the S256 method in the array of PKCE code challenge methods.
        public let metadata: String?

        @inlinable
        public init(authorizationStrategy: AuthorizationStrategy, fineGrainedAuthorizationEnabled: Bool? = nil, idpLambdaArn: String? = nil, metadata: String? = nil) {
            self.authorizationStrategy = authorizationStrategy
            self.fineGrainedAuthorizationEnabled = fineGrainedAuthorizationEnabled
            self.idpLambdaArn = idpLambdaArn
            self.metadata = metadata
        }

        public func validate(name: String) throws {
            try self.validate(self.idpLambdaArn, name: "idpLambdaArn", parent: name, max: 256)
            try self.validate(self.idpLambdaArn, name: "idpLambdaArn", parent: name, min: 49)
            try self.validate(self.idpLambdaArn, name: "idpLambdaArn", parent: name, pattern: "^arn:aws:lambda:[a-z]{2}-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9\\-_\\.]+(:(\\$LATEST|[a-zA-Z0-9\\-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationStrategy = "AuthorizationStrategy"
            case fineGrainedAuthorizationEnabled = "FineGrainedAuthorizationEnabled"
            case idpLambdaArn = "IdpLambdaArn"
            case metadata = "Metadata"
        }
    }

    public struct ImportJobProperties: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that grants AWS HealthLake access to the input data.
        public let dataAccessRoleArn: String?
        /// The data store identifier.
        public let datastoreId: String
        /// The time the import job was completed.
        public let endTime: Date?
        /// The input data configuration supplied when the import job was created.
        public let inputDataConfig: InputDataConfig
        /// The import job identifier.
        public let jobId: String
        /// The import job name.
        public let jobName: String?
        public let jobOutputDataConfig: OutputDataConfig?
        /// Displays the progress of the import job, including total resources scanned, total resources imported, and total size of data imported.
        public let jobProgressReport: JobProgressReport?
        /// The import job status.
        public let jobStatus: JobStatus
        /// An explanation of any errors that might have occurred during the FHIR import job.
        public let message: String?
        /// The time the import job was submitted for processing.
        public let submitTime: Date
        /// The validation level of the import job.
        public let validationLevel: ValidationLevel?

        @inlinable
        public init(dataAccessRoleArn: String? = nil, datastoreId: String, endTime: Date? = nil, inputDataConfig: InputDataConfig, jobId: String, jobName: String? = nil, jobOutputDataConfig: OutputDataConfig? = nil, jobProgressReport: JobProgressReport? = nil, jobStatus: JobStatus, message: String? = nil, submitTime: Date, validationLevel: ValidationLevel? = nil) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
            self.jobProgressReport = jobProgressReport
            self.jobStatus = jobStatus
            self.message = message
            self.submitTime = submitTime
            self.validationLevel = validationLevel
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "DataAccessRoleArn"
            case datastoreId = "DatastoreId"
            case endTime = "EndTime"
            case inputDataConfig = "InputDataConfig"
            case jobId = "JobId"
            case jobName = "JobName"
            case jobOutputDataConfig = "JobOutputDataConfig"
            case jobProgressReport = "JobProgressReport"
            case jobStatus = "JobStatus"
            case message = "Message"
            case submitTime = "SubmitTime"
            case validationLevel = "ValidationLevel"
        }
    }

    public struct JobProgressReport: AWSDecodableShape {
        /// The transaction rate the import job is processed at.
        public let throughput: Double?
        /// The number of files that failed to be read from the S3 input bucket due to customer error.
        public let totalNumberOfFilesReadWithCustomerError: Int64?
        /// The number of files imported.
        public let totalNumberOfImportedFiles: Int64?
        /// The number of resources imported.
        public let totalNumberOfResourcesImported: Int64?
        /// The number of resources scanned from the S3 input bucket.
        public let totalNumberOfResourcesScanned: Int64?
        /// The number of resources that failed due to customer error.
        public let totalNumberOfResourcesWithCustomerError: Int64?
        /// The number of files scanned from the S3 input bucket.
        public let totalNumberOfScannedFiles: Int64?
        /// The size (in MB) of files scanned from the S3 input bucket.
        public let totalSizeOfScannedFilesInMB: Double?

        @inlinable
        public init(throughput: Double? = nil, totalNumberOfFilesReadWithCustomerError: Int64? = nil, totalNumberOfImportedFiles: Int64? = nil, totalNumberOfResourcesImported: Int64? = nil, totalNumberOfResourcesScanned: Int64? = nil, totalNumberOfResourcesWithCustomerError: Int64? = nil, totalNumberOfScannedFiles: Int64? = nil, totalSizeOfScannedFilesInMB: Double? = nil) {
            self.throughput = throughput
            self.totalNumberOfFilesReadWithCustomerError = totalNumberOfFilesReadWithCustomerError
            self.totalNumberOfImportedFiles = totalNumberOfImportedFiles
            self.totalNumberOfResourcesImported = totalNumberOfResourcesImported
            self.totalNumberOfResourcesScanned = totalNumberOfResourcesScanned
            self.totalNumberOfResourcesWithCustomerError = totalNumberOfResourcesWithCustomerError
            self.totalNumberOfScannedFiles = totalNumberOfScannedFiles
            self.totalSizeOfScannedFilesInMB = totalSizeOfScannedFilesInMB
        }

        private enum CodingKeys: String, CodingKey {
            case throughput = "Throughput"
            case totalNumberOfFilesReadWithCustomerError = "TotalNumberOfFilesReadWithCustomerError"
            case totalNumberOfImportedFiles = "TotalNumberOfImportedFiles"
            case totalNumberOfResourcesImported = "TotalNumberOfResourcesImported"
            case totalNumberOfResourcesScanned = "TotalNumberOfResourcesScanned"
            case totalNumberOfResourcesWithCustomerError = "TotalNumberOfResourcesWithCustomerError"
            case totalNumberOfScannedFiles = "TotalNumberOfScannedFiles"
            case totalSizeOfScannedFilesInMB = "TotalSizeOfScannedFilesInMB"
        }
    }

    public struct KmsEncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of customer-managed-key (CMK) used for encryption.
        public let cmkType: CmkType
        /// The Key Management Service (KMS) encryption key id/alias used to encrypt the data store contents at rest.
        public let kmsKeyId: String?

        @inlinable
        public init(cmkType: CmkType, kmsKeyId: String? = nil) {
            self.cmkType = cmkType
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 400)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^(arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:kms:)?([a-z]{2}-[a-z]+(-[a-z]+)?-\\d:)?(\\d{12}:)?(((key/)?[a-zA-Z0-9-_]+)|(alias/[a-zA-Z0-9:/_-]+))$")
        }

        private enum CodingKeys: String, CodingKey {
            case cmkType = "CmkType"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct ListFHIRDatastoresRequest: AWSEncodableShape {
        /// List all filters associated with a FHIR data store request.
        public let filter: DatastoreFilter?
        /// The maximum number of data stores returned on a page.
        public let maxResults: Int?
        /// The token used to retrieve the next page of data stores when results are paginated.
        public let nextToken: String?

        @inlinable
        public init(filter: DatastoreFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListFHIRDatastoresResponse: AWSDecodableShape {
        /// The properties associated with all listed data stores.
        public let datastorePropertiesList: [DatastoreProperties]
        /// The pagination token used to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(datastorePropertiesList: [DatastoreProperties], nextToken: String? = nil) {
            self.datastorePropertiesList = datastorePropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datastorePropertiesList = "DatastorePropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListFHIRExportJobsRequest: AWSEncodableShape {
        /// Limits the response to the export job with the specified data store ID.
        public let datastoreId: String
        /// Limits the response to the export job with the specified job name.
        public let jobName: String?
        /// Limits the response to export jobs with the specified job status.
        public let jobStatus: JobStatus?
        /// Limits the number of results returned for a ListFHIRExportJobs to a maximum quantity specified by the user.
        public let maxResults: Int?
        /// A pagination token used to identify the next page of results to return.
        public let nextToken: String?
        /// Limits the response to FHIR export jobs submitted after a user-specified date.
        public let submittedAfter: Date?
        /// Limits the response to FHIR export jobs submitted before a user- specified date.
        public let submittedBefore: Date?

        @inlinable
        public init(datastoreId: String, jobName: String? = nil, jobStatus: JobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil, submittedAfter: Date? = nil, submittedBefore: Date? = nil) {
            self.datastoreId = datastoreId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.submittedAfter = submittedAfter
            self.submittedBefore = submittedBefore
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case submittedAfter = "SubmittedAfter"
            case submittedBefore = "SubmittedBefore"
        }
    }

    public struct ListFHIRExportJobsResponse: AWSDecodableShape {
        /// The properties of listed FHIR export jobs.
        public let exportJobPropertiesList: [ExportJobProperties]
        /// The pagination token used to identify the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(exportJobPropertiesList: [ExportJobProperties], nextToken: String? = nil) {
            self.exportJobPropertiesList = exportJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobPropertiesList = "ExportJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListFHIRImportJobsRequest: AWSEncodableShape {
        /// Limits the response to the import job with the specified data store ID.
        public let datastoreId: String
        /// Limits the response to the import job with the specified job name.
        public let jobName: String?
        /// Limits the response to the import job with the specified job status.
        public let jobStatus: JobStatus?
        /// Limits the number of results returned for ListFHIRImportJobs to a maximum quantity specified by the user.
        public let maxResults: Int?
        /// The pagination token used to identify the next page of results to return.
        public let nextToken: String?
        /// Limits the response to FHIR import jobs submitted after a user-specified date.
        public let submittedAfter: Date?
        /// Limits the response to FHIR import jobs submitted before a user- specified date.
        public let submittedBefore: Date?

        @inlinable
        public init(datastoreId: String, jobName: String? = nil, jobStatus: JobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil, submittedAfter: Date? = nil, submittedBefore: Date? = nil) {
            self.datastoreId = datastoreId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.submittedAfter = submittedAfter
            self.submittedBefore = submittedBefore
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobName = "JobName"
            case jobStatus = "JobStatus"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case submittedAfter = "SubmittedAfter"
            case submittedBefore = "SubmittedBefore"
        }
    }

    public struct ListFHIRImportJobsResponse: AWSDecodableShape {
        /// The properties for listed import jobs.
        public let importJobPropertiesList: [ImportJobProperties]
        /// The pagination token used to identify the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(importJobPropertiesList: [ImportJobProperties], nextToken: String? = nil) {
            self.importJobPropertiesList = importJobPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobPropertiesList = "ImportJobPropertiesList"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the data store to which tags are being added.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:healthlake:[a-z0-9-]+:\\d{12}:datastore\\/fhir\\/.{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Returns a list of tags associated with a data store.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct PreloadDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of preloaded data. Only Synthea preloaded data is supported.
        public let preloadDataType: PreloadDataType

        @inlinable
        public init(preloadDataType: PreloadDataType) {
            self.preloadDataType = preloadDataType
        }

        private enum CodingKeys: String, CodingKey {
            case preloadDataType = "PreloadDataType"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The Key Management Service (KMS) key ID used to access the S3 bucket.
        public let kmsKeyId: String
        /// The S3Uri is the user-specified S3 location of the FHIR data to be imported into AWS HealthLake.
        public let s3Uri: String

        @inlinable
        public init(kmsKeyId: String, s3Uri: String) {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 400)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^(arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:kms:)?([a-z]{2}-[a-z]+(-[a-z]+)?-\\d:)?(\\d{12}:)?(((key/)?[a-zA-Z0-9-_]+)|(alias/[a-zA-Z0-9:/_-]+))$")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3Uri = "S3Uri"
        }
    }

    public struct SseConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Key Management Service (KMS) encryption configuration used to provide details for data encryption.
        public let kmsEncryptionConfig: KmsEncryptionConfig

        @inlinable
        public init(kmsEncryptionConfig: KmsEncryptionConfig) {
            self.kmsEncryptionConfig = kmsEncryptionConfig
        }

        public func validate(name: String) throws {
            try self.kmsEncryptionConfig.validate(name: "\(name).kmsEncryptionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsEncryptionConfig = "KmsEncryptionConfig"
        }
    }

    public struct StartFHIRExportJobRequest: AWSEncodableShape {
        /// An optional user provided token used for ensuring API idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) used during initiation of the export job.
        public let dataAccessRoleArn: String
        /// The data store identifier from which files are being exported.
        public let datastoreId: String
        /// The export job name.
        public let jobName: String?
        /// The output data configuration supplied when the export job was started.
        public let outputDataConfig: OutputDataConfig

        @inlinable
        public init(clientToken: String? = StartFHIRExportJobRequest.idempotencyToken(), dataAccessRoleArn: String, datastoreId: String, jobName: String? = nil, outputDataConfig: OutputDataConfig) {
            self.clientToken = clientToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.jobName = jobName
            self.outputDataConfig = outputDataConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case datastoreId = "DatastoreId"
            case jobName = "JobName"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct StartFHIRExportJobResponse: AWSDecodableShape {
        /// The data store identifier from which files are being exported.
        public let datastoreId: String?
        /// The export job identifier.
        public let jobId: String
        /// The export job status.
        public let jobStatus: JobStatus

        @inlinable
        public init(datastoreId: String? = nil, jobId: String, jobStatus: JobStatus) {
            self.datastoreId = datastoreId
            self.jobId = jobId
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobId = "JobId"
            case jobStatus = "JobStatus"
        }
    }

    public struct StartFHIRImportJobRequest: AWSEncodableShape {
        /// The optional user-provided token used for ensuring API idempotency.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) that grants access permission to AWS HealthLake.
        public let dataAccessRoleArn: String
        /// The data store identifier.
        public let datastoreId: String
        /// The input properties for the import job request.
        public let inputDataConfig: InputDataConfig
        /// The import job name.
        public let jobName: String?
        public let jobOutputDataConfig: OutputDataConfig
        /// The validation level of the import job.
        public let validationLevel: ValidationLevel?

        @inlinable
        public init(clientToken: String? = StartFHIRImportJobRequest.idempotencyToken(), dataAccessRoleArn: String, datastoreId: String, inputDataConfig: InputDataConfig, jobName: String? = nil, jobOutputDataConfig: OutputDataConfig, validationLevel: ValidationLevel? = nil) {
            self.clientToken = clientToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
            self.validationLevel = validationLevel
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, max: 32)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, min: 1)
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-%@]*)$")
            try self.jobOutputDataConfig.validate(name: "\(name).jobOutputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case datastoreId = "DatastoreId"
            case inputDataConfig = "InputDataConfig"
            case jobName = "JobName"
            case jobOutputDataConfig = "JobOutputDataConfig"
            case validationLevel = "ValidationLevel"
        }
    }

    public struct StartFHIRImportJobResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String?
        /// The import job identifier.
        public let jobId: String
        /// The import job status.
        public let jobStatus: JobStatus

        @inlinable
        public init(datastoreId: String? = nil, jobId: String, jobStatus: JobStatus) {
            self.datastoreId = datastoreId
            self.jobId = jobId
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "DatastoreId"
            case jobId = "JobId"
            case jobStatus = "JobStatus"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key portion of a tag. Tag keys are case sensitive.
        public let key: String
        ///  The value portion of a tag. Tag values are case-sensitive.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that grants access to the data store tags are being added to.
        public let resourceARN: String
        /// The user-specified key and value pair tags being added to a data store.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:healthlake:[a-z0-9-]+:\\d{12}:datastore\\/fhir\\/.{32}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the data store from which tags are being removed.
        public let resourceARN: String
        /// The keys for the tags to be removed from the data store.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:healthlake:[a-z0-9-]+:\\d{12}:datastore\\/fhir\\/.{32}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct InputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3Uri is the user-specified S3 location of the FHIR data to be imported into AWS HealthLake.
        public let s3Uri: String?

        @inlinable
        public init(s3Uri: String? = nil) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "S3Uri"
        }
    }

    public struct OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The output data configuration supplied when the export job was created.
        public let s3Configuration: S3Configuration?

        @inlinable
        public init(s3Configuration: S3Configuration? = nil) {
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "S3Configuration"
        }
    }
}

// MARK: - Errors

/// Error enum for HealthLake
public struct HealthLakeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize HealthLake
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access is denied. Your account is not authorized to perform this operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The data store is in a transition state and the user requested action cannot be performed.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unknown internal error occurred in the service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested data store was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The user has exceeded their maximum number of allowed calls to the given API.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The user input parameter was invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension HealthLakeErrorType: Equatable {
    public static func == (lhs: HealthLakeErrorType, rhs: HealthLakeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension HealthLakeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
