//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension LicenseManagerLinuxSubscriptions {
    // MARK: Enums

    public enum LinuxSubscriptionsDiscovery: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Disabled LinuxSubscriptionsDiscovery
        case disabled = "Disabled"
        /// Enabled LinuxSubscriptionsDiscovery
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Contains operator
        case contains = "Contains"
        /// Equal operator
        case equal = "Equal"
        /// Not equal operator
        case notEqual = "NotEqual"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationIntegration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Disabled OrganizationIntegration
        case disabled = "Disabled"
        /// Enabled OrganizationIntegration
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Completed status
        case completed = "Completed"
        /// Failed status
        case failed = "Failed"
        /// InProgress status
        case inProgress = "InProgress"
        /// Successful status
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionProviderSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// RedHat subscription provider namespace
        case redHat = "RedHat"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionProviderStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// ACTIVE status
        case active = "ACTIVE"
        /// INVALID status
        case invalid = "INVALID"
        /// PENDING status
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct DeregisterSubscriptionProviderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the subscription provider resource to deregister.
        public let subscriptionProviderArn: String

        public init(subscriptionProviderArn: String) {
            self.subscriptionProviderArn = subscriptionProviderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.subscriptionProviderArn, name: "subscriptionProviderArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,510}/[a-z0-9-\\.]{1,510}$")
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionProviderArn = "SubscriptionProviderArn"
        }
    }

    public struct DeregisterSubscriptionProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Filter: AWSEncodableShape {
        /// The type of name to filter by.
        public let name: String?
        /// An operator for filtering results.
        public let `operator`: Operator?
        /// One or more values for the name to filter by.
        public let values: [String]?

        public init(name: String? = nil, operator: Operator? = nil, values: [String]? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 100)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct GetRegisteredSubscriptionProviderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the BYOL registration resource to get details for.
        public let subscriptionProviderArn: String

        public init(subscriptionProviderArn: String) {
            self.subscriptionProviderArn = subscriptionProviderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.subscriptionProviderArn, name: "subscriptionProviderArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,510}/[a-z0-9-\\.]{1,510}$")
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionProviderArn = "SubscriptionProviderArn"
        }
    }

    public struct GetRegisteredSubscriptionProviderResponse: AWSDecodableShape {
        /// The timestamp from the last time License Manager retrieved subscription details
        /// 			from your registered third-party Linux subscription provider.
        public let lastSuccessfulDataRetrievalTime: String?
        /// The Amazon Resource Name (ARN) of the third-party access secret stored in Secrets Manager for the BYOL
        /// 			registration resource specified in the request.
        public let secretArn: String?
        /// The Amazon Resource Name (ARN) for the BYOL registration resource specified in the request.
        public let subscriptionProviderArn: String?
        /// The subscription provider for the BYOL registration resource specified
        /// 			in the request.
        public let subscriptionProviderSource: SubscriptionProviderSource?
        /// The status of the Linux subscription provider access token from the last
        /// 			successful subscription data request.
        public let subscriptionProviderStatus: SubscriptionProviderStatus?
        /// The detailed message from your subscription provider token status.
        public let subscriptionProviderStatusMessage: String?

        public init(lastSuccessfulDataRetrievalTime: String? = nil, secretArn: String? = nil, subscriptionProviderArn: String? = nil, subscriptionProviderSource: SubscriptionProviderSource? = nil, subscriptionProviderStatus: SubscriptionProviderStatus? = nil, subscriptionProviderStatusMessage: String? = nil) {
            self.lastSuccessfulDataRetrievalTime = lastSuccessfulDataRetrievalTime
            self.secretArn = secretArn
            self.subscriptionProviderArn = subscriptionProviderArn
            self.subscriptionProviderSource = subscriptionProviderSource
            self.subscriptionProviderStatus = subscriptionProviderStatus
            self.subscriptionProviderStatusMessage = subscriptionProviderStatusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case lastSuccessfulDataRetrievalTime = "LastSuccessfulDataRetrievalTime"
            case secretArn = "SecretArn"
            case subscriptionProviderArn = "SubscriptionProviderArn"
            case subscriptionProviderSource = "SubscriptionProviderSource"
            case subscriptionProviderStatus = "SubscriptionProviderStatus"
            case subscriptionProviderStatusMessage = "SubscriptionProviderStatusMessage"
        }
    }

    public struct GetServiceSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetServiceSettingsResponse: AWSDecodableShape {
        /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
        public let homeRegions: [String]?
        /// Lists if discovery has been enabled for Linux subscriptions.
        public let linuxSubscriptionsDiscovery: LinuxSubscriptionsDiscovery?
        /// Lists the settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
        public let linuxSubscriptionsDiscoverySettings: LinuxSubscriptionsDiscoverySettings?
        /// Indicates the status of Linux subscriptions settings being applied.
        public let status: Status?
        /// A message which details the Linux subscriptions service settings current status.
        public let statusMessage: [String: String]?

        public init(homeRegions: [String]? = nil, linuxSubscriptionsDiscovery: LinuxSubscriptionsDiscovery? = nil, linuxSubscriptionsDiscoverySettings: LinuxSubscriptionsDiscoverySettings? = nil, status: Status? = nil, statusMessage: [String: String]? = nil) {
            self.homeRegions = homeRegions
            self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
            self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case homeRegions = "HomeRegions"
            case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
            case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct Instance: AWSDecodableShape {
        /// The account ID which owns the instance.
        public let accountID: String?
        /// The AMI ID used to launch the instance.
        public let amiId: String?
        /// Indicates that you have two different license subscriptions for
        /// 			the same software on your instance.
        public let dualSubscription: String?
        /// The instance ID of the resource.
        public let instanceID: String?
        /// The instance type of the resource.
        public let instanceType: String?
        /// The time in which the last discovery updated the instance details.
        public let lastUpdatedTime: String?
        /// The operating system software version that runs on your instance.
        public let osVersion: String?
        /// The product code for the instance. For more information, see Usage operation values in the License Manager User Guide .
        public let productCode: [String]?
        /// The Region the instance is running in.
        public let region: String?
        /// Indicates that your instance uses a BYOL license subscription from
        /// 			a third-party Linux subscription provider that you've registered with License Manager.
        public let registeredWithSubscriptionProvider: String?
        /// The status of the instance.
        public let status: String?
        /// The name of the license subscription that the instance uses.
        public let subscriptionName: String?
        /// The timestamp when you registered the third-party Linux subscription
        /// 			provider for the subscription that the instance uses.
        public let subscriptionProviderCreateTime: String?
        /// The timestamp from the last time that the instance synced with the registered
        /// 			third-party Linux subscription provider.
        public let subscriptionProviderUpdateTime: String?
        /// The usage operation of the instance. For more information, see For more information, see Usage operation values in the License Manager User Guide.
        public let usageOperation: String?

        public init(accountID: String? = nil, amiId: String? = nil, dualSubscription: String? = nil, instanceID: String? = nil, instanceType: String? = nil, lastUpdatedTime: String? = nil, osVersion: String? = nil, productCode: [String]? = nil, region: String? = nil, registeredWithSubscriptionProvider: String? = nil, status: String? = nil, subscriptionName: String? = nil, subscriptionProviderCreateTime: String? = nil, subscriptionProviderUpdateTime: String? = nil, usageOperation: String? = nil) {
            self.accountID = accountID
            self.amiId = amiId
            self.dualSubscription = dualSubscription
            self.instanceID = instanceID
            self.instanceType = instanceType
            self.lastUpdatedTime = lastUpdatedTime
            self.osVersion = osVersion
            self.productCode = productCode
            self.region = region
            self.registeredWithSubscriptionProvider = registeredWithSubscriptionProvider
            self.status = status
            self.subscriptionName = subscriptionName
            self.subscriptionProviderCreateTime = subscriptionProviderCreateTime
            self.subscriptionProviderUpdateTime = subscriptionProviderUpdateTime
            self.usageOperation = usageOperation
        }

        private enum CodingKeys: String, CodingKey {
            case accountID = "AccountID"
            case amiId = "AmiId"
            case dualSubscription = "DualSubscription"
            case instanceID = "InstanceID"
            case instanceType = "InstanceType"
            case lastUpdatedTime = "LastUpdatedTime"
            case osVersion = "OsVersion"
            case productCode = "ProductCode"
            case region = "Region"
            case registeredWithSubscriptionProvider = "RegisteredWithSubscriptionProvider"
            case status = "Status"
            case subscriptionName = "SubscriptionName"
            case subscriptionProviderCreateTime = "SubscriptionProviderCreateTime"
            case subscriptionProviderUpdateTime = "SubscriptionProviderUpdateTime"
            case usageOperation = "UsageOperation"
        }
    }

    public struct LinuxSubscriptionsDiscoverySettings: AWSEncodableShape & AWSDecodableShape {
        /// Details if you have enabled resource discovery across your accounts in Organizations.
        public let organizationIntegration: OrganizationIntegration
        /// The Regions in which to discover data for Linux subscriptions.
        public let sourceRegions: [String]

        public init(organizationIntegration: OrganizationIntegration, sourceRegions: [String]) {
            self.organizationIntegration = organizationIntegration
            self.sourceRegions = sourceRegions
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceRegions, name: "sourceRegions", parent: name, max: 100)
            try self.validate(self.sourceRegions, name: "sourceRegions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case organizationIntegration = "OrganizationIntegration"
            case sourceRegions = "SourceRegions"
        }
    }

    public struct ListLinuxSubscriptionInstancesRequest: AWSEncodableShape {
        /// An array of structures that you can use to filter the results by your specified criteria.  	For example, you can specify Region in the Name, with the  	contains operator to list all subscriptions that match a partial string in the  	Value, such as us-west. For each filter, you can specify one of the following values for the Name key  	to streamline results:    AccountID     AmiID     DualSubscription     InstanceID     InstanceType     ProductCode     Region     Status     UsageOperation    For each filter, you can use one of the following Operator values to  		define the behavior of the filter:    contains     equals     Notequal
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This
        /// 	is the nextToken from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListLinuxSubscriptionInstancesResponse: AWSDecodableShape {
        /// An array that contains instance objects.
        public let instances: [Instance]?
        /// The next token used for paginated responses. When this
        /// 	field isn't empty, there are additional elements that the service hasn't
        /// 	included in this request. Use this token with the next request to retrieve
        /// 	additional objects.
        public let nextToken: String?

        public init(instances: [Instance]? = nil, nextToken: String? = nil) {
            self.instances = instances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instances = "Instances"
            case nextToken = "NextToken"
        }
    }

    public struct ListLinuxSubscriptionsRequest: AWSEncodableShape {
        /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify. For example, you can filter by the name of Subscription with an optional operator to see subscriptions that match, partially match, or don't match a certain subscription's name. The valid names for this filter are:    Subscription    The valid Operators for this filter are:    contains     equals     Notequal
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This
        /// 	is the nextToken from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListLinuxSubscriptionsResponse: AWSDecodableShape {
        /// The next token used for paginated responses. When this
        /// 	field isn't empty, there are additional elements that the service hasn't
        /// 	included in this request. Use this token with the next request to retrieve
        /// 	additional objects.
        public let nextToken: String?
        /// An array that contains subscription objects.
        public let subscriptions: [Subscription]?

        public init(nextToken: String? = nil, subscriptions: [Subscription]? = nil) {
            self.nextToken = nextToken
            self.subscriptions = subscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case subscriptions = "Subscriptions"
        }
    }

    public struct ListRegisteredSubscriptionProvidersRequest: AWSEncodableShape {
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This
        /// 	is the nextToken from a previously truncated response.
        public let nextToken: String?
        /// To filter your results, specify which subscription providers to return
        /// 			in the list.
        public let subscriptionProviderSources: [SubscriptionProviderSource]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, subscriptionProviderSources: [SubscriptionProviderSource]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.subscriptionProviderSources = subscriptionProviderSources
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case subscriptionProviderSources = "SubscriptionProviderSources"
        }
    }

    public struct ListRegisteredSubscriptionProvidersResponse: AWSDecodableShape {
        /// The next token used for paginated responses. When this
        /// 	field isn't empty, there are additional elements that the service hasn't
        /// 	included in this request. Use this token with the next request to retrieve
        /// 	additional objects.
        public let nextToken: String?
        /// The list of BYOL registration resources that fit the criteria
        /// 			you specified in the request.
        public let registeredSubscriptionProviders: [RegisteredSubscriptionProvider]?

        public init(nextToken: String? = nil, registeredSubscriptionProviders: [RegisteredSubscriptionProvider]? = nil) {
            self.nextToken = nextToken
            self.registeredSubscriptionProviders = registeredSubscriptionProviders
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registeredSubscriptionProviders = "RegisteredSubscriptionProviders"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to list metadata tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,510}/[a-z0-9-\\.]{1,510}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The metadata tags for the requested resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct RegisterSubscriptionProviderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the secret where you've stored your subscription provider's access token. For
        /// 			RHEL subscriptions managed through the Red Hat Subscription Manager (RHSM), the secret contains
        /// 			your Red Hat Offline token.
        public let secretArn: String
        /// The supported Linux subscription provider to register.
        public let subscriptionProviderSource: SubscriptionProviderSource
        /// The metadata tags to assign to your registered Linux subscription provider
        /// 			resource.
        public let tags: [String: String]?

        public init(secretArn: String, subscriptionProviderSource: SubscriptionProviderSource, tags: [String: String]? = nil) {
            self.secretArn = secretArn
            self.subscriptionProviderSource = subscriptionProviderSource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:secretsmanager:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:secret:[^/]{1,1023}$")
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "SecretArn"
            case subscriptionProviderSource = "SubscriptionProviderSource"
            case tags = "Tags"
        }
    }

    public struct RegisterSubscriptionProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Linux subscription provider resource that you registered.
        public let subscriptionProviderArn: String?
        /// The Linux subscription provider that you registered.
        public let subscriptionProviderSource: SubscriptionProviderSource?
        /// Indicates the status of the registration action for the Linux subscription provider
        /// 			that you requested.
        public let subscriptionProviderStatus: SubscriptionProviderStatus?

        public init(subscriptionProviderArn: String? = nil, subscriptionProviderSource: SubscriptionProviderSource? = nil, subscriptionProviderStatus: SubscriptionProviderStatus? = nil) {
            self.subscriptionProviderArn = subscriptionProviderArn
            self.subscriptionProviderSource = subscriptionProviderSource
            self.subscriptionProviderStatus = subscriptionProviderStatus
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionProviderArn = "SubscriptionProviderArn"
            case subscriptionProviderSource = "SubscriptionProviderSource"
            case subscriptionProviderStatus = "SubscriptionProviderStatus"
        }
    }

    public struct RegisteredSubscriptionProvider: AWSDecodableShape {
        /// The timestamp from the last time that License Manager accessed third-party subscription data
        /// 			for your account from your registered Linux subscription provider.
        public let lastSuccessfulDataRetrievalTime: String?
        /// The Amazon Resource Name (ARN) of the Secrets Manager secret that stores your registered Linux subscription provider
        /// 			access token. For RHEL account subscriptions, this is the offline token.
        public let secretArn: String?
        /// The Amazon Resource Name (ARN) of the Linux subscription provider resource that you registered.
        public let subscriptionProviderArn: String?
        /// A supported third-party Linux subscription provider. License Manager currently supports
        /// 			Red Hat subscriptions.
        public let subscriptionProviderSource: SubscriptionProviderSource?
        /// Indicates the status of your registered Linux subscription provider access token
        /// 			from the last time License Manager retrieved subscription data. For RHEL account subscriptions,
        /// 			this is the status of the offline token.
        public let subscriptionProviderStatus: SubscriptionProviderStatus?
        /// A detailed message that's associated with your BYOL subscription
        /// 			provider token status.
        public let subscriptionProviderStatusMessage: String?

        public init(lastSuccessfulDataRetrievalTime: String? = nil, secretArn: String? = nil, subscriptionProviderArn: String? = nil, subscriptionProviderSource: SubscriptionProviderSource? = nil, subscriptionProviderStatus: SubscriptionProviderStatus? = nil, subscriptionProviderStatusMessage: String? = nil) {
            self.lastSuccessfulDataRetrievalTime = lastSuccessfulDataRetrievalTime
            self.secretArn = secretArn
            self.subscriptionProviderArn = subscriptionProviderArn
            self.subscriptionProviderSource = subscriptionProviderSource
            self.subscriptionProviderStatus = subscriptionProviderStatus
            self.subscriptionProviderStatusMessage = subscriptionProviderStatusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case lastSuccessfulDataRetrievalTime = "LastSuccessfulDataRetrievalTime"
            case secretArn = "SecretArn"
            case subscriptionProviderArn = "SubscriptionProviderArn"
            case subscriptionProviderSource = "SubscriptionProviderSource"
            case subscriptionProviderStatus = "SubscriptionProviderStatus"
            case subscriptionProviderStatusMessage = "SubscriptionProviderStatusMessage"
        }
    }

    public struct Subscription: AWSDecodableShape {
        /// The total amount of running instances using this subscription.
        public let instanceCount: Int64?
        /// The name of the subscription.
        public let name: String?
        /// The type of subscription. The type can be subscription-included with Amazon EC2, Bring Your Own Subscription model (BYOS), or from the Amazon Web Services Marketplace. Certain subscriptions may use licensing from the Amazon Web Services Marketplace as well as OS licensing from Amazon EC2 or BYOS.
        public let type: String?

        public init(instanceCount: Int64? = nil, name: String? = nil, type: String? = nil) {
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services resource to which to add the specified
        /// 			metadata tags.
        public let resourceArn: String
        /// The metadata tags to assign to the Amazon Web Services resource. Tags are
        /// 			formatted as key value pairs.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,510}/[a-z0-9-\\.]{1,510}$")
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services resource to remove the metadata tags from.
        public let resourceArn: String
        /// A list of metadata tag keys to remove from the requested
        /// 			resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{1,510}/[a-z0-9-\\.]{1,510}$")
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateServiceSettingsRequest: AWSEncodableShape {
        /// Describes if updates are allowed to the service settings for Linux subscriptions. If you allow updates, you can aggregate Linux subscription data in more than one home Region.
        public let allowUpdate: Bool?
        /// Describes if the discovery of Linux subscriptions is enabled.
        public let linuxSubscriptionsDiscovery: LinuxSubscriptionsDiscovery
        /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
        public let linuxSubscriptionsDiscoverySettings: LinuxSubscriptionsDiscoverySettings

        public init(allowUpdate: Bool? = nil, linuxSubscriptionsDiscovery: LinuxSubscriptionsDiscovery, linuxSubscriptionsDiscoverySettings: LinuxSubscriptionsDiscoverySettings) {
            self.allowUpdate = allowUpdate
            self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
            self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        }

        public func validate(name: String) throws {
            try self.linuxSubscriptionsDiscoverySettings.validate(name: "\(name).linuxSubscriptionsDiscoverySettings")
        }

        private enum CodingKeys: String, CodingKey {
            case allowUpdate = "AllowUpdate"
            case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
            case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
        }
    }

    public struct UpdateServiceSettingsResponse: AWSDecodableShape {
        /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
        public let homeRegions: [String]?
        /// Lists if discovery has been enabled for Linux subscriptions.
        public let linuxSubscriptionsDiscovery: LinuxSubscriptionsDiscovery?
        /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
        public let linuxSubscriptionsDiscoverySettings: LinuxSubscriptionsDiscoverySettings?
        /// Indicates the status of Linux subscriptions settings being applied.
        public let status: Status?
        /// A message which details the Linux subscriptions service settings current status.
        public let statusMessage: [String: String]?

        public init(homeRegions: [String]? = nil, linuxSubscriptionsDiscovery: LinuxSubscriptionsDiscovery? = nil, linuxSubscriptionsDiscoverySettings: LinuxSubscriptionsDiscoverySettings? = nil, status: Status? = nil, statusMessage: [String: String]? = nil) {
            self.homeRegions = homeRegions
            self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
            self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case homeRegions = "HomeRegions"
            case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
            case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }
}

// MARK: - Errors

/// Error enum for LicenseManagerLinuxSubscriptions
public struct LicenseManagerLinuxSubscriptionsErrorType: AWSErrorType {
    enum Code: String {
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize LicenseManagerLinuxSubscriptions
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An exception occurred with the service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Unable to find the requested Amazon Web Services resource.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The provided input is not valid. Try your request again.
    public static var validationException: Self { .init(.validationException) }
}

extension LicenseManagerLinuxSubscriptionsErrorType: Equatable {
    public static func == (lhs: LicenseManagerLinuxSubscriptionsErrorType, rhs: LicenseManagerLinuxSubscriptionsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LicenseManagerLinuxSubscriptionsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
