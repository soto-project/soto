//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension KinesisAnalyticsV2 {
    // MARK: Enums

    public enum ApplicationMode: String, CustomStringConvertible, Codable {
        case interactive = "INTERACTIVE"
        case streaming = "STREAMING"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationRestoreType: String, CustomStringConvertible, Codable {
        case restoreFromCustomSnapshot = "RESTORE_FROM_CUSTOM_SNAPSHOT"
        case restoreFromLatestSnapshot = "RESTORE_FROM_LATEST_SNAPSHOT"
        case skipRestoreFromSnapshot = "SKIP_RESTORE_FROM_SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationStatus: String, CustomStringConvertible, Codable {
        case autoscaling = "AUTOSCALING"
        case deleting = "DELETING"
        case forceStopping = "FORCE_STOPPING"
        case maintenance = "MAINTENANCE"
        case ready = "READY"
        case rolledBack = "ROLLED_BACK"
        case rollingBack = "ROLLING_BACK"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopping = "STOPPING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactType: String, CustomStringConvertible, Codable {
        case dependencyJar = "DEPENDENCY_JAR"
        case udf = "UDF"
        public var description: String { return self.rawValue }
    }

    public enum CodeContentType: String, CustomStringConvertible, Codable {
        case plaintext = "PLAINTEXT"
        case zipfile = "ZIPFILE"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationType: String, CustomStringConvertible, Codable {
        case custom = "CUSTOM"
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum InputStartingPosition: String, CustomStringConvertible, Codable {
        case lastStoppedPoint = "LAST_STOPPED_POINT"
        case now = "NOW"
        case trimHorizon = "TRIM_HORIZON"
        public var description: String { return self.rawValue }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable {
        case debug = "DEBUG"
        case error = "ERROR"
        case info = "INFO"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum MetricsLevel: String, CustomStringConvertible, Codable {
        case application = "APPLICATION"
        case `operator` = "OPERATOR"
        case parallelism = "PARALLELISM"
        case task = "TASK"
        public var description: String { return self.rawValue }
    }

    public enum RecordFormatType: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum RuntimeEnvironment: String, CustomStringConvertible, Codable {
        case flink111 = "FLINK-1_11"
        case flink16 = "FLINK-1_6"
        case flink18 = "FLINK-1_8"
        case sql10 = "SQL-1_0"
        case zeppelinFlink10 = "ZEPPELIN-FLINK-1_0"
        public var description: String { return self.rawValue }
    }

    public enum SnapshotStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum UrlType: String, CustomStringConvertible, Codable {
        case flinkDashboardUrl = "FLINK_DASHBOARD_URL"
        case zeppelinUiUrl = "ZEPPELIN_UI_URL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddApplicationCloudWatchLoggingOptionRequest: AWSEncodableShape {
        /// The Kinesis Data Analytics application name.
        public let applicationName: String
        /// Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN).
        public let cloudWatchLoggingOption: CloudWatchLoggingOption
        /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The version ID of the Kinesis Data Analytics application. You must provide the CurrentApplicationVersionId or the ConditionalToken.You can retrieve the application version ID using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?

        public init(applicationName: String, cloudWatchLoggingOption: CloudWatchLoggingOption, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil) {
            self.applicationName = applicationName
            self.cloudWatchLoggingOption = cloudWatchLoggingOption
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.cloudWatchLoggingOption.validate(name: "\(name).cloudWatchLoggingOption")
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "[a-zA-Z0-9-_+/=]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case cloudWatchLoggingOption = "CloudWatchLoggingOption"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
        }
    }

    public struct AddApplicationCloudWatchLoggingOptionResponse: AWSDecodableShape {
        /// The application's ARN.
        public let applicationARN: String?
        /// The new version ID of the Kinesis Data Analytics application. Kinesis Data Analytics updates the ApplicationVersionId each time you change the CloudWatch logging options.
        public let applicationVersionId: Int64?
        /// The descriptions of the current CloudWatch logging options for the Kinesis Data Analytics application.
        public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
        }
    }

    public struct AddApplicationInputProcessingConfigurationRequest: AWSEncodableShape {
        /// The name of the application to which you want to add the input processing configuration.
        public let applicationName: String
        /// The version of the application to which you want to add the input processing configuration. You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The ID of the input configuration to add the input processing configuration to. You can get a list of the input IDs for an application using the DescribeApplication operation.
        public let inputId: String
        /// The InputProcessingConfiguration to add to the application.
        public let inputProcessingConfiguration: InputProcessingConfiguration

        public init(applicationName: String, currentApplicationVersionId: Int64, inputId: String, inputProcessingConfiguration: InputProcessingConfiguration) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.inputId = inputId
            self.inputProcessingConfiguration = inputProcessingConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, max: 50)
            try self.validate(self.inputId, name: "inputId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.inputProcessingConfiguration.validate(name: "\(name).inputProcessingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case inputId = "InputId"
            case inputProcessingConfiguration = "InputProcessingConfiguration"
        }
    }

    public struct AddApplicationInputProcessingConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationARN: String?
        /// Provides the current application version.
        public let applicationVersionId: Int64?
        /// The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns  to each input configuration that you add to your application.
        public let inputId: String?
        /// The description of the preprocessor that executes on records in this input before the application's code is run.
        public let inputProcessingConfigurationDescription: InputProcessingConfigurationDescription?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, inputId: String? = nil, inputProcessingConfigurationDescription: InputProcessingConfigurationDescription? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.inputId = inputId
            self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case inputId = "InputId"
            case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
        }
    }

    public struct AddApplicationInputRequest: AWSEncodableShape {
        /// The name of your existing application to which you want to add the streaming source.
        public let applicationName: String
        /// The current version of your application.  You must provide the ApplicationVersionID or the ConditionalToken.You can use the DescribeApplication operation to find the current application version.
        public let currentApplicationVersionId: Int64
        /// The Input to add.
        public let input: Input

        public init(applicationName: String, currentApplicationVersionId: Int64, input: Input) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.input = input
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.input.validate(name: "\(name).input")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case input = "Input"
        }
    }

    public struct AddApplicationInputResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationARN: String?
        /// Provides the current application version.
        public let applicationVersionId: Int64?
        /// Describes the application input configuration.
        public let inputDescriptions: [InputDescription]?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, inputDescriptions: [InputDescription]? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.inputDescriptions = inputDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case inputDescriptions = "InputDescriptions"
        }
    }

    public struct AddApplicationOutputRequest: AWSEncodableShape {
        /// The name of the application to which you want to add the output configuration.
        public let applicationName: String
        /// The version of the application to which you want to add the output configuration. You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// An array of objects, each describing one output configuration. In the output configuration, you specify the name of an in-application stream, a destination (that is, a Kinesis data stream, a Kinesis Data Firehose delivery stream, or an AWS Lambda function), and record the formation to use when writing to the destination.
        public let output: Output

        public init(applicationName: String, currentApplicationVersionId: Int64, output: Output) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.output = output
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.output.validate(name: "\(name).output")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case output = "Output"
        }
    }

    public struct AddApplicationOutputResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The updated application version ID. Kinesis Data Analytics increments this ID when the application is updated.
        public let applicationVersionId: Int64?
        /// Describes the application output configuration. For more information,  see Configuring Application Output.
        public let outputDescriptions: [OutputDescription]?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, outputDescriptions: [OutputDescription]? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.outputDescriptions = outputDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case outputDescriptions = "OutputDescriptions"
        }
    }

    public struct AddApplicationReferenceDataSourceRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The version of the application for which you are adding the reference data source.  You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data  into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting  in-application table that is  created.
        public let referenceDataSource: ReferenceDataSource

        public init(applicationName: String, currentApplicationVersionId: Int64, referenceDataSource: ReferenceDataSource) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.referenceDataSource = referenceDataSource
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.referenceDataSource.validate(name: "\(name).referenceDataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case referenceDataSource = "ReferenceDataSource"
        }
    }

    public struct AddApplicationReferenceDataSourceResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The updated application version ID. Kinesis Data Analytics increments this ID when the application is updated.
        public let applicationVersionId: Int64?
        /// Describes reference data sources configured for the application.
        public let referenceDataSourceDescriptions: [ReferenceDataSourceDescription]?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, referenceDataSourceDescriptions: [ReferenceDataSourceDescription]? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
        }
    }

    public struct AddApplicationVpcConfigurationRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// A value you use to implement strong concurrency for application updates. You must provide the ApplicationVersionID or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The version of the application to which you want to add the VPC configuration. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?
        /// Description of the VPC to add to the application.
        public let vpcConfiguration: VpcConfiguration

        public init(applicationName: String, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil, vpcConfiguration: VpcConfiguration) {
            self.applicationName = applicationName
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "[a-zA-Z0-9-_+/=]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.vpcConfiguration.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct AddApplicationVpcConfigurationResponse: AWSDecodableShape {
        /// The ARN of the application.
        public let applicationARN: String?
        /// Provides the current application version. Kinesis Data Analytics updates the ApplicationVersionId each time you update the application.
        public let applicationVersionId: Int64?
        /// The parameters of the new VPC configuration.
        public let vpcConfigurationDescription: VpcConfigurationDescription?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, vpcConfigurationDescription: VpcConfigurationDescription? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.vpcConfigurationDescription = vpcConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case vpcConfigurationDescription = "VpcConfigurationDescription"
        }
    }

    public struct ApplicationCodeConfiguration: AWSEncodableShape {
        /// The location and type of the application code.
        public let codeContent: CodeContent?
        /// Specifies whether the code content is in text or zip format.
        public let codeContentType: CodeContentType

        public init(codeContent: CodeContent? = nil, codeContentType: CodeContentType) {
            self.codeContent = codeContent
            self.codeContentType = codeContentType
        }

        public func validate(name: String) throws {
            try self.codeContent?.validate(name: "\(name).codeContent")
        }

        private enum CodingKeys: String, CodingKey {
            case codeContent = "CodeContent"
            case codeContentType = "CodeContentType"
        }
    }

    public struct ApplicationCodeConfigurationDescription: AWSDecodableShape {
        /// Describes details about the location and format of the application code.
        public let codeContentDescription: CodeContentDescription?
        /// Specifies whether the code content is in text or zip format.
        public let codeContentType: CodeContentType

        public init(codeContentDescription: CodeContentDescription? = nil, codeContentType: CodeContentType) {
            self.codeContentDescription = codeContentDescription
            self.codeContentType = codeContentType
        }

        private enum CodingKeys: String, CodingKey {
            case codeContentDescription = "CodeContentDescription"
            case codeContentType = "CodeContentType"
        }
    }

    public struct ApplicationCodeConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to the code content type.
        public let codeContentTypeUpdate: CodeContentType?
        /// Describes updates to the code content of an application.
        public let codeContentUpdate: CodeContentUpdate?

        public init(codeContentTypeUpdate: CodeContentType? = nil, codeContentUpdate: CodeContentUpdate? = nil) {
            self.codeContentTypeUpdate = codeContentTypeUpdate
            self.codeContentUpdate = codeContentUpdate
        }

        public func validate(name: String) throws {
            try self.codeContentUpdate?.validate(name: "\(name).codeContentUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case codeContentTypeUpdate = "CodeContentTypeUpdate"
            case codeContentUpdate = "CodeContentUpdate"
        }
    }

    public struct ApplicationConfiguration: AWSEncodableShape {
        /// The code location and type parameters for a Flink-based Kinesis Data Analytics application.
        public let applicationCodeConfiguration: ApplicationCodeConfiguration?
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        public let applicationSnapshotConfiguration: ApplicationSnapshotConfiguration?
        /// Describes execution properties for a Flink-based Kinesis Data Analytics application.
        public let environmentProperties: EnvironmentProperties?
        /// The creation and update parameters for a Flink-based Kinesis Data Analytics application.
        public let flinkApplicationConfiguration: FlinkApplicationConfiguration?
        /// The creation and update parameters for a SQL-based Kinesis Data Analytics application.
        public let sqlApplicationConfiguration: SqlApplicationConfiguration?
        /// The array of descriptions of VPC configurations available to the application.
        public let vpcConfigurations: [VpcConfiguration]?
        /// The configuration parameters for a Kinesis Data Analytics Studio notebook.
        public let zeppelinApplicationConfiguration: ZeppelinApplicationConfiguration?

        public init(applicationCodeConfiguration: ApplicationCodeConfiguration? = nil, applicationSnapshotConfiguration: ApplicationSnapshotConfiguration? = nil, environmentProperties: EnvironmentProperties? = nil, flinkApplicationConfiguration: FlinkApplicationConfiguration? = nil, sqlApplicationConfiguration: SqlApplicationConfiguration? = nil, vpcConfigurations: [VpcConfiguration]? = nil, zeppelinApplicationConfiguration: ZeppelinApplicationConfiguration? = nil) {
            self.applicationCodeConfiguration = applicationCodeConfiguration
            self.applicationSnapshotConfiguration = applicationSnapshotConfiguration
            self.environmentProperties = environmentProperties
            self.flinkApplicationConfiguration = flinkApplicationConfiguration
            self.sqlApplicationConfiguration = sqlApplicationConfiguration
            self.vpcConfigurations = vpcConfigurations
            self.zeppelinApplicationConfiguration = zeppelinApplicationConfiguration
        }

        public func validate(name: String) throws {
            try self.applicationCodeConfiguration?.validate(name: "\(name).applicationCodeConfiguration")
            try self.environmentProperties?.validate(name: "\(name).environmentProperties")
            try self.flinkApplicationConfiguration?.validate(name: "\(name).flinkApplicationConfiguration")
            try self.sqlApplicationConfiguration?.validate(name: "\(name).sqlApplicationConfiguration")
            try self.vpcConfigurations?.forEach {
                try $0.validate(name: "\(name).vpcConfigurations[]")
            }
            try self.zeppelinApplicationConfiguration?.validate(name: "\(name).zeppelinApplicationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCodeConfiguration = "ApplicationCodeConfiguration"
            case applicationSnapshotConfiguration = "ApplicationSnapshotConfiguration"
            case environmentProperties = "EnvironmentProperties"
            case flinkApplicationConfiguration = "FlinkApplicationConfiguration"
            case sqlApplicationConfiguration = "SqlApplicationConfiguration"
            case vpcConfigurations = "VpcConfigurations"
            case zeppelinApplicationConfiguration = "ZeppelinApplicationConfiguration"
        }
    }

    public struct ApplicationConfigurationDescription: AWSDecodableShape {
        /// The details about the application code for a Flink-based Kinesis Data Analytics application.
        public let applicationCodeConfigurationDescription: ApplicationCodeConfigurationDescription?
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        public let applicationSnapshotConfigurationDescription: ApplicationSnapshotConfigurationDescription?
        /// Describes execution properties for a Flink-based Kinesis Data Analytics application.
        public let environmentPropertyDescriptions: EnvironmentPropertyDescriptions?
        /// The details about a Flink-based Kinesis Data Analytics application.
        public let flinkApplicationConfigurationDescription: FlinkApplicationConfigurationDescription?
        /// The details about the starting properties for a Kinesis Data Analytics application.
        public let runConfigurationDescription: RunConfigurationDescription?
        /// The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
        public let sqlApplicationConfigurationDescription: SqlApplicationConfigurationDescription?
        /// The array of descriptions of VPC configurations available to the application.
        public let vpcConfigurationDescriptions: [VpcConfigurationDescription]?
        /// The configuration parameters for a Kinesis Data Analytics Studio notebook.
        public let zeppelinApplicationConfigurationDescription: ZeppelinApplicationConfigurationDescription?

        public init(applicationCodeConfigurationDescription: ApplicationCodeConfigurationDescription? = nil, applicationSnapshotConfigurationDescription: ApplicationSnapshotConfigurationDescription? = nil, environmentPropertyDescriptions: EnvironmentPropertyDescriptions? = nil, flinkApplicationConfigurationDescription: FlinkApplicationConfigurationDescription? = nil, runConfigurationDescription: RunConfigurationDescription? = nil, sqlApplicationConfigurationDescription: SqlApplicationConfigurationDescription? = nil, vpcConfigurationDescriptions: [VpcConfigurationDescription]? = nil, zeppelinApplicationConfigurationDescription: ZeppelinApplicationConfigurationDescription? = nil) {
            self.applicationCodeConfigurationDescription = applicationCodeConfigurationDescription
            self.applicationSnapshotConfigurationDescription = applicationSnapshotConfigurationDescription
            self.environmentPropertyDescriptions = environmentPropertyDescriptions
            self.flinkApplicationConfigurationDescription = flinkApplicationConfigurationDescription
            self.runConfigurationDescription = runConfigurationDescription
            self.sqlApplicationConfigurationDescription = sqlApplicationConfigurationDescription
            self.vpcConfigurationDescriptions = vpcConfigurationDescriptions
            self.zeppelinApplicationConfigurationDescription = zeppelinApplicationConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCodeConfigurationDescription = "ApplicationCodeConfigurationDescription"
            case applicationSnapshotConfigurationDescription = "ApplicationSnapshotConfigurationDescription"
            case environmentPropertyDescriptions = "EnvironmentPropertyDescriptions"
            case flinkApplicationConfigurationDescription = "FlinkApplicationConfigurationDescription"
            case runConfigurationDescription = "RunConfigurationDescription"
            case sqlApplicationConfigurationDescription = "SqlApplicationConfigurationDescription"
            case vpcConfigurationDescriptions = "VpcConfigurationDescriptions"
            case zeppelinApplicationConfigurationDescription = "ZeppelinApplicationConfigurationDescription"
        }
    }

    public struct ApplicationConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to an application's code configuration.
        public let applicationCodeConfigurationUpdate: ApplicationCodeConfigurationUpdate?
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        public let applicationSnapshotConfigurationUpdate: ApplicationSnapshotConfigurationUpdate?
        /// Describes updates to the environment properties for a Flink-based Kinesis Data Analytics application.
        public let environmentPropertyUpdates: EnvironmentPropertyUpdates?
        /// Describes updates to a Flink-based Kinesis Data Analytics application's configuration.
        public let flinkApplicationConfigurationUpdate: FlinkApplicationConfigurationUpdate?
        /// Describes updates to a SQL-based Kinesis Data Analytics application's configuration.
        public let sqlApplicationConfigurationUpdate: SqlApplicationConfigurationUpdate?
        /// Updates to the array of descriptions of VPC configurations available to the application.
        public let vpcConfigurationUpdates: [VpcConfigurationUpdate]?
        /// Updates to the configuration of a Kinesis Data Analytics Studio notebook.
        public let zeppelinApplicationConfigurationUpdate: ZeppelinApplicationConfigurationUpdate?

        public init(applicationCodeConfigurationUpdate: ApplicationCodeConfigurationUpdate? = nil, applicationSnapshotConfigurationUpdate: ApplicationSnapshotConfigurationUpdate? = nil, environmentPropertyUpdates: EnvironmentPropertyUpdates? = nil, flinkApplicationConfigurationUpdate: FlinkApplicationConfigurationUpdate? = nil, sqlApplicationConfigurationUpdate: SqlApplicationConfigurationUpdate? = nil, vpcConfigurationUpdates: [VpcConfigurationUpdate]? = nil, zeppelinApplicationConfigurationUpdate: ZeppelinApplicationConfigurationUpdate? = nil) {
            self.applicationCodeConfigurationUpdate = applicationCodeConfigurationUpdate
            self.applicationSnapshotConfigurationUpdate = applicationSnapshotConfigurationUpdate
            self.environmentPropertyUpdates = environmentPropertyUpdates
            self.flinkApplicationConfigurationUpdate = flinkApplicationConfigurationUpdate
            self.sqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdate
            self.vpcConfigurationUpdates = vpcConfigurationUpdates
            self.zeppelinApplicationConfigurationUpdate = zeppelinApplicationConfigurationUpdate
        }

        public func validate(name: String) throws {
            try self.applicationCodeConfigurationUpdate?.validate(name: "\(name).applicationCodeConfigurationUpdate")
            try self.environmentPropertyUpdates?.validate(name: "\(name).environmentPropertyUpdates")
            try self.flinkApplicationConfigurationUpdate?.validate(name: "\(name).flinkApplicationConfigurationUpdate")
            try self.sqlApplicationConfigurationUpdate?.validate(name: "\(name).sqlApplicationConfigurationUpdate")
            try self.vpcConfigurationUpdates?.forEach {
                try $0.validate(name: "\(name).vpcConfigurationUpdates[]")
            }
            try self.zeppelinApplicationConfigurationUpdate?.validate(name: "\(name).zeppelinApplicationConfigurationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCodeConfigurationUpdate = "ApplicationCodeConfigurationUpdate"
            case applicationSnapshotConfigurationUpdate = "ApplicationSnapshotConfigurationUpdate"
            case environmentPropertyUpdates = "EnvironmentPropertyUpdates"
            case flinkApplicationConfigurationUpdate = "FlinkApplicationConfigurationUpdate"
            case sqlApplicationConfigurationUpdate = "SqlApplicationConfigurationUpdate"
            case vpcConfigurationUpdates = "VpcConfigurationUpdates"
            case zeppelinApplicationConfigurationUpdate = "ZeppelinApplicationConfigurationUpdate"
        }
    }

    public struct ApplicationDetail: AWSDecodableShape {
        /// The ARN of the application.
        public let applicationARN: String
        /// Describes details about the application code and starting parameters for a Kinesis Data Analytics application.
        public let applicationConfigurationDescription: ApplicationConfigurationDescription?
        /// The description of the application.
        public let applicationDescription: String?
        /// The details of the maintenance configuration for the application.
        public let applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription?
        /// To create a Kinesis Data Analytics Studio notebook, you must set the mode to INTERACTIVE. However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.
        public let applicationMode: ApplicationMode?
        /// The name of the application.
        public let applicationName: String
        /// The status of the application.
        public let applicationStatus: ApplicationStatus
        /// Provides the current application version. Kinesis Data Analytics updates the ApplicationVersionId each time you update the application.
        public let applicationVersionId: Int64
        /// If you reverted the application using RollbackApplication, the application version when RollbackApplication was called.
        public let applicationVersionRolledBackFrom: Int64?
        /// The version to which you want to roll back the application.
        public let applicationVersionRolledBackTo: Int64?
        /// The previous application version before the latest application update. RollbackApplication reverts the application to this version.
        public let applicationVersionUpdatedFrom: Int64?
        /// Describes the application Amazon CloudWatch logging options.
        public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?
        /// A value you use to implement strong concurrency for application updates.
        public let conditionalToken: String?
        /// The current timestamp when the application was created.
        public let createTimestamp: Date?
        /// The current timestamp when the application was last updated.
        public let lastUpdateTimestamp: Date?
        /// The runtime environment for the application (SQL-1_0, FLINK-1_6, FLINK-1_8, or FLINK-1_11).
        public let runtimeEnvironment: RuntimeEnvironment
        /// Specifies the IAM role that the application uses to access external resources.
        public let serviceExecutionRole: String?

        public init(applicationARN: String, applicationConfigurationDescription: ApplicationConfigurationDescription? = nil, applicationDescription: String? = nil, applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription? = nil, applicationMode: ApplicationMode? = nil, applicationName: String, applicationStatus: ApplicationStatus, applicationVersionId: Int64, applicationVersionRolledBackFrom: Int64? = nil, applicationVersionRolledBackTo: Int64? = nil, applicationVersionUpdatedFrom: Int64? = nil, cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil, conditionalToken: String? = nil, createTimestamp: Date? = nil, lastUpdateTimestamp: Date? = nil, runtimeEnvironment: RuntimeEnvironment, serviceExecutionRole: String? = nil) {
            self.applicationARN = applicationARN
            self.applicationConfigurationDescription = applicationConfigurationDescription
            self.applicationDescription = applicationDescription
            self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
            self.applicationVersionRolledBackFrom = applicationVersionRolledBackFrom
            self.applicationVersionRolledBackTo = applicationVersionRolledBackTo
            self.applicationVersionUpdatedFrom = applicationVersionUpdatedFrom
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
            self.conditionalToken = conditionalToken
            self.createTimestamp = createTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.runtimeEnvironment = runtimeEnvironment
            self.serviceExecutionRole = serviceExecutionRole
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationConfigurationDescription = "ApplicationConfigurationDescription"
            case applicationDescription = "ApplicationDescription"
            case applicationMaintenanceConfigurationDescription = "ApplicationMaintenanceConfigurationDescription"
            case applicationMode = "ApplicationMode"
            case applicationName = "ApplicationName"
            case applicationStatus = "ApplicationStatus"
            case applicationVersionId = "ApplicationVersionId"
            case applicationVersionRolledBackFrom = "ApplicationVersionRolledBackFrom"
            case applicationVersionRolledBackTo = "ApplicationVersionRolledBackTo"
            case applicationVersionUpdatedFrom = "ApplicationVersionUpdatedFrom"
            case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
            case conditionalToken = "ConditionalToken"
            case createTimestamp = "CreateTimestamp"
            case lastUpdateTimestamp = "LastUpdateTimestamp"
            case runtimeEnvironment = "RuntimeEnvironment"
            case serviceExecutionRole = "ServiceExecutionRole"
        }
    }

    public struct ApplicationMaintenanceConfigurationDescription: AWSDecodableShape {
        /// The end time for the maintenance window.
        public let applicationMaintenanceWindowEndTime: String
        /// The start time for the maintenance window.
        public let applicationMaintenanceWindowStartTime: String

        public init(applicationMaintenanceWindowEndTime: String, applicationMaintenanceWindowStartTime: String) {
            self.applicationMaintenanceWindowEndTime = applicationMaintenanceWindowEndTime
            self.applicationMaintenanceWindowStartTime = applicationMaintenanceWindowStartTime
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMaintenanceWindowEndTime = "ApplicationMaintenanceWindowEndTime"
            case applicationMaintenanceWindowStartTime = "ApplicationMaintenanceWindowStartTime"
        }
    }

    public struct ApplicationMaintenanceConfigurationUpdate: AWSEncodableShape {
        /// The updated start time for the maintenance window.
        public let applicationMaintenanceWindowStartTimeUpdate: String

        public init(applicationMaintenanceWindowStartTimeUpdate: String) {
            self.applicationMaintenanceWindowStartTimeUpdate = applicationMaintenanceWindowStartTimeUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationMaintenanceWindowStartTimeUpdate, name: "applicationMaintenanceWindowStartTimeUpdate", parent: name, max: 5)
            try self.validate(self.applicationMaintenanceWindowStartTimeUpdate, name: "applicationMaintenanceWindowStartTimeUpdate", parent: name, min: 5)
            try self.validate(self.applicationMaintenanceWindowStartTimeUpdate, name: "applicationMaintenanceWindowStartTimeUpdate", parent: name, pattern: "([01][0-9]|2[0-3]):[0-5][0-9]")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMaintenanceWindowStartTimeUpdate = "ApplicationMaintenanceWindowStartTimeUpdate"
        }
    }

    public struct ApplicationRestoreConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how the application should be restored.
        public let applicationRestoreType: ApplicationRestoreType
        /// The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for the  ApplicationRestoreType.
        public let snapshotName: String?

        public init(applicationRestoreType: ApplicationRestoreType, snapshotName: String? = nil) {
            self.applicationRestoreType = applicationRestoreType
            self.snapshotName = snapshotName
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 256)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationRestoreType = "ApplicationRestoreType"
            case snapshotName = "SnapshotName"
        }
    }

    public struct ApplicationSnapshotConfiguration: AWSEncodableShape {
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        public let snapshotsEnabled: Bool

        public init(snapshotsEnabled: Bool) {
            self.snapshotsEnabled = snapshotsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotsEnabled = "SnapshotsEnabled"
        }
    }

    public struct ApplicationSnapshotConfigurationDescription: AWSDecodableShape {
        /// Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
        public let snapshotsEnabled: Bool

        public init(snapshotsEnabled: Bool) {
            self.snapshotsEnabled = snapshotsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotsEnabled = "SnapshotsEnabled"
        }
    }

    public struct ApplicationSnapshotConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to whether snapshots are enabled for an application.
        public let snapshotsEnabledUpdate: Bool

        public init(snapshotsEnabledUpdate: Bool) {
            self.snapshotsEnabledUpdate = snapshotsEnabledUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotsEnabledUpdate = "SnapshotsEnabledUpdate"
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// The ARN of the application.
        public let applicationARN: String
        /// For a Kinesis Data Analytics for Apache Flink application, the mode is STREAMING. For a Kinesis Data Analytics Studio notebook, it is INTERACTIVE.
        public let applicationMode: ApplicationMode?
        /// The name of the application.
        public let applicationName: String
        /// The status of the application.
        public let applicationStatus: ApplicationStatus
        /// Provides the current application version.
        public let applicationVersionId: Int64
        /// The runtime environment for the application.
        public let runtimeEnvironment: RuntimeEnvironment

        public init(applicationARN: String, applicationMode: ApplicationMode? = nil, applicationName: String, applicationStatus: ApplicationStatus, applicationVersionId: Int64, runtimeEnvironment: RuntimeEnvironment) {
            self.applicationARN = applicationARN
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
            self.runtimeEnvironment = runtimeEnvironment
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationMode = "ApplicationMode"
            case applicationName = "ApplicationName"
            case applicationStatus = "ApplicationStatus"
            case applicationVersionId = "ApplicationVersionId"
            case runtimeEnvironment = "RuntimeEnvironment"
        }
    }

    public struct ApplicationVersionSummary: AWSDecodableShape {
        /// The status of the application.
        public let applicationStatus: ApplicationStatus
        /// The ID of the application version. Kinesis Data Analytics updates the ApplicationVersionId each time you update the application.
        public let applicationVersionId: Int64

        public init(applicationStatus: ApplicationStatus, applicationVersionId: Int64) {
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationStatus = "ApplicationStatus"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct CSVMappingParameters: AWSEncodableShape & AWSDecodableShape {
        /// The column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
        public let recordColumnDelimiter: String
        /// The row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
        public let recordRowDelimiter: String

        public init(recordColumnDelimiter: String, recordRowDelimiter: String) {
            self.recordColumnDelimiter = recordColumnDelimiter
            self.recordRowDelimiter = recordRowDelimiter
        }

        public func validate(name: String) throws {
            try self.validate(self.recordColumnDelimiter, name: "recordColumnDelimiter", parent: name, max: 1024)
            try self.validate(self.recordColumnDelimiter, name: "recordColumnDelimiter", parent: name, min: 1)
            try self.validate(self.recordRowDelimiter, name: "recordRowDelimiter", parent: name, max: 1024)
            try self.validate(self.recordRowDelimiter, name: "recordRowDelimiter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recordColumnDelimiter = "RecordColumnDelimiter"
            case recordRowDelimiter = "RecordRowDelimiter"
        }
    }

    public struct CatalogConfiguration: AWSEncodableShape {
        /// The configuration parameters for the default AWS Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.
        public let glueDataCatalogConfiguration: GlueDataCatalogConfiguration

        public init(glueDataCatalogConfiguration: GlueDataCatalogConfiguration) {
            self.glueDataCatalogConfiguration = glueDataCatalogConfiguration
        }

        public func validate(name: String) throws {
            try self.glueDataCatalogConfiguration.validate(name: "\(name).glueDataCatalogConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case glueDataCatalogConfiguration = "GlueDataCatalogConfiguration"
        }
    }

    public struct CatalogConfigurationDescription: AWSDecodableShape {
        /// The configuration parameters for the default AWS Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
        public let glueDataCatalogConfigurationDescription: GlueDataCatalogConfigurationDescription

        public init(glueDataCatalogConfigurationDescription: GlueDataCatalogConfigurationDescription) {
            self.glueDataCatalogConfigurationDescription = glueDataCatalogConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case glueDataCatalogConfigurationDescription = "GlueDataCatalogConfigurationDescription"
        }
    }

    public struct CatalogConfigurationUpdate: AWSEncodableShape {
        /// Updates to the configuration parameters for the default AWS Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
        public let glueDataCatalogConfigurationUpdate: GlueDataCatalogConfigurationUpdate

        public init(glueDataCatalogConfigurationUpdate: GlueDataCatalogConfigurationUpdate) {
            self.glueDataCatalogConfigurationUpdate = glueDataCatalogConfigurationUpdate
        }

        public func validate(name: String) throws {
            try self.glueDataCatalogConfigurationUpdate.validate(name: "\(name).glueDataCatalogConfigurationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case glueDataCatalogConfigurationUpdate = "GlueDataCatalogConfigurationUpdate"
        }
    }

    public struct CheckpointConfiguration: AWSEncodableShape {
        /// Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value  is set to another value using this API or in application code.
        public let checkpointingEnabled: Bool?
        /// Describes the interval in milliseconds between checkpoint operations.   If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set  to another value using this API or in application code.
        public let checkpointInterval: Int64?
        /// Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior.  You must set this property to CUSTOM in order to set the CheckpointingEnabled, CheckpointInterval, or MinPauseBetweenCheckpoints parameters.  If this value is set to DEFAULT, the application will use the following values, even if they are set to other values using APIs or application code:    CheckpointingEnabled: true    CheckpointInterval: 60000    MinPauseBetweenCheckpoints: 5000
        public let configurationType: ConfigurationType
        /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If a checkpoint operation takes longer than the CheckpointInterval, the application otherwise performs continual checkpoint operations. For more information, see  Tuning Checkpointing in the Apache Flink Documentation.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this  API or in application code.
        public let minPauseBetweenCheckpoints: Int64?

        public init(checkpointingEnabled: Bool? = nil, checkpointInterval: Int64? = nil, configurationType: ConfigurationType, minPauseBetweenCheckpoints: Int64? = nil) {
            self.checkpointingEnabled = checkpointingEnabled
            self.checkpointInterval = checkpointInterval
            self.configurationType = configurationType
            self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
        }

        public func validate(name: String) throws {
            try self.validate(self.checkpointInterval, name: "checkpointInterval", parent: name, min: 1)
            try self.validate(self.minPauseBetweenCheckpoints, name: "minPauseBetweenCheckpoints", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointingEnabled = "CheckpointingEnabled"
            case checkpointInterval = "CheckpointInterval"
            case configurationType = "ConfigurationType"
            case minPauseBetweenCheckpoints = "MinPauseBetweenCheckpoints"
        }
    }

    public struct CheckpointConfigurationDescription: AWSDecodableShape {
        /// Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to  another value using this API or in application code.
        public let checkpointingEnabled: Bool?
        /// Describes the interval in milliseconds between checkpoint operations.   If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value  using this API or in application code.
        public let checkpointInterval: Int64?
        /// Describes whether the application uses the default checkpointing behavior in Kinesis Data Analytics.   If this value is set to DEFAULT, the application will use the following values,  even if they are set to other values using APIs or application code:    CheckpointingEnabled: true    CheckpointInterval: 60000    MinPauseBetweenCheckpoints: 5000
        public let configurationType: ConfigurationType?
        /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.   If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this  API or in application code.
        public let minPauseBetweenCheckpoints: Int64?

        public init(checkpointingEnabled: Bool? = nil, checkpointInterval: Int64? = nil, configurationType: ConfigurationType? = nil, minPauseBetweenCheckpoints: Int64? = nil) {
            self.checkpointingEnabled = checkpointingEnabled
            self.checkpointInterval = checkpointInterval
            self.configurationType = configurationType
            self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointingEnabled = "CheckpointingEnabled"
            case checkpointInterval = "CheckpointInterval"
            case configurationType = "ConfigurationType"
            case minPauseBetweenCheckpoints = "MinPauseBetweenCheckpoints"
        }
    }

    public struct CheckpointConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to whether checkpointing is enabled for an application.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to  another value using this API or in application code.
        public let checkpointingEnabledUpdate: Bool?
        /// Describes updates to the interval in milliseconds between checkpoint operations.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value  using this API or in application code.
        public let checkpointIntervalUpdate: Int64?
        /// Describes updates to whether the application uses the default checkpointing behavior of Kinesis Data Analytics. You must set this property to CUSTOM in order to set the CheckpointingEnabled, CheckpointInterval, or MinPauseBetweenCheckpoints parameters.   If this value is set to DEFAULT, the application will use the following values, even if they are  set to other values using APIs or application code:    CheckpointingEnabled: true    CheckpointInterval: 60000    MinPauseBetweenCheckpoints: 5000
        public let configurationTypeUpdate: ConfigurationType?
        /// Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this API or  in application code.
        public let minPauseBetweenCheckpointsUpdate: Int64?

        public init(checkpointingEnabledUpdate: Bool? = nil, checkpointIntervalUpdate: Int64? = nil, configurationTypeUpdate: ConfigurationType? = nil, minPauseBetweenCheckpointsUpdate: Int64? = nil) {
            self.checkpointingEnabledUpdate = checkpointingEnabledUpdate
            self.checkpointIntervalUpdate = checkpointIntervalUpdate
            self.configurationTypeUpdate = configurationTypeUpdate
            self.minPauseBetweenCheckpointsUpdate = minPauseBetweenCheckpointsUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.checkpointIntervalUpdate, name: "checkpointIntervalUpdate", parent: name, min: 1)
            try self.validate(self.minPauseBetweenCheckpointsUpdate, name: "minPauseBetweenCheckpointsUpdate", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointingEnabledUpdate = "CheckpointingEnabledUpdate"
            case checkpointIntervalUpdate = "CheckpointIntervalUpdate"
            case configurationTypeUpdate = "ConfigurationTypeUpdate"
            case minPauseBetweenCheckpointsUpdate = "MinPauseBetweenCheckpointsUpdate"
        }
    }

    public struct CloudWatchLoggingOption: AWSEncodableShape {
        /// The ARN of the CloudWatch log to receive application messages.
        public let logStreamARN: String

        public init(logStreamARN: String) {
            self.logStreamARN = logStreamARN
        }

        public func validate(name: String) throws {
            try self.validate(self.logStreamARN, name: "logStreamARN", parent: name, max: 2048)
            try self.validate(self.logStreamARN, name: "logStreamARN", parent: name, min: 1)
            try self.validate(self.logStreamARN, name: "logStreamARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case logStreamARN = "LogStreamARN"
        }
    }

    public struct CloudWatchLoggingOptionDescription: AWSDecodableShape {
        /// The ID of the CloudWatch logging option description.
        public let cloudWatchLoggingOptionId: String?
        /// The Amazon Resource Name (ARN) of the CloudWatch log to receive application messages.
        public let logStreamARN: String
        /// The IAM ARN of the role to use to send application messages.   Provided for backward compatibility. Applications created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        public init(cloudWatchLoggingOptionId: String? = nil, logStreamARN: String, roleARN: String? = nil) {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARN = logStreamARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
            case logStreamARN = "LogStreamARN"
            case roleARN = "RoleARN"
        }
    }

    public struct CloudWatchLoggingOptionUpdate: AWSEncodableShape {
        /// The ID of the CloudWatch logging option to update
        public let cloudWatchLoggingOptionId: String
        /// The Amazon Resource Name (ARN) of the CloudWatch log to receive application messages.
        public let logStreamARNUpdate: String?

        public init(cloudWatchLoggingOptionId: String, logStreamARNUpdate: String? = nil) {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARNUpdate = logStreamARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, max: 50)
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, min: 1)
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.logStreamARNUpdate, name: "logStreamARNUpdate", parent: name, max: 2048)
            try self.validate(self.logStreamARNUpdate, name: "logStreamARNUpdate", parent: name, min: 1)
            try self.validate(self.logStreamARNUpdate, name: "logStreamARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
            case logStreamARNUpdate = "LogStreamARNUpdate"
        }
    }

    public struct CodeContent: AWSEncodableShape {
        /// Information about the Amazon S3 bucket that contains the application code.
        public let s3ContentLocation: S3ContentLocation?
        /// The text-format code for a Flink-based Kinesis Data Analytics application.
        public let textContent: String?
        /// The zip-format code for a Flink-based Kinesis Data Analytics application.
        public let zipFileContent: Data?

        public init(s3ContentLocation: S3ContentLocation? = nil, textContent: String? = nil, zipFileContent: Data? = nil) {
            self.s3ContentLocation = s3ContentLocation
            self.textContent = textContent
            self.zipFileContent = zipFileContent
        }

        public func validate(name: String) throws {
            try self.s3ContentLocation?.validate(name: "\(name).s3ContentLocation")
            try self.validate(self.textContent, name: "textContent", parent: name, max: 102_400)
            try self.validate(self.zipFileContent, name: "zipFileContent", parent: name, max: 52_428_800)
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocation = "S3ContentLocation"
            case textContent = "TextContent"
            case zipFileContent = "ZipFileContent"
        }
    }

    public struct CodeContentDescription: AWSDecodableShape {
        /// The checksum that can be used to validate zip-format code.
        public let codeMD5: String?
        /// The size in bytes of the application code. Can be used to validate zip-format code.
        public let codeSize: Int64?
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application code stored in Amazon S3.
        public let s3ApplicationCodeLocationDescription: S3ApplicationCodeLocationDescription?
        /// The text-format code
        public let textContent: String?

        public init(codeMD5: String? = nil, codeSize: Int64? = nil, s3ApplicationCodeLocationDescription: S3ApplicationCodeLocationDescription? = nil, textContent: String? = nil) {
            self.codeMD5 = codeMD5
            self.codeSize = codeSize
            self.s3ApplicationCodeLocationDescription = s3ApplicationCodeLocationDescription
            self.textContent = textContent
        }

        private enum CodingKeys: String, CodingKey {
            case codeMD5 = "CodeMD5"
            case codeSize = "CodeSize"
            case s3ApplicationCodeLocationDescription = "S3ApplicationCodeLocationDescription"
            case textContent = "TextContent"
        }
    }

    public struct CodeContentUpdate: AWSEncodableShape {
        /// Describes an update to the location of code for an application.
        public let s3ContentLocationUpdate: S3ContentLocationUpdate?
        /// Describes an update to the text code for an application.
        public let textContentUpdate: String?
        /// Describes an update to the zipped code for an application.
        public let zipFileContentUpdate: Data?

        public init(s3ContentLocationUpdate: S3ContentLocationUpdate? = nil, textContentUpdate: String? = nil, zipFileContentUpdate: Data? = nil) {
            self.s3ContentLocationUpdate = s3ContentLocationUpdate
            self.textContentUpdate = textContentUpdate
            self.zipFileContentUpdate = zipFileContentUpdate
        }

        public func validate(name: String) throws {
            try self.s3ContentLocationUpdate?.validate(name: "\(name).s3ContentLocationUpdate")
            try self.validate(self.textContentUpdate, name: "textContentUpdate", parent: name, max: 102_400)
            try self.validate(self.zipFileContentUpdate, name: "zipFileContentUpdate", parent: name, max: 52_428_800)
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocationUpdate = "S3ContentLocationUpdate"
            case textContentUpdate = "TextContentUpdate"
            case zipFileContentUpdate = "ZipFileContentUpdate"
        }
    }

    public struct CreateApplicationPresignedUrlRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// The duration in seconds for which the returned URL will be valid.
        public let sessionExpirationDurationInSeconds: Int64?
        /// The type of the extension for which to create and return a URL. Currently, the only valid extension URL type is FLINK_DASHBOARD_URL.
        public let urlType: UrlType

        public init(applicationName: String, sessionExpirationDurationInSeconds: Int64? = nil, urlType: UrlType) {
            self.applicationName = applicationName
            self.sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds
            self.urlType = urlType
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.sessionExpirationDurationInSeconds, name: "sessionExpirationDurationInSeconds", parent: name, max: 43200)
            try self.validate(self.sessionExpirationDurationInSeconds, name: "sessionExpirationDurationInSeconds", parent: name, min: 1800)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
            case urlType = "UrlType"
        }
    }

    public struct CreateApplicationPresignedUrlResponse: AWSDecodableShape {
        /// The URL of the extension.
        public let authorizedUrl: String?

        public init(authorizedUrl: String? = nil) {
            self.authorizedUrl = authorizedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedUrl = "AuthorizedUrl"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// Use this parameter to configure the application.
        public let applicationConfiguration: ApplicationConfiguration?
        /// A summary description of the application.
        public let applicationDescription: String?
        /// Use the STREAMING mode to create a Kinesis Data Analytics Studio notebook. To create a Kinesis Data Analytics Studio notebook, use the  INTERACTIVE mode.
        public let applicationMode: ApplicationMode?
        /// The name of your application (for example, sample-app).
        public let applicationName: String
        /// Use this parameter to configure an Amazon CloudWatch log stream to monitor application configuration errors.
        public let cloudWatchLoggingOptions: [CloudWatchLoggingOption]?
        /// The runtime environment for the application (SQL-1_0, FLINK-1_6, FLINK-1_8, or FLINK-1_11).
        public let runtimeEnvironment: RuntimeEnvironment
        /// The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose delivery streams, Amazon S3 objects, and other external resources.
        public let serviceExecutionRole: String
        /// A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an  application. Note that the maximum number of application tags includes system tags. The maximum number of  user-defined application tags is 50. For more information, see  Using Tagging.
        public let tags: [Tag]?

        public init(applicationConfiguration: ApplicationConfiguration? = nil, applicationDescription: String? = nil, applicationMode: ApplicationMode? = nil, applicationName: String, cloudWatchLoggingOptions: [CloudWatchLoggingOption]? = nil, runtimeEnvironment: RuntimeEnvironment, serviceExecutionRole: String, tags: [Tag]? = nil) {
            self.applicationConfiguration = applicationConfiguration
            self.applicationDescription = applicationDescription
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.cloudWatchLoggingOptions = cloudWatchLoggingOptions
            self.runtimeEnvironment = runtimeEnvironment
            self.serviceExecutionRole = serviceExecutionRole
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.applicationConfiguration?.validate(name: "\(name).applicationConfiguration")
            try self.validate(self.applicationDescription, name: "applicationDescription", parent: name, max: 1024)
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.cloudWatchLoggingOptions?.forEach {
                try $0.validate(name: "\(name).cloudWatchLoggingOptions[]")
            }
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, max: 2048)
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, min: 1)
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, pattern: "arn:.*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationConfiguration = "ApplicationConfiguration"
            case applicationDescription = "ApplicationDescription"
            case applicationMode = "ApplicationMode"
            case applicationName = "ApplicationName"
            case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
            case runtimeEnvironment = "RuntimeEnvironment"
            case serviceExecutionRole = "ServiceExecutionRole"
            case tags = "Tags"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// In response to your CreateApplication request, Kinesis Data Analytics returns a  response with details of the application it created.
        public let applicationDetail: ApplicationDetail

        public init(applicationDetail: ApplicationDetail) {
            self.applicationDetail = applicationDetail
        }

        private enum CodingKeys: String, CodingKey {
            case applicationDetail = "ApplicationDetail"
        }
    }

    public struct CreateApplicationSnapshotRequest: AWSEncodableShape {
        /// The name of an existing application
        public let applicationName: String
        /// An identifier for the application snapshot.
        public let snapshotName: String

        public init(applicationName: String, snapshotName: String) {
            self.applicationName = applicationName
            self.snapshotName = snapshotName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 256)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case snapshotName = "SnapshotName"
        }
    }

    public struct CreateApplicationSnapshotResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CustomArtifactConfiguration: AWSEncodableShape {
        ///  UDF stands for user-defined functions. This type of artifact must be in an S3 bucket. A DEPENDENCY_JAR can be in either Maven or an S3 bucket.
        public let artifactType: ArtifactType
        /// The parameters required to fully specify a Maven reference.
        public let mavenReference: MavenReference?
        public let s3ContentLocation: S3ContentLocation?

        public init(artifactType: ArtifactType, mavenReference: MavenReference? = nil, s3ContentLocation: S3ContentLocation? = nil) {
            self.artifactType = artifactType
            self.mavenReference = mavenReference
            self.s3ContentLocation = s3ContentLocation
        }

        public func validate(name: String) throws {
            try self.mavenReference?.validate(name: "\(name).mavenReference")
            try self.s3ContentLocation?.validate(name: "\(name).s3ContentLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactType = "ArtifactType"
            case mavenReference = "MavenReference"
            case s3ContentLocation = "S3ContentLocation"
        }
    }

    public struct CustomArtifactConfigurationDescription: AWSDecodableShape {
        ///  UDF stands for user-defined functions. This type of artifact must be in an S3 bucket. A DEPENDENCY_JAR can be in either Maven or an S3 bucket.
        public let artifactType: ArtifactType?
        /// The parameters that are required to specify a Maven dependency.
        public let mavenReferenceDescription: MavenReference?
        public let s3ContentLocationDescription: S3ContentLocation?

        public init(artifactType: ArtifactType? = nil, mavenReferenceDescription: MavenReference? = nil, s3ContentLocationDescription: S3ContentLocation? = nil) {
            self.artifactType = artifactType
            self.mavenReferenceDescription = mavenReferenceDescription
            self.s3ContentLocationDescription = s3ContentLocationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case artifactType = "ArtifactType"
            case mavenReferenceDescription = "MavenReferenceDescription"
            case s3ContentLocationDescription = "S3ContentLocationDescription"
        }
    }

    public struct DeleteApplicationCloudWatchLoggingOptionRequest: AWSEncodableShape {
        /// The application name.
        public let applicationName: String
        /// The CloudWatchLoggingOptionId of the Amazon CloudWatch logging option to delete. You can get the CloudWatchLoggingOptionId by using the DescribeApplication operation.
        public let cloudWatchLoggingOptionId: String
        /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The version ID of the application. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can retrieve the application version ID using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?

        public init(applicationName: String, cloudWatchLoggingOptionId: String, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil) {
            self.applicationName = applicationName
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, max: 50)
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, min: 1)
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "[a-zA-Z0-9-_+/=]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
        }
    }

    public struct DeleteApplicationCloudWatchLoggingOptionResponse: AWSDecodableShape {
        /// The application's Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The version ID of the application. Kinesis Data Analytics updates the ApplicationVersionId each time you change the CloudWatch logging options.
        public let applicationVersionId: Int64?
        /// The descriptions of the remaining CloudWatch logging options for the application.
        public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
        }
    }

    public struct DeleteApplicationInputProcessingConfigurationRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// The application version.  You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the  ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The ID of the input configuration from which to delete the input processing configuration. You can get a list of the input IDs for an application by using the DescribeApplication operation.
        public let inputId: String

        public init(applicationName: String, currentApplicationVersionId: Int64, inputId: String) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.inputId = inputId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, max: 50)
            try self.validate(self.inputId, name: "inputId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case inputId = "InputId"
        }
    }

    public struct DeleteApplicationInputProcessingConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationARN: String?
        /// The current application version ID.
        public let applicationVersionId: Int64?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DeleteApplicationOutputRequest: AWSEncodableShape {
        /// The application name.
        public let applicationName: String
        /// The application version.  You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the  ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The ID of the configuration to delete. Each output configuration that is added to the application (either when the application is created or later) using the AddApplicationOutput operation has a unique ID. You need to provide the ID to uniquely identify the output configuration that you want to delete from the application configuration. You can use the DescribeApplication operation to get the specific OutputId.
        public let outputId: String

        public init(applicationName: String, currentApplicationVersionId: Int64, outputId: String) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.outputId = outputId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.outputId, name: "outputId", parent: name, max: 50)
            try self.validate(self.outputId, name: "outputId", parent: name, min: 1)
            try self.validate(self.outputId, name: "outputId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case outputId = "OutputId"
        }
    }

    public struct DeleteApplicationOutputResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The current application version ID.
        public let applicationVersionId: Int64?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DeleteApplicationReferenceDataSourceRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The current application version.   You can use the DescribeApplication operation to get the current application version. If the version specified  is not the current version, the ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The ID of the reference data source. When you add a reference data source to your application using the AddApplicationReferenceDataSource, Kinesis Data Analytics assigns an ID.  You can use the DescribeApplication operation to get the reference ID.
        public let referenceId: String

        public init(applicationName: String, currentApplicationVersionId: Int64, referenceId: String) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.referenceId = referenceId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.referenceId, name: "referenceId", parent: name, max: 50)
            try self.validate(self.referenceId, name: "referenceId", parent: name, min: 1)
            try self.validate(self.referenceId, name: "referenceId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case referenceId = "ReferenceId"
        }
    }

    public struct DeleteApplicationReferenceDataSourceResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The updated version ID of the application.
        public let applicationVersionId: Int64?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The name of the application to delete.
        public let applicationName: String
        /// Use the DescribeApplication operation to get this value.
        public let createTimestamp: Date

        public init(applicationName: String, createTimestamp: Date) {
            self.applicationName = applicationName
            self.createTimestamp = createTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case createTimestamp = "CreateTimestamp"
        }
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteApplicationSnapshotRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The creation timestamp of the application snapshot to delete. You can retrieve this value  using  or .
        public let snapshotCreationTimestamp: Date
        /// The identifier for the snapshot delete.
        public let snapshotName: String

        public init(applicationName: String, snapshotCreationTimestamp: Date, snapshotName: String) {
            self.applicationName = applicationName
            self.snapshotCreationTimestamp = snapshotCreationTimestamp
            self.snapshotName = snapshotName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 256)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
            case snapshotName = "SnapshotName"
        }
    }

    public struct DeleteApplicationSnapshotResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteApplicationVpcConfigurationRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The current application version ID. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can retrieve the application version ID using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?
        /// The ID of the VPC configuration to delete.
        public let vpcConfigurationId: String

        public init(applicationName: String, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil, vpcConfigurationId: String) {
            self.applicationName = applicationName
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
            self.vpcConfigurationId = vpcConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "[a-zA-Z0-9-_+/=]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, max: 50)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, min: 1)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case vpcConfigurationId = "VpcConfigurationId"
        }
    }

    public struct DeleteApplicationVpcConfigurationResponse: AWSDecodableShape {
        /// The ARN of the Kinesis Data Analytics application.
        public let applicationARN: String?
        /// The updated version ID of the application.
        public let applicationVersionId: Int64?

        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DeployAsApplicationConfiguration: AWSEncodableShape {
        /// The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
        public let s3ContentLocation: S3ContentBaseLocation

        public init(s3ContentLocation: S3ContentBaseLocation) {
            self.s3ContentLocation = s3ContentLocation
        }

        public func validate(name: String) throws {
            try self.s3ContentLocation.validate(name: "\(name).s3ContentLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocation = "S3ContentLocation"
        }
    }

    public struct DeployAsApplicationConfigurationDescription: AWSDecodableShape {
        /// The location that holds the data required to specify an Amazon Data Analytics application.
        public let s3ContentLocationDescription: S3ContentBaseLocationDescription

        public init(s3ContentLocationDescription: S3ContentBaseLocationDescription) {
            self.s3ContentLocationDescription = s3ContentLocationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocationDescription = "S3ContentLocationDescription"
        }
    }

    public struct DeployAsApplicationConfigurationUpdate: AWSEncodableShape {
        /// Updates to the location that holds the data required to specify an Amazon Data Analytics application.
        public let s3ContentLocationUpdate: S3ContentBaseLocationUpdate

        public init(s3ContentLocationUpdate: S3ContentBaseLocationUpdate) {
            self.s3ContentLocationUpdate = s3ContentLocationUpdate
        }

        public func validate(name: String) throws {
            try self.s3ContentLocationUpdate.validate(name: "\(name).s3ContentLocationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocationUpdate = "S3ContentLocationUpdate"
        }
    }

    public struct DescribeApplicationRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// Displays verbose information about a Kinesis Data Analytics application, including the application's job plan.
        public let includeAdditionalDetails: Bool?

        public init(applicationName: String, includeAdditionalDetails: Bool? = nil) {
            self.applicationName = applicationName
            self.includeAdditionalDetails = includeAdditionalDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case includeAdditionalDetails = "IncludeAdditionalDetails"
        }
    }

    public struct DescribeApplicationResponse: AWSDecodableShape {
        /// Provides a description of the application, such as the application's Amazon Resource Name (ARN), status, and latest version.
        public let applicationDetail: ApplicationDetail

        public init(applicationDetail: ApplicationDetail) {
            self.applicationDetail = applicationDetail
        }

        private enum CodingKeys: String, CodingKey {
            case applicationDetail = "ApplicationDetail"
        }
    }

    public struct DescribeApplicationSnapshotRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The identifier of an application snapshot. You can retrieve this value using  .
        public let snapshotName: String

        public init(applicationName: String, snapshotName: String) {
            self.applicationName = applicationName
            self.snapshotName = snapshotName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 256)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case snapshotName = "SnapshotName"
        }
    }

    public struct DescribeApplicationSnapshotResponse: AWSDecodableShape {
        /// An object containing information about the application snapshot.
        public let snapshotDetails: SnapshotDetails

        public init(snapshotDetails: SnapshotDetails) {
            self.snapshotDetails = snapshotDetails
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotDetails = "SnapshotDetails"
        }
    }

    public struct DescribeApplicationVersionRequest: AWSEncodableShape {
        /// The name of the application for which you want to get the version description.
        public let applicationName: String
        /// The ID of the application version for which you want to get the description.
        public let applicationVersionId: Int64

        public init(applicationName: String, applicationVersionId: Int64) {
            self.applicationName = applicationName
            self.applicationVersionId = applicationVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.applicationVersionId, name: "applicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.applicationVersionId, name: "applicationVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DescribeApplicationVersionResponse: AWSDecodableShape {
        public let applicationVersionDetail: ApplicationDetail?

        public init(applicationVersionDetail: ApplicationDetail? = nil) {
            self.applicationVersionDetail = applicationVersionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersionDetail = "ApplicationVersionDetail"
        }
    }

    public struct DestinationSchema: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the format of the records on the output stream.
        public let recordFormatType: RecordFormatType

        public init(recordFormatType: RecordFormatType) {
            self.recordFormatType = recordFormatType
        }

        private enum CodingKeys: String, CodingKey {
            case recordFormatType = "RecordFormatType"
        }
    }

    public struct DiscoverInputSchemaRequest: AWSEncodableShape {
        /// The InputProcessingConfiguration to use to preprocess the records  before discovering the schema of the records.
        public let inputProcessingConfiguration: InputProcessingConfiguration?
        /// The point at which you want Kinesis Data Analytics to start reading records from the specified streaming source discovery purposes.
        public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
        /// The Amazon Resource Name (ARN) of the streaming source.
        public let resourceARN: String?
        /// Specify this parameter to discover a schema from data in an Amazon S3 object.
        public let s3Configuration: S3Configuration?
        /// The ARN of the role that is used to access the streaming source.
        public let serviceExecutionRole: String

        public init(inputProcessingConfiguration: InputProcessingConfiguration? = nil, inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil, resourceARN: String? = nil, s3Configuration: S3Configuration? = nil, serviceExecutionRole: String) {
            self.inputProcessingConfiguration = inputProcessingConfiguration
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
            self.resourceARN = resourceARN
            self.s3Configuration = s3Configuration
            self.serviceExecutionRole = serviceExecutionRole
        }

        public func validate(name: String) throws {
            try self.inputProcessingConfiguration?.validate(name: "\(name).inputProcessingConfiguration")
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, max: 2048)
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, min: 1)
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case inputProcessingConfiguration = "InputProcessingConfiguration"
            case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
            case resourceARN = "ResourceARN"
            case s3Configuration = "S3Configuration"
            case serviceExecutionRole = "ServiceExecutionRole"
        }
    }

    public struct DiscoverInputSchemaResponse: AWSDecodableShape {
        /// The schema inferred from the streaming source. It identifies the format of the data in the streaming source and how each data element maps to corresponding columns in the in-application stream that you can create.
        public let inputSchema: SourceSchema?
        /// An array of elements, where each element corresponds to a row in a stream record  (a stream record can have more than one row).
        public let parsedInputRecords: [[String]]?
        /// The stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
        public let processedInputRecords: [String]?
        /// The raw stream data that was sampled to infer the schema.
        public let rawInputRecords: [String]?

        public init(inputSchema: SourceSchema? = nil, parsedInputRecords: [[String]]? = nil, processedInputRecords: [String]? = nil, rawInputRecords: [String]? = nil) {
            self.inputSchema = inputSchema
            self.parsedInputRecords = parsedInputRecords
            self.processedInputRecords = processedInputRecords
            self.rawInputRecords = rawInputRecords
        }

        private enum CodingKeys: String, CodingKey {
            case inputSchema = "InputSchema"
            case parsedInputRecords = "ParsedInputRecords"
            case processedInputRecords = "ProcessedInputRecords"
            case rawInputRecords = "RawInputRecords"
        }
    }

    public struct EnvironmentProperties: AWSEncodableShape {
        /// Describes the execution property groups.
        public let propertyGroups: [PropertyGroup]

        public init(propertyGroups: [PropertyGroup]) {
            self.propertyGroups = propertyGroups
        }

        public func validate(name: String) throws {
            try self.propertyGroups.forEach {
                try $0.validate(name: "\(name).propertyGroups[]")
            }
            try self.validate(self.propertyGroups, name: "propertyGroups", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case propertyGroups = "PropertyGroups"
        }
    }

    public struct EnvironmentPropertyDescriptions: AWSDecodableShape {
        /// Describes the execution property groups.
        public let propertyGroupDescriptions: [PropertyGroup]?

        public init(propertyGroupDescriptions: [PropertyGroup]? = nil) {
            self.propertyGroupDescriptions = propertyGroupDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case propertyGroupDescriptions = "PropertyGroupDescriptions"
        }
    }

    public struct EnvironmentPropertyUpdates: AWSEncodableShape {
        /// Describes updates to the execution property groups.
        public let propertyGroups: [PropertyGroup]

        public init(propertyGroups: [PropertyGroup]) {
            self.propertyGroups = propertyGroups
        }

        public func validate(name: String) throws {
            try self.propertyGroups.forEach {
                try $0.validate(name: "\(name).propertyGroups[]")
            }
            try self.validate(self.propertyGroups, name: "propertyGroups", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case propertyGroups = "PropertyGroups"
        }
    }

    public struct FlinkApplicationConfiguration: AWSEncodableShape {
        /// Describes an application's checkpointing configuration. Checkpointing is the  process of persisting application state for fault tolerance. For more information, see   Checkpoints for Fault Tolerance in the  Apache Flink Documentation.
        public let checkpointConfiguration: CheckpointConfiguration?
        /// Describes configuration parameters for Amazon CloudWatch logging for an application.
        public let monitoringConfiguration: MonitoringConfiguration?
        /// Describes parameters for how an application executes multiple tasks simultaneously.
        public let parallelismConfiguration: ParallelismConfiguration?

        public init(checkpointConfiguration: CheckpointConfiguration? = nil, monitoringConfiguration: MonitoringConfiguration? = nil, parallelismConfiguration: ParallelismConfiguration? = nil) {
            self.checkpointConfiguration = checkpointConfiguration
            self.monitoringConfiguration = monitoringConfiguration
            self.parallelismConfiguration = parallelismConfiguration
        }

        public func validate(name: String) throws {
            try self.checkpointConfiguration?.validate(name: "\(name).checkpointConfiguration")
            try self.parallelismConfiguration?.validate(name: "\(name).parallelismConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointConfiguration = "CheckpointConfiguration"
            case monitoringConfiguration = "MonitoringConfiguration"
            case parallelismConfiguration = "ParallelismConfiguration"
        }
    }

    public struct FlinkApplicationConfigurationDescription: AWSDecodableShape {
        /// Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state  for fault tolerance.
        public let checkpointConfigurationDescription: CheckpointConfigurationDescription?
        /// The job plan for an application. For more information about the job plan, see Jobs and Scheduling in the Apache Flink Documentation. To retrieve the job plan for the application, use the DescribeApplicationRequest$IncludeAdditionalDetails parameter of the DescribeApplication operation.
        public let jobPlanDescription: String?
        /// Describes configuration parameters for Amazon CloudWatch logging for an application.
        public let monitoringConfigurationDescription: MonitoringConfigurationDescription?
        /// Describes parameters for how an application executes multiple tasks simultaneously.
        public let parallelismConfigurationDescription: ParallelismConfigurationDescription?

        public init(checkpointConfigurationDescription: CheckpointConfigurationDescription? = nil, jobPlanDescription: String? = nil, monitoringConfigurationDescription: MonitoringConfigurationDescription? = nil, parallelismConfigurationDescription: ParallelismConfigurationDescription? = nil) {
            self.checkpointConfigurationDescription = checkpointConfigurationDescription
            self.jobPlanDescription = jobPlanDescription
            self.monitoringConfigurationDescription = monitoringConfigurationDescription
            self.parallelismConfigurationDescription = parallelismConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointConfigurationDescription = "CheckpointConfigurationDescription"
            case jobPlanDescription = "JobPlanDescription"
            case monitoringConfigurationDescription = "MonitoringConfigurationDescription"
            case parallelismConfigurationDescription = "ParallelismConfigurationDescription"
        }
    }

    public struct FlinkApplicationConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting  application state for fault tolerance.
        public let checkpointConfigurationUpdate: CheckpointConfigurationUpdate?
        /// Describes updates to the configuration parameters for Amazon CloudWatch logging for an application.
        public let monitoringConfigurationUpdate: MonitoringConfigurationUpdate?
        /// Describes updates to the parameters for how an application executes multiple tasks simultaneously.
        public let parallelismConfigurationUpdate: ParallelismConfigurationUpdate?

        public init(checkpointConfigurationUpdate: CheckpointConfigurationUpdate? = nil, monitoringConfigurationUpdate: MonitoringConfigurationUpdate? = nil, parallelismConfigurationUpdate: ParallelismConfigurationUpdate? = nil) {
            self.checkpointConfigurationUpdate = checkpointConfigurationUpdate
            self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
            self.parallelismConfigurationUpdate = parallelismConfigurationUpdate
        }

        public func validate(name: String) throws {
            try self.checkpointConfigurationUpdate?.validate(name: "\(name).checkpointConfigurationUpdate")
            try self.parallelismConfigurationUpdate?.validate(name: "\(name).parallelismConfigurationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointConfigurationUpdate = "CheckpointConfigurationUpdate"
            case monitoringConfigurationUpdate = "MonitoringConfigurationUpdate"
            case parallelismConfigurationUpdate = "ParallelismConfigurationUpdate"
        }
    }

    public struct FlinkRunConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot  be mapped to the new program. This will happen if the program is updated between snapshots to remove stateful parameters, and  state data in the snapshot no longer  corresponds to valid application data. For more information, see   Allowing Non-Restored State in the Apache Flink  documentation.  This value defaults to false. If you update your application without specifying this parameter, AllowNonRestoredState will be set to false, even if it was previously set to true.
        public let allowNonRestoredState: Bool?

        public init(allowNonRestoredState: Bool? = nil) {
            self.allowNonRestoredState = allowNonRestoredState
        }

        private enum CodingKeys: String, CodingKey {
            case allowNonRestoredState = "AllowNonRestoredState"
        }
    }

    public struct GlueDataCatalogConfiguration: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the database.
        public let databaseARN: String

        public init(databaseARN: String) {
            self.databaseARN = databaseARN
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseARN, name: "databaseARN", parent: name, max: 2048)
            try self.validate(self.databaseARN, name: "databaseARN", parent: name, min: 1)
            try self.validate(self.databaseARN, name: "databaseARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseARN = "DatabaseARN"
        }
    }

    public struct GlueDataCatalogConfigurationDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the database.
        public let databaseARN: String

        public init(databaseARN: String) {
            self.databaseARN = databaseARN
        }

        private enum CodingKeys: String, CodingKey {
            case databaseARN = "DatabaseARN"
        }
    }

    public struct GlueDataCatalogConfigurationUpdate: AWSEncodableShape {
        /// The updated Amazon Resource Name (ARN) of the database.
        public let databaseARNUpdate: String?

        public init(databaseARNUpdate: String? = nil) {
            self.databaseARNUpdate = databaseARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseARNUpdate, name: "databaseARNUpdate", parent: name, max: 2048)
            try self.validate(self.databaseARNUpdate, name: "databaseARNUpdate", parent: name, min: 1)
            try self.validate(self.databaseARNUpdate, name: "databaseARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseARNUpdate = "DatabaseARNUpdate"
        }
    }

    public struct Input: AWSEncodableShape {
        /// Describes the number of in-application streams to create.
        public let inputParallelism: InputParallelism?
        /// The InputProcessingConfiguration for the input. An input processor transforms records as they are received  from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is  InputLambdaProcessor.
        public let inputProcessingConfiguration: InputProcessingConfiguration?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created. Also used to describe the format of the reference data source.
        public let inputSchema: SourceSchema
        /// If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
        public let kinesisFirehoseInput: KinesisFirehoseInput?
        /// If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
        public let kinesisStreamsInput: KinesisStreamsInput?
        /// The name prefix to use when creating an in-application stream. Suppose that you specify a prefix "MyInApplicationStream." Kinesis Data Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with the names "MyInApplicationStream_001," "MyInApplicationStream_002," and so on.
        public let namePrefix: String

        public init(inputParallelism: InputParallelism? = nil, inputProcessingConfiguration: InputProcessingConfiguration? = nil, inputSchema: SourceSchema, kinesisFirehoseInput: KinesisFirehoseInput? = nil, kinesisStreamsInput: KinesisStreamsInput? = nil, namePrefix: String) {
            self.inputParallelism = inputParallelism
            self.inputProcessingConfiguration = inputProcessingConfiguration
            self.inputSchema = inputSchema
            self.kinesisFirehoseInput = kinesisFirehoseInput
            self.kinesisStreamsInput = kinesisStreamsInput
            self.namePrefix = namePrefix
        }

        public func validate(name: String) throws {
            try self.inputParallelism?.validate(name: "\(name).inputParallelism")
            try self.inputProcessingConfiguration?.validate(name: "\(name).inputProcessingConfiguration")
            try self.inputSchema.validate(name: "\(name).inputSchema")
            try self.kinesisFirehoseInput?.validate(name: "\(name).kinesisFirehoseInput")
            try self.kinesisStreamsInput?.validate(name: "\(name).kinesisStreamsInput")
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, max: 32)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, min: 1)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, pattern: "[^-\\s<>&]*")
        }

        private enum CodingKeys: String, CodingKey {
            case inputParallelism = "InputParallelism"
            case inputProcessingConfiguration = "InputProcessingConfiguration"
            case inputSchema = "InputSchema"
            case kinesisFirehoseInput = "KinesisFirehoseInput"
            case kinesisStreamsInput = "KinesisStreamsInput"
            case namePrefix = "NamePrefix"
        }
    }

    public struct InputDescription: AWSDecodableShape {
        /// Returns the in-application stream names that are mapped to the stream source.
        public let inAppStreamNames: [String]?
        /// The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input  configuration that you add to your application.
        public let inputId: String?
        /// Describes the configured parallelism (number of in-application streams mapped to the streaming source).
        public let inputParallelism: InputParallelism?
        /// The description of the preprocessor that executes on records in this input before the application's code is run.
        public let inputProcessingConfigurationDescription: InputProcessingConfigurationDescription?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns  in the in-application stream that is being created.
        public let inputSchema: SourceSchema?
        /// The point at which the application is configured to read from the input stream.
        public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
        /// If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN.
        public let kinesisFirehoseInputDescription: KinesisFirehoseInputDescription?
        /// If a Kinesis data stream is configured as a streaming source, provides the Kinesis data stream's Amazon Resource Name (ARN).
        public let kinesisStreamsInputDescription: KinesisStreamsInputDescription?
        /// The in-application name prefix.
        public let namePrefix: String?

        public init(inAppStreamNames: [String]? = nil, inputId: String? = nil, inputParallelism: InputParallelism? = nil, inputProcessingConfigurationDescription: InputProcessingConfigurationDescription? = nil, inputSchema: SourceSchema? = nil, inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil, kinesisFirehoseInputDescription: KinesisFirehoseInputDescription? = nil, kinesisStreamsInputDescription: KinesisStreamsInputDescription? = nil, namePrefix: String? = nil) {
            self.inAppStreamNames = inAppStreamNames
            self.inputId = inputId
            self.inputParallelism = inputParallelism
            self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
            self.inputSchema = inputSchema
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
            self.kinesisFirehoseInputDescription = kinesisFirehoseInputDescription
            self.kinesisStreamsInputDescription = kinesisStreamsInputDescription
            self.namePrefix = namePrefix
        }

        private enum CodingKeys: String, CodingKey {
            case inAppStreamNames = "InAppStreamNames"
            case inputId = "InputId"
            case inputParallelism = "InputParallelism"
            case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
            case inputSchema = "InputSchema"
            case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
            case kinesisFirehoseInputDescription = "KinesisFirehoseInputDescription"
            case kinesisStreamsInputDescription = "KinesisStreamsInputDescription"
            case namePrefix = "NamePrefix"
        }
    }

    public struct InputLambdaProcessor: AWSEncodableShape {
        /// The ARN of the AWS Lambda function that operates on records in the stream.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: AWS Lambda
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct InputLambdaProcessorDescription: AWSDecodableShape {
        /// The ARN of the AWS Lambda function that is used to preprocess the records in the stream.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: AWS Lambda
        public let resourceARN: String
        /// The ARN of the IAM role that is used to access the AWS Lambda function.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct InputLambdaProcessorUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the new AWS Lambda function that is used to preprocess the records in the stream.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: AWS Lambda
        public let resourceARNUpdate: String

        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct InputParallelism: AWSEncodableShape & AWSDecodableShape {
        /// The number of in-application streams to create.
        public let count: Int?

        public init(count: Int? = nil) {
            self.count = count
        }

        public func validate(name: String) throws {
            try self.validate(self.count, name: "count", parent: name, max: 64)
            try self.validate(self.count, name: "count", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
        }
    }

    public struct InputParallelismUpdate: AWSEncodableShape {
        /// The number of in-application streams to create for the specified streaming source.
        public let countUpdate: Int

        public init(countUpdate: Int) {
            self.countUpdate = countUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.countUpdate, name: "countUpdate", parent: name, max: 64)
            try self.validate(self.countUpdate, name: "countUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case countUpdate = "CountUpdate"
        }
    }

    public struct InputProcessingConfiguration: AWSEncodableShape {
        /// The InputLambdaProcessor that is used to preprocess the records in the stream before being processed by your application code.
        public let inputLambdaProcessor: InputLambdaProcessor

        public init(inputLambdaProcessor: InputLambdaProcessor) {
            self.inputLambdaProcessor = inputLambdaProcessor
        }

        public func validate(name: String) throws {
            try self.inputLambdaProcessor.validate(name: "\(name).inputLambdaProcessor")
        }

        private enum CodingKeys: String, CodingKey {
            case inputLambdaProcessor = "InputLambdaProcessor"
        }
    }

    public struct InputProcessingConfigurationDescription: AWSDecodableShape {
        /// Provides configuration information about the associated InputLambdaProcessorDescription
        public let inputLambdaProcessorDescription: InputLambdaProcessorDescription?

        public init(inputLambdaProcessorDescription: InputLambdaProcessorDescription? = nil) {
            self.inputLambdaProcessorDescription = inputLambdaProcessorDescription
        }

        private enum CodingKeys: String, CodingKey {
            case inputLambdaProcessorDescription = "InputLambdaProcessorDescription"
        }
    }

    public struct InputProcessingConfigurationUpdate: AWSEncodableShape {
        /// Provides update information for an InputLambdaProcessor.
        public let inputLambdaProcessorUpdate: InputLambdaProcessorUpdate

        public init(inputLambdaProcessorUpdate: InputLambdaProcessorUpdate) {
            self.inputLambdaProcessorUpdate = inputLambdaProcessorUpdate
        }

        public func validate(name: String) throws {
            try self.inputLambdaProcessorUpdate.validate(name: "\(name).inputLambdaProcessorUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case inputLambdaProcessorUpdate = "InputLambdaProcessorUpdate"
        }
    }

    public struct InputSchemaUpdate: AWSEncodableShape {
        /// A list of RecordColumn objects. Each object describes the mapping  of the streaming source element to the corresponding column in the in-application stream.
        public let recordColumnUpdates: [RecordColumn]?
        /// Specifies the encoding of the records in the streaming source; for example, UTF-8.
        public let recordEncodingUpdate: String?
        /// Specifies the format of the records on the streaming source.
        public let recordFormatUpdate: RecordFormat?

        public init(recordColumnUpdates: [RecordColumn]? = nil, recordEncodingUpdate: String? = nil, recordFormatUpdate: RecordFormat? = nil) {
            self.recordColumnUpdates = recordColumnUpdates
            self.recordEncodingUpdate = recordEncodingUpdate
            self.recordFormatUpdate = recordFormatUpdate
        }

        public func validate(name: String) throws {
            try self.recordColumnUpdates?.forEach {
                try $0.validate(name: "\(name).recordColumnUpdates[]")
            }
            try self.validate(self.recordColumnUpdates, name: "recordColumnUpdates", parent: name, max: 1000)
            try self.validate(self.recordColumnUpdates, name: "recordColumnUpdates", parent: name, min: 1)
            try self.validate(self.recordEncodingUpdate, name: "recordEncodingUpdate", parent: name, max: 5)
            try self.validate(self.recordEncodingUpdate, name: "recordEncodingUpdate", parent: name, min: 5)
            try self.validate(self.recordEncodingUpdate, name: "recordEncodingUpdate", parent: name, pattern: "UTF-8")
            try self.recordFormatUpdate?.validate(name: "\(name).recordFormatUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case recordColumnUpdates = "RecordColumnUpdates"
            case recordEncodingUpdate = "RecordEncodingUpdate"
            case recordFormatUpdate = "RecordFormatUpdate"
        }
    }

    public struct InputStartingPositionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The starting position on the stream.    NOW - Start reading just after the most recent record in the stream, and start at the request timestamp that the customer issued.      TRIM_HORIZON - Start reading at the last untrimmed record in the stream,  which is the oldest record available in the stream. This option is not available  for an Amazon Kinesis Data Firehose delivery stream.    LAST_STOPPED_POINT - Resume reading from where the application last stopped reading.
        public let inputStartingPosition: InputStartingPosition?

        public init(inputStartingPosition: InputStartingPosition? = nil) {
            self.inputStartingPosition = inputStartingPosition
        }

        private enum CodingKeys: String, CodingKey {
            case inputStartingPosition = "InputStartingPosition"
        }
    }

    public struct InputUpdate: AWSEncodableShape {
        /// The input ID of the application input to be updated.
        public let inputId: String
        /// Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).
        public let inputParallelismUpdate: InputParallelismUpdate?
        /// Describes updates to an InputProcessingConfiguration.
        public let inputProcessingConfigurationUpdate: InputProcessingConfigurationUpdate?
        /// Describes the data format on the streaming source, and  how record elements on the streaming source map to columns of the in-application stream that is created.
        public let inputSchemaUpdate: InputSchemaUpdate?
        /// If a Kinesis Data Firehose delivery stream is the streaming source to be updated, provides an updated stream ARN.
        public let kinesisFirehoseInputUpdate: KinesisFirehoseInputUpdate?
        /// If a Kinesis data stream is the streaming source to be updated, provides an updated stream Amazon Resource Name (ARN).
        public let kinesisStreamsInputUpdate: KinesisStreamsInputUpdate?
        /// The name prefix for in-application streams that Kinesis Data Analytics creates for the specific streaming source.
        public let namePrefixUpdate: String?

        public init(inputId: String, inputParallelismUpdate: InputParallelismUpdate? = nil, inputProcessingConfigurationUpdate: InputProcessingConfigurationUpdate? = nil, inputSchemaUpdate: InputSchemaUpdate? = nil, kinesisFirehoseInputUpdate: KinesisFirehoseInputUpdate? = nil, kinesisStreamsInputUpdate: KinesisStreamsInputUpdate? = nil, namePrefixUpdate: String? = nil) {
            self.inputId = inputId
            self.inputParallelismUpdate = inputParallelismUpdate
            self.inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate
            self.inputSchemaUpdate = inputSchemaUpdate
            self.kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate
            self.kinesisStreamsInputUpdate = kinesisStreamsInputUpdate
            self.namePrefixUpdate = namePrefixUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.inputId, name: "inputId", parent: name, max: 50)
            try self.validate(self.inputId, name: "inputId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.inputParallelismUpdate?.validate(name: "\(name).inputParallelismUpdate")
            try self.inputProcessingConfigurationUpdate?.validate(name: "\(name).inputProcessingConfigurationUpdate")
            try self.inputSchemaUpdate?.validate(name: "\(name).inputSchemaUpdate")
            try self.kinesisFirehoseInputUpdate?.validate(name: "\(name).kinesisFirehoseInputUpdate")
            try self.kinesisStreamsInputUpdate?.validate(name: "\(name).kinesisStreamsInputUpdate")
            try self.validate(self.namePrefixUpdate, name: "namePrefixUpdate", parent: name, max: 32)
            try self.validate(self.namePrefixUpdate, name: "namePrefixUpdate", parent: name, min: 1)
            try self.validate(self.namePrefixUpdate, name: "namePrefixUpdate", parent: name, pattern: "[^-\\s<>&]*")
        }

        private enum CodingKeys: String, CodingKey {
            case inputId = "InputId"
            case inputParallelismUpdate = "InputParallelismUpdate"
            case inputProcessingConfigurationUpdate = "InputProcessingConfigurationUpdate"
            case inputSchemaUpdate = "InputSchemaUpdate"
            case kinesisFirehoseInputUpdate = "KinesisFirehoseInputUpdate"
            case kinesisStreamsInputUpdate = "KinesisStreamsInputUpdate"
            case namePrefixUpdate = "NamePrefixUpdate"
        }
    }

    public struct JSONMappingParameters: AWSEncodableShape & AWSDecodableShape {
        /// The path to the top-level parent that contains the records.
        public let recordRowPath: String

        public init(recordRowPath: String) {
            self.recordRowPath = recordRowPath
        }

        public func validate(name: String) throws {
            try self.validate(self.recordRowPath, name: "recordRowPath", parent: name, max: 65535)
            try self.validate(self.recordRowPath, name: "recordRowPath", parent: name, min: 1)
            try self.validate(self.recordRowPath, name: "recordRowPath", parent: name, pattern: "^(?=^\\$)(?=^\\S+$).*$")
        }

        private enum CodingKeys: String, CodingKey {
            case recordRowPath = "RecordRowPath"
        }
    }

    public struct KinesisFirehoseInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct KinesisFirehoseInputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct KinesisFirehoseInputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the input delivery stream to read.
        public let resourceARNUpdate: String

        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct KinesisFirehoseOutput: AWSEncodableShape {
        /// The ARN of the destination delivery stream to write to.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct KinesisFirehoseOutputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct KinesisFirehoseOutputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream to write to.
        public let resourceARNUpdate: String

        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct KinesisStreamsInput: AWSEncodableShape {
        /// The ARN of the input Kinesis data stream to read.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct KinesisStreamsInputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct KinesisStreamsInputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the input Kinesis data stream to read.
        public let resourceARNUpdate: String

        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct KinesisStreamsOutput: AWSEncodableShape {
        /// The ARN of the destination Kinesis data stream to write to.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct KinesisStreamsOutputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct KinesisStreamsOutputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the output.
        public let resourceARNUpdate: String

        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct LambdaOutput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the destination Lambda function to write to.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: AWS Lambda
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct LambdaOutputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination Lambda function.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination function.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct LambdaOutputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the destination AWS Lambda function.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: AWS Lambda
        public let resourceARNUpdate: String

        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct ListApplicationSnapshotsRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The maximum number of application snapshots to list.
        public let limit: Int?
        /// Use this parameter if you receive a NextToken response in a previous request that indicates that there is more  output available. Set it to the value of the previous call's NextToken response to indicate where the output should  continue from.
        public let nextToken: String?

        public init(applicationName: String, limit: Int? = nil, nextToken: String? = nil) {
            self.applicationName = applicationName
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 512)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationSnapshotsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A collection of objects containing information about the application snapshots.
        public let snapshotSummaries: [SnapshotDetails]?

        public init(nextToken: String? = nil, snapshotSummaries: [SnapshotDetails]? = nil) {
            self.nextToken = nextToken
            self.snapshotSummaries = snapshotSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case snapshotSummaries = "SnapshotSummaries"
        }
    }

    public struct ListApplicationVersionsRequest: AWSEncodableShape {
        /// The name of the application for which you want to list all versions.
        public let applicationName: String
        /// The maximum number of versions to list in this invocation of the operation.
        public let limit: Int?
        /// If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see  Using the AWS Command Line Interface's Pagination Options.
        public let nextToken: String?

        public init(applicationName: String, limit: Int? = nil, nextToken: String? = nil) {
            self.applicationName = applicationName
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 512)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationVersionsResponse: AWSDecodableShape {
        /// A list of the application versions and the associated configuration summaries. The list includes application versions that were rolled back. To get the complete description of a specific application version, invoke the DescribeApplicationVersion operation.
        public let applicationVersionSummaries: [ApplicationVersionSummary]?
        /// The pagination token for the next set of results, or null if there are no additional results.  To retrieve the next set of items, pass this token into a subsequent invocation of this operation. For more information about pagination, see  Using the AWS Command Line Interface's Pagination Options.
        public let nextToken: String?

        public init(applicationVersionSummaries: [ApplicationVersionSummary]? = nil, nextToken: String? = nil) {
            self.applicationVersionSummaries = applicationVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersionSummaries = "ApplicationVersionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The maximum number of applications to list.
        public let limit: Int?
        /// If a previous command returned a pagination token,  pass it into this value to retrieve the next set of results. For more information about pagination, see  Using the AWS Command Line Interface's Pagination Options.
        public let nextToken: String?

        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// A list of ApplicationSummary objects.
        public let applicationSummaries: [ApplicationSummary]
        /// The pagination token for the next set of results, or null if there are no additional results. Pass this token into a subsequent command to retrieve the next set of items For more information about pagination, see  Using the AWS Command Line Interface's Pagination Options.
        public let nextToken: String?

        public init(applicationSummaries: [ApplicationSummary], nextToken: String? = nil) {
            self.applicationSummaries = applicationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSummaries = "ApplicationSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the application for which to retrieve tags.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value tags assigned to the application.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct MappingParameters: AWSEncodableShape & AWSDecodableShape {
        /// Provides additional mapping information when the record format uses delimiters  (for example, CSV).
        public let cSVMappingParameters: CSVMappingParameters?
        /// Provides additional mapping information when JSON is the record format on the streaming source.
        public let jSONMappingParameters: JSONMappingParameters?

        public init(cSVMappingParameters: CSVMappingParameters? = nil, jSONMappingParameters: JSONMappingParameters? = nil) {
            self.cSVMappingParameters = cSVMappingParameters
            self.jSONMappingParameters = jSONMappingParameters
        }

        public func validate(name: String) throws {
            try self.cSVMappingParameters?.validate(name: "\(name).cSVMappingParameters")
            try self.jSONMappingParameters?.validate(name: "\(name).jSONMappingParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case cSVMappingParameters = "CSVMappingParameters"
            case jSONMappingParameters = "JSONMappingParameters"
        }
    }

    public struct MavenReference: AWSEncodableShape & AWSDecodableShape {
        /// The artifact ID of the Maven reference.
        public let artifactId: String
        /// The group ID of the Maven reference.
        public let groupId: String
        /// The version of the Maven reference.
        public let version: String

        public init(artifactId: String, groupId: String, version: String) {
            self.artifactId = artifactId
            self.groupId = groupId
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactId, name: "artifactId", parent: name, max: 256)
            try self.validate(self.artifactId, name: "artifactId", parent: name, min: 1)
            try self.validate(self.artifactId, name: "artifactId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.groupId, name: "groupId", parent: name, max: 256)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.version, name: "version", parent: name, max: 256)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactId = "ArtifactId"
            case groupId = "GroupId"
            case version = "Version"
        }
    }

    public struct MonitoringConfiguration: AWSEncodableShape {
        /// Describes whether to use the default CloudWatch logging configuration for an application.  You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
        public let configurationType: ConfigurationType
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public let logLevel: LogLevel?
        /// Describes the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
        public let metricsLevel: MetricsLevel?

        public init(configurationType: ConfigurationType, logLevel: LogLevel? = nil, metricsLevel: MetricsLevel? = nil) {
            self.configurationType = configurationType
            self.logLevel = logLevel
            self.metricsLevel = metricsLevel
        }

        private enum CodingKeys: String, CodingKey {
            case configurationType = "ConfigurationType"
            case logLevel = "LogLevel"
            case metricsLevel = "MetricsLevel"
        }
    }

    public struct MonitoringConfigurationDescription: AWSDecodableShape {
        /// Describes whether to use the default CloudWatch logging configuration for an application.
        public let configurationType: ConfigurationType?
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public let logLevel: LogLevel?
        /// Describes the granularity of the CloudWatch Logs for an application.
        public let metricsLevel: MetricsLevel?

        public init(configurationType: ConfigurationType? = nil, logLevel: LogLevel? = nil, metricsLevel: MetricsLevel? = nil) {
            self.configurationType = configurationType
            self.logLevel = logLevel
            self.metricsLevel = metricsLevel
        }

        private enum CodingKeys: String, CodingKey {
            case configurationType = "ConfigurationType"
            case logLevel = "LogLevel"
            case metricsLevel = "MetricsLevel"
        }
    }

    public struct MonitoringConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to whether to use the default CloudWatch logging configuration for  an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
        public let configurationTypeUpdate: ConfigurationType?
        /// Describes updates to the verbosity of the CloudWatch Logs for an application.
        public let logLevelUpdate: LogLevel?
        /// Describes updates to the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
        public let metricsLevelUpdate: MetricsLevel?

        public init(configurationTypeUpdate: ConfigurationType? = nil, logLevelUpdate: LogLevel? = nil, metricsLevelUpdate: MetricsLevel? = nil) {
            self.configurationTypeUpdate = configurationTypeUpdate
            self.logLevelUpdate = logLevelUpdate
            self.metricsLevelUpdate = metricsLevelUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case configurationTypeUpdate = "ConfigurationTypeUpdate"
            case logLevelUpdate = "LogLevelUpdate"
            case metricsLevelUpdate = "MetricsLevelUpdate"
        }
    }

    public struct Output: AWSEncodableShape {
        /// Describes the data format when records are written to the destination.
        public let destinationSchema: DestinationSchema
        /// Identifies a Kinesis Data Firehose delivery stream as the destination.
        public let kinesisFirehoseOutput: KinesisFirehoseOutput?
        /// Identifies a Kinesis data stream  as the destination.
        public let kinesisStreamsOutput: KinesisStreamsOutput?
        /// Identifies an AWS Lambda function as the destination.
        public let lambdaOutput: LambdaOutput?
        /// The name of the in-application stream.
        public let name: String

        public init(destinationSchema: DestinationSchema, kinesisFirehoseOutput: KinesisFirehoseOutput? = nil, kinesisStreamsOutput: KinesisStreamsOutput? = nil, lambdaOutput: LambdaOutput? = nil, name: String) {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutput = kinesisFirehoseOutput
            self.kinesisStreamsOutput = kinesisStreamsOutput
            self.lambdaOutput = lambdaOutput
            self.name = name
        }

        public func validate(name: String) throws {
            try self.kinesisFirehoseOutput?.validate(name: "\(name).kinesisFirehoseOutput")
            try self.kinesisStreamsOutput?.validate(name: "\(name).kinesisStreamsOutput")
            try self.lambdaOutput?.validate(name: "\(name).lambdaOutput")
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^-\\s<>&]*")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationSchema = "DestinationSchema"
            case kinesisFirehoseOutput = "KinesisFirehoseOutput"
            case kinesisStreamsOutput = "KinesisStreamsOutput"
            case lambdaOutput = "LambdaOutput"
            case name = "Name"
        }
    }

    public struct OutputDescription: AWSDecodableShape {
        /// The data format used for writing data to the destination.
        public let destinationSchema: DestinationSchema?
        /// Describes the Kinesis Data Firehose delivery stream that is configured as the destination where output is written.
        public let kinesisFirehoseOutputDescription: KinesisFirehoseOutputDescription?
        /// Describes the Kinesis data stream that is configured as the destination where output is written.
        public let kinesisStreamsOutputDescription: KinesisStreamsOutputDescription?
        /// Describes the Lambda function that is configured as the destination where output is written.
        public let lambdaOutputDescription: LambdaOutputDescription?
        /// The name of the in-application stream that is configured as output.
        public let name: String?
        /// A unique identifier for the output configuration.
        public let outputId: String?

        public init(destinationSchema: DestinationSchema? = nil, kinesisFirehoseOutputDescription: KinesisFirehoseOutputDescription? = nil, kinesisStreamsOutputDescription: KinesisStreamsOutputDescription? = nil, lambdaOutputDescription: LambdaOutputDescription? = nil, name: String? = nil, outputId: String? = nil) {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription
            self.kinesisStreamsOutputDescription = kinesisStreamsOutputDescription
            self.lambdaOutputDescription = lambdaOutputDescription
            self.name = name
            self.outputId = outputId
        }

        private enum CodingKeys: String, CodingKey {
            case destinationSchema = "DestinationSchema"
            case kinesisFirehoseOutputDescription = "KinesisFirehoseOutputDescription"
            case kinesisStreamsOutputDescription = "KinesisStreamsOutputDescription"
            case lambdaOutputDescription = "LambdaOutputDescription"
            case name = "Name"
            case outputId = "OutputId"
        }
    }

    public struct OutputUpdate: AWSEncodableShape {
        /// Describes the data format when records are written to the destination.
        public let destinationSchemaUpdate: DestinationSchema?
        /// Describes a Kinesis Data Firehose delivery stream as the destination for the output.
        public let kinesisFirehoseOutputUpdate: KinesisFirehoseOutputUpdate?
        /// Describes a Kinesis data stream as the destination for the output.
        public let kinesisStreamsOutputUpdate: KinesisStreamsOutputUpdate?
        /// Describes an AWS Lambda function as the destination for the output.
        public let lambdaOutputUpdate: LambdaOutputUpdate?
        /// If you want to specify a different in-application stream  for this output configuration, use this field to  specify the new in-application stream name.
        public let nameUpdate: String?
        /// Identifies the specific output configuration that you want to update.
        public let outputId: String

        public init(destinationSchemaUpdate: DestinationSchema? = nil, kinesisFirehoseOutputUpdate: KinesisFirehoseOutputUpdate? = nil, kinesisStreamsOutputUpdate: KinesisStreamsOutputUpdate? = nil, lambdaOutputUpdate: LambdaOutputUpdate? = nil, nameUpdate: String? = nil, outputId: String) {
            self.destinationSchemaUpdate = destinationSchemaUpdate
            self.kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate
            self.kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate
            self.lambdaOutputUpdate = lambdaOutputUpdate
            self.nameUpdate = nameUpdate
            self.outputId = outputId
        }

        public func validate(name: String) throws {
            try self.kinesisFirehoseOutputUpdate?.validate(name: "\(name).kinesisFirehoseOutputUpdate")
            try self.kinesisStreamsOutputUpdate?.validate(name: "\(name).kinesisStreamsOutputUpdate")
            try self.lambdaOutputUpdate?.validate(name: "\(name).lambdaOutputUpdate")
            try self.validate(self.nameUpdate, name: "nameUpdate", parent: name, max: 32)
            try self.validate(self.nameUpdate, name: "nameUpdate", parent: name, min: 1)
            try self.validate(self.nameUpdate, name: "nameUpdate", parent: name, pattern: "[^-\\s<>&]*")
            try self.validate(self.outputId, name: "outputId", parent: name, max: 50)
            try self.validate(self.outputId, name: "outputId", parent: name, min: 1)
            try self.validate(self.outputId, name: "outputId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationSchemaUpdate = "DestinationSchemaUpdate"
            case kinesisFirehoseOutputUpdate = "KinesisFirehoseOutputUpdate"
            case kinesisStreamsOutputUpdate = "KinesisStreamsOutputUpdate"
            case lambdaOutputUpdate = "LambdaOutputUpdate"
            case nameUpdate = "NameUpdate"
            case outputId = "OutputId"
        }
    }

    public struct ParallelismConfiguration: AWSEncodableShape {
        /// Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
        public let autoScalingEnabled: Bool?
        /// Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to CUSTOM in order to change your application's AutoScalingEnabled, Parallelism, or ParallelismPerKPU properties.
        public let configurationType: ConfigurationType
        /// Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If AutoScalingEnabled  is set to True, Kinesis Data Analytics increases the CurrentParallelism value in response to application load. The service can increase the CurrentParallelism value up to the maximum parallelism, which is  ParalellismPerKPU times the maximum KPUs for the application.  The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If  application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public let parallelism: Int?
        /// Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit  (KPU) used by the application. For more information about KPUs, see Amazon Kinesis Data Analytics Pricing.
        public let parallelismPerKPU: Int?

        public init(autoScalingEnabled: Bool? = nil, configurationType: ConfigurationType, parallelism: Int? = nil, parallelismPerKPU: Int? = nil) {
            self.autoScalingEnabled = autoScalingEnabled
            self.configurationType = configurationType
            self.parallelism = parallelism
            self.parallelismPerKPU = parallelismPerKPU
        }

        public func validate(name: String) throws {
            try self.validate(self.parallelism, name: "parallelism", parent: name, min: 1)
            try self.validate(self.parallelismPerKPU, name: "parallelismPerKPU", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingEnabled = "AutoScalingEnabled"
            case configurationType = "ConfigurationType"
            case parallelism = "Parallelism"
            case parallelismPerKPU = "ParallelismPerKPU"
        }
    }

    public struct ParallelismConfigurationDescription: AWSDecodableShape {
        /// Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
        public let autoScalingEnabled: Bool?
        /// Describes whether the application uses the default parallelism for the Kinesis Data Analytics service.
        public let configurationType: ConfigurationType?
        /// Describes the current number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.  If AutoScalingEnabled is set to True, Kinesis Data Analytics can increase this value in response to application load. The service can increase this value up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application.  The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public let currentParallelism: Int?
        /// Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.  If AutoScalingEnabled is set to True, then Kinesis Data Analytics can increase the CurrentParallelism value in response to application load. The service can increase CurrentParallelism up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application.  The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public let parallelism: Int?
        /// Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per  Kinesis Processing Unit (KPU) used by the application.
        public let parallelismPerKPU: Int?

        public init(autoScalingEnabled: Bool? = nil, configurationType: ConfigurationType? = nil, currentParallelism: Int? = nil, parallelism: Int? = nil, parallelismPerKPU: Int? = nil) {
            self.autoScalingEnabled = autoScalingEnabled
            self.configurationType = configurationType
            self.currentParallelism = currentParallelism
            self.parallelism = parallelism
            self.parallelismPerKPU = parallelismPerKPU
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingEnabled = "AutoScalingEnabled"
            case configurationType = "ConfigurationType"
            case currentParallelism = "CurrentParallelism"
            case parallelism = "Parallelism"
            case parallelismPerKPU = "ParallelismPerKPU"
        }
    }

    public struct ParallelismConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to whether the Kinesis Data Analytics service can increase the parallelism of a Flink-based Kinesis Data Analytics application in response to increased throughput.
        public let autoScalingEnabledUpdate: Bool?
        /// Describes updates to whether the application uses the default parallelism for the Kinesis Data Analytics service, or if a custom parallelism is used. You must set this property to CUSTOM in order to change your application's AutoScalingEnabled, Parallelism, or ParallelismPerKPU properties.
        public let configurationTypeUpdate: ConfigurationType?
        /// Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.
        public let parallelismPerKPUUpdate: Int?
        /// Describes updates to the initial number of parallel tasks an application can perform. If AutoScalingEnabled is set to True, then  Kinesis Data Analytics can increase the CurrentParallelism value in response to application load. The service can increase CurrentParallelism up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application.  The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will reduce CurrentParallelism down to the Parallelism setting.
        public let parallelismUpdate: Int?

        public init(autoScalingEnabledUpdate: Bool? = nil, configurationTypeUpdate: ConfigurationType? = nil, parallelismPerKPUUpdate: Int? = nil, parallelismUpdate: Int? = nil) {
            self.autoScalingEnabledUpdate = autoScalingEnabledUpdate
            self.configurationTypeUpdate = configurationTypeUpdate
            self.parallelismPerKPUUpdate = parallelismPerKPUUpdate
            self.parallelismUpdate = parallelismUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.parallelismPerKPUUpdate, name: "parallelismPerKPUUpdate", parent: name, min: 1)
            try self.validate(self.parallelismUpdate, name: "parallelismUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingEnabledUpdate = "AutoScalingEnabledUpdate"
            case configurationTypeUpdate = "ConfigurationTypeUpdate"
            case parallelismPerKPUUpdate = "ParallelismPerKPUUpdate"
            case parallelismUpdate = "ParallelismUpdate"
        }
    }

    public struct PropertyGroup: AWSEncodableShape & AWSDecodableShape {
        /// Describes the key of an application execution property key-value pair.
        public let propertyGroupId: String
        /// Describes the value of an application execution property key-value pair.
        public let propertyMap: [String: String]

        public init(propertyGroupId: String, propertyMap: [String: String]) {
            self.propertyGroupId = propertyGroupId
            self.propertyMap = propertyMap
        }

        public func validate(name: String) throws {
            try self.validate(self.propertyGroupId, name: "propertyGroupId", parent: name, max: 50)
            try self.validate(self.propertyGroupId, name: "propertyGroupId", parent: name, min: 1)
            try self.validate(self.propertyGroupId, name: "propertyGroupId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.propertyMap.forEach {
                try validate($0.key, name: "propertyMap.key", parent: name, max: 2048)
                try validate($0.key, name: "propertyMap.key", parent: name, min: 1)
                try validate($0.value, name: "propertyMap[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "propertyMap[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.propertyMap, name: "propertyMap", parent: name, max: 50)
            try self.validate(self.propertyMap, name: "propertyMap", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case propertyGroupId = "PropertyGroupId"
            case propertyMap = "PropertyMap"
        }
    }

    public struct RecordColumn: AWSEncodableShape & AWSDecodableShape {
        /// A reference to the data element in the streaming input or the reference data source.
        public let mapping: String?
        /// The name of the column that is created in the in-application input stream or reference table.
        public let name: String
        /// The type of column created in the in-application input stream or reference table.
        public let sqlType: String

        public init(mapping: String? = nil, name: String, sqlType: String) {
            self.mapping = mapping
            self.name = name
            self.sqlType = sqlType
        }

        public func validate(name: String) throws {
            try self.validate(self.mapping, name: "mapping", parent: name, max: 65535)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^-\\s<>&]*")
            try self.validate(self.sqlType, name: "sqlType", parent: name, max: 100)
            try self.validate(self.sqlType, name: "sqlType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mapping = "Mapping"
            case name = "Name"
            case sqlType = "SqlType"
        }
    }

    public struct RecordFormat: AWSEncodableShape & AWSDecodableShape {
        /// When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        public let mappingParameters: MappingParameters?
        /// The type of record format.
        public let recordFormatType: RecordFormatType

        public init(mappingParameters: MappingParameters? = nil, recordFormatType: RecordFormatType) {
            self.mappingParameters = mappingParameters
            self.recordFormatType = recordFormatType
        }

        public func validate(name: String) throws {
            try self.mappingParameters?.validate(name: "\(name).mappingParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case mappingParameters = "MappingParameters"
            case recordFormatType = "RecordFormatType"
        }
    }

    public struct ReferenceDataSource: AWSEncodableShape {
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public let referenceSchema: SourceSchema
        /// Identifies the S3 bucket and object that contains the reference data.  A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the UpdateApplication operation to trigger reloading of data into your application.
        public let s3ReferenceDataSource: S3ReferenceDataSource?
        /// The name of the in-application table to create.
        public let tableName: String

        public init(referenceSchema: SourceSchema, s3ReferenceDataSource: S3ReferenceDataSource? = nil, tableName: String) {
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSource = s3ReferenceDataSource
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.referenceSchema.validate(name: "\(name).referenceSchema")
            try self.s3ReferenceDataSource?.validate(name: "\(name).s3ReferenceDataSource")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 32)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case referenceSchema = "ReferenceSchema"
            case s3ReferenceDataSource = "S3ReferenceDataSource"
            case tableName = "TableName"
        }
    }

    public struct ReferenceDataSourceDescription: AWSDecodableShape {
        /// The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns when you add the reference data source to your application using the CreateApplication or UpdateApplication operation.
        public let referenceId: String
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public let referenceSchema: SourceSchema?
        /// Provides the Amazon S3 bucket name, the object key name that contains the reference data.
        public let s3ReferenceDataSourceDescription: S3ReferenceDataSourceDescription
        /// The in-application table name created by the specific reference data source configuration.
        public let tableName: String

        public init(referenceId: String, referenceSchema: SourceSchema? = nil, s3ReferenceDataSourceDescription: S3ReferenceDataSourceDescription, tableName: String) {
            self.referenceId = referenceId
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case referenceId = "ReferenceId"
            case referenceSchema = "ReferenceSchema"
            case s3ReferenceDataSourceDescription = "S3ReferenceDataSourceDescription"
            case tableName = "TableName"
        }
    }

    public struct ReferenceDataSourceUpdate: AWSEncodableShape {
        /// The ID of the reference data source that is being updated. You can use the DescribeApplication operation to get this value.
        public let referenceId: String
        /// Describes the format of the data in the streaming source, and how each data element maps to  corresponding columns created in the in-application stream.
        public let referenceSchemaUpdate: SourceSchema?
        /// Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the  Amazon S3 object on your behalf and populate the in-application reference table.
        public let s3ReferenceDataSourceUpdate: S3ReferenceDataSourceUpdate?
        /// The in-application table name that is created by this update.
        public let tableNameUpdate: String?

        public init(referenceId: String, referenceSchemaUpdate: SourceSchema? = nil, s3ReferenceDataSourceUpdate: S3ReferenceDataSourceUpdate? = nil, tableNameUpdate: String? = nil) {
            self.referenceId = referenceId
            self.referenceSchemaUpdate = referenceSchemaUpdate
            self.s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate
            self.tableNameUpdate = tableNameUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.referenceId, name: "referenceId", parent: name, max: 50)
            try self.validate(self.referenceId, name: "referenceId", parent: name, min: 1)
            try self.validate(self.referenceId, name: "referenceId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.referenceSchemaUpdate?.validate(name: "\(name).referenceSchemaUpdate")
            try self.s3ReferenceDataSourceUpdate?.validate(name: "\(name).s3ReferenceDataSourceUpdate")
            try self.validate(self.tableNameUpdate, name: "tableNameUpdate", parent: name, max: 32)
            try self.validate(self.tableNameUpdate, name: "tableNameUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case referenceId = "ReferenceId"
            case referenceSchemaUpdate = "ReferenceSchemaUpdate"
            case s3ReferenceDataSourceUpdate = "S3ReferenceDataSourceUpdate"
            case tableNameUpdate = "TableNameUpdate"
        }
    }

    public struct RollbackApplicationRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// The current application version ID. You can retrieve the application version ID using  DescribeApplication.
        public let currentApplicationVersionId: Int64

        public init(applicationName: String, currentApplicationVersionId: Int64) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
        }
    }

    public struct RollbackApplicationResponse: AWSDecodableShape {
        public let applicationDetail: ApplicationDetail

        public init(applicationDetail: ApplicationDetail) {
            self.applicationDetail = applicationDetail
        }

        private enum CodingKeys: String, CodingKey {
            case applicationDetail = "ApplicationDetail"
        }
    }

    public struct RunConfiguration: AWSEncodableShape {
        /// Describes the restore behavior of a restarting application.
        public let applicationRestoreConfiguration: ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
        public let flinkRunConfiguration: FlinkRunConfiguration?
        /// Describes the starting parameters for a SQL-based Kinesis Data Analytics application application.
        public let sqlRunConfigurations: [SqlRunConfiguration]?

        public init(applicationRestoreConfiguration: ApplicationRestoreConfiguration? = nil, flinkRunConfiguration: FlinkRunConfiguration? = nil, sqlRunConfigurations: [SqlRunConfiguration]? = nil) {
            self.applicationRestoreConfiguration = applicationRestoreConfiguration
            self.flinkRunConfiguration = flinkRunConfiguration
            self.sqlRunConfigurations = sqlRunConfigurations
        }

        public func validate(name: String) throws {
            try self.applicationRestoreConfiguration?.validate(name: "\(name).applicationRestoreConfiguration")
            try self.sqlRunConfigurations?.forEach {
                try $0.validate(name: "\(name).sqlRunConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicationRestoreConfiguration = "ApplicationRestoreConfiguration"
            case flinkRunConfiguration = "FlinkRunConfiguration"
            case sqlRunConfigurations = "SqlRunConfigurations"
        }
    }

    public struct RunConfigurationDescription: AWSDecodableShape {
        /// Describes the restore behavior of a restarting application.
        public let applicationRestoreConfigurationDescription: ApplicationRestoreConfiguration?
        public let flinkRunConfigurationDescription: FlinkRunConfiguration?

        public init(applicationRestoreConfigurationDescription: ApplicationRestoreConfiguration? = nil, flinkRunConfigurationDescription: FlinkRunConfiguration? = nil) {
            self.applicationRestoreConfigurationDescription = applicationRestoreConfigurationDescription
            self.flinkRunConfigurationDescription = flinkRunConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationRestoreConfigurationDescription = "ApplicationRestoreConfigurationDescription"
            case flinkRunConfigurationDescription = "FlinkRunConfigurationDescription"
        }
    }

    public struct RunConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to the restore behavior of a restarting application.
        public let applicationRestoreConfiguration: ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
        public let flinkRunConfiguration: FlinkRunConfiguration?

        public init(applicationRestoreConfiguration: ApplicationRestoreConfiguration? = nil, flinkRunConfiguration: FlinkRunConfiguration? = nil) {
            self.applicationRestoreConfiguration = applicationRestoreConfiguration
            self.flinkRunConfiguration = flinkRunConfiguration
        }

        public func validate(name: String) throws {
            try self.applicationRestoreConfiguration?.validate(name: "\(name).applicationRestoreConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationRestoreConfiguration = "ApplicationRestoreConfiguration"
            case flinkRunConfiguration = "FlinkRunConfiguration"
        }
    }

    public struct S3ApplicationCodeLocationDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        public let bucketARN: String
        /// The file key for the object containing the application code.
        public let fileKey: String
        /// The version of the object containing the application code.
        public let objectVersion: String?

        public init(bucketARN: String, fileKey: String, objectVersion: String? = nil) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
            case objectVersion = "ObjectVersion"
        }
    }

    public struct S3Configuration: AWSEncodableShape {
        /// The ARN of the S3 bucket that contains the data.
        public let bucketARN: String
        /// The name of the object that contains the data.
        public let fileKey: String

        public init(bucketARN: String, fileKey: String) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, max: 2048)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, min: 1)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, pattern: "arn:.*")
            try self.validate(self.fileKey, name: "fileKey", parent: name, max: 1024)
            try self.validate(self.fileKey, name: "fileKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
        }
    }

    public struct S3ContentBaseLocation: AWSEncodableShape {
        /// The base path for the S3 bucket.
        public let basePath: String?
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARN: String

        public init(basePath: String? = nil, bucketARN: String) {
            self.basePath = basePath
            self.bucketARN = bucketARN
        }

        public func validate(name: String) throws {
            try self.validate(self.basePath, name: "basePath", parent: name, max: 1024)
            try self.validate(self.basePath, name: "basePath", parent: name, min: 1)
            try self.validate(self.basePath, name: "basePath", parent: name, pattern: "[a-zA-Z0-9/!-_.*'()]+")
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, max: 2048)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, min: 1)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case basePath = "BasePath"
            case bucketARN = "BucketARN"
        }
    }

    public struct S3ContentBaseLocationDescription: AWSDecodableShape {
        /// The base path for the S3 bucket.
        public let basePath: String?
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARN: String

        public init(basePath: String? = nil, bucketARN: String) {
            self.basePath = basePath
            self.bucketARN = bucketARN
        }

        private enum CodingKeys: String, CodingKey {
            case basePath = "BasePath"
            case bucketARN = "BucketARN"
        }
    }

    public struct S3ContentBaseLocationUpdate: AWSEncodableShape {
        /// The updated S3 bucket path.
        public let basePathUpdate: String?
        /// The updated Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARNUpdate: String

        public init(basePathUpdate: String? = nil, bucketARNUpdate: String) {
            self.basePathUpdate = basePathUpdate
            self.bucketARNUpdate = bucketARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.basePathUpdate, name: "basePathUpdate", parent: name, max: 1024)
            try self.validate(self.basePathUpdate, name: "basePathUpdate", parent: name, min: 1)
            try self.validate(self.basePathUpdate, name: "basePathUpdate", parent: name, pattern: "[a-zA-Z0-9/!-_.*'()]+")
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, max: 2048)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, min: 1)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case basePathUpdate = "BasePathUpdate"
            case bucketARNUpdate = "BucketARNUpdate"
        }
    }

    public struct S3ContentLocation: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        public let bucketARN: String
        /// The file key for the object containing the application code.
        public let fileKey: String
        /// The version of the object containing the application code.
        public let objectVersion: String?

        public init(bucketARN: String, fileKey: String, objectVersion: String? = nil) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, max: 2048)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, min: 1)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, pattern: "arn:.*")
            try self.validate(self.fileKey, name: "fileKey", parent: name, max: 1024)
            try self.validate(self.fileKey, name: "fileKey", parent: name, min: 1)
            try self.validate(self.objectVersion, name: "objectVersion", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
            case objectVersion = "ObjectVersion"
        }
    }

    public struct S3ContentLocationUpdate: AWSEncodableShape {
        /// The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        public let bucketARNUpdate: String?
        /// The new file key for the object containing the application code.
        public let fileKeyUpdate: String?
        /// The new version of the object containing the application code.
        public let objectVersionUpdate: String?

        public init(bucketARNUpdate: String? = nil, fileKeyUpdate: String? = nil, objectVersionUpdate: String? = nil) {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
            self.objectVersionUpdate = objectVersionUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, max: 2048)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, min: 1)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, pattern: "arn:.*")
            try self.validate(self.fileKeyUpdate, name: "fileKeyUpdate", parent: name, max: 1024)
            try self.validate(self.fileKeyUpdate, name: "fileKeyUpdate", parent: name, min: 1)
            try self.validate(self.objectVersionUpdate, name: "objectVersionUpdate", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARNUpdate = "BucketARNUpdate"
            case fileKeyUpdate = "FileKeyUpdate"
            case objectVersionUpdate = "ObjectVersionUpdate"
        }
    }

    public struct S3ReferenceDataSource: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARN: String?
        /// The object key name containing the reference data.
        public let fileKey: String?

        public init(bucketARN: String? = nil, fileKey: String? = nil) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, max: 2048)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, min: 1)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, pattern: "arn:.*")
            try self.validate(self.fileKey, name: "fileKey", parent: name, max: 1024)
            try self.validate(self.fileKey, name: "fileKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
        }
    }

    public struct S3ReferenceDataSourceDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARN: String
        /// Amazon S3 object key name.
        public let fileKey: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3 object on your behalf to populate the in-application reference table.   Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let referenceRoleARN: String?

        public init(bucketARN: String, fileKey: String, referenceRoleARN: String? = nil) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.referenceRoleARN = referenceRoleARN
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
            case referenceRoleARN = "ReferenceRoleARN"
        }
    }

    public struct S3ReferenceDataSourceUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARNUpdate: String?
        /// The object key name.
        public let fileKeyUpdate: String?

        public init(bucketARNUpdate: String? = nil, fileKeyUpdate: String? = nil) {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, max: 2048)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, min: 1)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, pattern: "arn:.*")
            try self.validate(self.fileKeyUpdate, name: "fileKeyUpdate", parent: name, max: 1024)
            try self.validate(self.fileKeyUpdate, name: "fileKeyUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARNUpdate = "BucketARNUpdate"
            case fileKeyUpdate = "FileKeyUpdate"
        }
    }

    public struct SnapshotDetails: AWSDecodableShape {
        /// The current application version ID when the snapshot was created.
        public let applicationVersionId: Int64
        /// The timestamp of the application snapshot.
        public let snapshotCreationTimestamp: Date?
        /// The identifier for the application snapshot.
        public let snapshotName: String
        /// The status of the application snapshot.
        public let snapshotStatus: SnapshotStatus

        public init(applicationVersionId: Int64, snapshotCreationTimestamp: Date? = nil, snapshotName: String, snapshotStatus: SnapshotStatus) {
            self.applicationVersionId = applicationVersionId
            self.snapshotCreationTimestamp = snapshotCreationTimestamp
            self.snapshotName = snapshotName
            self.snapshotStatus = snapshotStatus
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersionId = "ApplicationVersionId"
            case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
            case snapshotName = "SnapshotName"
            case snapshotStatus = "SnapshotStatus"
        }
    }

    public struct SourceSchema: AWSEncodableShape & AWSDecodableShape {
        /// A list of RecordColumn objects.
        public let recordColumns: [RecordColumn]
        /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
        public let recordEncoding: String?
        /// Specifies the format of the records on the streaming source.
        public let recordFormat: RecordFormat

        public init(recordColumns: [RecordColumn], recordEncoding: String? = nil, recordFormat: RecordFormat) {
            self.recordColumns = recordColumns
            self.recordEncoding = recordEncoding
            self.recordFormat = recordFormat
        }

        public func validate(name: String) throws {
            try self.recordColumns.forEach {
                try $0.validate(name: "\(name).recordColumns[]")
            }
            try self.validate(self.recordColumns, name: "recordColumns", parent: name, max: 1000)
            try self.validate(self.recordColumns, name: "recordColumns", parent: name, min: 1)
            try self.validate(self.recordEncoding, name: "recordEncoding", parent: name, max: 5)
            try self.validate(self.recordEncoding, name: "recordEncoding", parent: name, min: 5)
            try self.validate(self.recordEncoding, name: "recordEncoding", parent: name, pattern: "UTF-8")
            try self.recordFormat.validate(name: "\(name).recordFormat")
        }

        private enum CodingKeys: String, CodingKey {
            case recordColumns = "RecordColumns"
            case recordEncoding = "RecordEncoding"
            case recordFormat = "RecordFormat"
        }
    }

    public struct SqlApplicationConfiguration: AWSEncodableShape {
        /// The array of Input objects describing the input streams used by the application.
        public let inputs: [Input]?
        /// The array of Output objects describing the destination streams used by the application.
        public let outputs: [Output]?
        /// The array of ReferenceDataSource objects describing the reference data sources used by the application.
        public let referenceDataSources: [ReferenceDataSource]?

        public init(inputs: [Input]? = nil, outputs: [Output]? = nil, referenceDataSources: [ReferenceDataSource]? = nil) {
            self.inputs = inputs
            self.outputs = outputs
            self.referenceDataSources = referenceDataSources
        }

        public func validate(name: String) throws {
            try self.inputs?.forEach {
                try $0.validate(name: "\(name).inputs[]")
            }
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.referenceDataSources?.forEach {
                try $0.validate(name: "\(name).referenceDataSources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case outputs = "Outputs"
            case referenceDataSources = "ReferenceDataSources"
        }
    }

    public struct SqlApplicationConfigurationDescription: AWSDecodableShape {
        /// The array of InputDescription objects describing the input streams used by the application.
        public let inputDescriptions: [InputDescription]?
        /// The array of OutputDescription objects describing the destination streams used by the application.
        public let outputDescriptions: [OutputDescription]?
        /// The array of ReferenceDataSourceDescription objects describing the reference data sources used by the application.
        public let referenceDataSourceDescriptions: [ReferenceDataSourceDescription]?

        public init(inputDescriptions: [InputDescription]? = nil, outputDescriptions: [OutputDescription]? = nil, referenceDataSourceDescriptions: [ReferenceDataSourceDescription]? = nil) {
            self.inputDescriptions = inputDescriptions
            self.outputDescriptions = outputDescriptions
            self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case inputDescriptions = "InputDescriptions"
            case outputDescriptions = "OutputDescriptions"
            case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
        }
    }

    public struct SqlApplicationConfigurationUpdate: AWSEncodableShape {
        /// The array of InputUpdate objects describing the new input streams used by the application.
        public let inputUpdates: [InputUpdate]?
        /// The array of OutputUpdate objects describing the new destination streams used by the application.
        public let outputUpdates: [OutputUpdate]?
        /// The array of ReferenceDataSourceUpdate objects describing the new reference data sources used by the application.
        public let referenceDataSourceUpdates: [ReferenceDataSourceUpdate]?

        public init(inputUpdates: [InputUpdate]? = nil, outputUpdates: [OutputUpdate]? = nil, referenceDataSourceUpdates: [ReferenceDataSourceUpdate]? = nil) {
            self.inputUpdates = inputUpdates
            self.outputUpdates = outputUpdates
            self.referenceDataSourceUpdates = referenceDataSourceUpdates
        }

        public func validate(name: String) throws {
            try self.inputUpdates?.forEach {
                try $0.validate(name: "\(name).inputUpdates[]")
            }
            try self.outputUpdates?.forEach {
                try $0.validate(name: "\(name).outputUpdates[]")
            }
            try self.referenceDataSourceUpdates?.forEach {
                try $0.validate(name: "\(name).referenceDataSourceUpdates[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inputUpdates = "InputUpdates"
            case outputUpdates = "OutputUpdates"
            case referenceDataSourceUpdates = "ReferenceDataSourceUpdates"
        }
    }

    public struct SqlRunConfiguration: AWSEncodableShape {
        /// The input source ID. You can get this ID by calling the DescribeApplication operation.
        public let inputId: String
        /// The point at which you want the application to start processing records from the streaming source.
        public let inputStartingPositionConfiguration: InputStartingPositionConfiguration

        public init(inputId: String, inputStartingPositionConfiguration: InputStartingPositionConfiguration) {
            self.inputId = inputId
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.inputId, name: "inputId", parent: name, max: 50)
            try self.validate(self.inputId, name: "inputId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case inputId = "InputId"
            case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        }
    }

    public struct StartApplicationRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.
        public let runConfiguration: RunConfiguration?

        public init(applicationName: String, runConfiguration: RunConfiguration? = nil) {
            self.applicationName = applicationName
            self.runConfiguration = runConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.runConfiguration?.validate(name: "\(name).runConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case runConfiguration = "RunConfiguration"
        }
    }

    public struct StartApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopApplicationRequest: AWSEncodableShape {
        /// The name of the running application to stop.
        public let applicationName: String
        /// Set to true to force the application to stop. If you set Force to true, Kinesis Data Analytics stops the application without taking a snapshot.    Force-stopping your application may lead to data loss or duplication. To prevent data loss or duplicate processing of data during application restarts,  we recommend you to take frequent snapshots of your application.  You can only force stop a Flink-based Kinesis Data Analytics application. You can't force stop a SQL-based Kinesis Data Analytics application. The application must be in the STARTING, UPDATING, STOPPING, AUTOSCALING, or RUNNING status.
        public let force: Bool?

        public init(applicationName: String, force: Bool? = nil) {
            self.applicationName = applicationName
            self.force = force
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case force = "Force"
        }
    }

    public struct StopApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the key-value tag.
        public let key: String
        /// The value of the key-value tag. The value is optional.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the application to assign the tags.
        public let resourceARN: String
        /// The key-value tags to assign to the application.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the Kinesis Data Analytics application from which to remove the tags.
        public let resourceARN: String
        /// A list of keys of tags to remove from the specified application.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "arn:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationMaintenanceConfigurationRequest: AWSEncodableShape {
        /// Describes the application maintenance configuration update.
        public let applicationMaintenanceConfigurationUpdate: ApplicationMaintenanceConfigurationUpdate
        /// The name of the application for which you want to update the maintenance configuration.
        public let applicationName: String

        public init(applicationMaintenanceConfigurationUpdate: ApplicationMaintenanceConfigurationUpdate, applicationName: String) {
            self.applicationMaintenanceConfigurationUpdate = applicationMaintenanceConfigurationUpdate
            self.applicationName = applicationName
        }

        public func validate(name: String) throws {
            try self.applicationMaintenanceConfigurationUpdate.validate(name: "\(name).applicationMaintenanceConfigurationUpdate")
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMaintenanceConfigurationUpdate = "ApplicationMaintenanceConfigurationUpdate"
            case applicationName = "ApplicationName"
        }
    }

    public struct UpdateApplicationMaintenanceConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationARN: String?
        /// The application maintenance configuration description after the update.
        public let applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription?

        public init(applicationARN: String? = nil, applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription? = nil) {
            self.applicationARN = applicationARN
            self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationMaintenanceConfigurationDescription = "ApplicationMaintenanceConfigurationDescription"
        }
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// Describes application configuration updates.
        public let applicationConfigurationUpdate: ApplicationConfigurationUpdate?
        /// The name of the application to update.
        public let applicationName: String
        /// Describes application Amazon CloudWatch logging option updates. You can only update existing CloudWatch logging options with this action. To add a new CloudWatch logging option, use AddApplicationCloudWatchLoggingOption.
        public let cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]?
        /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The current application version ID. You must provide the CurrentApplicationVersionId or the ConditionalToken.You can retrieve the application version ID using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?
        /// Describes updates to the application's starting parameters.
        public let runConfigurationUpdate: RunConfigurationUpdate?
        /// Describes updates to the service execution role.
        public let serviceExecutionRoleUpdate: String?

        public init(applicationConfigurationUpdate: ApplicationConfigurationUpdate? = nil, applicationName: String, cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]? = nil, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil, runConfigurationUpdate: RunConfigurationUpdate? = nil, serviceExecutionRoleUpdate: String? = nil) {
            self.applicationConfigurationUpdate = applicationConfigurationUpdate
            self.applicationName = applicationName
            self.cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
            self.runConfigurationUpdate = runConfigurationUpdate
            self.serviceExecutionRoleUpdate = serviceExecutionRoleUpdate
        }

        public func validate(name: String) throws {
            try self.applicationConfigurationUpdate?.validate(name: "\(name).applicationConfigurationUpdate")
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "[a-zA-Z0-9_.-]+")
            try self.cloudWatchLoggingOptionUpdates?.forEach {
                try $0.validate(name: "\(name).cloudWatchLoggingOptionUpdates[]")
            }
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "[a-zA-Z0-9-_+/=]+")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999_999_999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.runConfigurationUpdate?.validate(name: "\(name).runConfigurationUpdate")
            try self.validate(self.serviceExecutionRoleUpdate, name: "serviceExecutionRoleUpdate", parent: name, max: 2048)
            try self.validate(self.serviceExecutionRoleUpdate, name: "serviceExecutionRoleUpdate", parent: name, min: 1)
            try self.validate(self.serviceExecutionRoleUpdate, name: "serviceExecutionRoleUpdate", parent: name, pattern: "arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationConfigurationUpdate = "ApplicationConfigurationUpdate"
            case applicationName = "ApplicationName"
            case cloudWatchLoggingOptionUpdates = "CloudWatchLoggingOptionUpdates"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case runConfigurationUpdate = "RunConfigurationUpdate"
            case serviceExecutionRoleUpdate = "ServiceExecutionRoleUpdate"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        /// Describes application updates.
        public let applicationDetail: ApplicationDetail

        public init(applicationDetail: ApplicationDetail) {
            self.applicationDetail = applicationDetail
        }

        private enum CodingKeys: String, CodingKey {
            case applicationDetail = "ApplicationDetail"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape {
        /// The array of SecurityGroup  IDs used by the VPC configuration.
        public let securityGroupIds: [String]
        /// The array of Subnet IDs  used by the VPC configuration.
        public let subnetIds: [String]

        public init(securityGroupIds: [String], subnetIds: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 16)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct VpcConfigurationDescription: AWSDecodableShape {
        /// The array of SecurityGroup  IDs used by the VPC configuration.
        public let securityGroupIds: [String]
        /// The array of Subnet  IDs used by the VPC configuration.
        public let subnetIds: [String]
        /// The ID of the VPC configuration.
        public let vpcConfigurationId: String
        /// The ID of the associated VPC.
        public let vpcId: String

        public init(securityGroupIds: [String], subnetIds: [String], vpcConfigurationId: String, vpcId: String) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcConfigurationId = vpcConfigurationId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcConfigurationId = "VpcConfigurationId"
            case vpcId = "VpcId"
        }
    }

    public struct VpcConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to the array of  SecurityGroup IDs used by the VPC configuration.
        public let securityGroupIdUpdates: [String]?
        /// Describes updates to the array of Subnet  IDs  used by the VPC configuration.
        public let subnetIdUpdates: [String]?
        /// Describes an update to the ID of the VPC configuration.
        public let vpcConfigurationId: String

        public init(securityGroupIdUpdates: [String]? = nil, subnetIdUpdates: [String]? = nil, vpcConfigurationId: String) {
            self.securityGroupIdUpdates = securityGroupIdUpdates
            self.subnetIdUpdates = subnetIdUpdates
            self.vpcConfigurationId = vpcConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.securityGroupIdUpdates, name: "securityGroupIdUpdates", parent: name, max: 5)
            try self.validate(self.securityGroupIdUpdates, name: "securityGroupIdUpdates", parent: name, min: 1)
            try self.validate(self.subnetIdUpdates, name: "subnetIdUpdates", parent: name, max: 16)
            try self.validate(self.subnetIdUpdates, name: "subnetIdUpdates", parent: name, min: 1)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, max: 50)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, min: 1)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, pattern: "[a-zA-Z0-9_.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIdUpdates = "SecurityGroupIdUpdates"
            case subnetIdUpdates = "SubnetIdUpdates"
            case vpcConfigurationId = "VpcConfigurationId"
        }
    }

    public struct ZeppelinApplicationConfiguration: AWSEncodableShape {
        /// The AWS Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.
        public let catalogConfiguration: CatalogConfiguration?
        /// Custom artifacts are dependency JARs and user-defined functions (UDF).
        public let customArtifactsConfiguration: [CustomArtifactConfiguration]?
        /// The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state..
        public let deployAsApplicationConfiguration: DeployAsApplicationConfiguration?
        /// The monitoring configuration of a Kinesis Data Analytics Studio notebook.
        public let monitoringConfiguration: ZeppelinMonitoringConfiguration?

        public init(catalogConfiguration: CatalogConfiguration? = nil, customArtifactsConfiguration: [CustomArtifactConfiguration]? = nil, deployAsApplicationConfiguration: DeployAsApplicationConfiguration? = nil, monitoringConfiguration: ZeppelinMonitoringConfiguration? = nil) {
            self.catalogConfiguration = catalogConfiguration
            self.customArtifactsConfiguration = customArtifactsConfiguration
            self.deployAsApplicationConfiguration = deployAsApplicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }

        public func validate(name: String) throws {
            try self.catalogConfiguration?.validate(name: "\(name).catalogConfiguration")
            try self.customArtifactsConfiguration?.forEach {
                try $0.validate(name: "\(name).customArtifactsConfiguration[]")
            }
            try self.validate(self.customArtifactsConfiguration, name: "customArtifactsConfiguration", parent: name, max: 50)
            try self.deployAsApplicationConfiguration?.validate(name: "\(name).deployAsApplicationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogConfiguration = "CatalogConfiguration"
            case customArtifactsConfiguration = "CustomArtifactsConfiguration"
            case deployAsApplicationConfiguration = "DeployAsApplicationConfiguration"
            case monitoringConfiguration = "MonitoringConfiguration"
        }
    }

    public struct ZeppelinApplicationConfigurationDescription: AWSDecodableShape {
        /// The AWS Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.
        public let catalogConfigurationDescription: CatalogConfigurationDescription?
        /// Custom artifacts are dependency JARs and user-defined functions (UDF).
        public let customArtifactsConfigurationDescription: [CustomArtifactConfigurationDescription]?
        /// The parameters required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state..
        public let deployAsApplicationConfigurationDescription: DeployAsApplicationConfigurationDescription?
        /// The monitoring configuration of a Kinesis Data Analytics Studio notebook.
        public let monitoringConfigurationDescription: ZeppelinMonitoringConfigurationDescription

        public init(catalogConfigurationDescription: CatalogConfigurationDescription? = nil, customArtifactsConfigurationDescription: [CustomArtifactConfigurationDescription]? = nil, deployAsApplicationConfigurationDescription: DeployAsApplicationConfigurationDescription? = nil, monitoringConfigurationDescription: ZeppelinMonitoringConfigurationDescription) {
            self.catalogConfigurationDescription = catalogConfigurationDescription
            self.customArtifactsConfigurationDescription = customArtifactsConfigurationDescription
            self.deployAsApplicationConfigurationDescription = deployAsApplicationConfigurationDescription
            self.monitoringConfigurationDescription = monitoringConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case catalogConfigurationDescription = "CatalogConfigurationDescription"
            case customArtifactsConfigurationDescription = "CustomArtifactsConfigurationDescription"
            case deployAsApplicationConfigurationDescription = "DeployAsApplicationConfigurationDescription"
            case monitoringConfigurationDescription = "MonitoringConfigurationDescription"
        }
    }

    public struct ZeppelinApplicationConfigurationUpdate: AWSEncodableShape {
        /// Updates to the configuration of the AWS Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.
        public let catalogConfigurationUpdate: CatalogConfigurationUpdate?
        /// Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).
        public let customArtifactsConfigurationUpdate: [CustomArtifactConfiguration]?
        public let deployAsApplicationConfigurationUpdate: DeployAsApplicationConfigurationUpdate?
        /// Updates to the monitoring configuration of a Kinesis Data Analytics Studio notebook.
        public let monitoringConfigurationUpdate: ZeppelinMonitoringConfigurationUpdate?

        public init(catalogConfigurationUpdate: CatalogConfigurationUpdate? = nil, customArtifactsConfigurationUpdate: [CustomArtifactConfiguration]? = nil, deployAsApplicationConfigurationUpdate: DeployAsApplicationConfigurationUpdate? = nil, monitoringConfigurationUpdate: ZeppelinMonitoringConfigurationUpdate? = nil) {
            self.catalogConfigurationUpdate = catalogConfigurationUpdate
            self.customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdate
            self.deployAsApplicationConfigurationUpdate = deployAsApplicationConfigurationUpdate
            self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
        }

        public func validate(name: String) throws {
            try self.catalogConfigurationUpdate?.validate(name: "\(name).catalogConfigurationUpdate")
            try self.customArtifactsConfigurationUpdate?.forEach {
                try $0.validate(name: "\(name).customArtifactsConfigurationUpdate[]")
            }
            try self.validate(self.customArtifactsConfigurationUpdate, name: "customArtifactsConfigurationUpdate", parent: name, max: 50)
            try self.deployAsApplicationConfigurationUpdate?.validate(name: "\(name).deployAsApplicationConfigurationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogConfigurationUpdate = "CatalogConfigurationUpdate"
            case customArtifactsConfigurationUpdate = "CustomArtifactsConfigurationUpdate"
            case deployAsApplicationConfigurationUpdate = "DeployAsApplicationConfigurationUpdate"
            case monitoringConfigurationUpdate = "MonitoringConfigurationUpdate"
        }
    }

    public struct ZeppelinMonitoringConfiguration: AWSEncodableShape {
        /// The verbosity of the CloudWatch Logs for an application.
        public let logLevel: LogLevel

        public init(logLevel: LogLevel) {
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel = "LogLevel"
        }
    }

    public struct ZeppelinMonitoringConfigurationDescription: AWSDecodableShape {
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public let logLevel: LogLevel?

        public init(logLevel: LogLevel? = nil) {
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel = "LogLevel"
        }
    }

    public struct ZeppelinMonitoringConfigurationUpdate: AWSEncodableShape {
        /// Updates to the logging level for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.
        public let logLevelUpdate: LogLevel

        public init(logLevelUpdate: LogLevel) {
            self.logLevelUpdate = logLevelUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case logLevelUpdate = "LogLevelUpdate"
        }
    }
}
