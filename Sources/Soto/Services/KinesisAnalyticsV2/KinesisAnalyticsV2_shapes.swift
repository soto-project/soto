//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension KinesisAnalyticsV2 {
    // MARK: Enums

    public enum ApplicationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case interactive = "INTERACTIVE"
        case streaming = "STREAMING"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationRestoreType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case restoreFromCustomSnapshot = "RESTORE_FROM_CUSTOM_SNAPSHOT"
        case restoreFromLatestSnapshot = "RESTORE_FROM_LATEST_SNAPSHOT"
        case skipRestoreFromSnapshot = "SKIP_RESTORE_FROM_SNAPSHOT"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoscaling = "AUTOSCALING"
        case deleting = "DELETING"
        case forceStopping = "FORCE_STOPPING"
        case maintenance = "MAINTENANCE"
        case ready = "READY"
        case rolledBack = "ROLLED_BACK"
        case rollingBack = "ROLLING_BACK"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopping = "STOPPING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dependencyJar = "DEPENDENCY_JAR"
        case udf = "UDF"
        public var description: String { return self.rawValue }
    }

    public enum CodeContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plaintext = "PLAINTEXT"
        case zipfile = "ZIPFILE"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum InputStartingPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lastStoppedPoint = "LAST_STOPPED_POINT"
        case now = "NOW"
        case trimHorizon = "TRIM_HORIZON"
        public var description: String { return self.rawValue }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        case error = "ERROR"
        case info = "INFO"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum MetricsLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `operator` = "OPERATOR"
        case application = "APPLICATION"
        case parallelism = "PARALLELISM"
        case task = "TASK"
        public var description: String { return self.rawValue }
    }

    public enum OperationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case successful = "SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum RecordFormatType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum RuntimeEnvironment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case flink111 = "FLINK-1_11"
        case flink113 = "FLINK-1_13"
        case flink115 = "FLINK-1_15"
        case flink118 = "FLINK-1_18"
        case flink119 = "FLINK-1_19"
        case flink120 = "FLINK-1_20"
        case flink16 = "FLINK-1_6"
        case flink18 = "FLINK-1_8"
        case sql10 = "SQL-1_0"
        case zeppelinFlink10 = "ZEPPELIN-FLINK-1_0"
        case zeppelinFlink20 = "ZEPPELIN-FLINK-2_0"
        case zeppelinFlink30 = "ZEPPELIN-FLINK-3_0"
        public var description: String { return self.rawValue }
    }

    public enum SnapshotStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum UrlType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case flinkDashboardUrl = "FLINK_DASHBOARD_URL"
        case zeppelinUiUrl = "ZEPPELIN_UI_URL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddApplicationCloudWatchLoggingOptionRequest: AWSEncodableShape {
        /// The Kinesis Data Analytics application name.
        public let applicationName: String
        /// Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN).
        public let cloudWatchLoggingOption: CloudWatchLoggingOption
        /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The version ID of the SQL-based Kinesis Data Analytics application. You must provide the CurrentApplicationVersionId or the ConditionalToken.You can retrieve the application version ID using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?

        @inlinable
        public init(applicationName: String, cloudWatchLoggingOption: CloudWatchLoggingOption, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil) {
            self.applicationName = applicationName
            self.cloudWatchLoggingOption = cloudWatchLoggingOption
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.cloudWatchLoggingOption.validate(name: "\(name).cloudWatchLoggingOption")
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "^[a-zA-Z0-9-_+/=]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case cloudWatchLoggingOption = "CloudWatchLoggingOption"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
        }
    }

    public struct AddApplicationCloudWatchLoggingOptionResponse: AWSDecodableShape {
        /// The application's ARN.
        public let applicationARN: String?
        /// The new version ID of the SQL-based Kinesis Data Analytics application. Kinesis Data Analytics updates the ApplicationVersionId each time you change the CloudWatch logging options.
        public let applicationVersionId: Int64?
        /// The descriptions of the current CloudWatch logging options for the SQL-based Kinesis Data Analytics application.
        public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?
        /// Operation ID for tracking AddApplicationCloudWatchLoggingOption request
        public let operationId: String?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil, operationId: String? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
            case operationId = "OperationId"
        }
    }

    public struct AddApplicationInputProcessingConfigurationRequest: AWSEncodableShape {
        /// The name of the application to which you want to add the input processing configuration.
        public let applicationName: String
        /// The version of the application to which you want to add the input processing configuration. You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The ID of the input configuration to add the input processing configuration to. You can get a list of the input IDs for an application using the DescribeApplication operation.
        public let inputId: String
        /// The InputProcessingConfiguration to add to the application.
        public let inputProcessingConfiguration: InputProcessingConfiguration

        @inlinable
        public init(applicationName: String, currentApplicationVersionId: Int64, inputId: String, inputProcessingConfiguration: InputProcessingConfiguration) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.inputId = inputId
            self.inputProcessingConfiguration = inputProcessingConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, max: 50)
            try self.validate(self.inputId, name: "inputId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.inputProcessingConfiguration.validate(name: "\(name).inputProcessingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case inputId = "InputId"
            case inputProcessingConfiguration = "InputProcessingConfiguration"
        }
    }

    public struct AddApplicationInputProcessingConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationARN: String?
        /// Provides the current application version.
        public let applicationVersionId: Int64?
        /// The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input configuration that you add to your application.
        public let inputId: String?
        /// The description of the preprocessor that executes on records in this input before the application's code is run.
        public let inputProcessingConfigurationDescription: InputProcessingConfigurationDescription?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, inputId: String? = nil, inputProcessingConfigurationDescription: InputProcessingConfigurationDescription? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.inputId = inputId
            self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case inputId = "InputId"
            case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
        }
    }

    public struct AddApplicationInputRequest: AWSEncodableShape {
        /// The name of your existing application to which you want to add the streaming source.
        public let applicationName: String
        /// The current version of your application.  You must provide the ApplicationVersionID or the ConditionalToken.You can use the DescribeApplication operation to find the current application version.
        public let currentApplicationVersionId: Int64
        /// The Input to add.
        public let input: Input

        @inlinable
        public init(applicationName: String, currentApplicationVersionId: Int64, input: Input) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.input = input
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.input.validate(name: "\(name).input")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case input = "Input"
        }
    }

    public struct AddApplicationInputResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationARN: String?
        /// Provides the current application version.
        public let applicationVersionId: Int64?
        /// Describes the application input configuration.
        public let inputDescriptions: [InputDescription]?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, inputDescriptions: [InputDescription]? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.inputDescriptions = inputDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case inputDescriptions = "InputDescriptions"
        }
    }

    public struct AddApplicationOutputRequest: AWSEncodableShape {
        /// The name of the application to which you want to add the output configuration.
        public let applicationName: String
        /// The version of the application to which you want to add the output configuration. You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// An array of objects, each describing one output configuration. In the output configuration, you specify the name of an in-application stream, a destination (that is, a Kinesis data stream, a Kinesis Data Firehose delivery stream, or an Amazon Lambda function), and record the formation to use when writing to the destination.
        public let output: Output

        @inlinable
        public init(applicationName: String, currentApplicationVersionId: Int64, output: Output) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.output = output
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.output.validate(name: "\(name).output")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case output = "Output"
        }
    }

    public struct AddApplicationOutputResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The updated application version ID. Kinesis Data Analytics increments this ID when the application is updated.
        public let applicationVersionId: Int64?
        /// Describes the application output configuration. For more information,  see Configuring Application Output.
        public let outputDescriptions: [OutputDescription]?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, outputDescriptions: [OutputDescription]? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.outputDescriptions = outputDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case outputDescriptions = "OutputDescriptions"
        }
    }

    public struct AddApplicationReferenceDataSourceRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The version of the application for which you are adding the reference data source.  You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting  in-application table that is  created.
        public let referenceDataSource: ReferenceDataSource

        @inlinable
        public init(applicationName: String, currentApplicationVersionId: Int64, referenceDataSource: ReferenceDataSource) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.referenceDataSource = referenceDataSource
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.referenceDataSource.validate(name: "\(name).referenceDataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case referenceDataSource = "ReferenceDataSource"
        }
    }

    public struct AddApplicationReferenceDataSourceResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The updated application version ID. Kinesis Data Analytics increments this ID when the application is updated.
        public let applicationVersionId: Int64?
        /// Describes reference data sources configured for the application.
        public let referenceDataSourceDescriptions: [ReferenceDataSourceDescription]?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, referenceDataSourceDescriptions: [ReferenceDataSourceDescription]? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
        }
    }

    public struct AddApplicationVpcConfigurationRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// A value you use to implement strong concurrency for application updates. You must provide the ApplicationVersionID or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The version of the application to which you want to add the VPC configuration. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?
        /// Description of the VPC to add to the application.
        public let vpcConfiguration: VpcConfiguration

        @inlinable
        public init(applicationName: String, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil, vpcConfiguration: VpcConfiguration) {
            self.applicationName = applicationName
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "^[a-zA-Z0-9-_+/=]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.vpcConfiguration.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct AddApplicationVpcConfigurationResponse: AWSDecodableShape {
        /// The ARN of the application.
        public let applicationARN: String?
        /// Provides the current application version. Managed Service for Apache Flink updates the ApplicationVersionId each time you update the application.
        public let applicationVersionId: Int64?
        /// Operation ID for tracking AddApplicationVpcConfiguration request
        public let operationId: String?
        /// The parameters of the new VPC configuration.
        public let vpcConfigurationDescription: VpcConfigurationDescription?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, operationId: String? = nil, vpcConfigurationDescription: VpcConfigurationDescription? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.operationId = operationId
            self.vpcConfigurationDescription = vpcConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case operationId = "OperationId"
            case vpcConfigurationDescription = "VpcConfigurationDescription"
        }
    }

    public struct ApplicationCodeConfiguration: AWSEncodableShape {
        /// The location and type of the application code.
        public let codeContent: CodeContent?
        /// Specifies whether the code content is in text or zip format.
        public let codeContentType: CodeContentType

        @inlinable
        public init(codeContent: CodeContent? = nil, codeContentType: CodeContentType) {
            self.codeContent = codeContent
            self.codeContentType = codeContentType
        }

        public func validate(name: String) throws {
            try self.codeContent?.validate(name: "\(name).codeContent")
        }

        private enum CodingKeys: String, CodingKey {
            case codeContent = "CodeContent"
            case codeContentType = "CodeContentType"
        }
    }

    public struct ApplicationCodeConfigurationDescription: AWSDecodableShape {
        /// Describes details about the location and format of the application code.
        public let codeContentDescription: CodeContentDescription?
        /// Specifies whether the code content is in text or zip format.
        public let codeContentType: CodeContentType

        @inlinable
        public init(codeContentDescription: CodeContentDescription? = nil, codeContentType: CodeContentType) {
            self.codeContentDescription = codeContentDescription
            self.codeContentType = codeContentType
        }

        private enum CodingKeys: String, CodingKey {
            case codeContentDescription = "CodeContentDescription"
            case codeContentType = "CodeContentType"
        }
    }

    public struct ApplicationCodeConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to the code content type.
        public let codeContentTypeUpdate: CodeContentType?
        /// Describes updates to the code content of an application.
        public let codeContentUpdate: CodeContentUpdate?

        @inlinable
        public init(codeContentTypeUpdate: CodeContentType? = nil, codeContentUpdate: CodeContentUpdate? = nil) {
            self.codeContentTypeUpdate = codeContentTypeUpdate
            self.codeContentUpdate = codeContentUpdate
        }

        public func validate(name: String) throws {
            try self.codeContentUpdate?.validate(name: "\(name).codeContentUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case codeContentTypeUpdate = "CodeContentTypeUpdate"
            case codeContentUpdate = "CodeContentUpdate"
        }
    }

    public struct ApplicationConfiguration: AWSEncodableShape {
        /// The code location and type parameters for a Managed Service for Apache Flink application.
        public let applicationCodeConfiguration: ApplicationCodeConfiguration?
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        public let applicationSnapshotConfiguration: ApplicationSnapshotConfiguration?
        public let applicationSystemRollbackConfiguration: ApplicationSystemRollbackConfiguration?
        /// Describes execution properties for a Managed Service for Apache Flink application.
        public let environmentProperties: EnvironmentProperties?
        /// The creation and update parameters for a Managed Service for Apache Flink application.
        public let flinkApplicationConfiguration: FlinkApplicationConfiguration?
        /// The creation and update parameters for a SQL-based Kinesis Data Analytics application.
        public let sqlApplicationConfiguration: SqlApplicationConfiguration?
        /// The array of descriptions of VPC configurations available to the application.
        public let vpcConfigurations: [VpcConfiguration]?
        /// The configuration parameters for a Managed Service for Apache Flink Studio notebook.
        public let zeppelinApplicationConfiguration: ZeppelinApplicationConfiguration?

        @inlinable
        public init(applicationCodeConfiguration: ApplicationCodeConfiguration? = nil, applicationSnapshotConfiguration: ApplicationSnapshotConfiguration? = nil, applicationSystemRollbackConfiguration: ApplicationSystemRollbackConfiguration? = nil, environmentProperties: EnvironmentProperties? = nil, flinkApplicationConfiguration: FlinkApplicationConfiguration? = nil, sqlApplicationConfiguration: SqlApplicationConfiguration? = nil, vpcConfigurations: [VpcConfiguration]? = nil, zeppelinApplicationConfiguration: ZeppelinApplicationConfiguration? = nil) {
            self.applicationCodeConfiguration = applicationCodeConfiguration
            self.applicationSnapshotConfiguration = applicationSnapshotConfiguration
            self.applicationSystemRollbackConfiguration = applicationSystemRollbackConfiguration
            self.environmentProperties = environmentProperties
            self.flinkApplicationConfiguration = flinkApplicationConfiguration
            self.sqlApplicationConfiguration = sqlApplicationConfiguration
            self.vpcConfigurations = vpcConfigurations
            self.zeppelinApplicationConfiguration = zeppelinApplicationConfiguration
        }

        public func validate(name: String) throws {
            try self.applicationCodeConfiguration?.validate(name: "\(name).applicationCodeConfiguration")
            try self.environmentProperties?.validate(name: "\(name).environmentProperties")
            try self.flinkApplicationConfiguration?.validate(name: "\(name).flinkApplicationConfiguration")
            try self.sqlApplicationConfiguration?.validate(name: "\(name).sqlApplicationConfiguration")
            try self.vpcConfigurations?.forEach {
                try $0.validate(name: "\(name).vpcConfigurations[]")
            }
            try self.zeppelinApplicationConfiguration?.validate(name: "\(name).zeppelinApplicationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCodeConfiguration = "ApplicationCodeConfiguration"
            case applicationSnapshotConfiguration = "ApplicationSnapshotConfiguration"
            case applicationSystemRollbackConfiguration = "ApplicationSystemRollbackConfiguration"
            case environmentProperties = "EnvironmentProperties"
            case flinkApplicationConfiguration = "FlinkApplicationConfiguration"
            case sqlApplicationConfiguration = "SqlApplicationConfiguration"
            case vpcConfigurations = "VpcConfigurations"
            case zeppelinApplicationConfiguration = "ZeppelinApplicationConfiguration"
        }
    }

    public struct ApplicationConfigurationDescription: AWSDecodableShape {
        /// The details about the application code for a Managed Service for Apache Flink application.
        public let applicationCodeConfigurationDescription: ApplicationCodeConfigurationDescription?
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        public let applicationSnapshotConfigurationDescription: ApplicationSnapshotConfigurationDescription?
        public let applicationSystemRollbackConfigurationDescription: ApplicationSystemRollbackConfigurationDescription?
        /// Describes execution properties for a Managed Service for Apache Flink application.
        public let environmentPropertyDescriptions: EnvironmentPropertyDescriptions?
        /// The details about a Managed Service for Apache Flink application.
        public let flinkApplicationConfigurationDescription: FlinkApplicationConfigurationDescription?
        /// The details about the starting properties for a Managed Service for Apache Flink application.
        public let runConfigurationDescription: RunConfigurationDescription?
        /// The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
        public let sqlApplicationConfigurationDescription: SqlApplicationConfigurationDescription?
        /// The array of descriptions of VPC configurations available to the application.
        public let vpcConfigurationDescriptions: [VpcConfigurationDescription]?
        /// The configuration parameters for a Managed Service for Apache Flink Studio notebook.
        public let zeppelinApplicationConfigurationDescription: ZeppelinApplicationConfigurationDescription?

        @inlinable
        public init(applicationCodeConfigurationDescription: ApplicationCodeConfigurationDescription? = nil, applicationSnapshotConfigurationDescription: ApplicationSnapshotConfigurationDescription? = nil, applicationSystemRollbackConfigurationDescription: ApplicationSystemRollbackConfigurationDescription? = nil, environmentPropertyDescriptions: EnvironmentPropertyDescriptions? = nil, flinkApplicationConfigurationDescription: FlinkApplicationConfigurationDescription? = nil, runConfigurationDescription: RunConfigurationDescription? = nil, sqlApplicationConfigurationDescription: SqlApplicationConfigurationDescription? = nil, vpcConfigurationDescriptions: [VpcConfigurationDescription]? = nil, zeppelinApplicationConfigurationDescription: ZeppelinApplicationConfigurationDescription? = nil) {
            self.applicationCodeConfigurationDescription = applicationCodeConfigurationDescription
            self.applicationSnapshotConfigurationDescription = applicationSnapshotConfigurationDescription
            self.applicationSystemRollbackConfigurationDescription = applicationSystemRollbackConfigurationDescription
            self.environmentPropertyDescriptions = environmentPropertyDescriptions
            self.flinkApplicationConfigurationDescription = flinkApplicationConfigurationDescription
            self.runConfigurationDescription = runConfigurationDescription
            self.sqlApplicationConfigurationDescription = sqlApplicationConfigurationDescription
            self.vpcConfigurationDescriptions = vpcConfigurationDescriptions
            self.zeppelinApplicationConfigurationDescription = zeppelinApplicationConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCodeConfigurationDescription = "ApplicationCodeConfigurationDescription"
            case applicationSnapshotConfigurationDescription = "ApplicationSnapshotConfigurationDescription"
            case applicationSystemRollbackConfigurationDescription = "ApplicationSystemRollbackConfigurationDescription"
            case environmentPropertyDescriptions = "EnvironmentPropertyDescriptions"
            case flinkApplicationConfigurationDescription = "FlinkApplicationConfigurationDescription"
            case runConfigurationDescription = "RunConfigurationDescription"
            case sqlApplicationConfigurationDescription = "SqlApplicationConfigurationDescription"
            case vpcConfigurationDescriptions = "VpcConfigurationDescriptions"
            case zeppelinApplicationConfigurationDescription = "ZeppelinApplicationConfigurationDescription"
        }
    }

    public struct ApplicationConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to an application's code configuration.
        public let applicationCodeConfigurationUpdate: ApplicationCodeConfigurationUpdate?
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        public let applicationSnapshotConfigurationUpdate: ApplicationSnapshotConfigurationUpdate?
        public let applicationSystemRollbackConfigurationUpdate: ApplicationSystemRollbackConfigurationUpdate?
        /// Describes updates to the environment properties for a Managed Service for Apache Flink application.
        public let environmentPropertyUpdates: EnvironmentPropertyUpdates?
        /// Describes updates to a Managed Service for Apache Flink application's configuration.
        public let flinkApplicationConfigurationUpdate: FlinkApplicationConfigurationUpdate?
        /// Describes updates to a SQL-based Kinesis Data Analytics application's configuration.
        public let sqlApplicationConfigurationUpdate: SqlApplicationConfigurationUpdate?
        /// Updates to the array of descriptions of VPC configurations available to the application.
        public let vpcConfigurationUpdates: [VpcConfigurationUpdate]?
        /// Updates to the configuration of a Managed Service for Apache Flink Studio notebook.
        public let zeppelinApplicationConfigurationUpdate: ZeppelinApplicationConfigurationUpdate?

        @inlinable
        public init(applicationCodeConfigurationUpdate: ApplicationCodeConfigurationUpdate? = nil, applicationSnapshotConfigurationUpdate: ApplicationSnapshotConfigurationUpdate? = nil, applicationSystemRollbackConfigurationUpdate: ApplicationSystemRollbackConfigurationUpdate? = nil, environmentPropertyUpdates: EnvironmentPropertyUpdates? = nil, flinkApplicationConfigurationUpdate: FlinkApplicationConfigurationUpdate? = nil, sqlApplicationConfigurationUpdate: SqlApplicationConfigurationUpdate? = nil, vpcConfigurationUpdates: [VpcConfigurationUpdate]? = nil, zeppelinApplicationConfigurationUpdate: ZeppelinApplicationConfigurationUpdate? = nil) {
            self.applicationCodeConfigurationUpdate = applicationCodeConfigurationUpdate
            self.applicationSnapshotConfigurationUpdate = applicationSnapshotConfigurationUpdate
            self.applicationSystemRollbackConfigurationUpdate = applicationSystemRollbackConfigurationUpdate
            self.environmentPropertyUpdates = environmentPropertyUpdates
            self.flinkApplicationConfigurationUpdate = flinkApplicationConfigurationUpdate
            self.sqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdate
            self.vpcConfigurationUpdates = vpcConfigurationUpdates
            self.zeppelinApplicationConfigurationUpdate = zeppelinApplicationConfigurationUpdate
        }

        public func validate(name: String) throws {
            try self.applicationCodeConfigurationUpdate?.validate(name: "\(name).applicationCodeConfigurationUpdate")
            try self.environmentPropertyUpdates?.validate(name: "\(name).environmentPropertyUpdates")
            try self.flinkApplicationConfigurationUpdate?.validate(name: "\(name).flinkApplicationConfigurationUpdate")
            try self.sqlApplicationConfigurationUpdate?.validate(name: "\(name).sqlApplicationConfigurationUpdate")
            try self.vpcConfigurationUpdates?.forEach {
                try $0.validate(name: "\(name).vpcConfigurationUpdates[]")
            }
            try self.zeppelinApplicationConfigurationUpdate?.validate(name: "\(name).zeppelinApplicationConfigurationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCodeConfigurationUpdate = "ApplicationCodeConfigurationUpdate"
            case applicationSnapshotConfigurationUpdate = "ApplicationSnapshotConfigurationUpdate"
            case applicationSystemRollbackConfigurationUpdate = "ApplicationSystemRollbackConfigurationUpdate"
            case environmentPropertyUpdates = "EnvironmentPropertyUpdates"
            case flinkApplicationConfigurationUpdate = "FlinkApplicationConfigurationUpdate"
            case sqlApplicationConfigurationUpdate = "SqlApplicationConfigurationUpdate"
            case vpcConfigurationUpdates = "VpcConfigurationUpdates"
            case zeppelinApplicationConfigurationUpdate = "ZeppelinApplicationConfigurationUpdate"
        }
    }

    public struct ApplicationDetail: AWSDecodableShape {
        /// The ARN of the application.
        public let applicationARN: String
        /// Describes details about the application code and starting parameters for a Managed Service for Apache Flink application.
        public let applicationConfigurationDescription: ApplicationConfigurationDescription?
        /// The description of the application.
        public let applicationDescription: String?
        /// The details of the maintenance configuration for the application.
        public let applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription?
        /// To create a Managed Service for Apache Flink Studio notebook, you must set the mode to INTERACTIVE. However, for a Managed Service for Apache Flink application, the mode is optional.
        public let applicationMode: ApplicationMode?
        /// The name of the application.
        public let applicationName: String
        /// The status of the application.
        public let applicationStatus: ApplicationStatus
        /// The current timestamp when the application version was created.
        public let applicationVersionCreateTimestamp: Date?
        /// Provides the current application version. Managed Service for Apache Flink updates the ApplicationVersionId each time you update the application.
        public let applicationVersionId: Int64
        /// If you reverted the application using RollbackApplication, the application version when RollbackApplication was called.
        public let applicationVersionRolledBackFrom: Int64?
        /// The version to which you want to roll back the application.
        public let applicationVersionRolledBackTo: Int64?
        /// The previous application version before the latest application update. RollbackApplication reverts the application to this version.
        public let applicationVersionUpdatedFrom: Int64?
        /// Describes the application Amazon CloudWatch logging options.
        public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?
        /// A value you use to implement strong concurrency for application updates.
        public let conditionalToken: String?
        /// The current timestamp when the application was created.
        public let createTimestamp: Date?
        /// The current timestamp when the application was last updated.
        public let lastUpdateTimestamp: Date?
        /// The runtime environment for the application.
        public let runtimeEnvironment: RuntimeEnvironment
        /// Specifies the IAM role that the application uses to access external resources.
        public let serviceExecutionRole: String?

        @inlinable
        public init(applicationARN: String, applicationConfigurationDescription: ApplicationConfigurationDescription? = nil, applicationDescription: String? = nil, applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription? = nil, applicationMode: ApplicationMode? = nil, applicationName: String, applicationStatus: ApplicationStatus, applicationVersionCreateTimestamp: Date? = nil, applicationVersionId: Int64, applicationVersionRolledBackFrom: Int64? = nil, applicationVersionRolledBackTo: Int64? = nil, applicationVersionUpdatedFrom: Int64? = nil, cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil, conditionalToken: String? = nil, createTimestamp: Date? = nil, lastUpdateTimestamp: Date? = nil, runtimeEnvironment: RuntimeEnvironment, serviceExecutionRole: String? = nil) {
            self.applicationARN = applicationARN
            self.applicationConfigurationDescription = applicationConfigurationDescription
            self.applicationDescription = applicationDescription
            self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionCreateTimestamp = applicationVersionCreateTimestamp
            self.applicationVersionId = applicationVersionId
            self.applicationVersionRolledBackFrom = applicationVersionRolledBackFrom
            self.applicationVersionRolledBackTo = applicationVersionRolledBackTo
            self.applicationVersionUpdatedFrom = applicationVersionUpdatedFrom
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
            self.conditionalToken = conditionalToken
            self.createTimestamp = createTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.runtimeEnvironment = runtimeEnvironment
            self.serviceExecutionRole = serviceExecutionRole
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationConfigurationDescription = "ApplicationConfigurationDescription"
            case applicationDescription = "ApplicationDescription"
            case applicationMaintenanceConfigurationDescription = "ApplicationMaintenanceConfigurationDescription"
            case applicationMode = "ApplicationMode"
            case applicationName = "ApplicationName"
            case applicationStatus = "ApplicationStatus"
            case applicationVersionCreateTimestamp = "ApplicationVersionCreateTimestamp"
            case applicationVersionId = "ApplicationVersionId"
            case applicationVersionRolledBackFrom = "ApplicationVersionRolledBackFrom"
            case applicationVersionRolledBackTo = "ApplicationVersionRolledBackTo"
            case applicationVersionUpdatedFrom = "ApplicationVersionUpdatedFrom"
            case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
            case conditionalToken = "ConditionalToken"
            case createTimestamp = "CreateTimestamp"
            case lastUpdateTimestamp = "LastUpdateTimestamp"
            case runtimeEnvironment = "RuntimeEnvironment"
            case serviceExecutionRole = "ServiceExecutionRole"
        }
    }

    public struct ApplicationMaintenanceConfigurationDescription: AWSDecodableShape {
        /// The end time for the maintenance window.
        public let applicationMaintenanceWindowEndTime: String
        /// The start time for the maintenance window.
        public let applicationMaintenanceWindowStartTime: String

        @inlinable
        public init(applicationMaintenanceWindowEndTime: String, applicationMaintenanceWindowStartTime: String) {
            self.applicationMaintenanceWindowEndTime = applicationMaintenanceWindowEndTime
            self.applicationMaintenanceWindowStartTime = applicationMaintenanceWindowStartTime
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMaintenanceWindowEndTime = "ApplicationMaintenanceWindowEndTime"
            case applicationMaintenanceWindowStartTime = "ApplicationMaintenanceWindowStartTime"
        }
    }

    public struct ApplicationMaintenanceConfigurationUpdate: AWSEncodableShape {
        /// The updated start time for the maintenance window.
        public let applicationMaintenanceWindowStartTimeUpdate: String

        @inlinable
        public init(applicationMaintenanceWindowStartTimeUpdate: String) {
            self.applicationMaintenanceWindowStartTimeUpdate = applicationMaintenanceWindowStartTimeUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationMaintenanceWindowStartTimeUpdate, name: "applicationMaintenanceWindowStartTimeUpdate", parent: name, max: 5)
            try self.validate(self.applicationMaintenanceWindowStartTimeUpdate, name: "applicationMaintenanceWindowStartTimeUpdate", parent: name, min: 5)
            try self.validate(self.applicationMaintenanceWindowStartTimeUpdate, name: "applicationMaintenanceWindowStartTimeUpdate", parent: name, pattern: "^([01][0-9]|2[0-3]):[0-5][0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMaintenanceWindowStartTimeUpdate = "ApplicationMaintenanceWindowStartTimeUpdate"
        }
    }

    public struct ApplicationOperationInfo: AWSDecodableShape {
        /// The timestamp at which the operation finished for the application
        public let endTime: Date?
        public let operation: String?
        public let operationId: String?
        public let operationStatus: OperationStatus?
        /// The timestamp at which the operation was created
        public let startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, operation: String? = nil, operationId: String? = nil, operationStatus: OperationStatus? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.operation = operation
            self.operationId = operationId
            self.operationStatus = operationStatus
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case operation = "Operation"
            case operationId = "OperationId"
            case operationStatus = "OperationStatus"
            case startTime = "StartTime"
        }
    }

    public struct ApplicationOperationInfoDetails: AWSDecodableShape {
        public let applicationVersionChangeDetails: ApplicationVersionChangeDetails?
        /// The timestamp at which the operation finished for the application
        public let endTime: Date
        public let operation: String
        public let operationFailureDetails: OperationFailureDetails?
        public let operationStatus: OperationStatus
        /// The timestamp at which the operation was created
        public let startTime: Date

        @inlinable
        public init(applicationVersionChangeDetails: ApplicationVersionChangeDetails? = nil, endTime: Date, operation: String, operationFailureDetails: OperationFailureDetails? = nil, operationStatus: OperationStatus, startTime: Date) {
            self.applicationVersionChangeDetails = applicationVersionChangeDetails
            self.endTime = endTime
            self.operation = operation
            self.operationFailureDetails = operationFailureDetails
            self.operationStatus = operationStatus
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersionChangeDetails = "ApplicationVersionChangeDetails"
            case endTime = "EndTime"
            case operation = "Operation"
            case operationFailureDetails = "OperationFailureDetails"
            case operationStatus = "OperationStatus"
            case startTime = "StartTime"
        }
    }

    public struct ApplicationRestoreConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how the application should be restored.
        public let applicationRestoreType: ApplicationRestoreType
        /// The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for the  ApplicationRestoreType.
        public let snapshotName: String?

        @inlinable
        public init(applicationRestoreType: ApplicationRestoreType, snapshotName: String? = nil) {
            self.applicationRestoreType = applicationRestoreType
            self.snapshotName = snapshotName
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 256)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationRestoreType = "ApplicationRestoreType"
            case snapshotName = "SnapshotName"
        }
    }

    public struct ApplicationSnapshotConfiguration: AWSEncodableShape {
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        public let snapshotsEnabled: Bool

        @inlinable
        public init(snapshotsEnabled: Bool) {
            self.snapshotsEnabled = snapshotsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotsEnabled = "SnapshotsEnabled"
        }
    }

    public struct ApplicationSnapshotConfigurationDescription: AWSDecodableShape {
        /// Describes whether snapshots are enabled for a Managed Service for Apache Flink application.
        public let snapshotsEnabled: Bool

        @inlinable
        public init(snapshotsEnabled: Bool) {
            self.snapshotsEnabled = snapshotsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotsEnabled = "SnapshotsEnabled"
        }
    }

    public struct ApplicationSnapshotConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to whether snapshots are enabled for an application.
        public let snapshotsEnabledUpdate: Bool

        @inlinable
        public init(snapshotsEnabledUpdate: Bool) {
            self.snapshotsEnabledUpdate = snapshotsEnabledUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotsEnabledUpdate = "SnapshotsEnabledUpdate"
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// The ARN of the application.
        public let applicationARN: String
        /// For a Managed Service for Apache Flink application, the mode is STREAMING. For a Managed Service for Apache Flink Studio notebook, it is INTERACTIVE.
        public let applicationMode: ApplicationMode?
        /// The name of the application.
        public let applicationName: String
        /// The status of the application.
        public let applicationStatus: ApplicationStatus
        /// Provides the current application version.
        public let applicationVersionId: Int64
        /// The runtime environment for the application.
        public let runtimeEnvironment: RuntimeEnvironment

        @inlinable
        public init(applicationARN: String, applicationMode: ApplicationMode? = nil, applicationName: String, applicationStatus: ApplicationStatus, applicationVersionId: Int64, runtimeEnvironment: RuntimeEnvironment) {
            self.applicationARN = applicationARN
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
            self.runtimeEnvironment = runtimeEnvironment
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationMode = "ApplicationMode"
            case applicationName = "ApplicationName"
            case applicationStatus = "ApplicationStatus"
            case applicationVersionId = "ApplicationVersionId"
            case runtimeEnvironment = "RuntimeEnvironment"
        }
    }

    public struct ApplicationSystemRollbackConfiguration: AWSEncodableShape {
        /// Describes whether system rollbacks are enabled for a Managed Service for Apache Flink application
        public let rollbackEnabled: Bool

        @inlinable
        public init(rollbackEnabled: Bool) {
            self.rollbackEnabled = rollbackEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case rollbackEnabled = "RollbackEnabled"
        }
    }

    public struct ApplicationSystemRollbackConfigurationDescription: AWSDecodableShape {
        /// Describes whether system rollbacks are enabled for a Managed Service for Apache Flink application
        public let rollbackEnabled: Bool

        @inlinable
        public init(rollbackEnabled: Bool) {
            self.rollbackEnabled = rollbackEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case rollbackEnabled = "RollbackEnabled"
        }
    }

    public struct ApplicationSystemRollbackConfigurationUpdate: AWSEncodableShape {
        /// Describes whether system rollbacks are enabled for a Managed Service for Apache Flink application
        public let rollbackEnabledUpdate: Bool

        @inlinable
        public init(rollbackEnabledUpdate: Bool) {
            self.rollbackEnabledUpdate = rollbackEnabledUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case rollbackEnabledUpdate = "RollbackEnabledUpdate"
        }
    }

    public struct ApplicationVersionChangeDetails: AWSDecodableShape {
        /// The operation was performed on this version of the application
        public let applicationVersionUpdatedFrom: Int64
        /// The operation execution resulted in the transition to the following version of the application
        public let applicationVersionUpdatedTo: Int64

        @inlinable
        public init(applicationVersionUpdatedFrom: Int64, applicationVersionUpdatedTo: Int64) {
            self.applicationVersionUpdatedFrom = applicationVersionUpdatedFrom
            self.applicationVersionUpdatedTo = applicationVersionUpdatedTo
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersionUpdatedFrom = "ApplicationVersionUpdatedFrom"
            case applicationVersionUpdatedTo = "ApplicationVersionUpdatedTo"
        }
    }

    public struct ApplicationVersionSummary: AWSDecodableShape {
        /// The status of the application.
        public let applicationStatus: ApplicationStatus
        /// The ID of the application version. Managed Service for Apache Flink updates the ApplicationVersionId each time you update the application.
        public let applicationVersionId: Int64

        @inlinable
        public init(applicationStatus: ApplicationStatus, applicationVersionId: Int64) {
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationStatus = "ApplicationStatus"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct CSVMappingParameters: AWSEncodableShape & AWSDecodableShape {
        /// The column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
        public let recordColumnDelimiter: String
        /// The row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
        public let recordRowDelimiter: String

        @inlinable
        public init(recordColumnDelimiter: String, recordRowDelimiter: String) {
            self.recordColumnDelimiter = recordColumnDelimiter
            self.recordRowDelimiter = recordRowDelimiter
        }

        public func validate(name: String) throws {
            try self.validate(self.recordColumnDelimiter, name: "recordColumnDelimiter", parent: name, max: 1024)
            try self.validate(self.recordColumnDelimiter, name: "recordColumnDelimiter", parent: name, min: 1)
            try self.validate(self.recordRowDelimiter, name: "recordRowDelimiter", parent: name, max: 1024)
            try self.validate(self.recordRowDelimiter, name: "recordRowDelimiter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recordColumnDelimiter = "RecordColumnDelimiter"
            case recordRowDelimiter = "RecordRowDelimiter"
        }
    }

    public struct CatalogConfiguration: AWSEncodableShape {
        /// The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Managed Service for Apache Flink Studio notebook.
        public let glueDataCatalogConfiguration: GlueDataCatalogConfiguration

        @inlinable
        public init(glueDataCatalogConfiguration: GlueDataCatalogConfiguration) {
            self.glueDataCatalogConfiguration = glueDataCatalogConfiguration
        }

        public func validate(name: String) throws {
            try self.glueDataCatalogConfiguration.validate(name: "\(name).glueDataCatalogConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case glueDataCatalogConfiguration = "GlueDataCatalogConfiguration"
        }
    }

    public struct CatalogConfigurationDescription: AWSDecodableShape {
        /// The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Managed Service for Apache Flink Studio notebook.
        public let glueDataCatalogConfigurationDescription: GlueDataCatalogConfigurationDescription

        @inlinable
        public init(glueDataCatalogConfigurationDescription: GlueDataCatalogConfigurationDescription) {
            self.glueDataCatalogConfigurationDescription = glueDataCatalogConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case glueDataCatalogConfigurationDescription = "GlueDataCatalogConfigurationDescription"
        }
    }

    public struct CatalogConfigurationUpdate: AWSEncodableShape {
        /// Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Managed Service for Apache Flink Studio notebook.
        public let glueDataCatalogConfigurationUpdate: GlueDataCatalogConfigurationUpdate

        @inlinable
        public init(glueDataCatalogConfigurationUpdate: GlueDataCatalogConfigurationUpdate) {
            self.glueDataCatalogConfigurationUpdate = glueDataCatalogConfigurationUpdate
        }

        public func validate(name: String) throws {
            try self.glueDataCatalogConfigurationUpdate.validate(name: "\(name).glueDataCatalogConfigurationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case glueDataCatalogConfigurationUpdate = "GlueDataCatalogConfigurationUpdate"
        }
    }

    public struct CheckpointConfiguration: AWSEncodableShape {
        /// Describes whether checkpointing is enabled for a Managed Service for Apache Flink application.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value  is set to another value using this API or in application code.
        public let checkpointingEnabled: Bool?
        /// Describes the interval in milliseconds between checkpoint operations.   If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set  to another value using this API or in application code.
        public let checkpointInterval: Int64?
        /// Describes whether the application uses Managed Service for Apache Flink' default checkpointing behavior.  You must set this property to CUSTOM in order to set the CheckpointingEnabled, CheckpointInterval, or MinPauseBetweenCheckpoints parameters.  If this value is set to DEFAULT, the application will use the following values, even if they are set to other values using APIs or application code:    CheckpointingEnabled: true    CheckpointInterval: 60000    MinPauseBetweenCheckpoints: 5000
        public let configurationType: ConfigurationType
        /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If a checkpoint operation takes longer than the CheckpointInterval, the application otherwise performs continual checkpoint operations. For more information, see  Tuning Checkpointing in the Apache Flink Documentation.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this  API or in application code.
        public let minPauseBetweenCheckpoints: Int64?

        @inlinable
        public init(checkpointingEnabled: Bool? = nil, checkpointInterval: Int64? = nil, configurationType: ConfigurationType, minPauseBetweenCheckpoints: Int64? = nil) {
            self.checkpointingEnabled = checkpointingEnabled
            self.checkpointInterval = checkpointInterval
            self.configurationType = configurationType
            self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
        }

        public func validate(name: String) throws {
            try self.validate(self.checkpointInterval, name: "checkpointInterval", parent: name, min: 1)
            try self.validate(self.minPauseBetweenCheckpoints, name: "minPauseBetweenCheckpoints", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointingEnabled = "CheckpointingEnabled"
            case checkpointInterval = "CheckpointInterval"
            case configurationType = "ConfigurationType"
            case minPauseBetweenCheckpoints = "MinPauseBetweenCheckpoints"
        }
    }

    public struct CheckpointConfigurationDescription: AWSDecodableShape {
        /// Describes whether checkpointing is enabled for a Managed Service for Apache Flink application.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to  another value using this API or in application code.
        public let checkpointingEnabled: Bool?
        /// Describes the interval in milliseconds between checkpoint operations.   If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value  using this API or in application code.
        public let checkpointInterval: Int64?
        /// Describes whether the application uses the default checkpointing behavior in Managed Service for Apache Flink.   If this value is set to DEFAULT, the application will use the following values,  even if they are set to other values using APIs or application code:    CheckpointingEnabled: true    CheckpointInterval: 60000    MinPauseBetweenCheckpoints: 5000
        public let configurationType: ConfigurationType?
        /// Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.   If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this  API or in application code.
        public let minPauseBetweenCheckpoints: Int64?

        @inlinable
        public init(checkpointingEnabled: Bool? = nil, checkpointInterval: Int64? = nil, configurationType: ConfigurationType? = nil, minPauseBetweenCheckpoints: Int64? = nil) {
            self.checkpointingEnabled = checkpointingEnabled
            self.checkpointInterval = checkpointInterval
            self.configurationType = configurationType
            self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointingEnabled = "CheckpointingEnabled"
            case checkpointInterval = "CheckpointInterval"
            case configurationType = "ConfigurationType"
            case minPauseBetweenCheckpoints = "MinPauseBetweenCheckpoints"
        }
    }

    public struct CheckpointConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to whether checkpointing is enabled for an application.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointingEnabled value of true, even if this value is set to  another value using this API or in application code.
        public let checkpointingEnabledUpdate: Bool?
        /// Describes updates to the interval in milliseconds between checkpoint operations.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a CheckpointInterval value of 60000, even if this value is set to another value  using this API or in application code.
        public let checkpointIntervalUpdate: Int64?
        /// Describes updates to whether the application uses the default checkpointing behavior of Managed Service for Apache Flink. You must set this property to CUSTOM in order to set the CheckpointingEnabled, CheckpointInterval, or MinPauseBetweenCheckpoints parameters.   If this value is set to DEFAULT, the application will use the following values, even if they are  set to other values using APIs or application code:    CheckpointingEnabled: true    CheckpointInterval: 60000    MinPauseBetweenCheckpoints: 5000
        public let configurationTypeUpdate: ConfigurationType?
        /// Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.  If CheckpointConfiguration.ConfigurationType is DEFAULT, the application will use a MinPauseBetweenCheckpoints value of 5000, even if this value is set using this API or  in application code.
        public let minPauseBetweenCheckpointsUpdate: Int64?

        @inlinable
        public init(checkpointingEnabledUpdate: Bool? = nil, checkpointIntervalUpdate: Int64? = nil, configurationTypeUpdate: ConfigurationType? = nil, minPauseBetweenCheckpointsUpdate: Int64? = nil) {
            self.checkpointingEnabledUpdate = checkpointingEnabledUpdate
            self.checkpointIntervalUpdate = checkpointIntervalUpdate
            self.configurationTypeUpdate = configurationTypeUpdate
            self.minPauseBetweenCheckpointsUpdate = minPauseBetweenCheckpointsUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.checkpointIntervalUpdate, name: "checkpointIntervalUpdate", parent: name, min: 1)
            try self.validate(self.minPauseBetweenCheckpointsUpdate, name: "minPauseBetweenCheckpointsUpdate", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointingEnabledUpdate = "CheckpointingEnabledUpdate"
            case checkpointIntervalUpdate = "CheckpointIntervalUpdate"
            case configurationTypeUpdate = "ConfigurationTypeUpdate"
            case minPauseBetweenCheckpointsUpdate = "MinPauseBetweenCheckpointsUpdate"
        }
    }

    public struct CloudWatchLoggingOption: AWSEncodableShape {
        /// The ARN of the CloudWatch log to receive application messages.
        public let logStreamARN: String

        @inlinable
        public init(logStreamARN: String) {
            self.logStreamARN = logStreamARN
        }

        public func validate(name: String) throws {
            try self.validate(self.logStreamARN, name: "logStreamARN", parent: name, max: 2048)
            try self.validate(self.logStreamARN, name: "logStreamARN", parent: name, min: 1)
            try self.validate(self.logStreamARN, name: "logStreamARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case logStreamARN = "LogStreamARN"
        }
    }

    public struct CloudWatchLoggingOptionDescription: AWSDecodableShape {
        /// The ID of the CloudWatch logging option description.
        public let cloudWatchLoggingOptionId: String?
        /// The Amazon Resource Name (ARN) of the CloudWatch log to receive application messages.
        public let logStreamARN: String
        /// The IAM ARN of the role to use to send application messages.   Provided for backward compatibility. Applications created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        @inlinable
        public init(cloudWatchLoggingOptionId: String? = nil, logStreamARN: String, roleARN: String? = nil) {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARN = logStreamARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
            case logStreamARN = "LogStreamARN"
            case roleARN = "RoleARN"
        }
    }

    public struct CloudWatchLoggingOptionUpdate: AWSEncodableShape {
        /// The ID of the CloudWatch logging option to update
        public let cloudWatchLoggingOptionId: String
        /// The Amazon Resource Name (ARN) of the CloudWatch log to receive application messages.
        public let logStreamARNUpdate: String?

        @inlinable
        public init(cloudWatchLoggingOptionId: String, logStreamARNUpdate: String? = nil) {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARNUpdate = logStreamARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, max: 50)
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, min: 1)
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.logStreamARNUpdate, name: "logStreamARNUpdate", parent: name, max: 2048)
            try self.validate(self.logStreamARNUpdate, name: "logStreamARNUpdate", parent: name, min: 1)
            try self.validate(self.logStreamARNUpdate, name: "logStreamARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
            case logStreamARNUpdate = "LogStreamARNUpdate"
        }
    }

    public struct CodeContent: AWSEncodableShape {
        /// Information about the Amazon S3 bucket that contains the application code.
        public let s3ContentLocation: S3ContentLocation?
        /// The text-format code for a Managed Service for Apache Flink application.
        public let textContent: String?
        /// The zip-format code for a Managed Service for Apache Flink application.
        public let zipFileContent: AWSBase64Data?

        @inlinable
        public init(s3ContentLocation: S3ContentLocation? = nil, textContent: String? = nil, zipFileContent: AWSBase64Data? = nil) {
            self.s3ContentLocation = s3ContentLocation
            self.textContent = textContent
            self.zipFileContent = zipFileContent
        }

        public func validate(name: String) throws {
            try self.s3ContentLocation?.validate(name: "\(name).s3ContentLocation")
            try self.validate(self.textContent, name: "textContent", parent: name, max: 102400)
            try self.validate(self.zipFileContent, name: "zipFileContent", parent: name, max: 52428800)
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocation = "S3ContentLocation"
            case textContent = "TextContent"
            case zipFileContent = "ZipFileContent"
        }
    }

    public struct CodeContentDescription: AWSDecodableShape {
        /// The checksum that can be used to validate zip-format code.
        public let codeMD5: String?
        /// The size in bytes of the application code. Can be used to validate zip-format code.
        public let codeSize: Int64?
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application code stored in Amazon S3.
        public let s3ApplicationCodeLocationDescription: S3ApplicationCodeLocationDescription?
        /// The text-format code
        public let textContent: String?

        @inlinable
        public init(codeMD5: String? = nil, codeSize: Int64? = nil, s3ApplicationCodeLocationDescription: S3ApplicationCodeLocationDescription? = nil, textContent: String? = nil) {
            self.codeMD5 = codeMD5
            self.codeSize = codeSize
            self.s3ApplicationCodeLocationDescription = s3ApplicationCodeLocationDescription
            self.textContent = textContent
        }

        private enum CodingKeys: String, CodingKey {
            case codeMD5 = "CodeMD5"
            case codeSize = "CodeSize"
            case s3ApplicationCodeLocationDescription = "S3ApplicationCodeLocationDescription"
            case textContent = "TextContent"
        }
    }

    public struct CodeContentUpdate: AWSEncodableShape {
        /// Describes an update to the location of code for an application.
        public let s3ContentLocationUpdate: S3ContentLocationUpdate?
        /// Describes an update to the text code for an application.
        public let textContentUpdate: String?
        /// Describes an update to the zipped code for an application.
        public let zipFileContentUpdate: AWSBase64Data?

        @inlinable
        public init(s3ContentLocationUpdate: S3ContentLocationUpdate? = nil, textContentUpdate: String? = nil, zipFileContentUpdate: AWSBase64Data? = nil) {
            self.s3ContentLocationUpdate = s3ContentLocationUpdate
            self.textContentUpdate = textContentUpdate
            self.zipFileContentUpdate = zipFileContentUpdate
        }

        public func validate(name: String) throws {
            try self.s3ContentLocationUpdate?.validate(name: "\(name).s3ContentLocationUpdate")
            try self.validate(self.textContentUpdate, name: "textContentUpdate", parent: name, max: 102400)
            try self.validate(self.zipFileContentUpdate, name: "zipFileContentUpdate", parent: name, max: 52428800)
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocationUpdate = "S3ContentLocationUpdate"
            case textContentUpdate = "TextContentUpdate"
            case zipFileContentUpdate = "ZipFileContentUpdate"
        }
    }

    public struct CreateApplicationPresignedUrlRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// The duration in seconds for which the returned URL will be valid.
        public let sessionExpirationDurationInSeconds: Int64?
        /// The type of the extension for which to create and return a URL. Currently, the only valid extension URL type is FLINK_DASHBOARD_URL.
        public let urlType: UrlType

        @inlinable
        public init(applicationName: String, sessionExpirationDurationInSeconds: Int64? = nil, urlType: UrlType) {
            self.applicationName = applicationName
            self.sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds
            self.urlType = urlType
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.sessionExpirationDurationInSeconds, name: "sessionExpirationDurationInSeconds", parent: name, max: 43200)
            try self.validate(self.sessionExpirationDurationInSeconds, name: "sessionExpirationDurationInSeconds", parent: name, min: 1800)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
            case urlType = "UrlType"
        }
    }

    public struct CreateApplicationPresignedUrlResponse: AWSDecodableShape {
        /// The URL of the extension.
        public let authorizedUrl: String?

        @inlinable
        public init(authorizedUrl: String? = nil) {
            self.authorizedUrl = authorizedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedUrl = "AuthorizedUrl"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// Use this parameter to configure the application.
        public let applicationConfiguration: ApplicationConfiguration?
        /// A summary description of the application.
        public let applicationDescription: String?
        /// Use the STREAMING mode to create a Managed Service for Apache Flink application. To create a Managed Service for Apache Flink Studio notebook, use the  INTERACTIVE mode.
        public let applicationMode: ApplicationMode?
        /// The name of your application (for example, sample-app).
        public let applicationName: String
        /// Use this parameter to configure an Amazon CloudWatch log stream to monitor application configuration errors.
        public let cloudWatchLoggingOptions: [CloudWatchLoggingOption]?
        /// The runtime environment for the application.
        public let runtimeEnvironment: RuntimeEnvironment
        /// The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose delivery streams, Amazon S3 objects, and other external resources.
        public let serviceExecutionRole: String
        /// A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an  application. Note that the maximum number of application tags includes system tags. The maximum number of  user-defined application tags is 50. For more information, see  Using Tagging.
        public let tags: [Tag]?

        @inlinable
        public init(applicationConfiguration: ApplicationConfiguration? = nil, applicationDescription: String? = nil, applicationMode: ApplicationMode? = nil, applicationName: String, cloudWatchLoggingOptions: [CloudWatchLoggingOption]? = nil, runtimeEnvironment: RuntimeEnvironment, serviceExecutionRole: String, tags: [Tag]? = nil) {
            self.applicationConfiguration = applicationConfiguration
            self.applicationDescription = applicationDescription
            self.applicationMode = applicationMode
            self.applicationName = applicationName
            self.cloudWatchLoggingOptions = cloudWatchLoggingOptions
            self.runtimeEnvironment = runtimeEnvironment
            self.serviceExecutionRole = serviceExecutionRole
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.applicationConfiguration?.validate(name: "\(name).applicationConfiguration")
            try self.validate(self.applicationDescription, name: "applicationDescription", parent: name, max: 1024)
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.cloudWatchLoggingOptions?.forEach {
                try $0.validate(name: "\(name).cloudWatchLoggingOptions[]")
            }
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, max: 2048)
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, min: 1)
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, pattern: "^arn:")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationConfiguration = "ApplicationConfiguration"
            case applicationDescription = "ApplicationDescription"
            case applicationMode = "ApplicationMode"
            case applicationName = "ApplicationName"
            case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
            case runtimeEnvironment = "RuntimeEnvironment"
            case serviceExecutionRole = "ServiceExecutionRole"
            case tags = "Tags"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// In response to your CreateApplication request, Managed Service for Apache Flink returns a  response with details of the application it created.
        public let applicationDetail: ApplicationDetail

        @inlinable
        public init(applicationDetail: ApplicationDetail) {
            self.applicationDetail = applicationDetail
        }

        private enum CodingKeys: String, CodingKey {
            case applicationDetail = "ApplicationDetail"
        }
    }

    public struct CreateApplicationSnapshotRequest: AWSEncodableShape {
        /// The name of an existing application
        public let applicationName: String
        /// An identifier for the application snapshot.
        public let snapshotName: String

        @inlinable
        public init(applicationName: String, snapshotName: String) {
            self.applicationName = applicationName
            self.snapshotName = snapshotName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 256)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case snapshotName = "SnapshotName"
        }
    }

    public struct CreateApplicationSnapshotResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CustomArtifactConfiguration: AWSEncodableShape {
        ///  UDF stands for user-defined functions. This type of artifact must be in an S3 bucket. A DEPENDENCY_JAR can be in either Maven or an S3 bucket.
        public let artifactType: ArtifactType
        /// The parameters required to fully specify a Maven reference.
        public let mavenReference: MavenReference?
        public let s3ContentLocation: S3ContentLocation?

        @inlinable
        public init(artifactType: ArtifactType, mavenReference: MavenReference? = nil, s3ContentLocation: S3ContentLocation? = nil) {
            self.artifactType = artifactType
            self.mavenReference = mavenReference
            self.s3ContentLocation = s3ContentLocation
        }

        public func validate(name: String) throws {
            try self.mavenReference?.validate(name: "\(name).mavenReference")
            try self.s3ContentLocation?.validate(name: "\(name).s3ContentLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactType = "ArtifactType"
            case mavenReference = "MavenReference"
            case s3ContentLocation = "S3ContentLocation"
        }
    }

    public struct CustomArtifactConfigurationDescription: AWSDecodableShape {
        ///  UDF stands for user-defined functions. This type of artifact must be in an S3 bucket. A DEPENDENCY_JAR can be in either Maven or an S3 bucket.
        public let artifactType: ArtifactType?
        /// The parameters that are required to specify a Maven dependency.
        public let mavenReferenceDescription: MavenReference?
        public let s3ContentLocationDescription: S3ContentLocation?

        @inlinable
        public init(artifactType: ArtifactType? = nil, mavenReferenceDescription: MavenReference? = nil, s3ContentLocationDescription: S3ContentLocation? = nil) {
            self.artifactType = artifactType
            self.mavenReferenceDescription = mavenReferenceDescription
            self.s3ContentLocationDescription = s3ContentLocationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case artifactType = "ArtifactType"
            case mavenReferenceDescription = "MavenReferenceDescription"
            case s3ContentLocationDescription = "S3ContentLocationDescription"
        }
    }

    public struct DeleteApplicationCloudWatchLoggingOptionRequest: AWSEncodableShape {
        /// The application name.
        public let applicationName: String
        /// The CloudWatchLoggingOptionId of the Amazon CloudWatch logging option to delete. You can get the CloudWatchLoggingOptionId by using the DescribeApplication operation.
        public let cloudWatchLoggingOptionId: String
        /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The version ID of the application. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can retrieve the application version ID using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?

        @inlinable
        public init(applicationName: String, cloudWatchLoggingOptionId: String, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil) {
            self.applicationName = applicationName
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, max: 50)
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, min: 1)
            try self.validate(self.cloudWatchLoggingOptionId, name: "cloudWatchLoggingOptionId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "^[a-zA-Z0-9-_+/=]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
        }
    }

    public struct DeleteApplicationCloudWatchLoggingOptionResponse: AWSDecodableShape {
        /// The application's Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The version ID of the application. Kinesis Data Analytics updates the ApplicationVersionId each time you change the CloudWatch logging options.
        public let applicationVersionId: Int64?
        /// The descriptions of the remaining CloudWatch logging options for the application.
        public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?
        /// Operation ID for tracking DeleteApplicationCloudWatchLoggingOption request
        public let operationId: String?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil, operationId: String? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
            case operationId = "OperationId"
        }
    }

    public struct DeleteApplicationInputProcessingConfigurationRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// The application version.  You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the  ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The ID of the input configuration from which to delete the input processing configuration. You can get a list of the input IDs for an application by using the DescribeApplication operation.
        public let inputId: String

        @inlinable
        public init(applicationName: String, currentApplicationVersionId: Int64, inputId: String) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.inputId = inputId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, max: 50)
            try self.validate(self.inputId, name: "inputId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case inputId = "InputId"
        }
    }

    public struct DeleteApplicationInputProcessingConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationARN: String?
        /// The current application version ID.
        public let applicationVersionId: Int64?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DeleteApplicationOutputRequest: AWSEncodableShape {
        /// The application name.
        public let applicationName: String
        /// The application version.  You can use the DescribeApplication operation to get the current application version. If the version specified is not the current version, the  ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The ID of the configuration to delete. Each output configuration that is added to the application (either when the application is created or later) using the AddApplicationOutput operation has a unique ID. You need to provide the ID to uniquely identify the output configuration that you want to delete from the application configuration. You can use the DescribeApplication operation to get the specific OutputId.
        public let outputId: String

        @inlinable
        public init(applicationName: String, currentApplicationVersionId: Int64, outputId: String) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.outputId = outputId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.outputId, name: "outputId", parent: name, max: 50)
            try self.validate(self.outputId, name: "outputId", parent: name, min: 1)
            try self.validate(self.outputId, name: "outputId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case outputId = "OutputId"
        }
    }

    public struct DeleteApplicationOutputResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The current application version ID.
        public let applicationVersionId: Int64?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DeleteApplicationReferenceDataSourceRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The current application version.   You can use the DescribeApplication operation to get the current application version. If the version specified  is not the current version, the ConcurrentModificationException is returned.
        public let currentApplicationVersionId: Int64
        /// The ID of the reference data source. When you add a reference data source to your application using the AddApplicationReferenceDataSource, Kinesis Data Analytics assigns an ID. You can use the DescribeApplication operation to get the reference ID.
        public let referenceId: String

        @inlinable
        public init(applicationName: String, currentApplicationVersionId: Int64, referenceId: String) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
            self.referenceId = referenceId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.referenceId, name: "referenceId", parent: name, max: 50)
            try self.validate(self.referenceId, name: "referenceId", parent: name, min: 1)
            try self.validate(self.referenceId, name: "referenceId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case referenceId = "ReferenceId"
        }
    }

    public struct DeleteApplicationReferenceDataSourceResponse: AWSDecodableShape {
        /// The application Amazon Resource Name (ARN).
        public let applicationARN: String?
        /// The updated version ID of the application.
        public let applicationVersionId: Int64?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The name of the application to delete.
        public let applicationName: String
        /// Use the DescribeApplication operation to get this value.
        public let createTimestamp: Date

        @inlinable
        public init(applicationName: String, createTimestamp: Date) {
            self.applicationName = applicationName
            self.createTimestamp = createTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case createTimestamp = "CreateTimestamp"
        }
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteApplicationSnapshotRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The creation timestamp of the application snapshot to delete. You can retrieve this value  using  or .
        public let snapshotCreationTimestamp: Date
        /// The identifier for the snapshot delete.
        public let snapshotName: String

        @inlinable
        public init(applicationName: String, snapshotCreationTimestamp: Date, snapshotName: String) {
            self.applicationName = applicationName
            self.snapshotCreationTimestamp = snapshotCreationTimestamp
            self.snapshotName = snapshotName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 256)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
            case snapshotName = "SnapshotName"
        }
    }

    public struct DeleteApplicationSnapshotResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteApplicationVpcConfigurationRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The current application version ID. You must provide the CurrentApplicationVersionId or the ConditionalToken. You can retrieve the application version ID using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?
        /// The ID of the VPC configuration to delete.
        public let vpcConfigurationId: String

        @inlinable
        public init(applicationName: String, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil, vpcConfigurationId: String) {
            self.applicationName = applicationName
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
            self.vpcConfigurationId = vpcConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "^[a-zA-Z0-9-_+/=]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, max: 50)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, min: 1)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case vpcConfigurationId = "VpcConfigurationId"
        }
    }

    public struct DeleteApplicationVpcConfigurationResponse: AWSDecodableShape {
        /// The ARN of the Managed Service for Apache Flink application.
        public let applicationARN: String?
        /// The updated version ID of the application.
        public let applicationVersionId: Int64?
        /// Operation ID for tracking DeleteApplicationVpcConfiguration request
        public let operationId: String?

        @inlinable
        public init(applicationARN: String? = nil, applicationVersionId: Int64? = nil, operationId: String? = nil) {
            self.applicationARN = applicationARN
            self.applicationVersionId = applicationVersionId
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationVersionId = "ApplicationVersionId"
            case operationId = "OperationId"
        }
    }

    public struct DeployAsApplicationConfiguration: AWSEncodableShape {
        /// The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
        public let s3ContentLocation: S3ContentBaseLocation

        @inlinable
        public init(s3ContentLocation: S3ContentBaseLocation) {
            self.s3ContentLocation = s3ContentLocation
        }

        public func validate(name: String) throws {
            try self.s3ContentLocation.validate(name: "\(name).s3ContentLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocation = "S3ContentLocation"
        }
    }

    public struct DeployAsApplicationConfigurationDescription: AWSDecodableShape {
        /// The location that holds the data required to specify an Amazon Data Analytics application.
        public let s3ContentLocationDescription: S3ContentBaseLocationDescription

        @inlinable
        public init(s3ContentLocationDescription: S3ContentBaseLocationDescription) {
            self.s3ContentLocationDescription = s3ContentLocationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocationDescription = "S3ContentLocationDescription"
        }
    }

    public struct DeployAsApplicationConfigurationUpdate: AWSEncodableShape {
        /// Updates to the location that holds the data required to specify an Amazon Data Analytics application.
        public let s3ContentLocationUpdate: S3ContentBaseLocationUpdate?

        @inlinable
        public init(s3ContentLocationUpdate: S3ContentBaseLocationUpdate? = nil) {
            self.s3ContentLocationUpdate = s3ContentLocationUpdate
        }

        public func validate(name: String) throws {
            try self.s3ContentLocationUpdate?.validate(name: "\(name).s3ContentLocationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case s3ContentLocationUpdate = "S3ContentLocationUpdate"
        }
    }

    public struct DescribeApplicationOperationRequest: AWSEncodableShape {
        public let applicationName: String
        public let operationId: String

        @inlinable
        public init(applicationName: String, operationId: String) {
            self.applicationName = applicationName
            self.operationId = operationId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.operationId, name: "operationId", parent: name, max: 64)
            try self.validate(self.operationId, name: "operationId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case operationId = "OperationId"
        }
    }

    public struct DescribeApplicationOperationResponse: AWSDecodableShape {
        public let applicationOperationInfoDetails: ApplicationOperationInfoDetails?

        @inlinable
        public init(applicationOperationInfoDetails: ApplicationOperationInfoDetails? = nil) {
            self.applicationOperationInfoDetails = applicationOperationInfoDetails
        }

        private enum CodingKeys: String, CodingKey {
            case applicationOperationInfoDetails = "ApplicationOperationInfoDetails"
        }
    }

    public struct DescribeApplicationRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// Displays verbose information about a Managed Service for Apache Flink application, including the application's job plan.
        public let includeAdditionalDetails: Bool?

        @inlinable
        public init(applicationName: String, includeAdditionalDetails: Bool? = nil) {
            self.applicationName = applicationName
            self.includeAdditionalDetails = includeAdditionalDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case includeAdditionalDetails = "IncludeAdditionalDetails"
        }
    }

    public struct DescribeApplicationResponse: AWSDecodableShape {
        /// Provides a description of the application, such as the application's Amazon Resource Name (ARN), status, and latest version.
        public let applicationDetail: ApplicationDetail

        @inlinable
        public init(applicationDetail: ApplicationDetail) {
            self.applicationDetail = applicationDetail
        }

        private enum CodingKeys: String, CodingKey {
            case applicationDetail = "ApplicationDetail"
        }
    }

    public struct DescribeApplicationSnapshotRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The identifier of an application snapshot. You can retrieve this value using  .
        public let snapshotName: String

        @inlinable
        public init(applicationName: String, snapshotName: String) {
            self.applicationName = applicationName
            self.snapshotName = snapshotName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, max: 256)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, min: 1)
            try self.validate(self.snapshotName, name: "snapshotName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case snapshotName = "SnapshotName"
        }
    }

    public struct DescribeApplicationSnapshotResponse: AWSDecodableShape {
        /// An object containing information about the application snapshot.
        public let snapshotDetails: SnapshotDetails

        @inlinable
        public init(snapshotDetails: SnapshotDetails) {
            self.snapshotDetails = snapshotDetails
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotDetails = "SnapshotDetails"
        }
    }

    public struct DescribeApplicationVersionRequest: AWSEncodableShape {
        /// The name of the application for which you want to get the version description.
        public let applicationName: String
        /// The ID of the application version for which you want to get the description.
        public let applicationVersionId: Int64

        @inlinable
        public init(applicationName: String, applicationVersionId: Int64) {
            self.applicationName = applicationName
            self.applicationVersionId = applicationVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.applicationVersionId, name: "applicationVersionId", parent: name, max: 999999999)
            try self.validate(self.applicationVersionId, name: "applicationVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case applicationVersionId = "ApplicationVersionId"
        }
    }

    public struct DescribeApplicationVersionResponse: AWSDecodableShape {
        public let applicationVersionDetail: ApplicationDetail?

        @inlinable
        public init(applicationVersionDetail: ApplicationDetail? = nil) {
            self.applicationVersionDetail = applicationVersionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersionDetail = "ApplicationVersionDetail"
        }
    }

    public struct DestinationSchema: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the format of the records on the output stream.
        public let recordFormatType: RecordFormatType

        @inlinable
        public init(recordFormatType: RecordFormatType) {
            self.recordFormatType = recordFormatType
        }

        private enum CodingKeys: String, CodingKey {
            case recordFormatType = "RecordFormatType"
        }
    }

    public struct DiscoverInputSchemaRequest: AWSEncodableShape {
        /// The InputProcessingConfiguration to use to preprocess the records  before discovering the schema of the records.
        public let inputProcessingConfiguration: InputProcessingConfiguration?
        /// The point at which you want Kinesis Data Analytics to start reading records from the specified streaming source for discovery purposes.
        public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
        /// The Amazon Resource Name (ARN) of the streaming source.
        public let resourceARN: String?
        /// Specify this parameter to discover a schema from data in an Amazon S3 object.
        public let s3Configuration: S3Configuration?
        /// The ARN of the role that is used to access the streaming source.
        public let serviceExecutionRole: String

        @inlinable
        public init(inputProcessingConfiguration: InputProcessingConfiguration? = nil, inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil, resourceARN: String? = nil, s3Configuration: S3Configuration? = nil, serviceExecutionRole: String) {
            self.inputProcessingConfiguration = inputProcessingConfiguration
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
            self.resourceARN = resourceARN
            self.s3Configuration = s3Configuration
            self.serviceExecutionRole = serviceExecutionRole
        }

        public func validate(name: String) throws {
            try self.inputProcessingConfiguration?.validate(name: "\(name).inputProcessingConfiguration")
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, max: 2048)
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, min: 1)
            try self.validate(self.serviceExecutionRole, name: "serviceExecutionRole", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case inputProcessingConfiguration = "InputProcessingConfiguration"
            case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
            case resourceARN = "ResourceARN"
            case s3Configuration = "S3Configuration"
            case serviceExecutionRole = "ServiceExecutionRole"
        }
    }

    public struct DiscoverInputSchemaResponse: AWSDecodableShape {
        /// The schema inferred from the streaming source. It identifies the format of the data in the streaming source and how each data element maps to corresponding columns in the in-application stream that you can create.
        public let inputSchema: SourceSchema?
        /// An array of elements, where each element corresponds to a row in a stream record  (a stream record can have more than one row).
        public let parsedInputRecords: [[String]]?
        /// The stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
        public let processedInputRecords: [String]?
        /// The raw stream data that was sampled to infer the schema.
        public let rawInputRecords: [String]?

        @inlinable
        public init(inputSchema: SourceSchema? = nil, parsedInputRecords: [[String]]? = nil, processedInputRecords: [String]? = nil, rawInputRecords: [String]? = nil) {
            self.inputSchema = inputSchema
            self.parsedInputRecords = parsedInputRecords
            self.processedInputRecords = processedInputRecords
            self.rawInputRecords = rawInputRecords
        }

        private enum CodingKeys: String, CodingKey {
            case inputSchema = "InputSchema"
            case parsedInputRecords = "ParsedInputRecords"
            case processedInputRecords = "ProcessedInputRecords"
            case rawInputRecords = "RawInputRecords"
        }
    }

    public struct EnvironmentProperties: AWSEncodableShape {
        /// Describes the execution property groups.
        public let propertyGroups: [PropertyGroup]

        @inlinable
        public init(propertyGroups: [PropertyGroup]) {
            self.propertyGroups = propertyGroups
        }

        public func validate(name: String) throws {
            try self.propertyGroups.forEach {
                try $0.validate(name: "\(name).propertyGroups[]")
            }
            try self.validate(self.propertyGroups, name: "propertyGroups", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case propertyGroups = "PropertyGroups"
        }
    }

    public struct EnvironmentPropertyDescriptions: AWSDecodableShape {
        /// Describes the execution property groups.
        public let propertyGroupDescriptions: [PropertyGroup]?

        @inlinable
        public init(propertyGroupDescriptions: [PropertyGroup]? = nil) {
            self.propertyGroupDescriptions = propertyGroupDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case propertyGroupDescriptions = "PropertyGroupDescriptions"
        }
    }

    public struct EnvironmentPropertyUpdates: AWSEncodableShape {
        /// Describes updates to the execution property groups.
        public let propertyGroups: [PropertyGroup]

        @inlinable
        public init(propertyGroups: [PropertyGroup]) {
            self.propertyGroups = propertyGroups
        }

        public func validate(name: String) throws {
            try self.propertyGroups.forEach {
                try $0.validate(name: "\(name).propertyGroups[]")
            }
            try self.validate(self.propertyGroups, name: "propertyGroups", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case propertyGroups = "PropertyGroups"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        public let errorString: String?

        @inlinable
        public init(errorString: String? = nil) {
            self.errorString = errorString
        }

        private enum CodingKeys: String, CodingKey {
            case errorString = "ErrorString"
        }
    }

    public struct FlinkApplicationConfiguration: AWSEncodableShape {
        /// Describes an application's checkpointing configuration. Checkpointing is the  process of persisting application state for fault tolerance. For more information, see   Checkpoints for Fault Tolerance in the  Apache Flink Documentation.
        public let checkpointConfiguration: CheckpointConfiguration?
        /// Describes configuration parameters for Amazon CloudWatch logging for an application.
        public let monitoringConfiguration: MonitoringConfiguration?
        /// Describes parameters for how an application executes multiple tasks simultaneously.
        public let parallelismConfiguration: ParallelismConfiguration?

        @inlinable
        public init(checkpointConfiguration: CheckpointConfiguration? = nil, monitoringConfiguration: MonitoringConfiguration? = nil, parallelismConfiguration: ParallelismConfiguration? = nil) {
            self.checkpointConfiguration = checkpointConfiguration
            self.monitoringConfiguration = monitoringConfiguration
            self.parallelismConfiguration = parallelismConfiguration
        }

        public func validate(name: String) throws {
            try self.checkpointConfiguration?.validate(name: "\(name).checkpointConfiguration")
            try self.parallelismConfiguration?.validate(name: "\(name).parallelismConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointConfiguration = "CheckpointConfiguration"
            case monitoringConfiguration = "MonitoringConfiguration"
            case parallelismConfiguration = "ParallelismConfiguration"
        }
    }

    public struct FlinkApplicationConfigurationDescription: AWSDecodableShape {
        /// Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state  for fault tolerance.
        public let checkpointConfigurationDescription: CheckpointConfigurationDescription?
        /// The job plan for an application. For more information about the job plan, see Jobs and Scheduling in the Apache Flink Documentation. To retrieve the job plan for the application, use the DescribeApplicationRequest$IncludeAdditionalDetails parameter of the DescribeApplication operation.
        public let jobPlanDescription: String?
        /// Describes configuration parameters for Amazon CloudWatch logging for an application.
        public let monitoringConfigurationDescription: MonitoringConfigurationDescription?
        /// Describes parameters for how an application executes multiple tasks simultaneously.
        public let parallelismConfigurationDescription: ParallelismConfigurationDescription?

        @inlinable
        public init(checkpointConfigurationDescription: CheckpointConfigurationDescription? = nil, jobPlanDescription: String? = nil, monitoringConfigurationDescription: MonitoringConfigurationDescription? = nil, parallelismConfigurationDescription: ParallelismConfigurationDescription? = nil) {
            self.checkpointConfigurationDescription = checkpointConfigurationDescription
            self.jobPlanDescription = jobPlanDescription
            self.monitoringConfigurationDescription = monitoringConfigurationDescription
            self.parallelismConfigurationDescription = parallelismConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointConfigurationDescription = "CheckpointConfigurationDescription"
            case jobPlanDescription = "JobPlanDescription"
            case monitoringConfigurationDescription = "MonitoringConfigurationDescription"
            case parallelismConfigurationDescription = "ParallelismConfigurationDescription"
        }
    }

    public struct FlinkApplicationConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting  application state for fault tolerance.
        public let checkpointConfigurationUpdate: CheckpointConfigurationUpdate?
        /// Describes updates to the configuration parameters for Amazon CloudWatch logging for an application.
        public let monitoringConfigurationUpdate: MonitoringConfigurationUpdate?
        /// Describes updates to the parameters for how an application executes multiple tasks simultaneously.
        public let parallelismConfigurationUpdate: ParallelismConfigurationUpdate?

        @inlinable
        public init(checkpointConfigurationUpdate: CheckpointConfigurationUpdate? = nil, monitoringConfigurationUpdate: MonitoringConfigurationUpdate? = nil, parallelismConfigurationUpdate: ParallelismConfigurationUpdate? = nil) {
            self.checkpointConfigurationUpdate = checkpointConfigurationUpdate
            self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
            self.parallelismConfigurationUpdate = parallelismConfigurationUpdate
        }

        public func validate(name: String) throws {
            try self.checkpointConfigurationUpdate?.validate(name: "\(name).checkpointConfigurationUpdate")
            try self.parallelismConfigurationUpdate?.validate(name: "\(name).parallelismConfigurationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case checkpointConfigurationUpdate = "CheckpointConfigurationUpdate"
            case monitoringConfigurationUpdate = "MonitoringConfigurationUpdate"
            case parallelismConfigurationUpdate = "ParallelismConfigurationUpdate"
        }
    }

    public struct FlinkRunConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot  be mapped to the new program. This will happen if the program is updated between snapshots to remove stateful parameters, and  state data in the snapshot no longer  corresponds to valid application data. For more information, see   Allowing Non-Restored State in the Apache Flink documentation.  This value defaults to false. If you update your application without specifying this parameter, AllowNonRestoredState will be set to false, even if it was previously set to true.
        public let allowNonRestoredState: Bool?

        @inlinable
        public init(allowNonRestoredState: Bool? = nil) {
            self.allowNonRestoredState = allowNonRestoredState
        }

        private enum CodingKeys: String, CodingKey {
            case allowNonRestoredState = "AllowNonRestoredState"
        }
    }

    public struct GlueDataCatalogConfiguration: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the database.
        public let databaseARN: String

        @inlinable
        public init(databaseARN: String) {
            self.databaseARN = databaseARN
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseARN, name: "databaseARN", parent: name, max: 2048)
            try self.validate(self.databaseARN, name: "databaseARN", parent: name, min: 1)
            try self.validate(self.databaseARN, name: "databaseARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseARN = "DatabaseARN"
        }
    }

    public struct GlueDataCatalogConfigurationDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the database.
        public let databaseARN: String

        @inlinable
        public init(databaseARN: String) {
            self.databaseARN = databaseARN
        }

        private enum CodingKeys: String, CodingKey {
            case databaseARN = "DatabaseARN"
        }
    }

    public struct GlueDataCatalogConfigurationUpdate: AWSEncodableShape {
        /// The updated Amazon Resource Name (ARN) of the database.
        public let databaseARNUpdate: String

        @inlinable
        public init(databaseARNUpdate: String) {
            self.databaseARNUpdate = databaseARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseARNUpdate, name: "databaseARNUpdate", parent: name, max: 2048)
            try self.validate(self.databaseARNUpdate, name: "databaseARNUpdate", parent: name, min: 1)
            try self.validate(self.databaseARNUpdate, name: "databaseARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseARNUpdate = "DatabaseARNUpdate"
        }
    }

    public struct Input: AWSEncodableShape {
        /// Describes the number of in-application streams to create.
        public let inputParallelism: InputParallelism?
        /// The InputProcessingConfiguration for the input. An input processor transforms records as they are received  from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is  InputLambdaProcessor.
        public let inputProcessingConfiguration: InputProcessingConfiguration?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created. Also used to describe the format of the reference data source.
        public let inputSchema: SourceSchema
        /// If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
        public let kinesisFirehoseInput: KinesisFirehoseInput?
        /// If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
        public let kinesisStreamsInput: KinesisStreamsInput?
        /// The name prefix to use when creating an in-application stream. Suppose that you specify a prefix "MyInApplicationStream." Kinesis Data Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with the names "MyInApplicationStream_001," "MyInApplicationStream_002," and so on.
        public let namePrefix: String

        @inlinable
        public init(inputParallelism: InputParallelism? = nil, inputProcessingConfiguration: InputProcessingConfiguration? = nil, inputSchema: SourceSchema, kinesisFirehoseInput: KinesisFirehoseInput? = nil, kinesisStreamsInput: KinesisStreamsInput? = nil, namePrefix: String) {
            self.inputParallelism = inputParallelism
            self.inputProcessingConfiguration = inputProcessingConfiguration
            self.inputSchema = inputSchema
            self.kinesisFirehoseInput = kinesisFirehoseInput
            self.kinesisStreamsInput = kinesisStreamsInput
            self.namePrefix = namePrefix
        }

        public func validate(name: String) throws {
            try self.inputParallelism?.validate(name: "\(name).inputParallelism")
            try self.inputProcessingConfiguration?.validate(name: "\(name).inputProcessingConfiguration")
            try self.inputSchema.validate(name: "\(name).inputSchema")
            try self.kinesisFirehoseInput?.validate(name: "\(name).kinesisFirehoseInput")
            try self.kinesisStreamsInput?.validate(name: "\(name).kinesisStreamsInput")
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, max: 32)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, min: 1)
            try self.validate(self.namePrefix, name: "namePrefix", parent: name, pattern: "^[^-\\s<>&]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputParallelism = "InputParallelism"
            case inputProcessingConfiguration = "InputProcessingConfiguration"
            case inputSchema = "InputSchema"
            case kinesisFirehoseInput = "KinesisFirehoseInput"
            case kinesisStreamsInput = "KinesisStreamsInput"
            case namePrefix = "NamePrefix"
        }
    }

    public struct InputDescription: AWSDecodableShape {
        /// Returns the in-application stream names that are mapped to the stream source.
        public let inAppStreamNames: [String]?
        /// The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input configuration that you add to your application.
        public let inputId: String?
        /// Describes the configured parallelism (number of in-application streams mapped to the streaming source).
        public let inputParallelism: InputParallelism?
        /// The description of the preprocessor that executes on records in this input before the application's code is run.
        public let inputProcessingConfigurationDescription: InputProcessingConfigurationDescription?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns  in the in-application stream that is being created.
        public let inputSchema: SourceSchema?
        /// The point at which the application is configured to read from the input stream.
        public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
        /// If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN.
        public let kinesisFirehoseInputDescription: KinesisFirehoseInputDescription?
        /// If a Kinesis data stream is configured as a streaming source, provides the Kinesis data stream's Amazon Resource Name (ARN).
        public let kinesisStreamsInputDescription: KinesisStreamsInputDescription?
        /// The in-application name prefix.
        public let namePrefix: String?

        @inlinable
        public init(inAppStreamNames: [String]? = nil, inputId: String? = nil, inputParallelism: InputParallelism? = nil, inputProcessingConfigurationDescription: InputProcessingConfigurationDescription? = nil, inputSchema: SourceSchema? = nil, inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil, kinesisFirehoseInputDescription: KinesisFirehoseInputDescription? = nil, kinesisStreamsInputDescription: KinesisStreamsInputDescription? = nil, namePrefix: String? = nil) {
            self.inAppStreamNames = inAppStreamNames
            self.inputId = inputId
            self.inputParallelism = inputParallelism
            self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
            self.inputSchema = inputSchema
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
            self.kinesisFirehoseInputDescription = kinesisFirehoseInputDescription
            self.kinesisStreamsInputDescription = kinesisStreamsInputDescription
            self.namePrefix = namePrefix
        }

        private enum CodingKeys: String, CodingKey {
            case inAppStreamNames = "InAppStreamNames"
            case inputId = "InputId"
            case inputParallelism = "InputParallelism"
            case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
            case inputSchema = "InputSchema"
            case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
            case kinesisFirehoseInputDescription = "KinesisFirehoseInputDescription"
            case kinesisStreamsInputDescription = "KinesisStreamsInputDescription"
            case namePrefix = "NamePrefix"
        }
    }

    public struct InputLambdaProcessor: AWSEncodableShape {
        /// The ARN of the Amazon Lambda function that operates on records in the stream.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: Amazon Lambda
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct InputLambdaProcessorDescription: AWSDecodableShape {
        /// The ARN of the Amazon Lambda function that is used to preprocess the records in the stream.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: Amazon Lambda
        public let resourceARN: String
        /// The ARN of the IAM role that is used to access the Amazon Lambda function.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        @inlinable
        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct InputLambdaProcessorUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the new Amazon Lambda function that is used to preprocess the records in the stream.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: Amazon Lambda
        public let resourceARNUpdate: String

        @inlinable
        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct InputParallelism: AWSEncodableShape & AWSDecodableShape {
        /// The number of in-application streams to create.
        public let count: Int?

        @inlinable
        public init(count: Int? = nil) {
            self.count = count
        }

        public func validate(name: String) throws {
            try self.validate(self.count, name: "count", parent: name, max: 64)
            try self.validate(self.count, name: "count", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
        }
    }

    public struct InputParallelismUpdate: AWSEncodableShape {
        /// The number of in-application streams to create for the specified streaming source.
        public let countUpdate: Int

        @inlinable
        public init(countUpdate: Int) {
            self.countUpdate = countUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.countUpdate, name: "countUpdate", parent: name, max: 64)
            try self.validate(self.countUpdate, name: "countUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case countUpdate = "CountUpdate"
        }
    }

    public struct InputProcessingConfiguration: AWSEncodableShape {
        /// The InputLambdaProcessor that is used to preprocess the records in the stream before being processed by your application code.
        public let inputLambdaProcessor: InputLambdaProcessor

        @inlinable
        public init(inputLambdaProcessor: InputLambdaProcessor) {
            self.inputLambdaProcessor = inputLambdaProcessor
        }

        public func validate(name: String) throws {
            try self.inputLambdaProcessor.validate(name: "\(name).inputLambdaProcessor")
        }

        private enum CodingKeys: String, CodingKey {
            case inputLambdaProcessor = "InputLambdaProcessor"
        }
    }

    public struct InputProcessingConfigurationDescription: AWSDecodableShape {
        /// Provides configuration information about the associated InputLambdaProcessorDescription
        public let inputLambdaProcessorDescription: InputLambdaProcessorDescription?

        @inlinable
        public init(inputLambdaProcessorDescription: InputLambdaProcessorDescription? = nil) {
            self.inputLambdaProcessorDescription = inputLambdaProcessorDescription
        }

        private enum CodingKeys: String, CodingKey {
            case inputLambdaProcessorDescription = "InputLambdaProcessorDescription"
        }
    }

    public struct InputProcessingConfigurationUpdate: AWSEncodableShape {
        /// Provides update information for an InputLambdaProcessor.
        public let inputLambdaProcessorUpdate: InputLambdaProcessorUpdate

        @inlinable
        public init(inputLambdaProcessorUpdate: InputLambdaProcessorUpdate) {
            self.inputLambdaProcessorUpdate = inputLambdaProcessorUpdate
        }

        public func validate(name: String) throws {
            try self.inputLambdaProcessorUpdate.validate(name: "\(name).inputLambdaProcessorUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case inputLambdaProcessorUpdate = "InputLambdaProcessorUpdate"
        }
    }

    public struct InputSchemaUpdate: AWSEncodableShape {
        /// A list of RecordColumn objects. Each object describes the mapping  of the streaming source element to the corresponding column in the in-application stream.
        public let recordColumnUpdates: [RecordColumn]?
        /// Specifies the encoding of the records in the streaming source; for example, UTF-8.
        public let recordEncodingUpdate: String?
        /// Specifies the format of the records on the streaming source.
        public let recordFormatUpdate: RecordFormat?

        @inlinable
        public init(recordColumnUpdates: [RecordColumn]? = nil, recordEncodingUpdate: String? = nil, recordFormatUpdate: RecordFormat? = nil) {
            self.recordColumnUpdates = recordColumnUpdates
            self.recordEncodingUpdate = recordEncodingUpdate
            self.recordFormatUpdate = recordFormatUpdate
        }

        public func validate(name: String) throws {
            try self.recordColumnUpdates?.forEach {
                try $0.validate(name: "\(name).recordColumnUpdates[]")
            }
            try self.validate(self.recordColumnUpdates, name: "recordColumnUpdates", parent: name, max: 1000)
            try self.validate(self.recordColumnUpdates, name: "recordColumnUpdates", parent: name, min: 1)
            try self.validate(self.recordEncodingUpdate, name: "recordEncodingUpdate", parent: name, max: 5)
            try self.validate(self.recordEncodingUpdate, name: "recordEncodingUpdate", parent: name, min: 5)
            try self.validate(self.recordEncodingUpdate, name: "recordEncodingUpdate", parent: name, pattern: "^UTF-8$")
            try self.recordFormatUpdate?.validate(name: "\(name).recordFormatUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case recordColumnUpdates = "RecordColumnUpdates"
            case recordEncodingUpdate = "RecordEncodingUpdate"
            case recordFormatUpdate = "RecordFormatUpdate"
        }
    }

    public struct InputStartingPositionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The starting position on the stream.    NOW - Start reading just after the most recent record in the stream, and start at the request timestamp that the customer issued.    TRIM_HORIZON - Start reading at the last untrimmed record in the stream,  which is the oldest record available in the stream. This option is not available  for an Amazon Kinesis Data Firehose delivery stream.    LAST_STOPPED_POINT - Resume reading from where the application last stopped reading.
        public let inputStartingPosition: InputStartingPosition?

        @inlinable
        public init(inputStartingPosition: InputStartingPosition? = nil) {
            self.inputStartingPosition = inputStartingPosition
        }

        private enum CodingKeys: String, CodingKey {
            case inputStartingPosition = "InputStartingPosition"
        }
    }

    public struct InputUpdate: AWSEncodableShape {
        /// The input ID of the application input to be updated.
        public let inputId: String
        /// Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).
        public let inputParallelismUpdate: InputParallelismUpdate?
        /// Describes updates to an InputProcessingConfiguration.
        public let inputProcessingConfigurationUpdate: InputProcessingConfigurationUpdate?
        /// Describes the data format on the streaming source, and  how record elements on the streaming source map to columns of the in-application stream that is created.
        public let inputSchemaUpdate: InputSchemaUpdate?
        /// If a Kinesis Data Firehose delivery stream is the streaming source to be updated, provides an updated stream ARN.
        public let kinesisFirehoseInputUpdate: KinesisFirehoseInputUpdate?
        /// If a Kinesis data stream is the streaming source to be updated, provides an updated stream Amazon Resource Name (ARN).
        public let kinesisStreamsInputUpdate: KinesisStreamsInputUpdate?
        /// The name prefix for in-application streams that Kinesis Data Analytics creates for the specific streaming source.
        public let namePrefixUpdate: String?

        @inlinable
        public init(inputId: String, inputParallelismUpdate: InputParallelismUpdate? = nil, inputProcessingConfigurationUpdate: InputProcessingConfigurationUpdate? = nil, inputSchemaUpdate: InputSchemaUpdate? = nil, kinesisFirehoseInputUpdate: KinesisFirehoseInputUpdate? = nil, kinesisStreamsInputUpdate: KinesisStreamsInputUpdate? = nil, namePrefixUpdate: String? = nil) {
            self.inputId = inputId
            self.inputParallelismUpdate = inputParallelismUpdate
            self.inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate
            self.inputSchemaUpdate = inputSchemaUpdate
            self.kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate
            self.kinesisStreamsInputUpdate = kinesisStreamsInputUpdate
            self.namePrefixUpdate = namePrefixUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.inputId, name: "inputId", parent: name, max: 50)
            try self.validate(self.inputId, name: "inputId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.inputParallelismUpdate?.validate(name: "\(name).inputParallelismUpdate")
            try self.inputProcessingConfigurationUpdate?.validate(name: "\(name).inputProcessingConfigurationUpdate")
            try self.inputSchemaUpdate?.validate(name: "\(name).inputSchemaUpdate")
            try self.kinesisFirehoseInputUpdate?.validate(name: "\(name).kinesisFirehoseInputUpdate")
            try self.kinesisStreamsInputUpdate?.validate(name: "\(name).kinesisStreamsInputUpdate")
            try self.validate(self.namePrefixUpdate, name: "namePrefixUpdate", parent: name, max: 32)
            try self.validate(self.namePrefixUpdate, name: "namePrefixUpdate", parent: name, min: 1)
            try self.validate(self.namePrefixUpdate, name: "namePrefixUpdate", parent: name, pattern: "^[^-\\s<>&]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputId = "InputId"
            case inputParallelismUpdate = "InputParallelismUpdate"
            case inputProcessingConfigurationUpdate = "InputProcessingConfigurationUpdate"
            case inputSchemaUpdate = "InputSchemaUpdate"
            case kinesisFirehoseInputUpdate = "KinesisFirehoseInputUpdate"
            case kinesisStreamsInputUpdate = "KinesisStreamsInputUpdate"
            case namePrefixUpdate = "NamePrefixUpdate"
        }
    }

    public struct JSONMappingParameters: AWSEncodableShape & AWSDecodableShape {
        /// The path to the top-level parent that contains the records.
        public let recordRowPath: String

        @inlinable
        public init(recordRowPath: String) {
            self.recordRowPath = recordRowPath
        }

        public func validate(name: String) throws {
            try self.validate(self.recordRowPath, name: "recordRowPath", parent: name, max: 65535)
            try self.validate(self.recordRowPath, name: "recordRowPath", parent: name, min: 1)
            try self.validate(self.recordRowPath, name: "recordRowPath", parent: name, pattern: "^(?=^\\$)(?=^\\S+$).*$")
        }

        private enum CodingKeys: String, CodingKey {
            case recordRowPath = "RecordRowPath"
        }
    }

    public struct KinesisFirehoseInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct KinesisFirehoseInputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        @inlinable
        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct KinesisFirehoseInputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the input delivery stream to read.
        public let resourceARNUpdate: String

        @inlinable
        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct KinesisFirehoseOutput: AWSEncodableShape {
        /// The ARN of the destination delivery stream to write to.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct KinesisFirehoseOutputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        @inlinable
        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct KinesisFirehoseOutputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream to write to.
        public let resourceARNUpdate: String

        @inlinable
        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct KinesisStreamsInput: AWSEncodableShape {
        /// The ARN of the input Kinesis data stream to read.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct KinesisStreamsInputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        @inlinable
        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct KinesisStreamsInputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the input Kinesis data stream to read.
        public let resourceARNUpdate: String

        @inlinable
        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct KinesisStreamsOutput: AWSEncodableShape {
        /// The ARN of the destination Kinesis data stream to write to.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct KinesisStreamsOutputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to access the stream.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        @inlinable
        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct KinesisStreamsOutputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the output.
        public let resourceARNUpdate: String

        @inlinable
        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct LambdaOutput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the destination Lambda function to write to.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: Amazon Lambda
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct LambdaOutputDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination Lambda function.
        public let resourceARN: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination function.  Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let roleARN: String?

        @inlinable
        public init(resourceARN: String, roleARN: String? = nil) {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case roleARN = "RoleARN"
        }
    }

    public struct LambdaOutputUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the destination Amazon Lambda function.  To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see Example ARNs: Amazon Lambda
        public let resourceARNUpdate: String

        @inlinable
        public init(resourceARNUpdate: String) {
            self.resourceARNUpdate = resourceARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, max: 2048)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, min: 1)
            try self.validate(self.resourceARNUpdate, name: "resourceARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNUpdate = "ResourceARNUpdate"
        }
    }

    public struct ListApplicationOperationsRequest: AWSEncodableShape {
        public let applicationName: String
        public let limit: Int?
        public let nextToken: String?
        public let operation: String?
        public let operationStatus: OperationStatus?

        @inlinable
        public init(applicationName: String, limit: Int? = nil, nextToken: String? = nil, operation: String? = nil, operationStatus: OperationStatus? = nil) {
            self.applicationName = applicationName
            self.limit = limit
            self.nextToken = nextToken
            self.operation = operation
            self.operationStatus = operationStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 512)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.operation, name: "operation", parent: name, max: 64)
            try self.validate(self.operation, name: "operation", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case limit = "Limit"
            case nextToken = "NextToken"
            case operation = "Operation"
            case operationStatus = "OperationStatus"
        }
    }

    public struct ListApplicationOperationsResponse: AWSDecodableShape {
        public let applicationOperationInfoList: [ApplicationOperationInfo]?
        public let nextToken: String?

        @inlinable
        public init(applicationOperationInfoList: [ApplicationOperationInfo]? = nil, nextToken: String? = nil) {
            self.applicationOperationInfoList = applicationOperationInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationOperationInfoList = "ApplicationOperationInfoList"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationSnapshotsRequest: AWSEncodableShape {
        /// The name of an existing application.
        public let applicationName: String
        /// The maximum number of application snapshots to list.
        public let limit: Int?
        /// Use this parameter if you receive a NextToken response in a previous request that indicates that there is more  output available. Set it to the value of the previous call's NextToken response to indicate where the output should  continue from.
        public let nextToken: String?

        @inlinable
        public init(applicationName: String, limit: Int? = nil, nextToken: String? = nil) {
            self.applicationName = applicationName
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 512)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationSnapshotsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A collection of objects containing information about the application snapshots.
        public let snapshotSummaries: [SnapshotDetails]?

        @inlinable
        public init(nextToken: String? = nil, snapshotSummaries: [SnapshotDetails]? = nil) {
            self.nextToken = nextToken
            self.snapshotSummaries = snapshotSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case snapshotSummaries = "SnapshotSummaries"
        }
    }

    public struct ListApplicationVersionsRequest: AWSEncodableShape {
        /// The name of the application for which you want to list all versions.
        public let applicationName: String
        /// The maximum number of versions to list in this invocation of the operation.
        public let limit: Int?
        /// If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see  Using the Amazon Command Line Interface's Pagination Options.
        public let nextToken: String?

        @inlinable
        public init(applicationName: String, limit: Int? = nil, nextToken: String? = nil) {
            self.applicationName = applicationName
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 512)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationVersionsResponse: AWSDecodableShape {
        /// A list of the application versions and the associated configuration summaries. The list includes application versions that were rolled back. To get the complete description of a specific application version, invoke the DescribeApplicationVersion operation.
        public let applicationVersionSummaries: [ApplicationVersionSummary]?
        /// The pagination token for the next set of results, or null if there are no additional results.  To retrieve the next set of items, pass this token into a subsequent invocation of this operation. For more information about pagination, see  Using the Amazon Command Line Interface's Pagination Options.
        public let nextToken: String?

        @inlinable
        public init(applicationVersionSummaries: [ApplicationVersionSummary]? = nil, nextToken: String? = nil) {
            self.applicationVersionSummaries = applicationVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersionSummaries = "ApplicationVersionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The maximum number of applications to list.
        public let limit: Int?
        /// If a previous command returned a pagination token,  pass it into this value to retrieve the next set of results. For more information about pagination, see  Using the Amazon Command Line Interface's Pagination Options.
        public let nextToken: String?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 128)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// A list of ApplicationSummary objects.
        public let applicationSummaries: [ApplicationSummary]
        /// The pagination token for the next set of results, or null if there are no additional results. Pass this token into a subsequent command to retrieve the next set of items For more information about pagination, see  Using the Amazon Command Line Interface's Pagination Options.
        public let nextToken: String?

        @inlinable
        public init(applicationSummaries: [ApplicationSummary], nextToken: String? = nil) {
            self.applicationSummaries = applicationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSummaries = "ApplicationSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the application for which to retrieve tags.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value tags assigned to the application.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct MappingParameters: AWSEncodableShape & AWSDecodableShape {
        /// Provides additional mapping information when the record format uses delimiters  (for example, CSV).
        public let csvMappingParameters: CSVMappingParameters?
        /// Provides additional mapping information when JSON is the record format on the streaming source.
        public let jsonMappingParameters: JSONMappingParameters?

        @inlinable
        public init(csvMappingParameters: CSVMappingParameters? = nil, jsonMappingParameters: JSONMappingParameters? = nil) {
            self.csvMappingParameters = csvMappingParameters
            self.jsonMappingParameters = jsonMappingParameters
        }

        public func validate(name: String) throws {
            try self.csvMappingParameters?.validate(name: "\(name).csvMappingParameters")
            try self.jsonMappingParameters?.validate(name: "\(name).jsonMappingParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case csvMappingParameters = "CSVMappingParameters"
            case jsonMappingParameters = "JSONMappingParameters"
        }
    }

    public struct MavenReference: AWSEncodableShape & AWSDecodableShape {
        /// The artifact ID of the Maven reference.
        public let artifactId: String
        /// The group ID of the Maven reference.
        public let groupId: String
        /// The version of the Maven reference.
        public let version: String

        @inlinable
        public init(artifactId: String, groupId: String, version: String) {
            self.artifactId = artifactId
            self.groupId = groupId
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactId, name: "artifactId", parent: name, max: 256)
            try self.validate(self.artifactId, name: "artifactId", parent: name, min: 1)
            try self.validate(self.artifactId, name: "artifactId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.groupId, name: "groupId", parent: name, max: 256)
            try self.validate(self.groupId, name: "groupId", parent: name, min: 1)
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.version, name: "version", parent: name, max: 256)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactId = "ArtifactId"
            case groupId = "GroupId"
            case version = "Version"
        }
    }

    public struct MonitoringConfiguration: AWSEncodableShape {
        /// Describes whether to use the default CloudWatch logging configuration for an application.  You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
        public let configurationType: ConfigurationType
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public let logLevel: LogLevel?
        /// Describes the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
        public let metricsLevel: MetricsLevel?

        @inlinable
        public init(configurationType: ConfigurationType, logLevel: LogLevel? = nil, metricsLevel: MetricsLevel? = nil) {
            self.configurationType = configurationType
            self.logLevel = logLevel
            self.metricsLevel = metricsLevel
        }

        private enum CodingKeys: String, CodingKey {
            case configurationType = "ConfigurationType"
            case logLevel = "LogLevel"
            case metricsLevel = "MetricsLevel"
        }
    }

    public struct MonitoringConfigurationDescription: AWSDecodableShape {
        /// Describes whether to use the default CloudWatch logging configuration for an application.
        public let configurationType: ConfigurationType?
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public let logLevel: LogLevel?
        /// Describes the granularity of the CloudWatch Logs for an application.
        public let metricsLevel: MetricsLevel?

        @inlinable
        public init(configurationType: ConfigurationType? = nil, logLevel: LogLevel? = nil, metricsLevel: MetricsLevel? = nil) {
            self.configurationType = configurationType
            self.logLevel = logLevel
            self.metricsLevel = metricsLevel
        }

        private enum CodingKeys: String, CodingKey {
            case configurationType = "ConfigurationType"
            case logLevel = "LogLevel"
            case metricsLevel = "MetricsLevel"
        }
    }

    public struct MonitoringConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to whether to use the default CloudWatch logging configuration for  an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
        public let configurationTypeUpdate: ConfigurationType?
        /// Describes updates to the verbosity of the CloudWatch Logs for an application.
        public let logLevelUpdate: LogLevel?
        /// Describes updates to the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
        public let metricsLevelUpdate: MetricsLevel?

        @inlinable
        public init(configurationTypeUpdate: ConfigurationType? = nil, logLevelUpdate: LogLevel? = nil, metricsLevelUpdate: MetricsLevel? = nil) {
            self.configurationTypeUpdate = configurationTypeUpdate
            self.logLevelUpdate = logLevelUpdate
            self.metricsLevelUpdate = metricsLevelUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case configurationTypeUpdate = "ConfigurationTypeUpdate"
            case logLevelUpdate = "LogLevelUpdate"
            case metricsLevelUpdate = "MetricsLevelUpdate"
        }
    }

    public struct OperationFailureDetails: AWSDecodableShape {
        public let errorInfo: ErrorInfo?
        /// Provides the operation ID of a system-rollback operation executed due to failure in the current operation
        public let rollbackOperationId: String?

        @inlinable
        public init(errorInfo: ErrorInfo? = nil, rollbackOperationId: String? = nil) {
            self.errorInfo = errorInfo
            self.rollbackOperationId = rollbackOperationId
        }

        private enum CodingKeys: String, CodingKey {
            case errorInfo = "ErrorInfo"
            case rollbackOperationId = "RollbackOperationId"
        }
    }

    public struct Output: AWSEncodableShape {
        /// Describes the data format when records are written to the destination.
        public let destinationSchema: DestinationSchema
        /// Identifies a Kinesis Data Firehose delivery stream as the destination.
        public let kinesisFirehoseOutput: KinesisFirehoseOutput?
        /// Identifies a Kinesis data stream  as the destination.
        public let kinesisStreamsOutput: KinesisStreamsOutput?
        /// Identifies an Amazon Lambda function as the destination.
        public let lambdaOutput: LambdaOutput?
        /// The name of the in-application stream.
        public let name: String

        @inlinable
        public init(destinationSchema: DestinationSchema, kinesisFirehoseOutput: KinesisFirehoseOutput? = nil, kinesisStreamsOutput: KinesisStreamsOutput? = nil, lambdaOutput: LambdaOutput? = nil, name: String) {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutput = kinesisFirehoseOutput
            self.kinesisStreamsOutput = kinesisStreamsOutput
            self.lambdaOutput = lambdaOutput
            self.name = name
        }

        public func validate(name: String) throws {
            try self.kinesisFirehoseOutput?.validate(name: "\(name).kinesisFirehoseOutput")
            try self.kinesisStreamsOutput?.validate(name: "\(name).kinesisStreamsOutput")
            try self.lambdaOutput?.validate(name: "\(name).lambdaOutput")
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^-\\s<>&]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationSchema = "DestinationSchema"
            case kinesisFirehoseOutput = "KinesisFirehoseOutput"
            case kinesisStreamsOutput = "KinesisStreamsOutput"
            case lambdaOutput = "LambdaOutput"
            case name = "Name"
        }
    }

    public struct OutputDescription: AWSDecodableShape {
        /// The data format used for writing data to the destination.
        public let destinationSchema: DestinationSchema?
        /// Describes the Kinesis Data Firehose delivery stream that is configured as the destination where output is written.
        public let kinesisFirehoseOutputDescription: KinesisFirehoseOutputDescription?
        /// Describes the Kinesis data stream that is configured as the destination where output is written.
        public let kinesisStreamsOutputDescription: KinesisStreamsOutputDescription?
        /// Describes the Lambda function that is configured as the destination where output is written.
        public let lambdaOutputDescription: LambdaOutputDescription?
        /// The name of the in-application stream that is configured as output.
        public let name: String?
        /// A unique identifier for the output configuration.
        public let outputId: String?

        @inlinable
        public init(destinationSchema: DestinationSchema? = nil, kinesisFirehoseOutputDescription: KinesisFirehoseOutputDescription? = nil, kinesisStreamsOutputDescription: KinesisStreamsOutputDescription? = nil, lambdaOutputDescription: LambdaOutputDescription? = nil, name: String? = nil, outputId: String? = nil) {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription
            self.kinesisStreamsOutputDescription = kinesisStreamsOutputDescription
            self.lambdaOutputDescription = lambdaOutputDescription
            self.name = name
            self.outputId = outputId
        }

        private enum CodingKeys: String, CodingKey {
            case destinationSchema = "DestinationSchema"
            case kinesisFirehoseOutputDescription = "KinesisFirehoseOutputDescription"
            case kinesisStreamsOutputDescription = "KinesisStreamsOutputDescription"
            case lambdaOutputDescription = "LambdaOutputDescription"
            case name = "Name"
            case outputId = "OutputId"
        }
    }

    public struct OutputUpdate: AWSEncodableShape {
        /// Describes the data format when records are written to the destination.
        public let destinationSchemaUpdate: DestinationSchema?
        /// Describes a Kinesis Data Firehose delivery stream as the destination for the output.
        public let kinesisFirehoseOutputUpdate: KinesisFirehoseOutputUpdate?
        /// Describes a Kinesis data stream as the destination for the output.
        public let kinesisStreamsOutputUpdate: KinesisStreamsOutputUpdate?
        /// Describes an Amazon Lambda function as the destination for the output.
        public let lambdaOutputUpdate: LambdaOutputUpdate?
        /// If you want to specify a different in-application stream  for this output configuration, use this field to  specify the new in-application stream name.
        public let nameUpdate: String?
        /// Identifies the specific output configuration that you want to update.
        public let outputId: String

        @inlinable
        public init(destinationSchemaUpdate: DestinationSchema? = nil, kinesisFirehoseOutputUpdate: KinesisFirehoseOutputUpdate? = nil, kinesisStreamsOutputUpdate: KinesisStreamsOutputUpdate? = nil, lambdaOutputUpdate: LambdaOutputUpdate? = nil, nameUpdate: String? = nil, outputId: String) {
            self.destinationSchemaUpdate = destinationSchemaUpdate
            self.kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate
            self.kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate
            self.lambdaOutputUpdate = lambdaOutputUpdate
            self.nameUpdate = nameUpdate
            self.outputId = outputId
        }

        public func validate(name: String) throws {
            try self.kinesisFirehoseOutputUpdate?.validate(name: "\(name).kinesisFirehoseOutputUpdate")
            try self.kinesisStreamsOutputUpdate?.validate(name: "\(name).kinesisStreamsOutputUpdate")
            try self.lambdaOutputUpdate?.validate(name: "\(name).lambdaOutputUpdate")
            try self.validate(self.nameUpdate, name: "nameUpdate", parent: name, max: 32)
            try self.validate(self.nameUpdate, name: "nameUpdate", parent: name, min: 1)
            try self.validate(self.nameUpdate, name: "nameUpdate", parent: name, pattern: "^[^-\\s<>&]*$")
            try self.validate(self.outputId, name: "outputId", parent: name, max: 50)
            try self.validate(self.outputId, name: "outputId", parent: name, min: 1)
            try self.validate(self.outputId, name: "outputId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationSchemaUpdate = "DestinationSchemaUpdate"
            case kinesisFirehoseOutputUpdate = "KinesisFirehoseOutputUpdate"
            case kinesisStreamsOutputUpdate = "KinesisStreamsOutputUpdate"
            case lambdaOutputUpdate = "LambdaOutputUpdate"
            case nameUpdate = "NameUpdate"
            case outputId = "OutputId"
        }
    }

    public struct ParallelismConfiguration: AWSEncodableShape {
        /// Describes whether the Managed Service for Apache Flink service can increase the parallelism of the application in response to increased throughput.
        public let autoScalingEnabled: Bool?
        /// Describes whether the application uses the default parallelism for the Managed Service for Apache Flink service. You must set this property to CUSTOM in order to change your application's AutoScalingEnabled, Parallelism, or ParallelismPerKPU properties.
        public let configurationType: ConfigurationType
        /// Describes the initial number of parallel tasks that a Managed Service for Apache Flink application can perform. If AutoScalingEnabled  is set to True, Managed Service for Apache Flink increases the CurrentParallelism value in response to application load. The service can increase the CurrentParallelism value up to the maximum parallelism, which is  ParalellismPerKPU times the maximum KPUs for the application.  The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If  application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public let parallelism: Int?
        /// Describes the number of parallel tasks that a Managed Service for Apache Flink application can perform per Kinesis Processing Unit  (KPU) used by the application. For more information about KPUs, see Amazon Managed Service for Apache Flink Pricing.
        public let parallelismPerKPU: Int?

        @inlinable
        public init(autoScalingEnabled: Bool? = nil, configurationType: ConfigurationType, parallelism: Int? = nil, parallelismPerKPU: Int? = nil) {
            self.autoScalingEnabled = autoScalingEnabled
            self.configurationType = configurationType
            self.parallelism = parallelism
            self.parallelismPerKPU = parallelismPerKPU
        }

        public func validate(name: String) throws {
            try self.validate(self.parallelism, name: "parallelism", parent: name, min: 1)
            try self.validate(self.parallelismPerKPU, name: "parallelismPerKPU", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingEnabled = "AutoScalingEnabled"
            case configurationType = "ConfigurationType"
            case parallelism = "Parallelism"
            case parallelismPerKPU = "ParallelismPerKPU"
        }
    }

    public struct ParallelismConfigurationDescription: AWSDecodableShape {
        /// Describes whether the Managed Service for Apache Flink service can increase the parallelism of the application in response to increased throughput.
        public let autoScalingEnabled: Bool?
        /// Describes whether the application uses the default parallelism for the Managed Service for Apache Flink service.
        public let configurationType: ConfigurationType?
        /// Describes the current number of parallel tasks that a Managed Service for Apache Flink application can perform.  If AutoScalingEnabled is set to True, Managed Service for Apache Flink can increase this value in response to application load. The service can increase this value up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application.  The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public let currentParallelism: Int?
        /// Describes the initial number of parallel tasks that a Managed Service for Apache Flink application can perform.  If AutoScalingEnabled is set to True, then Managed Service for Apache Flink can increase the CurrentParallelism value in response to application load. The service can increase CurrentParallelism up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application.  The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce the CurrentParallelism value down to the Parallelism setting.
        public let parallelism: Int?
        /// Describes the number of parallel tasks that a Managed Service for Apache Flink application can perform per  Kinesis Processing Unit (KPU) used by the application.
        public let parallelismPerKPU: Int?

        @inlinable
        public init(autoScalingEnabled: Bool? = nil, configurationType: ConfigurationType? = nil, currentParallelism: Int? = nil, parallelism: Int? = nil, parallelismPerKPU: Int? = nil) {
            self.autoScalingEnabled = autoScalingEnabled
            self.configurationType = configurationType
            self.currentParallelism = currentParallelism
            self.parallelism = parallelism
            self.parallelismPerKPU = parallelismPerKPU
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingEnabled = "AutoScalingEnabled"
            case configurationType = "ConfigurationType"
            case currentParallelism = "CurrentParallelism"
            case parallelism = "Parallelism"
            case parallelismPerKPU = "ParallelismPerKPU"
        }
    }

    public struct ParallelismConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to whether the Managed Service for Apache Flink service can increase the parallelism of a Managed Service for Apache Flink application in response to increased throughput.
        public let autoScalingEnabledUpdate: Bool?
        /// Describes updates to whether the application uses the default parallelism for the Managed Service for Apache Flink service, or if a custom parallelism is used. You must set this property to CUSTOM in order to change your application's AutoScalingEnabled, Parallelism, or ParallelismPerKPU properties.
        public let configurationTypeUpdate: ConfigurationType?
        /// Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.
        public let parallelismPerKPUUpdate: Int?
        /// Describes updates to the initial number of parallel tasks an application can perform. If AutoScalingEnabled is set to True, then  Managed Service for Apache Flink can increase the CurrentParallelism value in response to application load. The service can increase CurrentParallelism up to the maximum parallelism, which is ParalellismPerKPU times the maximum KPUs for the application.  The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will reduce CurrentParallelism down to the Parallelism setting.
        public let parallelismUpdate: Int?

        @inlinable
        public init(autoScalingEnabledUpdate: Bool? = nil, configurationTypeUpdate: ConfigurationType? = nil, parallelismPerKPUUpdate: Int? = nil, parallelismUpdate: Int? = nil) {
            self.autoScalingEnabledUpdate = autoScalingEnabledUpdate
            self.configurationTypeUpdate = configurationTypeUpdate
            self.parallelismPerKPUUpdate = parallelismPerKPUUpdate
            self.parallelismUpdate = parallelismUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.parallelismPerKPUUpdate, name: "parallelismPerKPUUpdate", parent: name, min: 1)
            try self.validate(self.parallelismUpdate, name: "parallelismUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingEnabledUpdate = "AutoScalingEnabledUpdate"
            case configurationTypeUpdate = "ConfigurationTypeUpdate"
            case parallelismPerKPUUpdate = "ParallelismPerKPUUpdate"
            case parallelismUpdate = "ParallelismUpdate"
        }
    }

    public struct PropertyGroup: AWSEncodableShape & AWSDecodableShape {
        /// Describes the key of an application execution property key-value pair.
        public let propertyGroupId: String
        /// Describes the value of an application execution property key-value pair.
        public let propertyMap: [String: String]

        @inlinable
        public init(propertyGroupId: String, propertyMap: [String: String]) {
            self.propertyGroupId = propertyGroupId
            self.propertyMap = propertyMap
        }

        public func validate(name: String) throws {
            try self.validate(self.propertyGroupId, name: "propertyGroupId", parent: name, max: 50)
            try self.validate(self.propertyGroupId, name: "propertyGroupId", parent: name, min: 1)
            try self.validate(self.propertyGroupId, name: "propertyGroupId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.propertyMap.forEach {
                try validate($0.key, name: "propertyMap.key", parent: name, max: 2048)
                try validate($0.key, name: "propertyMap.key", parent: name, min: 1)
                try validate($0.value, name: "propertyMap[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "propertyMap[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.propertyMap, name: "propertyMap", parent: name, max: 50)
            try self.validate(self.propertyMap, name: "propertyMap", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case propertyGroupId = "PropertyGroupId"
            case propertyMap = "PropertyMap"
        }
    }

    public struct RecordColumn: AWSEncodableShape & AWSDecodableShape {
        /// A reference to the data element in the streaming input or the reference data source.
        public let mapping: String?
        /// The name of the column that is created in the in-application input stream or reference table.
        public let name: String
        /// The type of column created in the in-application input stream or reference table.
        public let sqlType: String

        @inlinable
        public init(mapping: String? = nil, name: String, sqlType: String) {
            self.mapping = mapping
            self.name = name
            self.sqlType = sqlType
        }

        public func validate(name: String) throws {
            try self.validate(self.mapping, name: "mapping", parent: name, max: 65535)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^-\\s<>&]*$")
            try self.validate(self.sqlType, name: "sqlType", parent: name, max: 100)
            try self.validate(self.sqlType, name: "sqlType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mapping = "Mapping"
            case name = "Name"
            case sqlType = "SqlType"
        }
    }

    public struct RecordFormat: AWSEncodableShape & AWSDecodableShape {
        /// When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        public let mappingParameters: MappingParameters?
        /// The type of record format.
        public let recordFormatType: RecordFormatType

        @inlinable
        public init(mappingParameters: MappingParameters? = nil, recordFormatType: RecordFormatType) {
            self.mappingParameters = mappingParameters
            self.recordFormatType = recordFormatType
        }

        public func validate(name: String) throws {
            try self.mappingParameters?.validate(name: "\(name).mappingParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case mappingParameters = "MappingParameters"
            case recordFormatType = "RecordFormatType"
        }
    }

    public struct ReferenceDataSource: AWSEncodableShape {
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public let referenceSchema: SourceSchema
        /// Identifies the S3 bucket and object that contains the reference data.  A SQL-based Kinesis Data Analytics application loads reference data only once. If the data changes, you call the UpdateApplication operation to trigger reloading of data into your application.
        public let s3ReferenceDataSource: S3ReferenceDataSource?
        /// The name of the in-application table to create.
        public let tableName: String

        @inlinable
        public init(referenceSchema: SourceSchema, s3ReferenceDataSource: S3ReferenceDataSource? = nil, tableName: String) {
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSource = s3ReferenceDataSource
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.referenceSchema.validate(name: "\(name).referenceSchema")
            try self.s3ReferenceDataSource?.validate(name: "\(name).s3ReferenceDataSource")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 32)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case referenceSchema = "ReferenceSchema"
            case s3ReferenceDataSource = "S3ReferenceDataSource"
            case tableName = "TableName"
        }
    }

    public struct ReferenceDataSourceDescription: AWSDecodableShape {
        /// The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns when you add the reference data source to your application using the CreateApplication or UpdateApplication operation.
        public let referenceId: String
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public let referenceSchema: SourceSchema?
        /// Provides the Amazon S3 bucket name, the object key name that contains the reference data.
        public let s3ReferenceDataSourceDescription: S3ReferenceDataSourceDescription
        /// The in-application table name created by the specific reference data source configuration.
        public let tableName: String

        @inlinable
        public init(referenceId: String, referenceSchema: SourceSchema? = nil, s3ReferenceDataSourceDescription: S3ReferenceDataSourceDescription, tableName: String) {
            self.referenceId = referenceId
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case referenceId = "ReferenceId"
            case referenceSchema = "ReferenceSchema"
            case s3ReferenceDataSourceDescription = "S3ReferenceDataSourceDescription"
            case tableName = "TableName"
        }
    }

    public struct ReferenceDataSourceUpdate: AWSEncodableShape {
        /// The ID of the reference data source that is being updated. You can use the DescribeApplication operation to get this value.
        public let referenceId: String
        /// Describes the format of the data in the streaming source, and how each data element maps to  corresponding columns created in the in-application stream.
        public let referenceSchemaUpdate: SourceSchema?
        /// Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.
        public let s3ReferenceDataSourceUpdate: S3ReferenceDataSourceUpdate?
        /// The in-application table name that is created by this update.
        public let tableNameUpdate: String?

        @inlinable
        public init(referenceId: String, referenceSchemaUpdate: SourceSchema? = nil, s3ReferenceDataSourceUpdate: S3ReferenceDataSourceUpdate? = nil, tableNameUpdate: String? = nil) {
            self.referenceId = referenceId
            self.referenceSchemaUpdate = referenceSchemaUpdate
            self.s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate
            self.tableNameUpdate = tableNameUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.referenceId, name: "referenceId", parent: name, max: 50)
            try self.validate(self.referenceId, name: "referenceId", parent: name, min: 1)
            try self.validate(self.referenceId, name: "referenceId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.referenceSchemaUpdate?.validate(name: "\(name).referenceSchemaUpdate")
            try self.s3ReferenceDataSourceUpdate?.validate(name: "\(name).s3ReferenceDataSourceUpdate")
            try self.validate(self.tableNameUpdate, name: "tableNameUpdate", parent: name, max: 32)
            try self.validate(self.tableNameUpdate, name: "tableNameUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case referenceId = "ReferenceId"
            case referenceSchemaUpdate = "ReferenceSchemaUpdate"
            case s3ReferenceDataSourceUpdate = "S3ReferenceDataSourceUpdate"
            case tableNameUpdate = "TableNameUpdate"
        }
    }

    public struct RollbackApplicationRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// The current application version ID. You can retrieve the application version ID using  DescribeApplication.
        public let currentApplicationVersionId: Int64

        @inlinable
        public init(applicationName: String, currentApplicationVersionId: Int64) {
            self.applicationName = applicationName
            self.currentApplicationVersionId = currentApplicationVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
        }
    }

    public struct RollbackApplicationResponse: AWSDecodableShape {
        public let applicationDetail: ApplicationDetail
        /// Operation ID for tracking RollbackApplication request
        public let operationId: String?

        @inlinable
        public init(applicationDetail: ApplicationDetail, operationId: String? = nil) {
            self.applicationDetail = applicationDetail
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationDetail = "ApplicationDetail"
            case operationId = "OperationId"
        }
    }

    public struct RunConfiguration: AWSEncodableShape {
        /// Describes the restore behavior of a restarting application.
        public let applicationRestoreConfiguration: ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Managed Service for Apache Flink application.
        public let flinkRunConfiguration: FlinkRunConfiguration?
        /// Describes the starting parameters for a SQL-based Kinesis Data Analytics application application.
        public let sqlRunConfigurations: [SqlRunConfiguration]?

        @inlinable
        public init(applicationRestoreConfiguration: ApplicationRestoreConfiguration? = nil, flinkRunConfiguration: FlinkRunConfiguration? = nil, sqlRunConfigurations: [SqlRunConfiguration]? = nil) {
            self.applicationRestoreConfiguration = applicationRestoreConfiguration
            self.flinkRunConfiguration = flinkRunConfiguration
            self.sqlRunConfigurations = sqlRunConfigurations
        }

        public func validate(name: String) throws {
            try self.applicationRestoreConfiguration?.validate(name: "\(name).applicationRestoreConfiguration")
            try self.sqlRunConfigurations?.forEach {
                try $0.validate(name: "\(name).sqlRunConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicationRestoreConfiguration = "ApplicationRestoreConfiguration"
            case flinkRunConfiguration = "FlinkRunConfiguration"
            case sqlRunConfigurations = "SqlRunConfigurations"
        }
    }

    public struct RunConfigurationDescription: AWSDecodableShape {
        /// Describes the restore behavior of a restarting application.
        public let applicationRestoreConfigurationDescription: ApplicationRestoreConfiguration?
        public let flinkRunConfigurationDescription: FlinkRunConfiguration?

        @inlinable
        public init(applicationRestoreConfigurationDescription: ApplicationRestoreConfiguration? = nil, flinkRunConfigurationDescription: FlinkRunConfiguration? = nil) {
            self.applicationRestoreConfigurationDescription = applicationRestoreConfigurationDescription
            self.flinkRunConfigurationDescription = flinkRunConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationRestoreConfigurationDescription = "ApplicationRestoreConfigurationDescription"
            case flinkRunConfigurationDescription = "FlinkRunConfigurationDescription"
        }
    }

    public struct RunConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to the restore behavior of a restarting application.
        public let applicationRestoreConfiguration: ApplicationRestoreConfiguration?
        /// Describes the starting parameters for a Managed Service for Apache Flink application.
        public let flinkRunConfiguration: FlinkRunConfiguration?

        @inlinable
        public init(applicationRestoreConfiguration: ApplicationRestoreConfiguration? = nil, flinkRunConfiguration: FlinkRunConfiguration? = nil) {
            self.applicationRestoreConfiguration = applicationRestoreConfiguration
            self.flinkRunConfiguration = flinkRunConfiguration
        }

        public func validate(name: String) throws {
            try self.applicationRestoreConfiguration?.validate(name: "\(name).applicationRestoreConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationRestoreConfiguration = "ApplicationRestoreConfiguration"
            case flinkRunConfiguration = "FlinkRunConfiguration"
        }
    }

    public struct S3ApplicationCodeLocationDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        public let bucketARN: String
        /// The file key for the object containing the application code.
        public let fileKey: String
        /// The version of the object containing the application code.
        public let objectVersion: String?

        @inlinable
        public init(bucketARN: String, fileKey: String, objectVersion: String? = nil) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
            case objectVersion = "ObjectVersion"
        }
    }

    public struct S3Configuration: AWSEncodableShape {
        /// The ARN of the S3 bucket that contains the data.
        public let bucketARN: String
        /// The name of the object that contains the data.
        public let fileKey: String

        @inlinable
        public init(bucketARN: String, fileKey: String) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, max: 2048)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, min: 1)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, pattern: "^arn:")
            try self.validate(self.fileKey, name: "fileKey", parent: name, max: 1024)
            try self.validate(self.fileKey, name: "fileKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
        }
    }

    public struct S3ContentBaseLocation: AWSEncodableShape {
        /// The base path for the S3 bucket.
        public let basePath: String?
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARN: String

        @inlinable
        public init(basePath: String? = nil, bucketARN: String) {
            self.basePath = basePath
            self.bucketARN = bucketARN
        }

        public func validate(name: String) throws {
            try self.validate(self.basePath, name: "basePath", parent: name, max: 1024)
            try self.validate(self.basePath, name: "basePath", parent: name, min: 1)
            try self.validate(self.basePath, name: "basePath", parent: name, pattern: "^[a-zA-Z0-9/!-_.*'()]+$")
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, max: 2048)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, min: 1)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case basePath = "BasePath"
            case bucketARN = "BucketARN"
        }
    }

    public struct S3ContentBaseLocationDescription: AWSDecodableShape {
        /// The base path for the S3 bucket.
        public let basePath: String?
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARN: String

        @inlinable
        public init(basePath: String? = nil, bucketARN: String) {
            self.basePath = basePath
            self.bucketARN = bucketARN
        }

        private enum CodingKeys: String, CodingKey {
            case basePath = "BasePath"
            case bucketARN = "BucketARN"
        }
    }

    public struct S3ContentBaseLocationUpdate: AWSEncodableShape {
        /// The updated S3 bucket path.
        public let basePathUpdate: String?
        /// The updated Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARNUpdate: String?

        @inlinable
        public init(basePathUpdate: String? = nil, bucketARNUpdate: String? = nil) {
            self.basePathUpdate = basePathUpdate
            self.bucketARNUpdate = bucketARNUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.basePathUpdate, name: "basePathUpdate", parent: name, max: 1024)
            try self.validate(self.basePathUpdate, name: "basePathUpdate", parent: name, min: 1)
            try self.validate(self.basePathUpdate, name: "basePathUpdate", parent: name, pattern: "^[a-zA-Z0-9/!-_.*'()]+$")
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, max: 2048)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, min: 1)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case basePathUpdate = "BasePathUpdate"
            case bucketARNUpdate = "BucketARNUpdate"
        }
    }

    public struct S3ContentLocation: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        public let bucketARN: String
        /// The file key for the object containing the application code.
        public let fileKey: String
        /// The version of the object containing the application code.
        public let objectVersion: String?

        @inlinable
        public init(bucketARN: String, fileKey: String, objectVersion: String? = nil) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, max: 2048)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, min: 1)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, pattern: "^arn:")
            try self.validate(self.fileKey, name: "fileKey", parent: name, max: 1024)
            try self.validate(self.fileKey, name: "fileKey", parent: name, min: 1)
            try self.validate(self.objectVersion, name: "objectVersion", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
            case objectVersion = "ObjectVersion"
        }
    }

    public struct S3ContentLocationUpdate: AWSEncodableShape {
        /// The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.
        public let bucketARNUpdate: String?
        /// The new file key for the object containing the application code.
        public let fileKeyUpdate: String?
        /// The new version of the object containing the application code.
        public let objectVersionUpdate: String?

        @inlinable
        public init(bucketARNUpdate: String? = nil, fileKeyUpdate: String? = nil, objectVersionUpdate: String? = nil) {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
            self.objectVersionUpdate = objectVersionUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, max: 2048)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, min: 1)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, pattern: "^arn:")
            try self.validate(self.fileKeyUpdate, name: "fileKeyUpdate", parent: name, max: 1024)
            try self.validate(self.fileKeyUpdate, name: "fileKeyUpdate", parent: name, min: 1)
            try self.validate(self.objectVersionUpdate, name: "objectVersionUpdate", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARNUpdate = "BucketARNUpdate"
            case fileKeyUpdate = "FileKeyUpdate"
            case objectVersionUpdate = "ObjectVersionUpdate"
        }
    }

    public struct S3ReferenceDataSource: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARN: String?
        /// The object key name containing the reference data.
        public let fileKey: String?

        @inlinable
        public init(bucketARN: String? = nil, fileKey: String? = nil) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, max: 2048)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, min: 1)
            try self.validate(self.bucketARN, name: "bucketARN", parent: name, pattern: "^arn:")
            try self.validate(self.fileKey, name: "fileKey", parent: name, max: 1024)
            try self.validate(self.fileKey, name: "fileKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
        }
    }

    public struct S3ReferenceDataSourceDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARN: String
        /// Amazon S3 object key name.
        public let fileKey: String
        /// The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3 object on your behalf to populate the in-application reference table.   Provided for backward compatibility. Applications that are created with the current API version have an application-level service execution role rather than a resource-level role.
        public let referenceRoleARN: String?

        @inlinable
        public init(bucketARN: String, fileKey: String, referenceRoleARN: String? = nil) {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.referenceRoleARN = referenceRoleARN
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARN = "BucketARN"
            case fileKey = "FileKey"
            case referenceRoleARN = "ReferenceRoleARN"
        }
    }

    public struct S3ReferenceDataSourceUpdate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let bucketARNUpdate: String?
        /// The object key name.
        public let fileKeyUpdate: String?

        @inlinable
        public init(bucketARNUpdate: String? = nil, fileKeyUpdate: String? = nil) {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, max: 2048)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, min: 1)
            try self.validate(self.bucketARNUpdate, name: "bucketARNUpdate", parent: name, pattern: "^arn:")
            try self.validate(self.fileKeyUpdate, name: "fileKeyUpdate", parent: name, max: 1024)
            try self.validate(self.fileKeyUpdate, name: "fileKeyUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketARNUpdate = "BucketARNUpdate"
            case fileKeyUpdate = "FileKeyUpdate"
        }
    }

    public struct SnapshotDetails: AWSDecodableShape {
        /// The current application version ID when the snapshot was created.
        public let applicationVersionId: Int64
        /// The Flink Runtime for the application snapshot.
        public let runtimeEnvironment: RuntimeEnvironment?
        /// The timestamp of the application snapshot.
        public let snapshotCreationTimestamp: Date?
        /// The identifier for the application snapshot.
        public let snapshotName: String
        /// The status of the application snapshot.
        public let snapshotStatus: SnapshotStatus

        @inlinable
        public init(applicationVersionId: Int64, runtimeEnvironment: RuntimeEnvironment? = nil, snapshotCreationTimestamp: Date? = nil, snapshotName: String, snapshotStatus: SnapshotStatus) {
            self.applicationVersionId = applicationVersionId
            self.runtimeEnvironment = runtimeEnvironment
            self.snapshotCreationTimestamp = snapshotCreationTimestamp
            self.snapshotName = snapshotName
            self.snapshotStatus = snapshotStatus
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersionId = "ApplicationVersionId"
            case runtimeEnvironment = "RuntimeEnvironment"
            case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
            case snapshotName = "SnapshotName"
            case snapshotStatus = "SnapshotStatus"
        }
    }

    public struct SourceSchema: AWSEncodableShape & AWSDecodableShape {
        /// A list of RecordColumn objects.
        public let recordColumns: [RecordColumn]
        /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
        public let recordEncoding: String?
        /// Specifies the format of the records on the streaming source.
        public let recordFormat: RecordFormat

        @inlinable
        public init(recordColumns: [RecordColumn], recordEncoding: String? = nil, recordFormat: RecordFormat) {
            self.recordColumns = recordColumns
            self.recordEncoding = recordEncoding
            self.recordFormat = recordFormat
        }

        public func validate(name: String) throws {
            try self.recordColumns.forEach {
                try $0.validate(name: "\(name).recordColumns[]")
            }
            try self.validate(self.recordColumns, name: "recordColumns", parent: name, max: 1000)
            try self.validate(self.recordColumns, name: "recordColumns", parent: name, min: 1)
            try self.validate(self.recordEncoding, name: "recordEncoding", parent: name, max: 5)
            try self.validate(self.recordEncoding, name: "recordEncoding", parent: name, min: 5)
            try self.validate(self.recordEncoding, name: "recordEncoding", parent: name, pattern: "^UTF-8$")
            try self.recordFormat.validate(name: "\(name).recordFormat")
        }

        private enum CodingKeys: String, CodingKey {
            case recordColumns = "RecordColumns"
            case recordEncoding = "RecordEncoding"
            case recordFormat = "RecordFormat"
        }
    }

    public struct SqlApplicationConfiguration: AWSEncodableShape {
        /// The array of Input objects describing the input streams used by the application.
        public let inputs: [Input]?
        /// The array of Output objects describing the destination streams used by the application.
        public let outputs: [Output]?
        /// The array of ReferenceDataSource objects describing the reference data sources used by the application.
        public let referenceDataSources: [ReferenceDataSource]?

        @inlinable
        public init(inputs: [Input]? = nil, outputs: [Output]? = nil, referenceDataSources: [ReferenceDataSource]? = nil) {
            self.inputs = inputs
            self.outputs = outputs
            self.referenceDataSources = referenceDataSources
        }

        public func validate(name: String) throws {
            try self.inputs?.forEach {
                try $0.validate(name: "\(name).inputs[]")
            }
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.referenceDataSources?.forEach {
                try $0.validate(name: "\(name).referenceDataSources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case outputs = "Outputs"
            case referenceDataSources = "ReferenceDataSources"
        }
    }

    public struct SqlApplicationConfigurationDescription: AWSDecodableShape {
        /// The array of InputDescription objects describing the input streams used by the application.
        public let inputDescriptions: [InputDescription]?
        /// The array of OutputDescription objects describing the destination streams used by the application.
        public let outputDescriptions: [OutputDescription]?
        /// The array of ReferenceDataSourceDescription objects describing the reference data sources used by the application.
        public let referenceDataSourceDescriptions: [ReferenceDataSourceDescription]?

        @inlinable
        public init(inputDescriptions: [InputDescription]? = nil, outputDescriptions: [OutputDescription]? = nil, referenceDataSourceDescriptions: [ReferenceDataSourceDescription]? = nil) {
            self.inputDescriptions = inputDescriptions
            self.outputDescriptions = outputDescriptions
            self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case inputDescriptions = "InputDescriptions"
            case outputDescriptions = "OutputDescriptions"
            case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
        }
    }

    public struct SqlApplicationConfigurationUpdate: AWSEncodableShape {
        /// The array of InputUpdate objects describing the new input streams used by the application.
        public let inputUpdates: [InputUpdate]?
        /// The array of OutputUpdate objects describing the new destination streams used by the application.
        public let outputUpdates: [OutputUpdate]?
        /// The array of ReferenceDataSourceUpdate objects describing the new reference data sources used by the application.
        public let referenceDataSourceUpdates: [ReferenceDataSourceUpdate]?

        @inlinable
        public init(inputUpdates: [InputUpdate]? = nil, outputUpdates: [OutputUpdate]? = nil, referenceDataSourceUpdates: [ReferenceDataSourceUpdate]? = nil) {
            self.inputUpdates = inputUpdates
            self.outputUpdates = outputUpdates
            self.referenceDataSourceUpdates = referenceDataSourceUpdates
        }

        public func validate(name: String) throws {
            try self.inputUpdates?.forEach {
                try $0.validate(name: "\(name).inputUpdates[]")
            }
            try self.outputUpdates?.forEach {
                try $0.validate(name: "\(name).outputUpdates[]")
            }
            try self.referenceDataSourceUpdates?.forEach {
                try $0.validate(name: "\(name).referenceDataSourceUpdates[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inputUpdates = "InputUpdates"
            case outputUpdates = "OutputUpdates"
            case referenceDataSourceUpdates = "ReferenceDataSourceUpdates"
        }
    }

    public struct SqlRunConfiguration: AWSEncodableShape {
        /// The input source ID. You can get this ID by calling the DescribeApplication operation.
        public let inputId: String
        /// The point at which you want the application to start processing records from the streaming source.
        public let inputStartingPositionConfiguration: InputStartingPositionConfiguration

        @inlinable
        public init(inputId: String, inputStartingPositionConfiguration: InputStartingPositionConfiguration) {
            self.inputId = inputId
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.inputId, name: "inputId", parent: name, max: 50)
            try self.validate(self.inputId, name: "inputId", parent: name, min: 1)
            try self.validate(self.inputId, name: "inputId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputId = "InputId"
            case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        }
    }

    public struct StartApplicationRequest: AWSEncodableShape {
        /// The name of the application.
        public let applicationName: String
        /// Identifies the run configuration (start parameters) of a Managed Service for Apache Flink application.
        public let runConfiguration: RunConfiguration?

        @inlinable
        public init(applicationName: String, runConfiguration: RunConfiguration? = nil) {
            self.applicationName = applicationName
            self.runConfiguration = runConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.runConfiguration?.validate(name: "\(name).runConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case runConfiguration = "RunConfiguration"
        }
    }

    public struct StartApplicationResponse: AWSDecodableShape {
        /// Operation ID for tracking StartApplication request
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct StopApplicationRequest: AWSEncodableShape {
        /// The name of the running application to stop.
        public let applicationName: String
        /// Set to true to force the application to stop. If you set Force to true, Managed Service for Apache Flink stops the application without taking a snapshot.    Force-stopping your application may lead to data loss or duplication. To prevent data loss or duplicate processing of data during application restarts,  we recommend you to take frequent snapshots of your application.  You can only force stop a Managed Service for Apache Flink application. You can't force stop a SQL-based Kinesis Data Analytics application. The application must be in the STARTING, UPDATING, STOPPING, AUTOSCALING, or RUNNING status.
        public let force: Bool?

        @inlinable
        public init(applicationName: String, force: Bool? = nil) {
            self.applicationName = applicationName
            self.force = force
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case force = "Force"
        }
    }

    public struct StopApplicationResponse: AWSDecodableShape {
        /// Operation ID for tracking StopApplication request
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the key-value tag.
        public let key: String
        /// The value of the key-value tag. The value is optional.
        public let value: String?

        @inlinable
        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the application to assign the tags.
        public let resourceARN: String
        /// The key-value tags to assign to the application.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UnableToDetectSchemaException: AWSErrorShape {
        public let message: String?
        /// Stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
        public let processedInputRecords: [String]?
        /// Raw stream data that was sampled to infer the schema.
        public let rawInputRecords: [String]?

        @inlinable
        public init(message: String? = nil, processedInputRecords: [String]? = nil, rawInputRecords: [String]? = nil) {
            self.message = message
            self.processedInputRecords = processedInputRecords
            self.rawInputRecords = rawInputRecords
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case processedInputRecords = "ProcessedInputRecords"
            case rawInputRecords = "RawInputRecords"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the Managed Service for Apache Flink application from which to remove the tags.
        public let resourceARN: String
        /// A list of keys of tags to remove from the specified application.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationMaintenanceConfigurationRequest: AWSEncodableShape {
        /// Describes the application maintenance configuration update.
        public let applicationMaintenanceConfigurationUpdate: ApplicationMaintenanceConfigurationUpdate
        /// The name of the application for which you want to update the maintenance configuration.
        public let applicationName: String

        @inlinable
        public init(applicationMaintenanceConfigurationUpdate: ApplicationMaintenanceConfigurationUpdate, applicationName: String) {
            self.applicationMaintenanceConfigurationUpdate = applicationMaintenanceConfigurationUpdate
            self.applicationName = applicationName
        }

        public func validate(name: String) throws {
            try self.applicationMaintenanceConfigurationUpdate.validate(name: "\(name).applicationMaintenanceConfigurationUpdate")
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMaintenanceConfigurationUpdate = "ApplicationMaintenanceConfigurationUpdate"
            case applicationName = "ApplicationName"
        }
    }

    public struct UpdateApplicationMaintenanceConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationARN: String?
        /// The application maintenance configuration description after the update.
        public let applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription?

        @inlinable
        public init(applicationARN: String? = nil, applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription? = nil) {
            self.applicationARN = applicationARN
            self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case applicationARN = "ApplicationARN"
            case applicationMaintenanceConfigurationDescription = "ApplicationMaintenanceConfigurationDescription"
        }
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// Describes application configuration updates.
        public let applicationConfigurationUpdate: ApplicationConfigurationUpdate?
        /// The name of the application to update.
        public let applicationName: String
        /// Describes application Amazon CloudWatch logging option updates. You can only update existing CloudWatch logging options with this action. To add a new CloudWatch logging option, use AddApplicationCloudWatchLoggingOption.
        public let cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]?
        /// A value you use to implement strong concurrency for application updates. You must provide the CurrentApplicationVersionId or the ConditionalToken. You get the application's current ConditionalToken using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let conditionalToken: String?
        /// The current application version ID. You must provide the CurrentApplicationVersionId or the ConditionalToken.You can retrieve the application version ID using DescribeApplication. For better concurrency support, use the ConditionalToken parameter instead of CurrentApplicationVersionId.
        public let currentApplicationVersionId: Int64?
        /// Describes updates to the application's starting parameters.
        public let runConfigurationUpdate: RunConfigurationUpdate?
        /// Updates the Managed Service for Apache Flink runtime environment used to run your code. To avoid issues you must:   Ensure your new jar and dependencies are compatible with the new runtime selected.   Ensure your new code's state is compatible with the snapshot from which your application will start
        public let runtimeEnvironmentUpdate: RuntimeEnvironment?
        /// Describes updates to the service execution role.
        public let serviceExecutionRoleUpdate: String?

        @inlinable
        public init(applicationConfigurationUpdate: ApplicationConfigurationUpdate? = nil, applicationName: String, cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]? = nil, conditionalToken: String? = nil, currentApplicationVersionId: Int64? = nil, runConfigurationUpdate: RunConfigurationUpdate? = nil, runtimeEnvironmentUpdate: RuntimeEnvironment? = nil, serviceExecutionRoleUpdate: String? = nil) {
            self.applicationConfigurationUpdate = applicationConfigurationUpdate
            self.applicationName = applicationName
            self.cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates
            self.conditionalToken = conditionalToken
            self.currentApplicationVersionId = currentApplicationVersionId
            self.runConfigurationUpdate = runConfigurationUpdate
            self.runtimeEnvironmentUpdate = runtimeEnvironmentUpdate
            self.serviceExecutionRoleUpdate = serviceExecutionRoleUpdate
        }

        public func validate(name: String) throws {
            try self.applicationConfigurationUpdate?.validate(name: "\(name).applicationConfigurationUpdate")
            try self.validate(self.applicationName, name: "applicationName", parent: name, max: 128)
            try self.validate(self.applicationName, name: "applicationName", parent: name, min: 1)
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.cloudWatchLoggingOptionUpdates?.forEach {
                try $0.validate(name: "\(name).cloudWatchLoggingOptionUpdates[]")
            }
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, max: 512)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, min: 1)
            try self.validate(self.conditionalToken, name: "conditionalToken", parent: name, pattern: "^[a-zA-Z0-9-_+/=]+$")
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, max: 999999999)
            try self.validate(self.currentApplicationVersionId, name: "currentApplicationVersionId", parent: name, min: 1)
            try self.runConfigurationUpdate?.validate(name: "\(name).runConfigurationUpdate")
            try self.validate(self.serviceExecutionRoleUpdate, name: "serviceExecutionRoleUpdate", parent: name, max: 2048)
            try self.validate(self.serviceExecutionRoleUpdate, name: "serviceExecutionRoleUpdate", parent: name, min: 1)
            try self.validate(self.serviceExecutionRoleUpdate, name: "serviceExecutionRoleUpdate", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationConfigurationUpdate = "ApplicationConfigurationUpdate"
            case applicationName = "ApplicationName"
            case cloudWatchLoggingOptionUpdates = "CloudWatchLoggingOptionUpdates"
            case conditionalToken = "ConditionalToken"
            case currentApplicationVersionId = "CurrentApplicationVersionId"
            case runConfigurationUpdate = "RunConfigurationUpdate"
            case runtimeEnvironmentUpdate = "RuntimeEnvironmentUpdate"
            case serviceExecutionRoleUpdate = "ServiceExecutionRoleUpdate"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        /// Describes application updates.
        public let applicationDetail: ApplicationDetail
        /// Operation ID for tracking UpdateApplication request
        public let operationId: String?

        @inlinable
        public init(applicationDetail: ApplicationDetail, operationId: String? = nil) {
            self.applicationDetail = applicationDetail
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationDetail = "ApplicationDetail"
            case operationId = "OperationId"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape {
        /// The array of SecurityGroup  IDs used by the VPC configuration.
        public let securityGroupIds: [String]
        /// The array of Subnet IDs  used by the VPC configuration.
        public let subnetIds: [String]

        @inlinable
        public init(securityGroupIds: [String], subnetIds: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 16)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct VpcConfigurationDescription: AWSDecodableShape {
        /// The array of SecurityGroup  IDs used by the VPC configuration.
        public let securityGroupIds: [String]
        /// The array of Subnet  IDs used by the VPC configuration.
        public let subnetIds: [String]
        /// The ID of the VPC configuration.
        public let vpcConfigurationId: String
        /// The ID of the associated VPC.
        public let vpcId: String

        @inlinable
        public init(securityGroupIds: [String], subnetIds: [String], vpcConfigurationId: String, vpcId: String) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcConfigurationId = vpcConfigurationId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcConfigurationId = "VpcConfigurationId"
            case vpcId = "VpcId"
        }
    }

    public struct VpcConfigurationUpdate: AWSEncodableShape {
        /// Describes updates to the array of  SecurityGroup IDs used by the VPC configuration.
        public let securityGroupIdUpdates: [String]?
        /// Describes updates to the array of Subnet  IDs  used by the VPC configuration.
        public let subnetIdUpdates: [String]?
        /// Describes an update to the ID of the VPC configuration.
        public let vpcConfigurationId: String

        @inlinable
        public init(securityGroupIdUpdates: [String]? = nil, subnetIdUpdates: [String]? = nil, vpcConfigurationId: String) {
            self.securityGroupIdUpdates = securityGroupIdUpdates
            self.subnetIdUpdates = subnetIdUpdates
            self.vpcConfigurationId = vpcConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.securityGroupIdUpdates, name: "securityGroupIdUpdates", parent: name, max: 5)
            try self.validate(self.securityGroupIdUpdates, name: "securityGroupIdUpdates", parent: name, min: 1)
            try self.validate(self.subnetIdUpdates, name: "subnetIdUpdates", parent: name, max: 16)
            try self.validate(self.subnetIdUpdates, name: "subnetIdUpdates", parent: name, min: 1)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, max: 50)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, min: 1)
            try self.validate(self.vpcConfigurationId, name: "vpcConfigurationId", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIdUpdates = "SecurityGroupIdUpdates"
            case subnetIdUpdates = "SubnetIdUpdates"
            case vpcConfigurationId = "VpcConfigurationId"
        }
    }

    public struct ZeppelinApplicationConfiguration: AWSEncodableShape {
        /// The Amazon Glue Data Catalog that you use in queries in a Managed Service for Apache Flink Studio notebook.
        public let catalogConfiguration: CatalogConfiguration?
        /// Custom artifacts are dependency JARs and user-defined functions (UDF).
        public let customArtifactsConfiguration: [CustomArtifactConfiguration]?
        /// The information required to deploy a Managed Service for Apache Flink Studio notebook as an application with durable state.
        public let deployAsApplicationConfiguration: DeployAsApplicationConfiguration?
        /// The monitoring configuration of a Managed Service for Apache Flink Studio notebook.
        public let monitoringConfiguration: ZeppelinMonitoringConfiguration?

        @inlinable
        public init(catalogConfiguration: CatalogConfiguration? = nil, customArtifactsConfiguration: [CustomArtifactConfiguration]? = nil, deployAsApplicationConfiguration: DeployAsApplicationConfiguration? = nil, monitoringConfiguration: ZeppelinMonitoringConfiguration? = nil) {
            self.catalogConfiguration = catalogConfiguration
            self.customArtifactsConfiguration = customArtifactsConfiguration
            self.deployAsApplicationConfiguration = deployAsApplicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }

        public func validate(name: String) throws {
            try self.catalogConfiguration?.validate(name: "\(name).catalogConfiguration")
            try self.customArtifactsConfiguration?.forEach {
                try $0.validate(name: "\(name).customArtifactsConfiguration[]")
            }
            try self.validate(self.customArtifactsConfiguration, name: "customArtifactsConfiguration", parent: name, max: 50)
            try self.deployAsApplicationConfiguration?.validate(name: "\(name).deployAsApplicationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogConfiguration = "CatalogConfiguration"
            case customArtifactsConfiguration = "CustomArtifactsConfiguration"
            case deployAsApplicationConfiguration = "DeployAsApplicationConfiguration"
            case monitoringConfiguration = "MonitoringConfiguration"
        }
    }

    public struct ZeppelinApplicationConfigurationDescription: AWSDecodableShape {
        /// The Amazon Glue Data Catalog that is associated with the Managed Service for Apache Flink Studio notebook.
        public let catalogConfigurationDescription: CatalogConfigurationDescription?
        /// Custom artifacts are dependency JARs and user-defined functions (UDF).
        public let customArtifactsConfigurationDescription: [CustomArtifactConfigurationDescription]?
        /// The parameters required to deploy a Managed Service for Apache Flink Studio notebook as an application with durable state.
        public let deployAsApplicationConfigurationDescription: DeployAsApplicationConfigurationDescription?
        /// The monitoring configuration of a Managed Service for Apache Flink Studio notebook.
        public let monitoringConfigurationDescription: ZeppelinMonitoringConfigurationDescription

        @inlinable
        public init(catalogConfigurationDescription: CatalogConfigurationDescription? = nil, customArtifactsConfigurationDescription: [CustomArtifactConfigurationDescription]? = nil, deployAsApplicationConfigurationDescription: DeployAsApplicationConfigurationDescription? = nil, monitoringConfigurationDescription: ZeppelinMonitoringConfigurationDescription) {
            self.catalogConfigurationDescription = catalogConfigurationDescription
            self.customArtifactsConfigurationDescription = customArtifactsConfigurationDescription
            self.deployAsApplicationConfigurationDescription = deployAsApplicationConfigurationDescription
            self.monitoringConfigurationDescription = monitoringConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case catalogConfigurationDescription = "CatalogConfigurationDescription"
            case customArtifactsConfigurationDescription = "CustomArtifactsConfigurationDescription"
            case deployAsApplicationConfigurationDescription = "DeployAsApplicationConfigurationDescription"
            case monitoringConfigurationDescription = "MonitoringConfigurationDescription"
        }
    }

    public struct ZeppelinApplicationConfigurationUpdate: AWSEncodableShape {
        /// Updates to the configuration of the Amazon Glue Data Catalog that is associated with the Managed Service for Apache Flink Studio notebook.
        public let catalogConfigurationUpdate: CatalogConfigurationUpdate?
        /// Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).
        public let customArtifactsConfigurationUpdate: [CustomArtifactConfiguration]?
        public let deployAsApplicationConfigurationUpdate: DeployAsApplicationConfigurationUpdate?
        /// Updates to the monitoring configuration of a Managed Service for Apache Flink Studio notebook.
        public let monitoringConfigurationUpdate: ZeppelinMonitoringConfigurationUpdate?

        @inlinable
        public init(catalogConfigurationUpdate: CatalogConfigurationUpdate? = nil, customArtifactsConfigurationUpdate: [CustomArtifactConfiguration]? = nil, deployAsApplicationConfigurationUpdate: DeployAsApplicationConfigurationUpdate? = nil, monitoringConfigurationUpdate: ZeppelinMonitoringConfigurationUpdate? = nil) {
            self.catalogConfigurationUpdate = catalogConfigurationUpdate
            self.customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdate
            self.deployAsApplicationConfigurationUpdate = deployAsApplicationConfigurationUpdate
            self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
        }

        public func validate(name: String) throws {
            try self.catalogConfigurationUpdate?.validate(name: "\(name).catalogConfigurationUpdate")
            try self.customArtifactsConfigurationUpdate?.forEach {
                try $0.validate(name: "\(name).customArtifactsConfigurationUpdate[]")
            }
            try self.validate(self.customArtifactsConfigurationUpdate, name: "customArtifactsConfigurationUpdate", parent: name, max: 50)
            try self.deployAsApplicationConfigurationUpdate?.validate(name: "\(name).deployAsApplicationConfigurationUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogConfigurationUpdate = "CatalogConfigurationUpdate"
            case customArtifactsConfigurationUpdate = "CustomArtifactsConfigurationUpdate"
            case deployAsApplicationConfigurationUpdate = "DeployAsApplicationConfigurationUpdate"
            case monitoringConfigurationUpdate = "MonitoringConfigurationUpdate"
        }
    }

    public struct ZeppelinMonitoringConfiguration: AWSEncodableShape {
        /// The verbosity of the CloudWatch Logs for an application.
        public let logLevel: LogLevel

        @inlinable
        public init(logLevel: LogLevel) {
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel = "LogLevel"
        }
    }

    public struct ZeppelinMonitoringConfigurationDescription: AWSDecodableShape {
        /// Describes the verbosity of the CloudWatch Logs for an application.
        public let logLevel: LogLevel?

        @inlinable
        public init(logLevel: LogLevel? = nil) {
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case logLevel = "LogLevel"
        }
    }

    public struct ZeppelinMonitoringConfigurationUpdate: AWSEncodableShape {
        /// Updates to the logging level for Apache Zeppelin within a Managed Service for Apache Flink Studio notebook.
        public let logLevelUpdate: LogLevel

        @inlinable
        public init(logLevelUpdate: LogLevel) {
            self.logLevelUpdate = logLevelUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case logLevelUpdate = "LogLevelUpdate"
        }
    }
}

// MARK: - Errors

/// Error enum for KinesisAnalyticsV2
public struct KinesisAnalyticsV2ErrorType: AWSErrorType {
    enum Code: String {
        case codeValidationException = "CodeValidationException"
        case concurrentModificationException = "ConcurrentModificationException"
        case invalidApplicationConfigurationException = "InvalidApplicationConfigurationException"
        case invalidArgumentException = "InvalidArgumentException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceProvisionedThroughputExceededException = "ResourceProvisionedThroughputExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyTagsException = "TooManyTagsException"
        case unableToDetectSchemaException = "UnableToDetectSchemaException"
        case unsupportedOperationException = "UnsupportedOperationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize KinesisAnalyticsV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The user-provided application code (query) is not valid. This can be a simple syntax error.
    public static var codeValidationException: Self { .init(.codeValidationException) }
    /// Exception thrown as a result of concurrent modifications to an application. This error can be the result of attempting to modify an application without using the current application ID.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// The user-provided application configuration is not valid.
    public static var invalidApplicationConfigurationException: Self { .init(.invalidApplicationConfigurationException) }
    /// The specified input parameter value is not valid.
    public static var invalidArgumentException: Self { .init(.invalidArgumentException) }
    /// The request JSON is not valid for the operation.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The number of allowed resources has been exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The application is not available for this operation.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// Specified application can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Discovery failed to get a record from the streaming source because of the Kinesis Streams ProvisionedThroughputExceededException. For more information, see GetRecords in the Amazon Kinesis Streams API Reference.
    public static var resourceProvisionedThroughputExceededException: Self { .init(.resourceProvisionedThroughputExceededException) }
    /// The service cannot complete the request.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// Application created with too many tags, or too many tags added to an application. Note that the maximum  number of application tags includes system tags. The maximum number of user-defined application tags is 50.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The data format is not valid. Kinesis Data Analytics cannot detect the schema for the given streaming source.
    public static var unableToDetectSchemaException: Self { .init(.unableToDetectSchemaException) }
    /// The request was rejected because a specified parameter is not supported or a specified resource is not valid for this  operation.
    public static var unsupportedOperationException: Self { .init(.unsupportedOperationException) }
}

extension KinesisAnalyticsV2ErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "UnableToDetectSchemaException": KinesisAnalyticsV2.UnableToDetectSchemaException.self
    ]
}

extension KinesisAnalyticsV2ErrorType: Equatable {
    public static func == (lhs: KinesisAnalyticsV2ErrorType, rhs: KinesisAnalyticsV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension KinesisAnalyticsV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
