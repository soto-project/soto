//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CodeArtifact {
    // MARK: Enums

    public enum AllowPublish: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case block = "BLOCK"
        public var description: String { return self.rawValue }
    }

    public enum AllowUpstream: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case block = "BLOCK"
        public var description: String { return self.rawValue }
    }

    public enum DomainStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case deleted = "Deleted"
        public var description: String { return self.rawValue }
    }

    public enum EndpointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dualstack = "dualstack"
        case ipv4 = "ipv4"
        public var description: String { return self.rawValue }
    }

    public enum ExternalConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        public var description: String { return self.rawValue }
    }

    public enum HashAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case md5 = "MD5"
        case sha1 = "SHA-1"
        case sha256 = "SHA-256"
        case sha512 = "SHA-512"
        public var description: String { return self.rawValue }
    }

    public enum PackageFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cargo = "cargo"
        case generic = "generic"
        case maven = "maven"
        case npm = "npm"
        case nuget = "nuget"
        case pypi = "pypi"
        case ruby = "ruby"
        case swift = "swift"
        public var description: String { return self.rawValue }
    }

    public enum PackageGroupAllowedRepositoryUpdateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case added = "ADDED"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum PackageGroupAssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case strong = "STRONG"
        case weak = "WEAK"
        public var description: String { return self.rawValue }
    }

    public enum PackageGroupOriginRestrictionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case allowSpecificRepositories = "ALLOW_SPECIFIC_REPOSITORIES"
        case block = "BLOCK"
        case inherit = "INHERIT"
        public var description: String { return self.rawValue }
    }

    public enum PackageGroupOriginRestrictionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case externalUpstream = "EXTERNAL_UPSTREAM"
        case internalUpstream = "INTERNAL_UPSTREAM"
        case publish = "PUBLISH"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alreadyExists = "ALREADY_EXISTS"
        case mismatchedRevision = "MISMATCHED_REVISION"
        case mismatchedStatus = "MISMATCHED_STATUS"
        case notAllowed = "NOT_ALLOWED"
        case notFound = "NOT_FOUND"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionOriginType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `internal` = "INTERNAL"
        case external = "EXTERNAL"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionSortType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case publishedTime = "PUBLISHED_TIME"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archived = "Archived"
        case deleted = "Deleted"
        case disposed = "Disposed"
        case published = "Published"
        case unfinished = "Unfinished"
        case unlisted = "Unlisted"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "asset"
        case domain = "domain"
        case package = "package"
        case packageVersion = "package-version"
        case repository = "repository"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CANNOT_PARSE"
        case encryptionKeyError = "ENCRYPTION_KEY_ERROR"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case other = "OTHER"
        case unknownOperation = "UNKNOWN_OPERATION"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssetSummary: AWSDecodableShape {
        ///  The hashes of the asset.
        public let hashes: [HashAlgorithm: String]?
        ///  The name of the asset.
        public let name: String
        ///  The size of the asset.
        public let size: Int64?

        @inlinable
        public init(hashes: [HashAlgorithm: String]? = nil, name: String, size: Int64? = nil) {
            self.hashes = hashes
            self.name = name
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case hashes = "hashes"
            case name = "name"
            case size = "size"
        }
    }

    public struct AssociateExternalConnectionRequest: AWSEncodableShape {
        /// The name of the domain that contains the repository.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The name of the external connection to add to the repository. The following values are supported:     public:npmjs - for the npm public repository.     public:nuget-org - for the NuGet Gallery.     public:pypi - for the Python Package Index.     public:maven-central - for Maven Central.     public:maven-googleandroid - for the Google Android repository.     public:maven-gradleplugins - for the Gradle plugins repository.     public:maven-commonsware - for the CommonsWare Android repository.     public:maven-clojars - for the Clojars repository.     public:ruby-gems-org - for RubyGems.org.     public:crates-io - for Crates.io.
        public let externalConnection: String
        ///  The name of the repository to which the external connection is added.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, externalConnection: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.externalConnection = externalConnection
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.externalConnection, key: "external-connection")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.externalConnection, name: "externalConnection", parent: name, max: 100)
            try self.validate(self.externalConnection, name: "externalConnection", parent: name, min: 2)
            try self.validate(self.externalConnection, name: "externalConnection", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-:]{1,99}$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateExternalConnectionResult: AWSDecodableShape {
        ///  Information about the connected repository after processing the request.
        public let repository: RepositoryDescription?

        @inlinable
        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct AssociatedPackage: AWSDecodableShape {
        /// Describes the strength of the association between the package and package group. A strong match can be thought of as an  exact match, and a weak match can be thought of as a variation match, for example, the package name matches a variation of the package group pattern.  For more information about package group pattern matching, including strong and weak matches, see Package group definition syntax and matching behavior  in the CodeArtifact User Guide.
        public let associationType: PackageGroupAssociationType?
        /// A format that specifies the type of the associated package.
        public let format: PackageFormat?
        /// The namespace of the associated package. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the associated package.
        public let package: String?

        @inlinable
        public init(associationType: PackageGroupAssociationType? = nil, format: PackageFormat? = nil, namespace: String? = nil, package: String? = nil) {
            self.associationType = associationType
            self.format = format
            self.namespace = namespace
            self.package = package
        }

        private enum CodingKeys: String, CodingKey {
            case associationType = "associationType"
            case format = "format"
            case namespace = "namespace"
            case package = "package"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        ///  The ID of the resource.
        public let resourceId: String?
        ///  The type of Amazon Web Services resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CopyPackageVersionsRequest: AWSEncodableShape {
        ///  Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the failedVersions field of the response with  an ALREADY_EXISTS error code.
        public let allowOverwrite: Bool?
        ///  The name of the repository into which package versions are copied.
        public let destinationRepository: String
        ///  The name of the domain that contains the source and destination repositories.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The format of the package versions to be copied.
        public let format: PackageFormat
        ///  Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see Working with upstream repositories.
        public let includeFromUpstream: Bool?
        /// The namespace of the package versions to be copied. The package component that specifies its namespace depends on its type. For example:  The namespace is required when copying package versions of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the package that contains the versions to be copied.
        public let package: String
        ///  The name of the repository that contains the package versions to be copied.
        public let sourceRepository: String
        ///  A list of key-value pairs. The keys are package versions and the values are package version revisions. A CopyPackageVersion operation succeeds if the specified versions in the source repository match the specified package version revision.    You must specify versions or versionRevisions. You cannot specify both.
        public let versionRevisions: [String: String]?
        ///  The versions of the package to be copied.    You must specify versions or versionRevisions. You cannot specify both.
        public let versions: [String]?

        @inlinable
        public init(allowOverwrite: Bool? = nil, destinationRepository: String, domain: String, domainOwner: String? = nil, format: PackageFormat, includeFromUpstream: Bool? = nil, namespace: String? = nil, package: String, sourceRepository: String, versionRevisions: [String: String]? = nil, versions: [String]? = nil) {
            self.allowOverwrite = allowOverwrite
            self.destinationRepository = destinationRepository
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.includeFromUpstream = includeFromUpstream
            self.namespace = namespace
            self.package = package
            self.sourceRepository = sourceRepository
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowOverwrite, forKey: .allowOverwrite)
            request.encodeQuery(self.destinationRepository, key: "destination-repository")
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            try container.encodeIfPresent(self.includeFromUpstream, forKey: .includeFromUpstream)
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.sourceRepository, key: "source-repository")
            try container.encodeIfPresent(self.versionRevisions, forKey: .versionRevisions)
            try container.encodeIfPresent(self.versions, forKey: .versions)
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationRepository, name: "destinationRepository", parent: name, max: 100)
            try self.validate(self.destinationRepository, name: "destinationRepository", parent: name, min: 2)
            try self.validate(self.destinationRepository, name: "destinationRepository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.sourceRepository, name: "sourceRepository", parent: name, max: 100)
            try self.validate(self.sourceRepository, name: "sourceRepository", parent: name, min: 2)
            try self.validate(self.sourceRepository, name: "sourceRepository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
            try self.versionRevisions?.forEach {
                try validate($0.key, name: "versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name: "versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name: "versionRevisions.key", parent: name, pattern: "^[^#/\\s]+$")
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.versions?.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "^[^#/\\s]+$")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case allowOverwrite = "allowOverwrite"
            case includeFromUpstream = "includeFromUpstream"
            case versionRevisions = "versionRevisions"
            case versions = "versions"
        }
    }

    public struct CopyPackageVersionsResult: AWSDecodableShape {
        ///  A map of package versions that failed to copy and their error codes. The possible error codes are in  the PackageVersionError data type. They are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully copied to your repository.
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        @inlinable
        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions = "failedVersions"
            case successfulVersions = "successfulVersions"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        ///  The name of the domain to create. All domain names in an Amazon Web Services Region that are in the same Amazon Web Services account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable.
        public let domain: String
        ///  The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an encryptionKey, your IAM role must have kms:DescribeKey and kms:CreateGrant permissions on the encryption key that is used. For more information, see DescribeKey in the Key Management Service API Reference and Key Management Service API Permissions Reference in the Key Management Service Developer Guide.   CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see Using symmetric and asymmetric keys in the Key Management Service Developer Guide.
        public let encryptionKey: String?
        /// One or more tag key-value pairs for the domain.
        public let tags: [Tag]?

        @inlinable
        public init(domain: String, encryptionKey: String? = nil, tags: [Tag]? = nil) {
            self.domain = domain
            self.encryptionKey = encryptionKey
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            try container.encodeIfPresent(self.encryptionKey, forKey: .encryptionKey)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, max: 1011)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, min: 1)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, pattern: "^\\S+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKey = "encryptionKey"
            case tags = "tags"
        }
    }

    public struct CreateDomainResult: AWSDecodableShape {
        ///  Contains information about the created domain after processing the request.
        public let domain: DomainDescription?

        @inlinable
        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct CreatePackageGroupRequest: AWSEncodableShape {
        ///  The contact information for the created package group.
        public let contactInfo: String?
        ///  A description of the package group.
        public let description: String?
        ///  The name of the domain in which you want to create a package group.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The pattern of the package group to create. The pattern is also the identifier of the package group.
        public let packageGroup: String
        /// One or more tag key-value pairs for the package group.
        public let tags: [Tag]?

        @inlinable
        public init(contactInfo: String? = nil, description: String? = nil, domain: String, domainOwner: String? = nil, packageGroup: String, tags: [Tag]? = nil) {
            self.contactInfo = contactInfo
            self.description = description
            self.domain = domain
            self.domainOwner = domainOwner
            self.packageGroup = packageGroup
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.contactInfo, forKey: .contactInfo)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            try container.encode(self.packageGroup, forKey: .packageGroup)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactInfo, name: "contactInfo", parent: name, max: 1000)
            try self.validate(self.contactInfo, name: "contactInfo", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, max: 520)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, min: 2)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, pattern: "^[^\\p{C}\\p{IsWhitespace}]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case contactInfo = "contactInfo"
            case description = "description"
            case packageGroup = "packageGroup"
            case tags = "tags"
        }
    }

    public struct CreatePackageGroupResult: AWSDecodableShape {
        ///  Information about the created package group after processing the request.
        public let packageGroup: PackageGroupDescription?

        @inlinable
        public init(packageGroup: PackageGroupDescription? = nil) {
            self.packageGroup = packageGroup
        }

        private enum CodingKeys: String, CodingKey {
            case packageGroup = "packageGroup"
        }
    }

    public struct CreateRepositoryRequest: AWSEncodableShape {
        ///  A description of the created repository.
        public let description: String?
        ///  The name of the domain that contains the created repository.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The name of the repository to create.
        public let repository: String
        /// One or more tag key-value pairs for the repository.
        public let tags: [Tag]?
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories  in the list determines their priority order when CodeArtifact looks for a requested package version. For more  information, see Working with upstream repositories.
        public let upstreams: [UpstreamRepository]?

        @inlinable
        public init(description: String? = nil, domain: String, domainOwner: String? = nil, repository: String, tags: [Tag]? = nil, upstreams: [UpstreamRepository]? = nil) {
            self.description = description
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
            self.tags = tags
            self.upstreams = upstreams
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.repository, key: "repository")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.upstreams, forKey: .upstreams)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.upstreams?.forEach {
                try $0.validate(name: "\(name).upstreams[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case tags = "tags"
            case upstreams = "upstreams"
        }
    }

    public struct CreateRepositoryResult: AWSDecodableShape {
        ///  Information about the created repository after processing the request.
        public let repository: RepositoryDescription?

        @inlinable
        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DeleteDomainPermissionsPolicyRequest: AWSEncodableShape {
        ///  The name of the domain associated with the resource policy to be deleted.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy.
        public let policyRevision: String?

        @inlinable
        public init(domain: String, domainOwner: String? = nil, policyRevision: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyRevision = policyRevision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.policyRevision, key: "policy-revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, max: 100)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainPermissionsPolicyResult: AWSDecodableShape {
        ///  Information about the deleted resource policy after processing the request.
        public let policy: ResourcePolicy?

        @inlinable
        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        ///  The name of the domain to delete.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?

        @inlinable
        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainResult: AWSDecodableShape {
        ///  Contains information about the deleted domain after processing the request.
        public let domain: DomainDescription?

        @inlinable
        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct DeletePackageGroupRequest: AWSEncodableShape {
        ///  The domain that contains the package group to be deleted.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The pattern of the package group to be deleted.
        public let packageGroup: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, packageGroup: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.packageGroup = packageGroup
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.packageGroup, key: "package-group")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackageGroupResult: AWSDecodableShape {
        ///  Information about the deleted package group after processing the request.
        public let packageGroup: PackageGroupDescription?

        @inlinable
        public init(packageGroup: PackageGroupDescription? = nil) {
            self.packageGroup = packageGroup
        }

        private enum CodingKeys: String, CodingKey {
            case packageGroup = "packageGroup"
        }
    }

    public struct DeletePackageRequest: AWSEncodableShape {
        /// The name of the domain that contains the package to delete.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The format of the requested package to delete.
        public let format: PackageFormat
        /// The namespace of the package to delete. The package component that specifies its namespace depends on its type. For example:  The namespace is required when deleting packages of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        /// The name of the package to delete.
        public let package: String
        /// The name of the repository that contains the package to delete.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackageResult: AWSDecodableShape {
        public let deletedPackage: PackageSummary?

        @inlinable
        public init(deletedPackage: PackageSummary? = nil) {
            self.deletedPackage = deletedPackage
        }

        private enum CodingKeys: String, CodingKey {
            case deletedPackage = "deletedPackage"
        }
    }

    public struct DeletePackageVersionsRequest: AWSEncodableShape {
        ///  The name of the domain that contains the package to delete.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The expected status of the package version to delete.
        public let expectedStatus: PackageVersionStatus?
        ///  The format of the package versions to delete.
        public let format: PackageFormat
        /// The namespace of the package versions to be deleted. The package component that specifies its namespace depends on its type. For example:  The namespace is required when deleting package versions of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the package with the versions to delete.
        public let package: String
        ///  The name of the repository that contains the package versions to delete.
        public let repository: String
        ///  An array of strings that specify the versions of the package to delete.
        public let versions: [String]

        @inlinable
        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.versions = versions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            try container.encodeIfPresent(self.expectedStatus, forKey: .expectedStatus)
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.repository, key: "repository")
            try container.encode(self.versions, forKey: .versions)
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "^[^#/\\s]+$")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case expectedStatus = "expectedStatus"
            case versions = "versions"
        }
    }

    public struct DeletePackageVersionsResult: AWSDecodableShape {
        ///  A PackageVersionError object that contains a map of errors codes for the  deleted package that failed. The possible error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully deleted. The  status of every successful version will be Deleted.
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        @inlinable
        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions = "failedVersions"
            case successfulVersions = "successfulVersions"
        }
    }

    public struct DeleteRepositoryPermissionsPolicyRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository associated with the resource policy to be deleted.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy.
        public let policyRevision: String?
        ///  The name of the repository that is associated with the resource policy to be deleted
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, policyRevision: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyRevision = policyRevision
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.policyRevision, key: "policy-revision")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, max: 100)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, pattern: "^\\S+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRepositoryPermissionsPolicyResult: AWSDecodableShape {
        ///  Information about the deleted policy after processing the request.
        public let policy: ResourcePolicy?

        @inlinable
        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct DeleteRepositoryRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository to delete.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository to delete.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRepositoryResult: AWSDecodableShape {
        ///  Information about the deleted repository after processing the request.
        public let repository: RepositoryDescription?

        @inlinable
        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DescribeDomainRequest: AWSEncodableShape {
        ///  A string that specifies the name of the requested domain.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?

        @inlinable
        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainResult: AWSDecodableShape {
        public let domain: DomainDescription?

        @inlinable
        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct DescribePackageGroupRequest: AWSEncodableShape {
        ///  The name of the domain that contains the package group.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The pattern of the requested package group.
        public let packageGroup: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, packageGroup: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.packageGroup = packageGroup
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.packageGroup, key: "package-group")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, max: 520)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, min: 2)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, pattern: "^[^\\p{C}\\p{IsWhitespace}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackageGroupResult: AWSDecodableShape {
        /// A PackageGroupDescription object  that contains information about the requested package group.
        public let packageGroup: PackageGroupDescription?

        @inlinable
        public init(packageGroup: PackageGroupDescription? = nil) {
            self.packageGroup = packageGroup
        }

        private enum CodingKeys: String, CodingKey {
            case packageGroup = "packageGroup"
        }
    }

    public struct DescribePackageRequest: AWSEncodableShape {
        /// The name of the domain that contains the repository that contains the package.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// A format that specifies the type of the requested package.
        public let format: PackageFormat
        /// The namespace of the requested package. The package component that specifies its namespace depends on its type. For example:  The namespace is required when requesting packages of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        /// The name of the requested package.
        public let package: String
        /// The name of the repository that contains the requested package.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackageResult: AWSDecodableShape {
        /// A PackageDescription  object that contains information about the requested package.
        public let package: PackageDescription

        @inlinable
        public init(package: PackageDescription) {
            self.package = package
        }

        private enum CodingKeys: String, CodingKey {
            case package = "package"
        }
    }

    public struct DescribePackageVersionRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository that contains the package version.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  A format that specifies the type of the requested package version.
        public let format: PackageFormat
        /// The namespace of the requested package version. The package component that specifies its  namespace depends on its type. For example:  The namespace is required when requesting package versions of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the requested package version.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The name of the repository that contains the package version.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.packageVersion, key: "version")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackageVersionResult: AWSDecodableShape {
        ///  A PackageVersionDescription  object that contains information about the requested package version.
        public let packageVersion: PackageVersionDescription

        @inlinable
        public init(packageVersion: PackageVersionDescription) {
            self.packageVersion = packageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case packageVersion = "packageVersion"
        }
    }

    public struct DescribeRepositoryRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository to describe.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  A string that specifies the name of the requested repository.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRepositoryResult: AWSDecodableShape {
        ///  A RepositoryDescription object that contains the requested repository information.
        public let repository: RepositoryDescription?

        @inlinable
        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DisassociateExternalConnectionRequest: AWSEncodableShape {
        /// The name of the domain that contains the repository from which to remove the external repository.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The name of the external connection to be removed from the repository.
        public let externalConnection: String
        /// The name of the repository from which the external connection will be removed.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, externalConnection: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.externalConnection = externalConnection
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.externalConnection, key: "external-connection")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.externalConnection, name: "externalConnection", parent: name, max: 100)
            try self.validate(self.externalConnection, name: "externalConnection", parent: name, min: 2)
            try self.validate(self.externalConnection, name: "externalConnection", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-:]{1,99}$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateExternalConnectionResult: AWSDecodableShape {
        ///  The repository associated with the removed external connection.
        public let repository: RepositoryDescription?

        @inlinable
        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DisposePackageVersionsRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository you want to dispose.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The expected status of the package version to dispose.
        public let expectedStatus: PackageVersionStatus?
        ///  A format that specifies the type of package versions you want to dispose.
        public let format: PackageFormat
        /// The namespace of the package versions to be disposed. The package component that specifies its  namespace depends on its type. For example:  The namespace is required when disposing package versions of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the package with the versions you want to dispose.
        public let package: String
        ///  The name of the repository that contains the package versions you want to dispose.
        public let repository: String
        ///  The revisions of the package versions you want to dispose.
        public let versionRevisions: [String: String]?
        ///  The versions of the package you want to dispose.
        public let versions: [String]

        @inlinable
        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, versionRevisions: [String: String]? = nil, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            try container.encodeIfPresent(self.expectedStatus, forKey: .expectedStatus)
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.repository, key: "repository")
            try container.encodeIfPresent(self.versionRevisions, forKey: .versionRevisions)
            try container.encode(self.versions, forKey: .versions)
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
            try self.versionRevisions?.forEach {
                try validate($0.key, name: "versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name: "versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name: "versionRevisions.key", parent: name, pattern: "^[^#/\\s]+$")
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "^[^#/\\s]+$")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case expectedStatus = "expectedStatus"
            case versionRevisions = "versionRevisions"
            case versions = "versions"
        }
    }

    public struct DisposePackageVersionsResult: AWSDecodableShape {
        ///  A PackageVersionError object that contains a map of errors codes for the  disposed package versions that failed. The possible error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully disposed.
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        @inlinable
        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions = "failedVersions"
            case successfulVersions = "successfulVersions"
        }
    }

    public struct DomainDescription: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the domain.
        public let arn: String?
        ///  The total size of all assets in the domain.
        public let assetSizeBytes: Int64?
        ///  A timestamp that represents the date and time the domain was created.
        public let createdTime: Date?
        ///  The ARN of an Key Management Service (KMS) key associated with a domain.
        public let encryptionKey: String?
        ///  The name of the domain.
        public let name: String?
        ///  The Amazon Web Services account ID that owns the domain.
        public let owner: String?
        ///  The number of repositories in the domain.
        public let repositoryCount: Int?
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket that is used to store package assets in the domain.
        public let s3BucketArn: String?
        ///  The current status of a domain.
        public let status: DomainStatus?

        @inlinable
        public init(arn: String? = nil, assetSizeBytes: Int64? = nil, createdTime: Date? = nil, encryptionKey: String? = nil, name: String? = nil, owner: String? = nil, repositoryCount: Int? = nil, s3BucketArn: String? = nil, status: DomainStatus? = nil) {
            self.arn = arn
            self.assetSizeBytes = assetSizeBytes
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.repositoryCount = repositoryCount
            self.s3BucketArn = s3BucketArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetSizeBytes = "assetSizeBytes"
            case createdTime = "createdTime"
            case encryptionKey = "encryptionKey"
            case name = "name"
            case owner = "owner"
            case repositoryCount = "repositoryCount"
            case s3BucketArn = "s3BucketArn"
            case status = "status"
        }
    }

    public struct DomainEntryPoint: AWSDecodableShape {
        /// The name of the external connection that a package was ingested from.
        public let externalConnectionName: String?
        /// The name of the repository that a package was originally published to.
        public let repositoryName: String?

        @inlinable
        public init(externalConnectionName: String? = nil, repositoryName: String? = nil) {
            self.externalConnectionName = externalConnectionName
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case externalConnectionName = "externalConnectionName"
            case repositoryName = "repositoryName"
        }
    }

    public struct DomainSummary: AWSDecodableShape {
        ///  The ARN of the domain.
        public let arn: String?
        ///  A timestamp that contains the date and time the domain was created.
        public let createdTime: Date?
        ///  The key used to encrypt the domain.
        public let encryptionKey: String?
        ///  The name of the domain.
        public let name: String?
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let owner: String?
        ///  A string that contains the status of the domain.
        public let status: DomainStatus?

        @inlinable
        public init(arn: String? = nil, createdTime: Date? = nil, encryptionKey: String? = nil, name: String? = nil, owner: String? = nil, status: DomainStatus? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case encryptionKey = "encryptionKey"
            case name = "name"
            case owner = "owner"
            case status = "status"
        }
    }

    public struct GetAssociatedPackageGroupRequest: AWSEncodableShape {
        ///  The name of the domain that contains the package from which to get the associated package group.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The format of the package from which to get the associated package group.
        public let format: PackageFormat
        /// The namespace of the package from which to get the associated package group. The package component that specifies its  namespace depends on its type. For example:  The namespace is required when getting associated package groups from packages of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The package from which to get the associated package group.
        public let package: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssociatedPackageGroupResult: AWSDecodableShape {
        /// Describes the strength of the association between the package and package group. A strong match is also known as an  exact match, and a weak match is known as a relative match.
        public let associationType: PackageGroupAssociationType?
        /// The package group that is associated with the requested package.
        public let packageGroup: PackageGroupDescription?

        @inlinable
        public init(associationType: PackageGroupAssociationType? = nil, packageGroup: PackageGroupDescription? = nil) {
            self.associationType = associationType
            self.packageGroup = packageGroup
        }

        private enum CodingKeys: String, CodingKey {
            case associationType = "associationType"
            case packageGroup = "packageGroup"
        }
    }

    public struct GetAuthorizationTokenRequest: AWSEncodableShape {
        ///  The name of the domain that is in scope for the generated authorization token.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The time, in seconds, that the generated authorization token is valid. Valid values are  0 and any number between 900 (15 minutes) and 43200 (12 hours).  A value of 0 will set the expiration of the authorization token to the same expiration of  the user's role's temporary credentials.
        public let durationSeconds: Int64?

        @inlinable
        public init(domain: String, domainOwner: String? = nil, durationSeconds: Int64? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.durationSeconds = durationSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.durationSeconds, key: "duration")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.durationSeconds, name: "durationSeconds", parent: name, max: 43200)
            try self.validate(self.durationSeconds, name: "durationSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAuthorizationTokenResult: AWSDecodableShape {
        ///  The returned authentication token.
        public let authorizationToken: String?
        ///  A timestamp that specifies the date and time the authorization token expires.
        public let expiration: Date?

        @inlinable
        public init(authorizationToken: String? = nil, expiration: Date? = nil) {
            self.authorizationToken = authorizationToken
            self.expiration = expiration
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationToken = "authorizationToken"
            case expiration = "expiration"
        }
    }

    public struct GetDomainPermissionsPolicyRequest: AWSEncodableShape {
        ///  The name of the domain to which the resource policy is attached.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?

        @inlinable
        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainPermissionsPolicyResult: AWSDecodableShape {
        ///  The returned resource policy.
        public let policy: ResourcePolicy?

        @inlinable
        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct GetPackageVersionAssetRequest: AWSEncodableShape {
        ///  The name of the requested asset.
        public let asset: String
        ///  The name of the domain that contains the repository that contains the package version with the requested asset.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  A format that specifies the type of the package version with the requested asset file.
        public let format: PackageFormat
        /// The namespace of the package version with the requested asset file. The package component that specifies its  namespace depends on its type. For example:  The namespace is required when requesting assets from package versions of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the package that contains the requested asset.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The name of the package version revision that contains the requested asset.
        public let packageVersionRevision: String?
        ///  The repository that contains the package version with the requested asset.
        public let repository: String

        @inlinable
        public init(asset: String, domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, packageVersionRevision: String? = nil, repository: String) {
            self.asset = asset
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.packageVersionRevision = packageVersionRevision
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.asset, key: "asset")
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.packageVersion, key: "version")
            request.encodeQuery(self.packageVersionRevision, key: "revision")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.asset, name: "asset", parent: name, max: 255)
            try self.validate(self.asset, name: "asset", parent: name, min: 1)
            try self.validate(self.asset, name: "asset", parent: name, pattern: "^\\P{C}+$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.packageVersionRevision, name: "packageVersionRevision", parent: name, max: 50)
            try self.validate(self.packageVersionRevision, name: "packageVersionRevision", parent: name, min: 1)
            try self.validate(self.packageVersionRevision, name: "packageVersionRevision", parent: name, pattern: "^\\S+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPackageVersionAssetResult: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        ///  The binary file, or asset, that is downloaded.
        public let asset: AWSHTTPBody
        ///  The name of the asset that is downloaded.
        public let assetName: String?
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String?
        ///  The name of the package version revision that contains the downloaded asset.
        public let packageVersionRevision: String?

        @inlinable
        public init(asset: AWSHTTPBody, assetName: String? = nil, packageVersion: String? = nil, packageVersionRevision: String? = nil) {
            self.asset = asset
            self.assetName = assetName
            self.packageVersion = packageVersion
            self.packageVersionRevision = packageVersionRevision
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.asset = try container.decode(AWSHTTPBody.self)
            self.assetName = try response.decodeHeaderIfPresent(String.self, key: "X-AssetName")
            self.packageVersion = try response.decodeHeaderIfPresent(String.self, key: "X-PackageVersion")
            self.packageVersionRevision = try response.decodeHeaderIfPresent(String.self, key: "X-PackageVersionRevision")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPackageVersionReadmeRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository that contains the package version with the requested readme file.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  A format that specifies the type of the package version with the requested readme file.
        public let format: PackageFormat
        /// The namespace of the package version with the requested readme file. The package component that specifies its  namespace depends on its type. For example:  The namespace is required when requesting the readme from package versions of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the package version that contains the requested readme file.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The repository that contains the package with the requested readme file.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.packageVersion, key: "version")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPackageVersionReadmeResult: AWSDecodableShape {
        ///  The format of the package with the requested readme file.
        public let format: PackageFormat?
        /// The namespace of the package version with the requested readme file. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the package that contains the returned readme file.
        public let package: String?
        ///  The text of the returned readme file.
        public let readme: String?
        ///  The version of the package with the requested readme file.
        public let version: String?
        ///  The current revision associated with the package version.
        public let versionRevision: String?

        @inlinable
        public init(format: PackageFormat? = nil, namespace: String? = nil, package: String? = nil, readme: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.format = format
            self.namespace = namespace
            self.package = package
            self.readme = readme
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case readme = "readme"
            case version = "version"
            case versionRevision = "versionRevision"
        }
    }

    public struct GetRepositoryEndpointRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain that contains the repository. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// A string that specifies the type of endpoint.
        public let endpointType: EndpointType?
        ///  Returns which endpoint of a repository to return. A repository has one endpoint for each  package format.
        public let format: PackageFormat
        ///  The name of the repository.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, endpointType: EndpointType? = nil, format: PackageFormat, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.endpointType = endpointType
            self.format = format
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.endpointType, key: "endpointType")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRepositoryEndpointResult: AWSDecodableShape {
        ///  A string that specifies the URL of the returned endpoint.
        public let repositoryEndpoint: String?

        @inlinable
        public init(repositoryEndpoint: String? = nil) {
            self.repositoryEndpoint = repositoryEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryEndpoint = "repositoryEndpoint"
        }
    }

    public struct GetRepositoryPermissionsPolicyRequest: AWSEncodableShape {
        ///  The name of the domain containing the repository whose associated resource policy is to be retrieved.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository whose associated resource policy is to be retrieved.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRepositoryPermissionsPolicyResult: AWSDecodableShape {
        ///  The returned resource policy.
        public let policy: ResourcePolicy?

        @inlinable
        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct LicenseInfo: AWSDecodableShape {
        ///  Name of the license.
        public let name: String?
        ///  The URL for license data.
        public let url: String?

        @inlinable
        public init(name: String? = nil, url: String? = nil) {
            self.name = name
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case url = "url"
        }
    }

    public struct ListAllowedRepositoriesForGroupRequest: AWSEncodableShape {
        ///  The name of the domain that contains the package group from which to list allowed repositories.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin configuration restriction type of which to list allowed repositories.
        public let originRestrictionType: PackageGroupOriginRestrictionType
        /// The pattern of the package group from which to list allowed repositories.
        public let packageGroup: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, originRestrictionType: PackageGroupOriginRestrictionType, packageGroup: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.originRestrictionType = originRestrictionType
            self.packageGroup = packageGroup
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.originRestrictionType, key: "originRestrictionType")
            request.encodeQuery(self.packageGroup, key: "package-group")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, max: 520)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, min: 2)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, pattern: "^[^\\p{C}\\p{IsWhitespace}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAllowedRepositoriesForGroupResult: AWSDecodableShape {
        /// The list of allowed repositories for the package group and origin configuration restriction type.
        public let allowedRepositories: [String]?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(allowedRepositories: [String]? = nil, nextToken: String? = nil) {
            self.allowedRepositories = allowedRepositories
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case allowedRepositories = "allowedRepositories"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssociatedPackagesRequest: AWSEncodableShape {
        ///  The name of the domain that contains the package group from which to list associated packages.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The pattern of the package group from which to list associated packages.
        public let packageGroup: String
        ///  When this flag is included, ListAssociatedPackages will return a list of packages that would be associated with a package  group, even if it does not exist.
        public let preview: Bool?

        @inlinable
        public init(domain: String, domainOwner: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, packageGroup: String, preview: Bool? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packageGroup = packageGroup
            self.preview = preview
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.packageGroup, key: "package-group")
            request.encodeQuery(self.preview, key: "preview")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, max: 520)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, min: 2)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, pattern: "^[^\\p{C}\\p{IsWhitespace}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssociatedPackagesResult: AWSDecodableShape {
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The list of packages associated with the requested package group.
        public let packages: [AssociatedPackage]?

        @inlinable
        public init(nextToken: String? = nil, packages: [AssociatedPackage]? = nil) {
            self.nextToken = nextToken
            self.packages = packages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packages = "packages"
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainsResult: AWSDecodableShape {
        ///  The returned list of DomainSummary objects.
        public let domains: [DomainSummary]?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(domains: [DomainSummary]? = nil, nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "domains"
            case nextToken = "nextToken"
        }
    }

    public struct ListPackageGroupsRequest: AWSEncodableShape {
        ///  The domain for which you want to list package groups.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  A prefix for which to search package groups. When included, ListPackageGroups will return only package groups with patterns that match the prefix.
        public let prefix: String?

        @inlinable
        public init(domain: String, domainOwner: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, prefix: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.prefix = prefix
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.prefix, key: "prefix")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 520)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackageGroupsResult: AWSDecodableShape {
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The list of package groups in the requested domain.
        public let packageGroups: [PackageGroupSummary]?

        @inlinable
        public init(nextToken: String? = nil, packageGroups: [PackageGroupSummary]? = nil) {
            self.nextToken = nextToken
            self.packageGroups = packageGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packageGroups = "packageGroups"
        }
    }

    public struct ListPackageVersionAssetsRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository associated with the package version assets.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The format of the package that contains the requested package version assets.
        public let format: PackageFormat
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        /// The namespace of the package version that contains the requested package version assets. The package component that specifies its  namespace depends on its type. For example:  The namespace is required requesting assets from package versions of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The name of the package that contains the requested package version assets.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The name of the repository that contains the package that contains the requested package version assets.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.packageVersion, key: "version")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackageVersionAssetsResult: AWSDecodableShape {
        ///  The returned list of AssetSummary objects.
        public let assets: [AssetSummary]?
        ///  The format of the package that contains the requested package version assets.
        public let format: PackageFormat?
        /// The namespace of the package version that contains the requested package version assets. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The name of the package that contains the requested package version assets.
        public let package: String?
        ///  The version of the package associated with the requested assets.
        public let version: String?
        ///  The current revision associated with the package version.
        public let versionRevision: String?

        @inlinable
        public init(assets: [AssetSummary]? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.assets = assets
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case format = "format"
            case namespace = "namespace"
            case nextToken = "nextToken"
            case package = "package"
            case version = "version"
            case versionRevision = "versionRevision"
        }
    }

    public struct ListPackageVersionDependenciesRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository that contains the requested package version dependencies.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The format of the package with the requested dependencies.
        public let format: PackageFormat
        /// The namespace of the package version with the requested dependencies. The package component that specifies its  namespace depends on its type. For example:  The namespace is required when listing dependencies from package versions of the following formats:   Maven       The namespace of a Maven package version is its groupId.     The namespace of an npm package version is its scope.     Python and NuGet package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The name of the package versions' package.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The name of the repository that contains the requested package version.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, nextToken: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.packageVersion, key: "version")
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackageVersionDependenciesResult: AWSDecodableShape {
        ///  The returned list of PackageDependency objects.
        public let dependencies: [PackageDependency]?
        ///  A format that specifies the type of the package that contains the returned dependencies.
        public let format: PackageFormat?
        /// The namespace of the package version that contains the returned dependencies. The package component that specifies its  namespace depends on its type. For example:  The namespace is required when listing dependencies from package versions of the following formats:   Maven       The namespace of a Maven package version is its groupId.     The namespace of an npm package version is its scope.     Python and NuGet package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The name of the package that contains the returned package versions dependencies.
        public let package: String?
        ///  The version of the package that is specified in the request.
        public let version: String?
        ///  The current revision associated with the package version.
        public let versionRevision: String?

        @inlinable
        public init(dependencies: [PackageDependency]? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.dependencies = dependencies
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies = "dependencies"
            case format = "format"
            case namespace = "namespace"
            case nextToken = "nextToken"
            case package = "package"
            case version = "version"
            case versionRevision = "versionRevision"
        }
    }

    public struct ListPackageVersionsRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository that contains the requested package versions.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The format of the package versions you want to list.
        public let format: PackageFormat
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        /// The namespace of the package that contains the requested package versions. The package component that specifies its  namespace depends on its type. For example:  The namespace is required when deleting package versions of the following formats:   Maven   Swift   generic       The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The originType used to filter package versions.  Only package versions with the provided originType will be returned.
        public let originType: PackageVersionOriginType?
        ///  The name of the package for which you want to request package versions.
        public let package: String
        ///  The name of the repository that contains the requested package versions.
        public let repository: String
        ///  How to sort the requested list of package versions.
        public let sortBy: PackageVersionSortType?
        ///  A string that filters the requested package versions by status.
        public let status: PackageVersionStatus?

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, originType: PackageVersionOriginType? = nil, package: String, repository: String, sortBy: PackageVersionSortType? = nil, status: PackageVersionStatus? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.originType = originType
            self.package = package
            self.repository = repository
            self.sortBy = sortBy
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.originType, key: "originType")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.repository, key: "repository")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackageVersionsResult: AWSDecodableShape {
        ///  The default package version to display. This depends on the package format:     For Maven and PyPI packages, it's the most recently published package version.     For npm packages, it's the version referenced by the latest tag. If the  latest tag is not set, it's the most recently published package version.
        public let defaultDisplayVersion: String?
        ///  A format of the package.
        public let format: PackageFormat?
        /// The namespace of the package that contains the requested package versions. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The name of the package.
        public let package: String?
        ///  The returned list of  PackageVersionSummary  objects.
        public let versions: [PackageVersionSummary]?

        @inlinable
        public init(defaultDisplayVersion: String? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, versions: [PackageVersionSummary]? = nil) {
            self.defaultDisplayVersion = defaultDisplayVersion
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case defaultDisplayVersion = "defaultDisplayVersion"
            case format = "format"
            case namespace = "namespace"
            case nextToken = "nextToken"
            case package = "package"
            case versions = "versions"
        }
    }

    public struct ListPackagesRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository that contains the requested packages.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The format used to filter requested packages. Only packages from the provided format will be returned.
        public let format: PackageFormat?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        /// The namespace prefix used to filter requested packages.  Only packages with a namespace that starts with the provided string value are returned.  Note that although this option is called --namespace and not --namespace-prefix, it has prefix-matching behavior. Each package format uses namespace as follows:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  A prefix used to filter requested packages. Only packages with names that start with  packagePrefix are returned.
        public let packagePrefix: String?
        /// The value of the Publish package origin control restriction used to filter requested packages.  Only packages with the provided restriction are returned.  For more information, see PackageOriginRestrictions.
        public let publish: AllowPublish?
        ///  The name of the repository that contains the requested packages.
        public let repository: String
        /// The value of the Upstream package origin control restriction used to filter requested packages.  Only packages with the provided restriction are returned. For more information, see PackageOriginRestrictions.
        public let upstream: AllowUpstream?

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat? = nil, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, packagePrefix: String? = nil, publish: AllowPublish? = nil, repository: String, upstream: AllowUpstream? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.packagePrefix = packagePrefix
            self.publish = publish
            self.repository = repository
            self.upstream = upstream
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.packagePrefix, key: "package-prefix")
            request.encodeQuery(self.publish, key: "publish")
            request.encodeQuery(self.repository, key: "repository")
            request.encodeQuery(self.upstream, key: "upstream")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.packagePrefix, name: "packagePrefix", parent: name, max: 255)
            try self.validate(self.packagePrefix, name: "packagePrefix", parent: name, min: 1)
            try self.validate(self.packagePrefix, name: "packagePrefix", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagesResult: AWSDecodableShape {
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The list of returned PackageSummary  objects.
        public let packages: [PackageSummary]?

        @inlinable
        public init(nextToken: String? = nil, packages: [PackageSummary]? = nil) {
            self.nextToken = nextToken
            self.packages = packages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packages = "packages"
        }
    }

    public struct ListRepositoriesInDomainRequest: AWSEncodableShape {
        ///  Filter the list of repositories to only include those that are managed by the Amazon Web Services account ID.
        public let administratorAccount: String?
        ///  The name of the domain that contains the returned list of repositories.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  A prefix used to filter returned repositories. Only repositories with names that start with  repositoryPrefix are returned.
        public let repositoryPrefix: String?

        @inlinable
        public init(administratorAccount: String? = nil, domain: String, domainOwner: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, repositoryPrefix: String? = nil) {
            self.administratorAccount = administratorAccount
            self.domain = domain
            self.domainOwner = domainOwner
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.repositoryPrefix = repositoryPrefix
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.administratorAccount, key: "administrator-account")
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.repositoryPrefix, key: "repository-prefix")
        }

        public func validate(name: String) throws {
            try self.validate(self.administratorAccount, name: "administratorAccount", parent: name, max: 12)
            try self.validate(self.administratorAccount, name: "administratorAccount", parent: name, min: 12)
            try self.validate(self.administratorAccount, name: "administratorAccount", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, max: 100)
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, min: 2)
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRepositoriesInDomainResult: AWSDecodableShape {
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The returned list of repositories.
        public let repositories: [RepositorySummary]?

        @inlinable
        public init(nextToken: String? = nil, repositories: [RepositorySummary]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositories = "repositories"
        }
    }

    public struct ListRepositoriesRequest: AWSEncodableShape {
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned.
        public let repositoryPrefix: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, repositoryPrefix: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.repositoryPrefix = repositoryPrefix
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.repositoryPrefix, key: "repository-prefix")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, max: 100)
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, min: 2)
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRepositoriesResult: AWSDecodableShape {
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The returned list of RepositorySummary  objects.
        public let repositories: [RepositorySummary]?

        @inlinable
        public init(nextToken: String? = nil, repositories: [RepositorySummary]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositories = "repositories"
        }
    }

    public struct ListSubPackageGroupsRequest: AWSEncodableShape {
        ///  The name of the domain which contains the package group from which to list sub package groups.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The pattern of the package group from which to list sub package groups.
        public let packageGroup: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, packageGroup: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packageGroup = packageGroup
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.packageGroup, key: "package-group")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, max: 520)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, min: 2)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, pattern: "^[^\\p{C}\\p{IsWhitespace}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubPackageGroupsResult: AWSDecodableShape {
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  A list of sub package groups for the requested package group.
        public let packageGroups: [PackageGroupSummary]?

        @inlinable
        public init(nextToken: String? = nil, packageGroups: [PackageGroupSummary]? = nil) {
            self.nextToken = nextToken
            self.packageGroups = packageGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packageGroups = "packageGroups"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to get tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResult: AWSDecodableShape {
        /// A list of tag key and value pairs associated with the specified resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct PackageDependency: AWSDecodableShape {
        ///  The type of a package dependency. The possible values depend on the package type.   npm: regular, dev, peer, optional    maven: optional, parent, compile, runtime, test, system, provided.  Note that parent is not a regular Maven dependency type; instead this is extracted from the  element if one is defined in the package version's POM file.    nuget: The dependencyType field is never set for NuGet packages.   pypi: Requires-Dist
        public let dependencyType: String?
        /// The namespace of the package that this package depends on. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the package that this package depends on.
        public let package: String?
        ///  The required version, or version range, of the package that this package depends on. The version format is specific to the package type. For example, the following are possible valid required versions: 1.2.3, ^2.3.4, or 4.x.
        public let versionRequirement: String?

        @inlinable
        public init(dependencyType: String? = nil, namespace: String? = nil, package: String? = nil, versionRequirement: String? = nil) {
            self.dependencyType = dependencyType
            self.namespace = namespace
            self.package = package
            self.versionRequirement = versionRequirement
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyType = "dependencyType"
            case namespace = "namespace"
            case package = "package"
            case versionRequirement = "versionRequirement"
        }
    }

    public struct PackageDescription: AWSDecodableShape {
        /// A format that specifies the type of the package.
        public let format: PackageFormat?
        /// The name of the package.
        public let name: String?
        /// The namespace of the package. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        /// The package origin configuration for the package.
        public let originConfiguration: PackageOriginConfiguration?

        @inlinable
        public init(format: PackageFormat? = nil, name: String? = nil, namespace: String? = nil, originConfiguration: PackageOriginConfiguration? = nil) {
            self.format = format
            self.name = name
            self.namespace = namespace
            self.originConfiguration = originConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case name = "name"
            case namespace = "namespace"
            case originConfiguration = "originConfiguration"
        }
    }

    public struct PackageGroupAllowedRepository: AWSEncodableShape {
        /// The origin configuration restriction type of the allowed repository.
        public let originRestrictionType: PackageGroupOriginRestrictionType?
        ///  The name of the allowed repository.
        public let repositoryName: String?

        @inlinable
        public init(originRestrictionType: PackageGroupOriginRestrictionType? = nil, repositoryName: String? = nil) {
            self.originRestrictionType = originRestrictionType
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: String, CodingKey {
            case originRestrictionType = "originRestrictionType"
            case repositoryName = "repositoryName"
        }
    }

    public struct PackageGroupDescription: AWSDecodableShape {
        ///  The ARN of the package group.
        public let arn: String?
        ///  The contact information of the package group.
        public let contactInfo: String?
        /// A timestamp that represents the date and time the package group was created.
        public let createdTime: Date?
        ///  The description of the package group.
        public let description: String?
        ///  The name of the domain that contains the package group.
        public let domainName: String?
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// The package group origin configuration that determines how package versions can enter repositories.
        public let originConfiguration: PackageGroupOriginConfiguration?
        ///  The direct parent package group of the package group.
        public let parent: PackageGroupReference?
        ///  The pattern of the package group. The pattern determines which packages are associated with the package group.
        public let pattern: String?

        @inlinable
        public init(arn: String? = nil, contactInfo: String? = nil, createdTime: Date? = nil, description: String? = nil, domainName: String? = nil, domainOwner: String? = nil, originConfiguration: PackageGroupOriginConfiguration? = nil, parent: PackageGroupReference? = nil, pattern: String? = nil) {
            self.arn = arn
            self.contactInfo = contactInfo
            self.createdTime = createdTime
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.originConfiguration = originConfiguration
            self.parent = parent
            self.pattern = pattern
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case contactInfo = "contactInfo"
            case createdTime = "createdTime"
            case description = "description"
            case domainName = "domainName"
            case domainOwner = "domainOwner"
            case originConfiguration = "originConfiguration"
            case parent = "parent"
            case pattern = "pattern"
        }
    }

    public struct PackageGroupOriginConfiguration: AWSDecodableShape {
        /// The origin configuration settings that determine how package versions can enter repositories.
        public let restrictions: [PackageGroupOriginRestrictionType: PackageGroupOriginRestriction]?

        @inlinable
        public init(restrictions: [PackageGroupOriginRestrictionType: PackageGroupOriginRestriction]? = nil) {
            self.restrictions = restrictions
        }

        private enum CodingKeys: String, CodingKey {
            case restrictions = "restrictions"
        }
    }

    public struct PackageGroupOriginRestriction: AWSDecodableShape {
        /// The effective package group origin restriction setting. If the value of mode is ALLOW,  ALLOW_SPECIFIC_REPOSITORIES, or BLOCK, then the value of effectiveMode  is the same. Otherwise, when the value of mode is INHERIT, then the value of effectiveMode is the value of  mode of the first parent group which does not have a value of INHERIT.
        public let effectiveMode: PackageGroupOriginRestrictionMode?
        /// The parent package group that the package group origin restrictions are inherited from.
        public let inheritedFrom: PackageGroupReference?
        /// The package group origin restriction setting. If the value of mode is ALLOW,  ALLOW_SPECIFIC_REPOSITORIES, or BLOCK, then the value of effectiveMode  is the same. Otherwise, when the value is INHERIT, then the value of effectiveMode is the value of  mode of the first parent group which does not have a value of INHERIT.
        public let mode: PackageGroupOriginRestrictionMode?
        /// The number of repositories in the allowed repository list.
        public let repositoriesCount: Int64?

        @inlinable
        public init(effectiveMode: PackageGroupOriginRestrictionMode? = nil, inheritedFrom: PackageGroupReference? = nil, mode: PackageGroupOriginRestrictionMode? = nil, repositoriesCount: Int64? = nil) {
            self.effectiveMode = effectiveMode
            self.inheritedFrom = inheritedFrom
            self.mode = mode
            self.repositoriesCount = repositoriesCount
        }

        private enum CodingKeys: String, CodingKey {
            case effectiveMode = "effectiveMode"
            case inheritedFrom = "inheritedFrom"
            case mode = "mode"
            case repositoriesCount = "repositoriesCount"
        }
    }

    public struct PackageGroupReference: AWSDecodableShape {
        ///  The ARN of the package group.
        public let arn: String?
        ///  The pattern of the package group. The pattern determines which packages are associated with the package group, and is  also the identifier of the package group.
        public let pattern: String?

        @inlinable
        public init(arn: String? = nil, pattern: String? = nil) {
            self.arn = arn
            self.pattern = pattern
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case pattern = "pattern"
        }
    }

    public struct PackageGroupSummary: AWSDecodableShape {
        ///  The ARN of the package group.
        public let arn: String?
        ///  The contact information of the package group.
        public let contactInfo: String?
        /// A timestamp that represents the date and time the repository was created.
        public let createdTime: Date?
        ///  The description of the package group.
        public let description: String?
        ///  The domain that contains the package group.
        public let domainName: String?
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// Details about the package origin configuration of a package group.
        public let originConfiguration: PackageGroupOriginConfiguration?
        ///  The direct parent package group of the package group.
        public let parent: PackageGroupReference?
        ///  The pattern of the package group. The pattern determines which packages are associated with the package group.
        public let pattern: String?

        @inlinable
        public init(arn: String? = nil, contactInfo: String? = nil, createdTime: Date? = nil, description: String? = nil, domainName: String? = nil, domainOwner: String? = nil, originConfiguration: PackageGroupOriginConfiguration? = nil, parent: PackageGroupReference? = nil, pattern: String? = nil) {
            self.arn = arn
            self.contactInfo = contactInfo
            self.createdTime = createdTime
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.originConfiguration = originConfiguration
            self.parent = parent
            self.pattern = pattern
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case contactInfo = "contactInfo"
            case createdTime = "createdTime"
            case description = "description"
            case domainName = "domainName"
            case domainOwner = "domainOwner"
            case originConfiguration = "originConfiguration"
            case parent = "parent"
            case pattern = "pattern"
        }
    }

    public struct PackageOriginConfiguration: AWSDecodableShape {
        /// A PackageOriginRestrictions object that contains information  about the upstream and publish package origin configuration for the package.
        public let restrictions: PackageOriginRestrictions?

        @inlinable
        public init(restrictions: PackageOriginRestrictions? = nil) {
            self.restrictions = restrictions
        }

        private enum CodingKeys: String, CodingKey {
            case restrictions = "restrictions"
        }
    }

    public struct PackageOriginRestrictions: AWSEncodableShape & AWSDecodableShape {
        /// The package origin configuration that determines if new versions of the package can be published directly to the repository.
        public let publish: AllowPublish
        /// The package origin configuration that determines if new versions of the package can be added to the repository from an external connection or upstream source.
        public let upstream: AllowUpstream

        @inlinable
        public init(publish: AllowPublish, upstream: AllowUpstream) {
            self.publish = publish
            self.upstream = upstream
        }

        private enum CodingKeys: String, CodingKey {
            case publish = "publish"
            case upstream = "upstream"
        }
    }

    public struct PackageSummary: AWSDecodableShape {
        ///  The format of the package.
        public let format: PackageFormat?
        /// The namespace of the package. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        /// A PackageOriginConfiguration  object that contains a PackageOriginRestrictions object  that contains information about the upstream and publish package origin restrictions.
        public let originConfiguration: PackageOriginConfiguration?
        ///  The name of the package.
        public let package: String?

        @inlinable
        public init(format: PackageFormat? = nil, namespace: String? = nil, originConfiguration: PackageOriginConfiguration? = nil, package: String? = nil) {
            self.format = format
            self.namespace = namespace
            self.originConfiguration = originConfiguration
            self.package = package
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case namespace = "namespace"
            case originConfiguration = "originConfiguration"
            case package = "package"
        }
    }

    public struct PackageVersionDescription: AWSDecodableShape {
        ///  The name of the package that is displayed. The displayName varies depending  on the package version's format. For example, if an npm package is named ui,  is in the namespace vue, and has the format npm, then  the displayName is @vue/ui.
        public let displayName: String?
        ///  The format of the package version.
        public let format: PackageFormat?
        ///  The homepage associated with the package.
        public let homePage: String?
        ///  Information about licenses associated with the package version.
        public let licenses: [LicenseInfo]?
        /// The namespace of the package version. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        /// A PackageVersionOrigin object that contains  information about how the package version was added to the repository.
        public let origin: PackageVersionOrigin?
        ///  The name of the requested package.
        public let packageName: String?
        ///  A timestamp that contains the date and time the package version was published.
        public let publishedTime: Date?
        ///  The revision of the package version.
        public let revision: String?
        ///  The repository for the source code in the package version, or the source code used to build it.
        public let sourceCodeRepository: String?
        ///  A string that contains the status of the package version.
        public let status: PackageVersionStatus?
        ///  A summary of the package version. The summary is extracted from the package. The information in and  detail level of the summary depends on the package version's format.
        public let summary: String?
        ///  The version of the package.
        public let version: String?

        @inlinable
        public init(displayName: String? = nil, format: PackageFormat? = nil, homePage: String? = nil, licenses: [LicenseInfo]? = nil, namespace: String? = nil, origin: PackageVersionOrigin? = nil, packageName: String? = nil, publishedTime: Date? = nil, revision: String? = nil, sourceCodeRepository: String? = nil, status: PackageVersionStatus? = nil, summary: String? = nil, version: String? = nil) {
            self.displayName = displayName
            self.format = format
            self.homePage = homePage
            self.licenses = licenses
            self.namespace = namespace
            self.origin = origin
            self.packageName = packageName
            self.publishedTime = publishedTime
            self.revision = revision
            self.sourceCodeRepository = sourceCodeRepository
            self.status = status
            self.summary = summary
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case format = "format"
            case homePage = "homePage"
            case licenses = "licenses"
            case namespace = "namespace"
            case origin = "origin"
            case packageName = "packageName"
            case publishedTime = "publishedTime"
            case revision = "revision"
            case sourceCodeRepository = "sourceCodeRepository"
            case status = "status"
            case summary = "summary"
            case version = "version"
        }
    }

    public struct PackageVersionError: AWSDecodableShape {
        ///  The error code associated with the error. Valid error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED
        public let errorCode: PackageVersionErrorCode?
        ///  The error message associated with the error.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: PackageVersionErrorCode? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct PackageVersionOrigin: AWSDecodableShape {
        /// A DomainEntryPoint object that contains  information about from which repository or external connection the package version was added to the domain.
        public let domainEntryPoint: DomainEntryPoint?
        /// Describes how the package version was originally added to the domain. An INTERNAL origin type means the package version was published  directly to a repository in the domain. An EXTERNAL origin type means the package version was ingested from an external connection.
        public let originType: PackageVersionOriginType?

        @inlinable
        public init(domainEntryPoint: DomainEntryPoint? = nil, originType: PackageVersionOriginType? = nil) {
            self.domainEntryPoint = domainEntryPoint
            self.originType = originType
        }

        private enum CodingKeys: String, CodingKey {
            case domainEntryPoint = "domainEntryPoint"
            case originType = "originType"
        }
    }

    public struct PackageVersionSummary: AWSDecodableShape {
        /// A PackageVersionOrigin object that contains information  about how the package version was added to the repository.
        public let origin: PackageVersionOrigin?
        ///  The revision associated with a package version.
        public let revision: String?
        ///  A string that contains the status of the package version. It can be one of the following:
        public let status: PackageVersionStatus
        ///  Information about a package version.
        public let version: String

        @inlinable
        public init(origin: PackageVersionOrigin? = nil, revision: String? = nil, status: PackageVersionStatus, version: String) {
            self.origin = origin
            self.revision = revision
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case origin = "origin"
            case revision = "revision"
            case status = "status"
            case version = "version"
        }
    }

    public struct PublishPackageVersionRequest: AWSEncodableShape {
        public static let _options: AWSShapeOptions = [.allowStreaming]
        /// The content of the asset to publish.
        public let assetContent: AWSHTTPBody
        /// The name of the asset to publish. Asset names can include Unicode letters and numbers, and the following special characters: ~ ! @ ^ & ( ) - ` _ + [ ] { } ; , . `
        public let assetName: String
        /// The SHA256 hash of the assetContent to publish. This value must be calculated by the caller and provided with the request (see Publishing a generic package in the CodeArtifact User Guide). This value is used as an integrity check to verify that the assetContent has not changed after it was originally sent.
        public let assetSHA256: String
        /// The name of the domain that contains the repository that contains the package version to publish.
        public let domain: String
        /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        /// A format that specifies the type of the package version with the requested asset file. The only supported value is generic.
        public let format: PackageFormat
        /// The namespace of the package version to publish.
        public let namespace: String?
        /// The name of the package version to publish.
        public let package: String
        /// The package version to publish (for example, 3.5.2).
        public let packageVersion: String
        /// The name of the repository that the package version will be published to.
        public let repository: String
        /// Specifies whether the package version should remain in the unfinished state. If omitted, the package version status will be set to Published (see Package version status in the CodeArtifact User Guide). Valid values: unfinished
        public let unfinished: Bool?

        @inlinable
        public init(assetContent: AWSHTTPBody, assetName: String, assetSHA256: String, domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, repository: String, unfinished: Bool? = nil) {
            self.assetContent = assetContent
            self.assetName = assetName
            self.assetSHA256 = assetSHA256
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
            self.unfinished = unfinished
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            try container.encode(self.assetContent)
            request.encodeQuery(self.assetName, key: "asset")
            request.encodeHeader(self.assetSHA256, key: "x-amz-content-sha256")
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.packageVersion, key: "version")
            request.encodeQuery(self.repository, key: "repository")
            request.encodeQuery(self.unfinished, key: "unfinished")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetName, name: "assetName", parent: name, max: 255)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "^\\P{C}+$")
            try self.validate(self.assetSHA256, name: "assetSHA256", parent: name, max: 64)
            try self.validate(self.assetSHA256, name: "assetSHA256", parent: name, min: 64)
            try self.validate(self.assetSHA256, name: "assetSHA256", parent: name, pattern: "^[0-9a-f]+$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PublishPackageVersionResult: AWSDecodableShape {
        /// An AssetSummary for the published asset.
        public let asset: AssetSummary?
        /// The format of the package version.
        public let format: PackageFormat?
        /// The namespace of the package version.
        public let namespace: String?
        /// The name of the package.
        public let package: String?
        /// A string that contains the status of the package version. For more information, see Package version status in the CodeArtifact User Guide.
        public let status: PackageVersionStatus?
        /// The version of the package.
        public let version: String?
        /// The revision of the package version.
        public let versionRevision: String?

        @inlinable
        public init(asset: AssetSummary? = nil, format: PackageFormat? = nil, namespace: String? = nil, package: String? = nil, status: PackageVersionStatus? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.asset = asset
            self.format = format
            self.namespace = namespace
            self.package = package
            self.status = status
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case asset = "asset"
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case status = "status"
            case version = "version"
            case versionRevision = "versionRevision"
        }
    }

    public struct PutDomainPermissionsPolicyRequest: AWSEncodableShape {
        ///  The name of the domain on which to set the resource policy.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain.
        public let policyDocument: String
        ///  The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy.
        public let policyRevision: String?

        @inlinable
        public init(domain: String, domainOwner: String? = nil, policyDocument: String, policyRevision: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyDocument = policyDocument
            self.policyRevision = policyRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 7168)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, min: 1)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, pattern: "^[\\P{C}\\s]+$")
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, max: 100)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domainOwner"
            case policyDocument = "policyDocument"
            case policyRevision = "policyRevision"
        }
    }

    public struct PutDomainPermissionsPolicyResult: AWSDecodableShape {
        ///  The resource policy that was set after processing the request.
        public let policy: ResourcePolicy?

        @inlinable
        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct PutPackageOriginConfigurationRequest: AWSEncodableShape {
        /// The name of the domain that contains the repository that contains the package.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        /// A format that specifies the type of the package to be updated.
        public let format: PackageFormat
        /// The namespace of the package to be updated. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        /// The name of the package to be updated.
        public let package: String
        /// The name of the repository that contains the package.
        public let repository: String
        /// A PackageOriginRestrictions  object that contains information about the upstream and publish package origin restrictions.  The upstream restriction determines if new package versions can be ingested or retained from external connections or upstream repositories.  The publish restriction determines if new package versions can be published directly to the repository. You must include both the desired upstream and publish restrictions.
        public let restrictions: PackageOriginRestrictions

        @inlinable
        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, restrictions: PackageOriginRestrictions) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.restrictions = restrictions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.repository, key: "repository")
            try container.encode(self.restrictions, forKey: .restrictions)
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: String, CodingKey {
            case restrictions = "restrictions"
        }
    }

    public struct PutPackageOriginConfigurationResult: AWSDecodableShape {
        /// A PackageOriginConfiguration  object that describes the origin configuration set for the package. It contains a  PackageOriginRestrictions  object that describes how new versions of the package can be introduced to the repository.
        public let originConfiguration: PackageOriginConfiguration?

        @inlinable
        public init(originConfiguration: PackageOriginConfiguration? = nil) {
            self.originConfiguration = originConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case originConfiguration = "originConfiguration"
        }
    }

    public struct PutRepositoryPermissionsPolicyRequest: AWSEncodableShape {
        ///  The name of the domain containing the repository to set the resource policy on.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository.
        public let policyDocument: String
        ///  Sets the revision of the resource policy that specifies permissions to access the repository.  This revision is used for optimistic locking, which prevents others from overwriting your  changes to the repository's resource policy.
        public let policyRevision: String?
        ///  The name of the repository to set the resource policy on.
        public let repository: String

        @inlinable
        public init(domain: String, domainOwner: String? = nil, policyDocument: String, policyRevision: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyDocument = policyDocument
            self.policyRevision = policyRevision
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            try container.encode(self.policyDocument, forKey: .policyDocument)
            try container.encodeIfPresent(self.policyRevision, forKey: .policyRevision)
            request.encodeQuery(self.repository, key: "repository")
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 7168)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, min: 1)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, pattern: "^[\\P{C}\\s]+$")
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, max: 100)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, pattern: "^\\S+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "policyDocument"
            case policyRevision = "policyRevision"
        }
    }

    public struct PutRepositoryPermissionsPolicyResult: AWSDecodableShape {
        ///  The resource policy that was set after processing the request.
        public let policy: ResourcePolicy?

        @inlinable
        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct RepositoryDescription: AWSDecodableShape {
        ///  The 12-digit account number of the Amazon Web Services account that manages the repository.
        public let administratorAccount: String?
        ///  The Amazon Resource Name (ARN) of the repository.
        public let arn: String?
        /// A timestamp that represents the date and time the repository was created.
        public let createdTime: Date?
        ///  A text description of the repository.
        public let description: String?
        ///  The name of the domain that contains the repository.
        public let domainName: String?
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain that contains the repository. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  An array of external connections associated with the repository.
        public let externalConnections: [RepositoryExternalConnectionInfo]?
        ///  The name of the repository.
        public let name: String?
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories  in the list determines their priority order when CodeArtifact looks for a requested package version. For more  information, see Working with upstream repositories.
        public let upstreams: [UpstreamRepositoryInfo]?

        @inlinable
        public init(administratorAccount: String? = nil, arn: String? = nil, createdTime: Date? = nil, description: String? = nil, domainName: String? = nil, domainOwner: String? = nil, externalConnections: [RepositoryExternalConnectionInfo]? = nil, name: String? = nil, upstreams: [UpstreamRepositoryInfo]? = nil) {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.externalConnections = externalConnections
            self.name = name
            self.upstreams = upstreams
        }

        private enum CodingKeys: String, CodingKey {
            case administratorAccount = "administratorAccount"
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case domainName = "domainName"
            case domainOwner = "domainOwner"
            case externalConnections = "externalConnections"
            case name = "name"
            case upstreams = "upstreams"
        }
    }

    public struct RepositoryExternalConnectionInfo: AWSDecodableShape {
        ///  The name of the external connection associated with a repository.
        public let externalConnectionName: String?
        ///  The package format associated with a repository's external connection. The valid package formats are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.     nuget: A NuGet package.     generic: A generic package.     ruby: A Ruby package.     swift: A Swift package.     cargo: A Cargo package.
        public let packageFormat: PackageFormat?
        ///  The status of the external connection of a repository. There is one valid value, Available.
        public let status: ExternalConnectionStatus?

        @inlinable
        public init(externalConnectionName: String? = nil, packageFormat: PackageFormat? = nil, status: ExternalConnectionStatus? = nil) {
            self.externalConnectionName = externalConnectionName
            self.packageFormat = packageFormat
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case externalConnectionName = "externalConnectionName"
            case packageFormat = "packageFormat"
            case status = "status"
        }
    }

    public struct RepositorySummary: AWSDecodableShape {
        ///  The Amazon Web Services account ID that manages the repository.
        public let administratorAccount: String?
        ///  The ARN of the repository.
        public let arn: String?
        /// A timestamp that represents the date and time the repository was created.
        public let createdTime: Date?
        ///  The description of the repository.
        public let description: String?
        ///  The name of the domain that contains the repository.
        public let domainName: String?
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository.
        public let name: String?

        @inlinable
        public init(administratorAccount: String? = nil, arn: String? = nil, createdTime: Date? = nil, description: String? = nil, domainName: String? = nil, domainOwner: String? = nil, name: String? = nil) {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case administratorAccount = "administratorAccount"
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case domainName = "domainName"
            case domainOwner = "domainOwner"
            case name = "name"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        ///  The ID of the resource.
        public let resourceId: String?
        ///  The type of Amazon Web Services resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ResourcePolicy: AWSDecodableShape {
        ///  The resource policy formatted in JSON.
        public let document: String?
        ///  The ARN of the resource associated with the resource policy
        public let resourceArn: String?
        ///  The current revision of the resource policy.
        public let revision: String?

        @inlinable
        public init(document: String? = nil, resourceArn: String? = nil, revision: String? = nil) {
            self.document = document
            self.resourceArn = resourceArn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
            case resourceArn = "resourceArn"
            case revision = "revision"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        ///  The ID of the resource.
        public let resourceId: String?
        ///  The type of Amazon Web Services resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct SuccessfulPackageVersionInfo: AWSDecodableShape {
        ///  The revision of a package version.
        public let revision: String?
        ///  The status of a package version.
        public let status: PackageVersionStatus?

        @inlinable
        public init(revision: String? = nil, status: PackageVersionStatus? = nil) {
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case revision = "revision"
            case status = "status"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String
        /// The tag value.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^\\P{C}+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.
        public let resourceArn: String
        /// The tags you want to modify or add to the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^\\S+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        ///  The time period, in seconds, to wait before retrying the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
        public let resourceArn: String
        /// The tag key for each tag that you want to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^\\S+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^\\P{C}+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePackageGroupOriginConfigurationRequest: AWSEncodableShape {
        /// The repository name and restrictions to add to the allowed repository list of the specified package group.
        public let addAllowedRepositories: [PackageGroupAllowedRepository]?
        ///  The name of the domain which contains the package group for which to update the origin configuration.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The pattern of the package group for which to update the origin configuration.
        public let packageGroup: String
        /// The repository name and restrictions to remove from the allowed repository list of the specified package group.
        public let removeAllowedRepositories: [PackageGroupAllowedRepository]?
        ///  The origin configuration settings that determine how package versions can enter repositories.
        public let restrictions: [PackageGroupOriginRestrictionType: PackageGroupOriginRestrictionMode]?

        @inlinable
        public init(addAllowedRepositories: [PackageGroupAllowedRepository]? = nil, domain: String, domainOwner: String? = nil, packageGroup: String, removeAllowedRepositories: [PackageGroupAllowedRepository]? = nil, restrictions: [PackageGroupOriginRestrictionType: PackageGroupOriginRestrictionMode]? = nil) {
            self.addAllowedRepositories = addAllowedRepositories
            self.domain = domain
            self.domainOwner = domainOwner
            self.packageGroup = packageGroup
            self.removeAllowedRepositories = removeAllowedRepositories
            self.restrictions = restrictions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.addAllowedRepositories, forKey: .addAllowedRepositories)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.packageGroup, key: "package-group")
            try container.encodeIfPresent(self.removeAllowedRepositories, forKey: .removeAllowedRepositories)
            try container.encodeIfPresent(self.restrictions, forKey: .restrictions)
        }

        public func validate(name: String) throws {
            try self.addAllowedRepositories?.forEach {
                try $0.validate(name: "\(name).addAllowedRepositories[]")
            }
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, max: 520)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, min: 2)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, pattern: "^[^\\p{C}\\p{IsWhitespace}]+$")
            try self.removeAllowedRepositories?.forEach {
                try $0.validate(name: "\(name).removeAllowedRepositories[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addAllowedRepositories = "addAllowedRepositories"
            case removeAllowedRepositories = "removeAllowedRepositories"
            case restrictions = "restrictions"
        }
    }

    public struct UpdatePackageGroupOriginConfigurationResult: AWSDecodableShape {
        /// Information about the updated allowed repositories after processing the request.
        public let allowedRepositoryUpdates: [PackageGroupOriginRestrictionType: [PackageGroupAllowedRepositoryUpdateType: [String]]]?
        ///  The package group and information about it after processing the request.
        public let packageGroup: PackageGroupDescription?

        @inlinable
        public init(allowedRepositoryUpdates: [PackageGroupOriginRestrictionType: [PackageGroupAllowedRepositoryUpdateType: [String]]]? = nil, packageGroup: PackageGroupDescription? = nil) {
            self.allowedRepositoryUpdates = allowedRepositoryUpdates
            self.packageGroup = packageGroup
        }

        private enum CodingKeys: String, CodingKey {
            case allowedRepositoryUpdates = "allowedRepositoryUpdates"
            case packageGroup = "packageGroup"
        }
    }

    public struct UpdatePackageGroupRequest: AWSEncodableShape {
        ///  Contact information which you want to update the requested package group with.
        public let contactInfo: String?
        ///  The description you want to update the requested package group with.
        public let description: String?
        ///  The name of the domain which contains the package group to be updated.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The pattern of the package group to be updated.
        public let packageGroup: String

        @inlinable
        public init(contactInfo: String? = nil, description: String? = nil, domain: String, domainOwner: String? = nil, packageGroup: String) {
            self.contactInfo = contactInfo
            self.description = description
            self.domain = domain
            self.domainOwner = domainOwner
            self.packageGroup = packageGroup
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.contactInfo, forKey: .contactInfo)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            try container.encode(self.packageGroup, forKey: .packageGroup)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactInfo, name: "contactInfo", parent: name, max: 1000)
            try self.validate(self.contactInfo, name: "contactInfo", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, max: 520)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, min: 2)
            try self.validate(self.packageGroup, name: "packageGroup", parent: name, pattern: "^[^\\p{C}\\p{IsWhitespace}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactInfo = "contactInfo"
            case description = "description"
            case packageGroup = "packageGroup"
        }
    }

    public struct UpdatePackageGroupResult: AWSDecodableShape {
        ///  The package group and information about it after the request has been processed.
        public let packageGroup: PackageGroupDescription?

        @inlinable
        public init(packageGroup: PackageGroupDescription? = nil) {
            self.packageGroup = packageGroup
        }

        private enum CodingKeys: String, CodingKey {
            case packageGroup = "packageGroup"
        }
    }

    public struct UpdatePackageVersionsStatusRequest: AWSEncodableShape {
        ///  The name of the domain that contains the repository that contains the package versions with a status to be updated.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The package versions expected status before it is updated. If expectedStatus is provided, the package version's status is updated only if its status at the time UpdatePackageVersionsStatus is called matches expectedStatus.
        public let expectedStatus: PackageVersionStatus?
        ///  A format that specifies the type of the package with the statuses to update.
        public let format: PackageFormat
        /// The namespace of the package version to be updated. The package component that specifies its  namespace depends on its type. For example:    The namespace of a Maven package version is its groupId.     The namespace of an npm or Swift package version is its scope.    The namespace of a generic package is its namespace.    Python, NuGet, Ruby, and Cargo package versions do not contain a corresponding component, package versions  of those formats do not have a namespace.
        public let namespace: String?
        ///  The name of the package with the version statuses to update.
        public let package: String
        ///  The repository that contains the package versions with the status you want to update.
        public let repository: String
        ///  The status you want to change the package version status to.
        public let targetStatus: PackageVersionStatus
        ///  A map of package versions and package version revisions. The map key is the package version (for example, 3.5.2), and the map value is the package version revision.
        public let versionRevisions: [String: String]?
        ///  An array of strings that specify the versions of the package with the statuses to update.
        public let versions: [String]

        @inlinable
        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, targetStatus: PackageVersionStatus, versionRevisions: [String: String]? = nil, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.targetStatus = targetStatus
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            try container.encodeIfPresent(self.expectedStatus, forKey: .expectedStatus)
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.package, key: "package")
            request.encodeQuery(self.repository, key: "repository")
            try container.encode(self.targetStatus, forKey: .targetStatus)
            try container.encodeIfPresent(self.versionRevisions, forKey: .versionRevisions)
            try container.encode(self.versions, forKey: .versions)
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "^[^#/\\s]+$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
            try self.versionRevisions?.forEach {
                try validate($0.key, name: "versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name: "versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name: "versionRevisions.key", parent: name, pattern: "^[^#/\\s]+$")
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "^[^#/\\s]+$")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case expectedStatus = "expectedStatus"
            case targetStatus = "targetStatus"
            case versionRevisions = "versionRevisions"
            case versions = "versions"
        }
    }

    public struct UpdatePackageVersionsStatusResult: AWSDecodableShape {
        ///  A list of SuccessfulPackageVersionInfo objects, one for each package version with a status that successfully updated.
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of PackageVersionError objects, one for each package version with  a status that failed to update.
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        @inlinable
        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions = "failedVersions"
            case successfulVersions = "successfulVersions"
        }
    }

    public struct UpdateRepositoryRequest: AWSEncodableShape {
        ///  An updated repository description.
        public let description: String?
        ///  The name of the domain associated with the repository to update.
        public let domain: String
        ///  The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include  dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository to update.
        public let repository: String
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories  in the list determines their priority order when CodeArtifact looks for a requested package version. For more  information, see Working with upstream repositories.
        public let upstreams: [UpstreamRepository]?

        @inlinable
        public init(description: String? = nil, domain: String, domainOwner: String? = nil, repository: String, upstreams: [UpstreamRepository]? = nil) {
            self.description = description
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
            self.upstreams = upstreams
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeQuery(self.domain, key: "domain")
            request.encodeQuery(self.domainOwner, key: "domain-owner")
            request.encodeQuery(self.repository, key: "repository")
            try container.encodeIfPresent(self.upstreams, forKey: .upstreams)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^[a-z][a-z0-9\\-]{0,48}[a-z0-9]$")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
            try self.upstreams?.forEach {
                try $0.validate(name: "\(name).upstreams[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case upstreams = "upstreams"
        }
    }

    public struct UpdateRepositoryResult: AWSDecodableShape {
        ///  The updated repository.
        public let repository: RepositoryDescription?

        @inlinable
        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct UpstreamRepository: AWSEncodableShape {
        ///  The name of an upstream repository.
        public let repositoryName: String

        @inlinable
        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}$")
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
        }
    }

    public struct UpstreamRepositoryInfo: AWSDecodableShape {
        ///  The name of an upstream repository.
        public let repositoryName: String?

        @inlinable
        public init(repositoryName: String? = nil) {
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let message: String
        ///
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(message: String, reason: ValidationExceptionReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "reason"
        }
    }
}

// MARK: - Errors

/// Error enum for CodeArtifact
public struct CodeArtifactErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CodeArtifact
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  The operation did not succeed because of an unauthorized access attempt.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  The operation did not succeed because prerequisites are not met.
    public static var conflictException: Self { .init(.conflictException) }
    ///  The operation did not succeed because of an error that occurred inside CodeArtifact.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The operation did not succeed because the resource requested is not found in the service.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  The operation did not succeed because it would have exceeded a service limit for your account.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    ///  The operation did not succeed because too many requests are sent to the service.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The operation did not succeed because a parameter in the request was sent with an invalid value.
    public static var validationException: Self { .init(.validationException) }
}

extension CodeArtifactErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": CodeArtifact.ConflictException.self,
        "ResourceNotFoundException": CodeArtifact.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": CodeArtifact.ServiceQuotaExceededException.self,
        "ThrottlingException": CodeArtifact.ThrottlingException.self,
        "ValidationException": CodeArtifact.ValidationException.self
    ]
}

extension CodeArtifactErrorType: Equatable {
    public static func == (lhs: CodeArtifactErrorType, rhs: CodeArtifactErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CodeArtifactErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
