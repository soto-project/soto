//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension CodeArtifact {
    // MARK: Enums

    public enum DomainStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case deleted = "Deleted"
        public var description: String { return self.rawValue }
    }

    public enum ExternalConnectionStatus: String, CustomStringConvertible, Codable {
        case available = "Available"
        public var description: String { return self.rawValue }
    }

    public enum HashAlgorithm: String, CustomStringConvertible, Codable {
        case md5 = "MD5"
        case sha1 = "SHA-1"
        case sha256 = "SHA-256"
        case sha512 = "SHA-512"
        public var description: String { return self.rawValue }
    }

    public enum PackageFormat: String, CustomStringConvertible, Codable {
        case maven
        case npm
        case nuget
        case pypi
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionErrorCode: String, CustomStringConvertible, Codable {
        case alreadyExists = "ALREADY_EXISTS"
        case mismatchedRevision = "MISMATCHED_REVISION"
        case mismatchedStatus = "MISMATCHED_STATUS"
        case notAllowed = "NOT_ALLOWED"
        case notFound = "NOT_FOUND"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionSortType: String, CustomStringConvertible, Codable {
        case publishedTime = "PUBLISHED_TIME"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionStatus: String, CustomStringConvertible, Codable {
        case archived = "Archived"
        case deleted = "Deleted"
        case disposed = "Disposed"
        case published = "Published"
        case unfinished = "Unfinished"
        case unlisted = "Unlisted"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssetSummary: AWSDecodableShape {
        ///  The hashes of the asset.
        public let hashes: [HashAlgorithm: String]?
        ///  The name of the asset.
        public let name: String
        ///  The size of the asset.
        public let size: Int64?

        public init(hashes: [HashAlgorithm: String]? = nil, name: String, size: Int64? = nil) {
            self.hashes = hashes
            self.name = name
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case hashes
            case name
            case size
        }
    }

    public struct AssociateExternalConnectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "externalConnection", location: .querystring(locationName: "external-connection")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        /// The name of the domain that contains the repository.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The name of the external connection to add to the repository. The following values are supported:     public:npmjs - for the npm public repository.     public:pypi - for the Python Package Index.     public:maven-central - for Maven Central.     public:maven-googleandroid - for the Google Android repository.     public:maven-gradleplugins - for the Gradle plugins repository.     public:maven-commonsware - for the CommonsWare Android repository.
        public let externalConnection: String
        ///  The name of the repository to which the external connection is added.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, externalConnection: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.externalConnection = externalConnection
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.externalConnection, name: "externalConnection", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-:]{1,99}")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateExternalConnectionResult: AWSDecodableShape {
        ///  Information about the connected repository after processing the request.
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct CopyPackageVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "destinationRepository", location: .querystring(locationName: "destination-repository")),
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "sourceRepository", location: .querystring(locationName: "source-repository"))
        ]

        ///  Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the failedVersions field of the response with an ALREADY_EXISTS error code.
        public let allowOverwrite: Bool?
        ///  The name of the repository into which package versions are copied.
        public let destinationRepository: String
        ///  The name of the domain that contains the source and destination repositories.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The format of the package that is copied. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public let format: PackageFormat
        ///  Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see Working with upstream repositories.
        public let includeFromUpstream: Bool?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package that is copied.
        public let package: String
        ///  The name of the repository that contains the package versions to copy.
        public let sourceRepository: String
        ///  A list of key-value pairs. The keys are package versions and the values are package version revisions. A CopyPackageVersion operation succeeds if the specified versions in the source repository match the specified package version revision.    You must specify versions or versionRevisions. You cannot specify both.
        public let versionRevisions: [String: String]?
        ///  The versions of the package to copy.    You must specify versions or versionRevisions. You cannot specify both.
        public let versions: [String]?

        public init(allowOverwrite: Bool? = nil, destinationRepository: String, domain: String, domainOwner: String? = nil, format: PackageFormat, includeFromUpstream: Bool? = nil, namespace: String? = nil, package: String, sourceRepository: String, versionRevisions: [String: String]? = nil, versions: [String]? = nil) {
            self.allowOverwrite = allowOverwrite
            self.destinationRepository = destinationRepository
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.includeFromUpstream = includeFromUpstream
            self.namespace = namespace
            self.package = package
            self.sourceRepository = sourceRepository
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationRepository, name: "destinationRepository", parent: name, max: 100)
            try self.validate(self.destinationRepository, name: "destinationRepository", parent: name, min: 2)
            try self.validate(self.destinationRepository, name: "destinationRepository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.sourceRepository, name: "sourceRepository", parent: name, max: 100)
            try self.validate(self.sourceRepository, name: "sourceRepository", parent: name, min: 2)
            try self.validate(self.sourceRepository, name: "sourceRepository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.versionRevisions?.forEach {
                try validate($0.key, name: "versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name: "versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name: "versionRevisions.key", parent: name, pattern: "[^!#/\\s]+")
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, pattern: "\\S+")
            }
            try self.versions?.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "[^!#/\\s]+")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case allowOverwrite
            case includeFromUpstream
            case versionRevisions
            case versions
        }
    }

    public struct CopyPackageVersionsResult: AWSDecodableShape {
        ///  A map of package versions that failed to copy and their error codes. The possible error codes are in the PackageVersionError data type. They are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully copied to your repository.
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions
            case successfulVersions
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain"))
        ]

        ///  The name of the domain to create. All domain names in an AWS Region that are in the same AWS account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable.
        public let domain: String
        ///  The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an encryptionKey, your IAM role must have kms:DescribeKey and kms:CreateGrant permissions on the encryption key that is used. For more information, see DescribeKey in the AWS Key Management Service API Reference and AWS KMS API Permissions Reference in the AWS Key Management Service Developer Guide.    CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see Using symmetric and asymmetric keys in the AWS Key Management Service Developer Guide.
        public let encryptionKey: String?
        /// One or more tag key-value pairs for the domain.
        public let tags: [Tag]?

        public init(domain: String, encryptionKey: String? = nil, tags: [Tag]? = nil) {
            self.domain = domain
            self.encryptionKey = encryptionKey
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, max: 1011)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, min: 1)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, pattern: "\\S+")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKey
            case tags
        }
    }

    public struct CreateDomainResult: AWSDecodableShape {
        ///  Contains information about the created domain after processing the request.
        public let domain: DomainDescription?

        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain
        }
    }

    public struct CreateRepositoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  A description of the created repository.
        public let description: String?
        ///  The name of the domain that contains the created repository.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository to create.
        public let repository: String
        /// One or more tag key-value pairs for the repository.
        public let tags: [Tag]?
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see Working with upstream repositories.
        public let upstreams: [UpstreamRepository]?

        public init(description: String? = nil, domain: String, domainOwner: String? = nil, repository: String, tags: [Tag]? = nil, upstreams: [UpstreamRepository]? = nil) {
            self.description = description
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
            self.tags = tags
            self.upstreams = upstreams
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "\\P{C}+")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
            try self.upstreams?.forEach {
                try $0.validate(name: "\(name).upstreams[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case tags
            case upstreams
        }
    }

    public struct CreateRepositoryResult: AWSDecodableShape {
        ///  Information about the created repository after processing the request.
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct DeleteDomainPermissionsPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "policyRevision", location: .querystring(locationName: "policy-revision"))
        ]

        ///  The name of the domain associated with the resource policy to be deleted.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy.
        public let policyRevision: String?

        public init(domain: String, domainOwner: String? = nil, policyRevision: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyRevision = policyRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, max: 100)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainPermissionsPolicyResult: AWSDecodableShape {
        ///  Information about the deleted resource policy after processing the request.
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner"))
        ]

        ///  The name of the domain to delete.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?

        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainResult: AWSDecodableShape {
        ///  Contains information about the deleted domain after processing the request.
        public let domain: DomainDescription?

        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain
        }
    }

    public struct DeletePackageVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the package to delete.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The expected status of the package version to delete. Valid values are:     Published     Unfinished     Unlisted     Archived     Disposed
        public let expectedStatus: PackageVersionStatus?
        ///  The format of the package versions to delete. The valid values are:     npm     pypi     maven
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package with the versions to delete.
        public let package: String
        ///  The name of the repository that contains the package versions to delete.
        public let repository: String
        ///  An array of strings that specify the versions of the package to delete.
        public let versions: [String]

        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.versions = versions
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "[^!#/\\s]+")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case expectedStatus
            case versions
        }
    }

    public struct DeletePackageVersionsResult: AWSDecodableShape {
        ///  A PackageVersionError object that contains a map of errors codes for the deleted package that failed. The possible error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully deleted.
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions
            case successfulVersions
        }
    }

    public struct DeleteRepositoryPermissionsPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "policyRevision", location: .querystring(locationName: "policy-revision")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository associated with the resource policy to be deleted.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy.
        public let policyRevision: String?
        ///  The name of the repository that is associated with the resource policy to be deleted
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, policyRevision: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyRevision = policyRevision
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, max: 100)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, pattern: "\\S+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRepositoryPermissionsPolicyResult: AWSDecodableShape {
        ///  Information about the deleted policy after processing the request.
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy
        }
    }

    public struct DeleteRepositoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository to delete.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository to delete.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRepositoryResult: AWSDecodableShape {
        ///  Information about the deleted repository after processing the request.
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct DescribeDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner"))
        ]

        ///  A string that specifies the name of the requested domain.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?

        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainResult: AWSDecodableShape {
        public let domain: DomainDescription?

        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain
        }
    }

    public struct DescribePackageVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "packageVersion", location: .querystring(locationName: "version")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository that contains the package version.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  A format that specifies the type of the requested package version. The valid values are:     npm     pypi     maven
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the requested package version.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The name of the repository that contains the package version.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackageVersionResult: AWSDecodableShape {
        ///  A PackageVersionDescription object that contains information about the requested package version.
        public let packageVersion: PackageVersionDescription

        public init(packageVersion: PackageVersionDescription) {
            self.packageVersion = packageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case packageVersion
        }
    }

    public struct DescribeRepositoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository to describe.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  A string that specifies the name of the requested repository.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRepositoryResult: AWSDecodableShape {
        ///  A RepositoryDescription object that contains the requested repository information.
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct DisassociateExternalConnectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "externalConnection", location: .querystring(locationName: "external-connection")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        /// The name of the domain that contains the repository from which to remove the external repository.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        /// The name of the external connection to be removed from the repository.
        public let externalConnection: String
        /// The name of the repository from which the external connection will be removed.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, externalConnection: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.externalConnection = externalConnection
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.externalConnection, name: "externalConnection", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-:]{1,99}")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateExternalConnectionResult: AWSDecodableShape {
        ///  The repository associated with the removed external connection.
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct DisposePackageVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository you want to dispose.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The expected status of the package version to dispose. Valid values are:     Published     Unfinished     Unlisted     Archived     Disposed
        public let expectedStatus: PackageVersionStatus?
        ///  A format that specifies the type of package versions you want to dispose. The valid values are:     npm     pypi     maven
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package with the versions you want to dispose.
        public let package: String
        ///  The name of the repository that contains the package versions you want to dispose.
        public let repository: String
        ///  The revisions of the package versions you want to dispose.
        public let versionRevisions: [String: String]?
        ///  The versions of the package you want to dispose.
        public let versions: [String]

        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, versionRevisions: [String: String]? = nil, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.versionRevisions?.forEach {
                try validate($0.key, name: "versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name: "versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name: "versionRevisions.key", parent: name, pattern: "[^!#/\\s]+")
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, pattern: "\\S+")
            }
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "[^!#/\\s]+")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case expectedStatus
            case versionRevisions
            case versions
        }
    }

    public struct DisposePackageVersionsResult: AWSDecodableShape {
        ///  A PackageVersionError object that contains a map of errors codes for the disposed package versions that failed. The possible error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully disposed.
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions
            case successfulVersions
        }
    }

    public struct DomainDescription: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the domain.
        public let arn: String?
        ///  The total size of all assets in the domain.
        public let assetSizeBytes: Int64?
        ///  A timestamp that represents the date and time the domain was created.
        public let createdTime: Date?
        ///  The ARN of an AWS Key Management Service (AWS KMS) key associated with a domain.
        public let encryptionKey: String?
        ///  The name of the domain.
        public let name: String?
        ///  The AWS account ID that owns the domain.
        public let owner: String?
        ///  The number of repositories in the domain.
        public let repositoryCount: Int?
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket that is used to store package assets in the domain.
        public let s3BucketArn: String?
        ///  The current status of a domain. The valid values are     Active     Deleted
        public let status: DomainStatus?

        public init(arn: String? = nil, assetSizeBytes: Int64? = nil, createdTime: Date? = nil, encryptionKey: String? = nil, name: String? = nil, owner: String? = nil, repositoryCount: Int? = nil, s3BucketArn: String? = nil, status: DomainStatus? = nil) {
            self.arn = arn
            self.assetSizeBytes = assetSizeBytes
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.repositoryCount = repositoryCount
            self.s3BucketArn = s3BucketArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case assetSizeBytes
            case createdTime
            case encryptionKey
            case name
            case owner
            case repositoryCount
            case s3BucketArn
            case status
        }
    }

    public struct DomainSummary: AWSDecodableShape {
        ///  The ARN of the domain.
        public let arn: String?
        ///  A timestamp that contains the date and time the domain was created.
        public let createdTime: Date?
        ///  The key used to encrypt the domain.
        public let encryptionKey: String?
        ///  The name of the domain.
        public let name: String?
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let owner: String?
        ///  A string that contains the status of the domain. The valid values are:     Active     Deleted
        public let status: DomainStatus?

        public init(arn: String? = nil, createdTime: Date? = nil, encryptionKey: String? = nil, name: String? = nil, owner: String? = nil, status: DomainStatus? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case encryptionKey
            case name
            case owner
            case status
        }
    }

    public struct GetAuthorizationTokenRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "durationSeconds", location: .querystring(locationName: "duration"))
        ]

        ///  The name of the domain that is in scope for the generated authorization token.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        /// The time, in seconds, that the generated authorization token is valid. Valid values are 0 and any number between 900 (15 minutes) and 43200 (12 hours). A value of 0 will set the expiration of the authorization token to the same expiration of the user's role's temporary credentials.
        public let durationSeconds: Int64?

        public init(domain: String, domainOwner: String? = nil, durationSeconds: Int64? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.durationSeconds = durationSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.durationSeconds, name: "durationSeconds", parent: name, max: 43200)
            try self.validate(self.durationSeconds, name: "durationSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAuthorizationTokenResult: AWSDecodableShape {
        ///  The returned authentication token.
        public let authorizationToken: String?
        ///  A timestamp that specifies the date and time the authorization token expires.
        public let expiration: Date?

        public init(authorizationToken: String? = nil, expiration: Date? = nil) {
            self.authorizationToken = authorizationToken
            self.expiration = expiration
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationToken
            case expiration
        }
    }

    public struct GetDomainPermissionsPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner"))
        ]

        ///  The name of the domain to which the resource policy is attached.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?

        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainPermissionsPolicyResult: AWSDecodableShape {
        ///  The returned resource policy.
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy
        }
    }

    public struct GetPackageVersionAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "asset", location: .querystring(locationName: "asset")),
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "packageVersion", location: .querystring(locationName: "version")),
            AWSMemberEncoding(label: "packageVersionRevision", location: .querystring(locationName: "revision")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the requested asset.
        public let asset: String
        ///  The name of the domain that contains the repository that contains the package version with the requested asset.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  A format that specifies the type of the package version with the requested asset file. The valid values are:     npm     pypi     maven
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package that contains the requested asset.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The name of the package version revision that contains the requested asset.
        public let packageVersionRevision: String?
        ///  The repository that contains the package version with the requested asset.
        public let repository: String

        public init(asset: String, domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, packageVersionRevision: String? = nil, repository: String) {
            self.asset = asset
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.packageVersionRevision = packageVersionRevision
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.asset, name: "asset", parent: name, max: 255)
            try self.validate(self.asset, name: "asset", parent: name, min: 1)
            try self.validate(self.asset, name: "asset", parent: name, pattern: "\\P{C}+")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.packageVersionRevision, name: "packageVersionRevision", parent: name, max: 50)
            try self.validate(self.packageVersionRevision, name: "packageVersionRevision", parent: name, min: 1)
            try self.validate(self.packageVersionRevision, name: "packageVersionRevision", parent: name, pattern: "\\S+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPackageVersionAssetResult: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "asset"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw, .allowStreaming]
        public static var _encoding = [
            AWSMemberEncoding(label: "assetName", location: .header(locationName: "X-AssetName")),
            AWSMemberEncoding(label: "packageVersion", location: .header(locationName: "X-PackageVersion")),
            AWSMemberEncoding(label: "packageVersionRevision", location: .header(locationName: "X-PackageVersionRevision"))
        ]

        ///  The binary file, or asset, that is downloaded.
        public let asset: AWSPayload?
        ///  The name of the asset that is downloaded.
        public let assetName: String?
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String?
        ///  The name of the package version revision that contains the downloaded asset.
        public let packageVersionRevision: String?

        public init(asset: AWSPayload? = nil, assetName: String? = nil, packageVersion: String? = nil, packageVersionRevision: String? = nil) {
            self.asset = asset
            self.assetName = assetName
            self.packageVersion = packageVersion
            self.packageVersionRevision = packageVersionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case asset
            case assetName = "X-AssetName"
            case packageVersion = "X-PackageVersion"
            case packageVersionRevision = "X-PackageVersionRevision"
        }
    }

    public struct GetPackageVersionReadmeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "packageVersion", location: .querystring(locationName: "version")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository that contains the package version with the requested readme file.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  A format that specifies the type of the package version with the requested readme file. The valid values are:     npm     pypi     maven
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package version that contains the requested readme file.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The repository that contains the package with the requested readme file.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPackageVersionReadmeResult: AWSDecodableShape {
        ///  The format of the package with the requested readme file. Valid format types are:     npm     pypi     maven
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package that contains the returned readme file.
        public let package: String?
        ///  The text of the returned readme file.
        public let readme: String?
        ///  The version of the package with the requested readme file.
        public let version: String?
        ///  The current revision associated with the package version.
        public let versionRevision: String?

        public init(format: PackageFormat? = nil, namespace: String? = nil, package: String? = nil, readme: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.format = format
            self.namespace = namespace
            self.package = package
            self.readme = readme
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case format
            case namespace
            case package
            case readme
            case version
            case versionRevision
        }
    }

    public struct GetRepositoryEndpointRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  Returns which endpoint of a repository to return. A repository has one endpoint for each package format:     npm     pypi     maven
        public let format: PackageFormat
        ///  The name of the repository.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRepositoryEndpointResult: AWSDecodableShape {
        ///  A string that specifies the URL of the returned endpoint.
        public let repositoryEndpoint: String?

        public init(repositoryEndpoint: String? = nil) {
            self.repositoryEndpoint = repositoryEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryEndpoint
        }
    }

    public struct GetRepositoryPermissionsPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain containing the repository whose associated resource policy is to be retrieved.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository whose associated resource policy is to be retrieved.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRepositoryPermissionsPolicyResult: AWSDecodableShape {
        ///  The returned resource policy.
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy
        }
    }

    public struct LicenseInfo: AWSDecodableShape {
        ///  Name of the license.
        public let name: String?
        ///  The URL for license data.
        public let url: String?

        public init(name: String? = nil, url: String? = nil) {
            self.name = name
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case url
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListDomainsResult: AWSDecodableShape {
        ///  The returned list of DomainSummary objects.
        public let domains: [DomainSummary]?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(domains: [DomainSummary]? = nil, nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains
            case nextToken
        }
    }

    public struct ListPackageVersionAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "packageVersion", location: .querystring(locationName: "version")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository associated with the package version assets.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The format of the package that contains the returned package version assets. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public let format: PackageFormat
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The name of the package that contains the returned package version assets.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The name of the repository that contains the package that contains the returned package version assets.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackageVersionAssetsResult: AWSDecodableShape {
        ///  The returned list of AssetSummary objects.
        public let assets: [AssetSummary]?
        ///  The format of the package that contains the returned package version assets.
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The name of the package that contains the returned package version assets.
        public let package: String?
        ///  The version of the package associated with the returned assets.
        public let version: String?
        ///  The current revision associated with the package version.
        public let versionRevision: String?

        public init(assets: [AssetSummary]? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.assets = assets
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case assets
            case format
            case namespace
            case nextToken
            case package
            case version
            case versionRevision
        }
    }

    public struct ListPackageVersionDependenciesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "packageVersion", location: .querystring(locationName: "version")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository that contains the requested package version dependencies.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The format of the package with the requested dependencies. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The name of the package versions' package.
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2).
        public let packageVersion: String
        ///  The name of the repository that contains the requested package version.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, nextToken: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackageVersionDependenciesResult: AWSDecodableShape {
        ///  The returned list of PackageDependency objects.
        public let dependencies: [PackageDependency]?
        ///  A format that specifies the type of the package that contains the returned dependencies. The valid values are:     npm     pypi     maven
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The name of the package that contains the returned package versions dependencies.
        public let package: String?
        ///  The version of the package that is specified in the request.
        public let version: String?
        ///  The current revision associated with the package version.
        public let versionRevision: String?

        public init(dependencies: [PackageDependency]? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.dependencies = dependencies
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies
            case format
            case namespace
            case nextToken
            case package
            case version
            case versionRevision
        }
    }

    public struct ListPackageVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository")),
            AWSMemberEncoding(label: "sortBy", location: .querystring(locationName: "sortBy")),
            AWSMemberEncoding(label: "status", location: .querystring(locationName: "status"))
        ]

        ///  The name of the domain that contains the repository that contains the returned package versions.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The format of the returned packages. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public let format: PackageFormat
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  The name of the package for which you want to return a list of package versions.
        public let package: String
        ///  The name of the repository that contains the package.
        public let repository: String
        ///  How to sort the returned list of package versions.
        public let sortBy: PackageVersionSortType?
        ///  A string that specifies the status of the package versions to include in the returned list. It can be one of the following:     Published     Unfinished     Unlisted     Archived     Disposed
        public let status: PackageVersionStatus?

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, package: String, repository: String, sortBy: PackageVersionSortType? = nil, status: PackageVersionStatus? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.repository = repository
            self.sortBy = sortBy
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackageVersionsResult: AWSDecodableShape {
        ///  The default package version to display. This depends on the package format:     For Maven and PyPI packages, it's the most recently published package version.     For npm packages, it's the version referenced by the latest tag. If the latest tag is not set, it's the most recently published package version.
        public let defaultDisplayVersion: String?
        ///  A format of the package. Valid package format values are:     npm     pypi     maven
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The name of the package.
        public let package: String?
        ///  The returned list of PackageVersionSummary objects.
        public let versions: [PackageVersionSummary]?

        public init(defaultDisplayVersion: String? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, versions: [PackageVersionSummary]? = nil) {
            self.defaultDisplayVersion = defaultDisplayVersion
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case defaultDisplayVersion
            case format
            case namespace
            case nextToken
            case package
            case versions
        }
    }

    public struct ListPackagesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "packagePrefix", location: .querystring(locationName: "package-prefix")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository that contains the requested list of packages.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The format of the packages. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public let format: PackageFormat?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  A prefix used to filter returned packages. Only packages with names that start with packagePrefix are returned.
        public let packagePrefix: String?
        ///  The name of the repository from which packages are to be listed.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat? = nil, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, packagePrefix: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.packagePrefix = packagePrefix
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
            try self.validate(self.packagePrefix, name: "packagePrefix", parent: name, max: 255)
            try self.validate(self.packagePrefix, name: "packagePrefix", parent: name, min: 1)
            try self.validate(self.packagePrefix, name: "packagePrefix", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagesResult: AWSDecodableShape {
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The list of returned PackageSummary objects.
        public let packages: [PackageSummary]?

        public init(nextToken: String? = nil, packages: [PackageSummary]? = nil) {
            self.nextToken = nextToken
            self.packages = packages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case packages
        }
    }

    public struct ListRepositoriesInDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "administratorAccount", location: .querystring(locationName: "administrator-account")),
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "repositoryPrefix", location: .querystring(locationName: "repository-prefix"))
        ]

        ///  Filter the list of repositories to only include those that are managed by the AWS account ID.
        public let administratorAccount: String?
        ///  The name of the domain that contains the returned list of repositories.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned.
        public let repositoryPrefix: String?

        public init(administratorAccount: String? = nil, domain: String, domainOwner: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, repositoryPrefix: String? = nil) {
            self.administratorAccount = administratorAccount
            self.domain = domain
            self.domainOwner = domainOwner
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.repositoryPrefix = repositoryPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.administratorAccount, name: "administratorAccount", parent: name, max: 12)
            try self.validate(self.administratorAccount, name: "administratorAccount", parent: name, min: 12)
            try self.validate(self.administratorAccount, name: "administratorAccount", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, max: 100)
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, min: 2)
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRepositoriesInDomainResult: AWSDecodableShape {
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The returned list of repositories.
        public let repositories: [RepositorySummary]?

        public init(nextToken: String? = nil, repositories: [RepositorySummary]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case repositories
        }
    }

    public struct ListRepositoriesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "repositoryPrefix", location: .querystring(locationName: "repository-prefix"))
        ]

        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        ///  A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned.
        public let repositoryPrefix: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, repositoryPrefix: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.repositoryPrefix = repositoryPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S+")
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, max: 100)
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, min: 2)
            try self.validate(self.repositoryPrefix, name: "repositoryPrefix", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRepositoriesResult: AWSDecodableShape {
        ///  If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        ///  The returned list of RepositorySummary objects.
        public let repositories: [RepositorySummary]?

        public init(nextToken: String? = nil, repositories: [RepositorySummary]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case repositories
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to get tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResult: AWSDecodableShape {
        /// A list of tag key and value pairs associated with the specified resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct PackageDependency: AWSDecodableShape {
        ///  The type of a package dependency. The possible values depend on the package type. Example types are compile, runtime, and test for Maven packages, and dev, prod, and optional for npm packages.
        public let dependencyType: String?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package that this package depends on.
        public let package: String?
        ///  The required version, or version range, of the package that this package depends on. The version format is specific to the package type. For example, the following are possible valid required versions: 1.2.3, ^2.3.4, or 4.x.
        public let versionRequirement: String?

        public init(dependencyType: String? = nil, namespace: String? = nil, package: String? = nil, versionRequirement: String? = nil) {
            self.dependencyType = dependencyType
            self.namespace = namespace
            self.package = package
            self.versionRequirement = versionRequirement
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyType
            case namespace
            case package
            case versionRequirement
        }
    }

    public struct PackageSummary: AWSDecodableShape {
        ///  The format of the package. Valid values are:     npm     pypi     maven
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package.
        public let package: String?

        public init(format: PackageFormat? = nil, namespace: String? = nil, package: String? = nil) {
            self.format = format
            self.namespace = namespace
            self.package = package
        }

        private enum CodingKeys: String, CodingKey {
            case format
            case namespace
            case package
        }
    }

    public struct PackageVersionDescription: AWSDecodableShape {
        ///  The name of the package that is displayed. The displayName varies depending on the package version's format. For example, if an npm package is named ui, is in the namespace vue, and has the format npm, then the displayName is @vue/ui.
        public let displayName: String?
        ///  The format of the package version. The valid package formats are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public let format: PackageFormat?
        ///  The homepage associated with the package.
        public let homePage: String?
        ///  Information about licenses associated with the package version.
        public let licenses: [LicenseInfo]?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the requested package.
        public let packageName: String?
        ///  A timestamp that contains the date and time the package version was published.
        public let publishedTime: Date?
        ///  The revision of the package version.
        public let revision: String?
        ///  The repository for the source code in the package version, or the source code used to build it.
        public let sourceCodeRepository: String?
        ///  A string that contains the status of the package version. It can be one of the following:     Published     Unfinished     Unlisted     Archived     Disposed
        public let status: PackageVersionStatus?
        ///  A summary of the package version. The summary is extracted from the package. The information in and detail level of the summary depends on the package version's format.
        public let summary: String?
        ///  The version of the package.
        public let version: String?

        public init(displayName: String? = nil, format: PackageFormat? = nil, homePage: String? = nil, licenses: [LicenseInfo]? = nil, namespace: String? = nil, packageName: String? = nil, publishedTime: Date? = nil, revision: String? = nil, sourceCodeRepository: String? = nil, status: PackageVersionStatus? = nil, summary: String? = nil, version: String? = nil) {
            self.displayName = displayName
            self.format = format
            self.homePage = homePage
            self.licenses = licenses
            self.namespace = namespace
            self.packageName = packageName
            self.publishedTime = publishedTime
            self.revision = revision
            self.sourceCodeRepository = sourceCodeRepository
            self.status = status
            self.summary = summary
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case displayName
            case format
            case homePage
            case licenses
            case namespace
            case packageName
            case publishedTime
            case revision
            case sourceCodeRepository
            case status
            case summary
            case version
        }
    }

    public struct PackageVersionError: AWSDecodableShape {
        ///  The error code associated with the error. Valid error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED
        public let errorCode: PackageVersionErrorCode?
        ///  The error message associated with the error.
        public let errorMessage: String?

        public init(errorCode: PackageVersionErrorCode? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorMessage
        }
    }

    public struct PackageVersionSummary: AWSDecodableShape {
        ///  The revision associated with a package version.
        public let revision: String?
        ///  A string that contains the status of the package version. It can be one of the following:     Published     Unfinished     Unlisted     Archived     Disposed
        public let status: PackageVersionStatus
        ///  Information about a package version.
        public let version: String

        public init(revision: String? = nil, status: PackageVersionStatus, version: String) {
            self.revision = revision
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case revision
            case status
            case version
        }
    }

    public struct PutDomainPermissionsPolicyRequest: AWSEncodableShape {
        ///  The name of the domain on which to set the resource policy.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain.
        public let policyDocument: String
        ///  The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy.
        public let policyRevision: String?

        public init(domain: String, domainOwner: String? = nil, policyDocument: String, policyRevision: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyDocument = policyDocument
            self.policyRevision = policyRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 5120)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, max: 100)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case domain
            case domainOwner
            case policyDocument
            case policyRevision
        }
    }

    public struct PutDomainPermissionsPolicyResult: AWSDecodableShape {
        ///  The resource policy that was set after processing the request.
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy
        }
    }

    public struct PutRepositoryPermissionsPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain containing the repository to set the resource policy on.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository.
        public let policyDocument: String
        ///  Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy.
        public let policyRevision: String?
        ///  The name of the repository to set the resource policy on.
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, policyDocument: String, policyRevision: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyDocument = policyDocument
            self.policyRevision = policyRevision
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 5120)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, max: 100)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, min: 1)
            try self.validate(self.policyRevision, name: "policyRevision", parent: name, pattern: "\\S+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument
            case policyRevision
        }
    }

    public struct PutRepositoryPermissionsPolicyResult: AWSDecodableShape {
        ///  The resource policy that was set after processing the request.
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy
        }
    }

    public struct RepositoryDescription: AWSDecodableShape {
        ///  The 12-digit account number of the AWS account that manages the repository.
        public let administratorAccount: String?
        ///  The Amazon Resource Name (ARN) of the repository.
        public let arn: String?
        ///  A text description of the repository.
        public let description: String?
        ///  The name of the domain that contains the repository.
        public let domainName: String?
        ///  The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  An array of external connections associated with the repository.
        public let externalConnections: [RepositoryExternalConnectionInfo]?
        ///  The name of the repository.
        public let name: String?
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see Working with upstream repositories.
        public let upstreams: [UpstreamRepositoryInfo]?

        public init(administratorAccount: String? = nil, arn: String? = nil, description: String? = nil, domainName: String? = nil, domainOwner: String? = nil, externalConnections: [RepositoryExternalConnectionInfo]? = nil, name: String? = nil, upstreams: [UpstreamRepositoryInfo]? = nil) {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.externalConnections = externalConnections
            self.name = name
            self.upstreams = upstreams
        }

        private enum CodingKeys: String, CodingKey {
            case administratorAccount
            case arn
            case description
            case domainName
            case domainOwner
            case externalConnections
            case name
            case upstreams
        }
    }

    public struct RepositoryExternalConnectionInfo: AWSDecodableShape {
        ///  The name of the external connection associated with a repository.
        public let externalConnectionName: String?
        ///  The package format associated with a repository's external connection. The valid package formats are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        public let packageFormat: PackageFormat?
        ///  The status of the external connection of a repository. There is one valid value, Available.
        public let status: ExternalConnectionStatus?

        public init(externalConnectionName: String? = nil, packageFormat: PackageFormat? = nil, status: ExternalConnectionStatus? = nil) {
            self.externalConnectionName = externalConnectionName
            self.packageFormat = packageFormat
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case externalConnectionName
            case packageFormat
            case status
        }
    }

    public struct RepositorySummary: AWSDecodableShape {
        ///  The AWS account ID that manages the repository.
        public let administratorAccount: String?
        ///  The ARN of the repository.
        public let arn: String?
        ///  The description of the repository.
        public let description: String?
        ///  The name of the domain that contains the repository.
        public let domainName: String?
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository.
        public let name: String?

        public init(administratorAccount: String? = nil, arn: String? = nil, description: String? = nil, domainName: String? = nil, domainOwner: String? = nil, name: String? = nil) {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case administratorAccount
            case arn
            case description
            case domainName
            case domainOwner
            case name
        }
    }

    public struct ResourcePolicy: AWSDecodableShape {
        ///  The resource policy formatted in JSON.
        public let document: String?
        ///  The ARN of the resource associated with the resource policy
        public let resourceArn: String?
        ///  The current revision of the resource policy.
        public let revision: String?

        public init(document: String? = nil, resourceArn: String? = nil, revision: String? = nil) {
            self.document = document
            self.resourceArn = resourceArn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case document
            case resourceArn
            case revision
        }
    }

    public struct SuccessfulPackageVersionInfo: AWSDecodableShape {
        ///  The revision of a package version.
        public let revision: String?
        ///  The status of a package version. Valid statuses are:     Published     Unfinished     Unlisted     Archived     Disposed
        public let status: PackageVersionStatus?

        public init(revision: String? = nil, status: PackageVersionStatus? = nil) {
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case revision
            case status
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String
        /// The tag value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.
        public let resourceArn: String
        /// The tags you want to modify or add to the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S+")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
        public let resourceArn: String
        /// The tag key for each tag that you want to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S+")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys
        }
    }

    public struct UntagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePackageVersionsStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "package", location: .querystring(locationName: "package")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  The name of the domain that contains the repository that contains the package versions with a status to be updated.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The package versions expected status before it is updated. If expectedStatus is provided, the package version's status is updated only if its status at the time UpdatePackageVersionsStatus is called matches expectedStatus.
        public let expectedStatus: PackageVersionStatus?
        ///  A format that specifies the type of the package with the statuses to update. The valid values are:     npm     pypi     maven
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.
        public let namespace: String?
        ///  The name of the package with the version statuses to update.
        public let package: String
        ///  The repository that contains the package versions with the status you want to update.
        public let repository: String
        ///  The status you want to change the package version status to.
        public let targetStatus: PackageVersionStatus
        ///  A map of package versions and package version revisions. The map key is the package version (for example, 3.5.2), and the map value is the package version revision.
        public let versionRevisions: [String: String]?
        ///  An array of strings that specify the versions of the package with the statuses to update.
        public let versions: [String]

        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, targetStatus: PackageVersionStatus, versionRevisions: [String: String]? = nil, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.targetStatus = targetStatus
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.package, name: "package", parent: name, max: 255)
            try self.validate(self.package, name: "package", parent: name, min: 1)
            try self.validate(self.package, name: "package", parent: name, pattern: "[^!#/\\s]+")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.versionRevisions?.forEach {
                try validate($0.key, name: "versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name: "versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name: "versionRevisions.key", parent: name, pattern: "[^!#/\\s]+")
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "versionRevisions[\"\($0.key)\"]", parent: name, pattern: "\\S+")
            }
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "[^!#/\\s]+")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case expectedStatus
            case targetStatus
            case versionRevisions
            case versions
        }
    }

    public struct UpdatePackageVersionsStatusResult: AWSDecodableShape {
        ///  A list of SuccessfulPackageVersionInfo objects, one for each package version with a status that successfully updated.
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of PackageVersionError objects, one for each package version with a status that failed to update.
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions
            case successfulVersions
        }
    }

    public struct UpdateRepositoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domain", location: .querystring(locationName: "domain")),
            AWSMemberEncoding(label: "domainOwner", location: .querystring(locationName: "domain-owner")),
            AWSMemberEncoding(label: "repository", location: .querystring(locationName: "repository"))
        ]

        ///  An updated repository description.
        public let description: String?
        ///  The name of the domain associated with the repository to update.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
        public let domainOwner: String?
        ///  The name of the repository to update.
        public let repository: String
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see Working with upstream repositories.
        public let upstreams: [UpstreamRepository]?

        public init(description: String? = nil, domain: String, domainOwner: String? = nil, repository: String, upstreams: [UpstreamRepository]? = nil) {
            self.description = description
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
            self.upstreams = upstreams
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "\\P{C}+")
            try self.validate(self.domain, name: "domain", parent: name, max: 50)
            try self.validate(self.domain, name: "domain", parent: name, min: 2)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, max: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, min: 12)
            try self.validate(self.domainOwner, name: "domainOwner", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repository, name: "repository", parent: name, max: 100)
            try self.validate(self.repository, name: "repository", parent: name, min: 2)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.upstreams?.forEach {
                try $0.validate(name: "\(name).upstreams[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case upstreams
        }
    }

    public struct UpdateRepositoryResult: AWSDecodableShape {
        ///  The updated repository.
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct UpstreamRepository: AWSEncodableShape {
        ///  The name of an upstream repository.
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 100)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName
        }
    }

    public struct UpstreamRepositoryInfo: AWSDecodableShape {
        ///  The name of an upstream repository.
        public let repositoryName: String?

        public init(repositoryName: String? = nil) {
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName
        }
    }
}
