//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ObservabilityAdmin {
    // MARK: Enums

    public enum Action: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case block = "BLOCK"
        case captcha = "CAPTCHA"
        case challenge = "CHALLENGE"
        case count = "COUNT"
        case excludedAsCount = "EXCLUDED_AS_COUNT"
        public var description: String { return self.rawValue }
    }

    public enum CentralizationFailureReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case destinationAccountNotInOrganization = "DESTINATION_ACCOUNT_NOT_IN_ORGANIZATION"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case trustedAccessNotEnabled = "TRUSTED_ACCESS_NOT_ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DestinationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudwatchLogs = "cloud-watch-logs"
        public var description: String { return self.rawValue }
    }

    public enum EncryptedLogGroupStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case skip = "SKIP"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionConflictResolutionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case skip = "SKIP"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsOwned = "AWS_OWNED"
        case customerManaged = "CUSTOMER_MANAGED"
        public var description: String { return self.rawValue }
    }

    public enum FilterBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case drop = "DROP"
        case keep = "KEEP"
        public var description: String { return self.rawValue }
    }

    public enum FilterRequirement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case meetsAll = "MEETS_ALL"
        case meetsAny = "MEETS_ANY"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum LogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case application = "APPLICATION_LOGS"
        case usage = "USAGE_LOGS"
        public var description: String { return self.rawValue }
    }

    public enum OutputFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "json"
        case plain = "plain"
        public var description: String { return self.rawValue }
    }

    public enum RecordFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsBedrockAgentcoreBrowser = "AWS::BedrockAgentCore::Browser"
        case awsBedrockAgentcoreCodeInterpreter = "AWS::BedrockAgentCore::CodeInterpreter"
        case awsBedrockAgentcoreRuntime = "AWS::BedrockAgentCore::Runtime"
        case awsCloudtrail = "AWS::CloudTrail"
        case awsEc2Instance = "AWS::EC2::Instance"
        case awsEc2Vpc = "AWS::EC2::VPC"
        case awsEksCluster = "AWS::EKS::Cluster"
        case awsElbLoadbalancer = "AWS::ElasticLoadBalancingV2::LoadBalancer"
        case awsLamdbaFunction = "AWS::Lambda::Function"
        case awsRoute53ResolverResolverEndpoint = "AWS::Route53Resolver::ResolverEndpoint"
        case awsWafV2WebAcl = "AWS::WAFv2::WebACL"
        public var description: String { return self.rawValue }
    }

    public enum RuleHealth: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "Healthy"
        case provisioning = "Provisioning"
        case unhealthy = "Unhealthy"
        public var description: String { return self.rawValue }
    }

    public enum SSEAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sseKms = "aws:kms"
        case sseS3 = "AES256"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failedStart = "FAILED_START"
        case failedStop = "FAILED_STOP"
        case notStarted = "NOT_STARTED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum TelemetryEnrichmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case impaired = "Impaired"
        case running = "Running"
        case stopped = "Stopped"
        public var description: String { return self.rawValue }
    }

    public enum TelemetryPipelineStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TelemetrySourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eksApiLogs = "EKS_API_LOGS"
        case eksAuditLogs = "EKS_AUDIT_LOGS"
        case eksAuthenticatorLogs = "EKS_AUTHENTICATOR_LOGS"
        case eksControllerManagerLogs = "EKS_CONTROLLER_MANAGER_LOGS"
        case eksSchedulerLogs = "EKS_SCHEDULER_LOGS"
        case route53ResolverQueryLogs = "ROUTE53_RESOLVER_QUERY_LOGS"
        case vpcFlowLogs = "VPC_FLOW_LOGS"
        public var description: String { return self.rawValue }
    }

    public enum TelemetryState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        case notApplicable = "NotApplicable"
        public var description: String { return self.rawValue }
    }

    public enum TelemetryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case logs = "Logs"
        case metrics = "Metrics"
        case traces = "Traces"
        public var description: String { return self.rawValue }
    }

    public enum WAFLogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case wafLogs = "WAF_LOGS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        ///  The name of the exception.
        public let amznErrorType: String?
        public let message: String?

        @inlinable
        public init(amznErrorType: String? = nil, message: String? = nil) {
            self.amznErrorType = amznErrorType
            self.message = message
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.amznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct ActionCondition: AWSEncodableShape & AWSDecodableShape {
        ///  The WAF action to match against (ALLOW, BLOCK, COUNT, CAPTCHA, CHALLENGE, EXCLUDED_AS_COUNT).
        public let action: Action?

        @inlinable
        public init(action: Action? = nil) {
            self.action = action
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
        }
    }

    public struct AdvancedEventSelector: AWSEncodableShape & AWSDecodableShape {
        /// Contains all selector statements in an advanced event selector.
        public let fieldSelectors: [AdvancedFieldSelector]
        /// An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
        public let name: String?

        @inlinable
        public init(fieldSelectors: [AdvancedFieldSelector], name: String? = nil) {
            self.fieldSelectors = fieldSelectors
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case fieldSelectors = "FieldSelectors"
            case name = "Name"
        }
    }

    public struct AdvancedFieldSelector: AWSEncodableShape & AWSDecodableShape {
        ///  Matches if the field value ends with the specified value.
        public let endsWith: [String]?
        ///  Matches if the field value equals the specified value.
        public let equals: [String]?
        ///  The name of the field to use for selection.
        public let field: String
        ///  Matches if the field value does not end with the specified value.
        public let notEndsWith: [String]?
        ///  Matches if the field value does not equal the specified value.
        public let notEquals: [String]?
        ///  Matches if the field value does not start with the specified value.
        public let notStartsWith: [String]?
        ///  Matches if the field value starts with the specified value.
        public let startsWith: [String]?

        @inlinable
        public init(endsWith: [String]? = nil, equals: [String]? = nil, field: String, notEndsWith: [String]? = nil, notEquals: [String]? = nil, notStartsWith: [String]? = nil, startsWith: [String]? = nil) {
            self.endsWith = endsWith
            self.equals = equals
            self.field = field
            self.notEndsWith = notEndsWith
            self.notEquals = notEquals
            self.notStartsWith = notStartsWith
            self.startsWith = startsWith
        }

        private enum CodingKeys: String, CodingKey {
            case endsWith = "EndsWith"
            case equals = "Equals"
            case field = "Field"
            case notEndsWith = "NotEndsWith"
            case notEquals = "NotEquals"
            case notStartsWith = "NotStartsWith"
            case startsWith = "StartsWith"
        }
    }

    public struct CentralizationRule: AWSEncodableShape & AWSDecodableShape {
        /// Configuration determining where the telemetry data should be centralized, backed up, as well as encryption configuration for the primary and backup destinations.
        public let destination: CentralizationRuleDestination
        /// Configuration determining the source of the telemetry data to be centralized.
        public let source: CentralizationRuleSource

        @inlinable
        public init(destination: CentralizationRuleDestination, source: CentralizationRuleSource) {
            self.destination = destination
            self.source = source
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case source = "Source"
        }
    }

    public struct CentralizationRuleDestination: AWSEncodableShape & AWSDecodableShape {
        /// The destination account (within the organization) to which the telemetry data should be centralized.
        public let account: String?
        /// Log specific configuration for centralization destination log groups.
        public let destinationLogsConfiguration: DestinationLogsConfiguration?
        /// The primary destination region to which telemetry data should be centralized.
        public let region: String

        @inlinable
        public init(account: String? = nil, destinationLogsConfiguration: DestinationLogsConfiguration? = nil, region: String) {
            self.account = account
            self.destinationLogsConfiguration = destinationLogsConfiguration
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.account, name: "account", parent: name, max: 12)
            try self.validate(self.account, name: "account", parent: name, min: 12)
            try self.validate(self.account, name: "account", parent: name, pattern: "^[0-9]{12}$")
            try self.destinationLogsConfiguration?.validate(name: "\(name).destinationLogsConfiguration")
            try self.validate(self.region, name: "region", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case account = "Account"
            case destinationLogsConfiguration = "DestinationLogsConfiguration"
            case region = "Region"
        }
    }

    public struct CentralizationRuleSource: AWSEncodableShape & AWSDecodableShape {
        /// The list of source regions from which telemetry data should be centralized.
        public let regions: [String]
        /// The organizational scope from which telemetry data should be centralized, specified using organization id, accounts or organizational unit ids.
        public let scope: String?
        /// Log specific configuration for centralization source log groups.
        public let sourceLogsConfiguration: SourceLogsConfiguration?

        @inlinable
        public init(regions: [String], scope: String? = nil, sourceLogsConfiguration: SourceLogsConfiguration? = nil) {
            self.regions = regions
            self.scope = scope
            self.sourceLogsConfiguration = sourceLogsConfiguration
        }

        public func validate(name: String) throws {
            try self.regions.forEach {
                try validate($0, name: "regions[]", parent: name, min: 1)
            }
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
            try self.validate(self.scope, name: "scope", parent: name, max: 2000)
            try self.validate(self.scope, name: "scope", parent: name, min: 1)
            try self.sourceLogsConfiguration?.validate(name: "\(name).sourceLogsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case regions = "Regions"
            case scope = "Scope"
            case sourceLogsConfiguration = "SourceLogsConfiguration"
        }
    }

    public struct CentralizationRuleSummary: AWSDecodableShape {
        /// The Amazon Web Services region where the organization centralization rule was created.
        public let createdRegion: String?
        /// The timestamp when the organization centralization rule was created.
        public let createdTimeStamp: Int64?
        /// The Amazon Web Services Account that created the organization centralization rule.
        public let creatorAccountId: String?
        /// The primary destination account of the organization centralization rule.
        public let destinationAccountId: String?
        /// The primary destination region of the organization centralization rule.
        public let destinationRegion: String?
        /// The reason why an organization centralization rule is marked UNHEALTHY.
        public let failureReason: CentralizationFailureReason?
        /// The timestamp when the organization centralization rule was last updated.
        public let lastUpdateTimeStamp: Int64?
        /// The Amazon Resource Name (ARN) of the organization centralization rule.
        public let ruleArn: String?
        /// The health status of the organization centralization rule.
        public let ruleHealth: RuleHealth?
        /// The name of the organization centralization rule.
        public let ruleName: String?

        @inlinable
        public init(createdRegion: String? = nil, createdTimeStamp: Int64? = nil, creatorAccountId: String? = nil, destinationAccountId: String? = nil, destinationRegion: String? = nil, failureReason: CentralizationFailureReason? = nil, lastUpdateTimeStamp: Int64? = nil, ruleArn: String? = nil, ruleHealth: RuleHealth? = nil, ruleName: String? = nil) {
            self.createdRegion = createdRegion
            self.createdTimeStamp = createdTimeStamp
            self.creatorAccountId = creatorAccountId
            self.destinationAccountId = destinationAccountId
            self.destinationRegion = destinationRegion
            self.failureReason = failureReason
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.ruleArn = ruleArn
            self.ruleHealth = ruleHealth
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case createdRegion = "CreatedRegion"
            case createdTimeStamp = "CreatedTimeStamp"
            case creatorAccountId = "CreatorAccountId"
            case destinationAccountId = "DestinationAccountId"
            case destinationRegion = "DestinationRegion"
            case failureReason = "FailureReason"
            case lastUpdateTimeStamp = "LastUpdateTimeStamp"
            case ruleArn = "RuleArn"
            case ruleHealth = "RuleHealth"
            case ruleName = "RuleName"
        }
    }

    public struct CloudtrailParameters: AWSEncodableShape & AWSDecodableShape {
        ///  The advanced event selectors to use for filtering Amazon Web Services CloudTrail events.
        public let advancedEventSelectors: [AdvancedEventSelector]

        @inlinable
        public init(advancedEventSelectors: [AdvancedEventSelector]) {
            self.advancedEventSelectors = advancedEventSelectors
        }

        private enum CodingKeys: String, CodingKey {
            case advancedEventSelectors = "AdvancedEventSelectors"
        }
    }

    public struct Condition: AWSEncodableShape & AWSDecodableShape {
        ///  Matches log records based on the WAF rule action taken (ALLOW, BLOCK, COUNT, etc.).
        public let actionCondition: ActionCondition?
        ///  Matches log records based on WAF rule labels applied to the request.
        public let labelNameCondition: LabelNameCondition?

        @inlinable
        public init(actionCondition: ActionCondition? = nil, labelNameCondition: LabelNameCondition? = nil) {
            self.actionCondition = actionCondition
            self.labelNameCondition = labelNameCondition
        }

        private enum CodingKeys: String, CodingKey {
            case actionCondition = "ActionCondition"
            case labelNameCondition = "LabelNameCondition"
        }
    }

    public struct ConfigurationSummary: AWSDecodableShape {
        /// The list of data sources that provide telemetry data to the pipeline.
        public let dataSources: [DataSource]?
        /// The total number of processors configured in the pipeline.
        public let processorCount: Int?
        /// The list of processors configured in the pipeline for data transformation.
        public let processors: [String]?
        /// The list of destinations where processed data is sent.
        public let sinks: [String]?
        /// The list of data sources configured in the pipeline.
        public let sources: [Source]?

        @inlinable
        public init(dataSources: [DataSource]? = nil, processorCount: Int? = nil, processors: [String]? = nil, sinks: [String]? = nil, sources: [Source]? = nil) {
            self.dataSources = dataSources
            self.processorCount = processorCount
            self.processors = processors
            self.sinks = sinks
            self.sources = sources
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "DataSources"
            case processorCount = "ProcessorCount"
            case processors = "Processors"
            case sinks = "Sinks"
            case sources = "Sources"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String?
        ///  The identifier of the resource which is in conflict with the requested operation.
        public let resourceId: String?
        ///  The type of the resource which is in conflict with the requested operation.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateCentralizationRuleForOrganizationInput: AWSEncodableShape {
        /// The configuration details for the organization-wide centralization rule, including the source configuration and the destination configuration to centralize telemetry data across the organization.
        public let rule: CentralizationRule
        /// A unique name for the organization-wide centralization rule being created.
        public let ruleName: String
        /// The key-value pairs to associate with the organization telemetry rule resource for categorization and management purposes.
        public let tags: [String: String]?

        @inlinable
        public init(rule: CentralizationRule, ruleName: String, tags: [String: String]? = nil) {
            self.rule = rule
            self.ruleName = ruleName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.rule.validate(name: "\(name).rule")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 100)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[0-9A-Za-z-_.#/]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
            case ruleName = "RuleName"
            case tags = "Tags"
        }
    }

    public struct CreateCentralizationRuleForOrganizationOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created organization centralization rule.
        public let ruleArn: String?

        @inlinable
        public init(ruleArn: String? = nil) {
            self.ruleArn = ruleArn
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
        }
    }

    public struct CreateS3TableIntegrationInput: AWSEncodableShape {
        /// The encryption configuration for the S3 Table integration, including the encryption algorithm and KMS key settings.
        public let encryption: Encryption
        /// The Amazon Resource Name (ARN) of the IAM role that grants permissions for the S3 Table integration to access necessary resources.
        public let roleArn: String
        /// The key-value pairs to associate with the S3 Table integration resource for categorization and management purposes.
        public let tags: [String: String]?

        @inlinable
        public init(encryption: Encryption, roleArn: String, tags: [String: String]? = nil) {
            self.encryption = encryption
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.encryption.validate(name: "\(name).encryption")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1011)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "Encryption"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateS3TableIntegrationOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created S3 Table integration.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct CreateTelemetryPipelineInput: AWSEncodableShape {
        /// The configuration that defines how the telemetry pipeline processes data, including sources, processors, and destinations. For more information about pipeline components, see the Amazon CloudWatch User Guide
        public let configuration: TelemetryPipelineConfiguration
        /// The name of the telemetry pipeline to create. The name must be unique within your account.
        public let name: String
        /// The key-value pairs to associate with the telemetry pipeline resource for categorization and management purposes.
        public let tags: [String: String]?

        @inlinable
        public init(configuration: TelemetryPipelineConfiguration, name: String, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 28)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "[a-z][a-z0-9\\-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateTelemetryPipelineOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created telemetry pipeline.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct CreateTelemetryRuleForOrganizationInput: AWSEncodableShape {
        ///  The configuration details for the organization-wide telemetry rule, including the resource type, telemetry type, destination configuration, and selection criteria for which resources the rule applies to across the organization.
        public let rule: TelemetryRule
        ///  A unique name for the organization-wide telemetry rule being created.
        public let ruleName: String
        ///  The key-value pairs to associate with the organization telemetry rule resource for categorization and management purposes.
        public let tags: [String: String]?

        @inlinable
        public init(rule: TelemetryRule, ruleName: String, tags: [String: String]? = nil) {
            self.rule = rule
            self.ruleName = ruleName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.rule.validate(name: "\(name).rule")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 100)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[0-9A-Za-z-_.#/]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
            case ruleName = "RuleName"
            case tags = "Tags"
        }
    }

    public struct CreateTelemetryRuleForOrganizationOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the created organization telemetry rule.
        public let ruleArn: String?

        @inlinable
        public init(ruleArn: String? = nil) {
            self.ruleArn = ruleArn
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
        }
    }

    public struct CreateTelemetryRuleInput: AWSEncodableShape {
        ///  The configuration details for the telemetry rule, including the resource type, telemetry type, destination configuration, and selection criteria for which resources the rule applies to.
        public let rule: TelemetryRule
        ///  A unique name for the telemetry rule being created.
        public let ruleName: String
        ///  The key-value pairs to associate with the telemetry rule resource for categorization and management purposes.
        public let tags: [String: String]?

        @inlinable
        public init(rule: TelemetryRule, ruleName: String, tags: [String: String]? = nil) {
            self.rule = rule
            self.ruleName = ruleName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.rule.validate(name: "\(name).rule")
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 100)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[0-9A-Za-z-_.#/]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
            case ruleName = "RuleName"
            case tags = "Tags"
        }
    }

    public struct CreateTelemetryRuleOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the created telemetry rule.
        public let ruleArn: String?

        @inlinable
        public init(ruleArn: String? = nil) {
            self.ruleArn = ruleArn
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// The name of the data source. For CloudWatch Logs sources, this corresponds to the data_source_name from the log event metadata. For third-party sources, this is either the configured data_source_name or defaults to the plugin name if not specified.
        public let name: String?
        /// The type of the data source. For CloudWatch Logs sources, this corresponds to the data_source_type from the log event metadata. For third-party sources, this field is empty.
        public let type: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct DeleteCentralizationRuleForOrganizationInput: AWSEncodableShape {
        /// The identifier (name or ARN) of the organization centralization rule to delete.
        public let ruleIdentifier: String

        @inlinable
        public init(ruleIdentifier: String) {
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct DeleteS3TableIntegrationInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the S3 Table integration to delete.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DeleteTelemetryPipelineInput: AWSEncodableShape {
        /// The ARN of the telemetry pipeline to delete.
        public let pipelineIdentifier: String

        @inlinable
        public init(pipelineIdentifier: String) {
            self.pipelineIdentifier = pipelineIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineIdentifier, name: "pipelineIdentifier", parent: name, max: 512)
            try self.validate(self.pipelineIdentifier, name: "pipelineIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineIdentifier = "PipelineIdentifier"
        }
    }

    public struct DeleteTelemetryPipelineOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTelemetryRuleForOrganizationInput: AWSEncodableShape {
        ///  The identifier (name or ARN) of the organization telemetry rule to delete.
        public let ruleIdentifier: String

        @inlinable
        public init(ruleIdentifier: String) {
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct DeleteTelemetryRuleInput: AWSEncodableShape {
        ///  The identifier (name or ARN) of the telemetry rule to delete.
        public let ruleIdentifier: String

        @inlinable
        public init(ruleIdentifier: String) {
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct DestinationLogsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration defining the backup region and an optional KMS key for the backup destination.
        public let backupConfiguration: LogsBackupConfiguration?
        /// The encryption configuration for centralization destination log groups.
        public let logsEncryptionConfiguration: LogsEncryptionConfiguration?

        @inlinable
        public init(backupConfiguration: LogsBackupConfiguration? = nil, logsEncryptionConfiguration: LogsEncryptionConfiguration? = nil) {
            self.backupConfiguration = backupConfiguration
            self.logsEncryptionConfiguration = logsEncryptionConfiguration
        }

        public func validate(name: String) throws {
            try self.backupConfiguration?.validate(name: "\(name).backupConfiguration")
            try self.logsEncryptionConfiguration?.validate(name: "\(name).logsEncryptionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case backupConfiguration = "BackupConfiguration"
            case logsEncryptionConfiguration = "LogsEncryptionConfiguration"
        }
    }

    public struct ELBLoadBalancerLoggingParameters: AWSEncodableShape & AWSDecodableShape {
        ///  The delimiter character used to separate fields in ELB access log entries when using plain text format.
        public let fieldDelimiter: String?
        ///  The format for ELB access log entries (plain text or JSON format).
        public let outputFormat: OutputFormat?

        @inlinable
        public init(fieldDelimiter: String? = nil, outputFormat: OutputFormat? = nil) {
            self.fieldDelimiter = fieldDelimiter
            self.outputFormat = outputFormat
        }

        private enum CodingKeys: String, CodingKey {
            case fieldDelimiter = "FieldDelimiter"
            case outputFormat = "OutputFormat"
        }
    }

    public struct Encryption: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key used for encryption when using customer-managed keys.
        public let kmsKeyArn: String?
        /// The server-side encryption algorithm used for encrypting data in the S3 Table integration.
        public let sseAlgorithm: SSEAlgorithm

        @inlinable
        public init(kmsKeyArn: String? = nil, sseAlgorithm: SSEAlgorithm) {
            self.kmsKeyArn = kmsKeyArn
            self.sseAlgorithm = sseAlgorithm
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 1011)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
            case sseAlgorithm = "SseAlgorithm"
        }
    }

    public struct FieldToMatch: AWSEncodableShape & AWSDecodableShape {
        ///  Redacts the HTTP method from WAF logs.
        public let method: String?
        ///  Redacts the entire query string from WAF logs.
        public let queryString: String?
        ///  Redacts a specific header field by name from WAF logs.
        public let singleHeader: SingleHeader?
        ///  Redacts the URI path from WAF logs.
        public let uriPath: String?

        @inlinable
        public init(method: String? = nil, queryString: String? = nil, singleHeader: SingleHeader? = nil, uriPath: String? = nil) {
            self.method = method
            self.queryString = queryString
            self.singleHeader = singleHeader
            self.uriPath = uriPath
        }

        private enum CodingKeys: String, CodingKey {
            case method = "Method"
            case queryString = "QueryString"
            case singleHeader = "SingleHeader"
            case uriPath = "UriPath"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        ///  The action to take for log records matching this filter (KEEP or DROP).
        public let behavior: FilterBehavior?
        ///  The list of conditions that determine if a log record matches this filter.
        public let conditions: [Condition]?
        ///  Whether the log record must meet all conditions (MEETS_ALL) or any condition (MEETS_ANY) to match this filter.
        public let requirement: FilterRequirement?

        @inlinable
        public init(behavior: FilterBehavior? = nil, conditions: [Condition]? = nil, requirement: FilterRequirement? = nil) {
            self.behavior = behavior
            self.conditions = conditions
            self.requirement = requirement
        }

        public func validate(name: String) throws {
            try self.validate(self.conditions, name: "conditions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case behavior = "Behavior"
            case conditions = "Conditions"
            case requirement = "Requirement"
        }
    }

    public struct GetCentralizationRuleForOrganizationInput: AWSEncodableShape {
        /// The identifier (name or ARN) of the organization centralization rule to retrieve.
        public let ruleIdentifier: String

        @inlinable
        public init(ruleIdentifier: String) {
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct GetCentralizationRuleForOrganizationOutput: AWSDecodableShape {
        /// The configuration details for the organization centralization rule.
        public let centralizationRule: CentralizationRule?
        /// The Amazon Web Services region where the organization centralization rule was created.
        public let createdRegion: String?
        /// The timestamp when the organization centralization rule was created.
        public let createdTimeStamp: Int64?
        /// The Amazon Web Services Account that created the organization centralization rule.
        public let creatorAccountId: String?
        /// The reason why an organization centralization rule is marked UNHEALTHY.
        public let failureReason: CentralizationFailureReason?
        /// The timestamp when the organization centralization rule was last updated.
        public let lastUpdateTimeStamp: Int64?
        /// The Amazon Resource Name (ARN) of the organization centralization rule.
        public let ruleArn: String?
        /// The health status of the organization centralization rule.
        public let ruleHealth: RuleHealth?
        /// The name of the organization centralization rule.
        public let ruleName: String?

        @inlinable
        public init(centralizationRule: CentralizationRule? = nil, createdRegion: String? = nil, createdTimeStamp: Int64? = nil, creatorAccountId: String? = nil, failureReason: CentralizationFailureReason? = nil, lastUpdateTimeStamp: Int64? = nil, ruleArn: String? = nil, ruleHealth: RuleHealth? = nil, ruleName: String? = nil) {
            self.centralizationRule = centralizationRule
            self.createdRegion = createdRegion
            self.createdTimeStamp = createdTimeStamp
            self.creatorAccountId = creatorAccountId
            self.failureReason = failureReason
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.ruleArn = ruleArn
            self.ruleHealth = ruleHealth
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case centralizationRule = "CentralizationRule"
            case createdRegion = "CreatedRegion"
            case createdTimeStamp = "CreatedTimeStamp"
            case creatorAccountId = "CreatorAccountId"
            case failureReason = "FailureReason"
            case lastUpdateTimeStamp = "LastUpdateTimeStamp"
            case ruleArn = "RuleArn"
            case ruleHealth = "RuleHealth"
            case ruleName = "RuleName"
        }
    }

    public struct GetS3TableIntegrationInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the S3 Table integration to retrieve.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct GetS3TableIntegrationOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the S3 Table integration.
        public let arn: String?
        /// The timestamp when the S3 Table integration was created.
        public let createdTimeStamp: Int64?
        /// The Amazon Resource Name (ARN) of the S3 bucket used as the destination for the table data.
        public let destinationTableBucketArn: String?
        /// The encryption configuration for the S3 Table integration.
        public let encryption: Encryption?
        /// The Amazon Resource Name (ARN) of the IAM role used by the S3 Table integration.
        public let roleArn: String?
        /// The current status of the S3 Table integration.
        public let status: IntegrationStatus?

        @inlinable
        public init(arn: String? = nil, createdTimeStamp: Int64? = nil, destinationTableBucketArn: String? = nil, encryption: Encryption? = nil, roleArn: String? = nil, status: IntegrationStatus? = nil) {
            self.arn = arn
            self.createdTimeStamp = createdTimeStamp
            self.destinationTableBucketArn = destinationTableBucketArn
            self.encryption = encryption
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTimeStamp = "CreatedTimeStamp"
            case destinationTableBucketArn = "DestinationTableBucketArn"
            case encryption = "Encryption"
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct GetTelemetryEnrichmentStatusOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the Resource Explorer managed view used for resource tags for telemetry, if the feature is enabled.
        public let awsResourceExplorerManagedViewArn: String?
        ///  The current status of the resource tags for telemetry feature (Running, Stopped, or Impaired).
        public let status: TelemetryEnrichmentStatus?

        @inlinable
        public init(awsResourceExplorerManagedViewArn: String? = nil, status: TelemetryEnrichmentStatus? = nil) {
            self.awsResourceExplorerManagedViewArn = awsResourceExplorerManagedViewArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case awsResourceExplorerManagedViewArn = "AwsResourceExplorerManagedViewArn"
            case status = "Status"
        }
    }

    public struct GetTelemetryEvaluationStatusForOrganizationOutput: AWSDecodableShape {
        ///  This field describes the reason for the failure status. The field will only be populated if Status is FAILED_START or FAILED_STOP.
        public let failureReason: String?
        ///  The onboarding status of the telemetry config feature for the organization.
        public let status: Status?

        @inlinable
        public init(failureReason: String? = nil, status: Status? = nil) {
            self.failureReason = failureReason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case status = "Status"
        }
    }

    public struct GetTelemetryEvaluationStatusOutput: AWSDecodableShape {
        ///  Describes the reason for the failure status. The field will only be populated if Status is FAILED_START or FAILED_STOP.
        public let failureReason: String?
        ///  The onboarding status of the telemetry config feature.
        public let status: Status?

        @inlinable
        public init(failureReason: String? = nil, status: Status? = nil) {
            self.failureReason = failureReason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case status = "Status"
        }
    }

    public struct GetTelemetryPipelineInput: AWSEncodableShape {
        /// The identifier (name or ARN) of the telemetry pipeline to retrieve.
        public let pipelineIdentifier: String

        @inlinable
        public init(pipelineIdentifier: String) {
            self.pipelineIdentifier = pipelineIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineIdentifier, name: "pipelineIdentifier", parent: name, max: 512)
            try self.validate(self.pipelineIdentifier, name: "pipelineIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineIdentifier = "PipelineIdentifier"
        }
    }

    public struct GetTelemetryPipelineOutput: AWSDecodableShape {
        /// The complete telemetry pipeline resource information, including configuration, status, and metadata.
        public let pipeline: TelemetryPipeline?

        @inlinable
        public init(pipeline: TelemetryPipeline? = nil) {
            self.pipeline = pipeline
        }

        private enum CodingKeys: String, CodingKey {
            case pipeline = "Pipeline"
        }
    }

    public struct GetTelemetryRuleForOrganizationInput: AWSEncodableShape {
        ///  The identifier (name or ARN) of the organization telemetry rule to retrieve.
        public let ruleIdentifier: String

        @inlinable
        public init(ruleIdentifier: String) {
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct GetTelemetryRuleForOrganizationOutput: AWSDecodableShape {
        ///  The timestamp when the organization telemetry rule was created.
        public let createdTimeStamp: Int64?
        ///  The timestamp when the organization telemetry rule was last updated.
        public let lastUpdateTimeStamp: Int64?
        ///  The Amazon Resource Name (ARN) of the organization telemetry rule.
        public let ruleArn: String?
        ///  The name of the organization telemetry rule.
        public let ruleName: String?
        ///  The configuration details of the organization telemetry rule.
        public let telemetryRule: TelemetryRule?

        @inlinable
        public init(createdTimeStamp: Int64? = nil, lastUpdateTimeStamp: Int64? = nil, ruleArn: String? = nil, ruleName: String? = nil, telemetryRule: TelemetryRule? = nil) {
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.telemetryRule = telemetryRule
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimeStamp = "CreatedTimeStamp"
            case lastUpdateTimeStamp = "LastUpdateTimeStamp"
            case ruleArn = "RuleArn"
            case ruleName = "RuleName"
            case telemetryRule = "TelemetryRule"
        }
    }

    public struct GetTelemetryRuleInput: AWSEncodableShape {
        ///  The identifier (name or ARN) of the telemetry rule to retrieve.
        public let ruleIdentifier: String

        @inlinable
        public init(ruleIdentifier: String) {
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct GetTelemetryRuleOutput: AWSDecodableShape {
        ///  The timestamp when the telemetry rule was created.
        public let createdTimeStamp: Int64?
        ///  The timestamp when the telemetry rule was last updated.
        public let lastUpdateTimeStamp: Int64?
        ///  The Amazon Resource Name (ARN) of the telemetry rule.
        public let ruleArn: String?
        ///  The name of the telemetry rule.
        public let ruleName: String?
        ///  The configuration details of the telemetry rule.
        public let telemetryRule: TelemetryRule?

        @inlinable
        public init(createdTimeStamp: Int64? = nil, lastUpdateTimeStamp: Int64? = nil, ruleArn: String? = nil, ruleName: String? = nil, telemetryRule: TelemetryRule? = nil) {
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.telemetryRule = telemetryRule
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimeStamp = "CreatedTimeStamp"
            case lastUpdateTimeStamp = "LastUpdateTimeStamp"
            case ruleArn = "RuleArn"
            case ruleName = "RuleName"
            case telemetryRule = "TelemetryRule"
        }
    }

    public struct IntegrationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the S3 Table integration.
        public let arn: String?
        /// The current status of the S3 Table integration.
        public let status: IntegrationStatus?

        @inlinable
        public init(arn: String? = nil, status: IntegrationStatus? = nil) {
            self.arn = arn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case status = "Status"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        ///  The name of the exception.
        public let amznErrorType: String?
        public let message: String?
        /// The number of seconds to wait before retrying the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(amznErrorType: String? = nil, message: String? = nil, retryAfterSeconds: Int? = nil) {
            self.amznErrorType = amznErrorType
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.amznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct LabelNameCondition: AWSEncodableShape & AWSDecodableShape {
        ///  The label name to match, supporting alphanumeric characters, underscores, hyphens, and colons.
        public let labelName: String?

        @inlinable
        public init(labelName: String? = nil) {
            self.labelName = labelName
        }

        private enum CodingKeys: String, CodingKey {
            case labelName = "LabelName"
        }
    }

    public struct ListCentralizationRulesForOrganizationInput: AWSEncodableShape {
        /// A flag determining whether to return organization centralization rules from all regions or only the current region.
        public let allRegions: Bool?
        /// The maximum number of organization centralization rules to return in a single call.
        public let maxResults: Int?
        /// The token for the next set of results. A previous call generates this token.
        public let nextToken: String?
        /// A string to filter organization centralization rules whose names begin with the specified prefix.
        public let ruleNamePrefix: String?

        @inlinable
        public init(allRegions: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, ruleNamePrefix: String? = nil) {
            self.allRegions = allRegions
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ruleNamePrefix = ruleNamePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allRegions = "AllRegions"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case ruleNamePrefix = "RuleNamePrefix"
        }
    }

    public struct ListCentralizationRulesForOrganizationOutput: AWSDecodableShape {
        /// A list of centralization rule summaries.
        public let centralizationRuleSummaries: [CentralizationRuleSummary]?
        /// A token to resume pagination of results.
        public let nextToken: String?

        @inlinable
        public init(centralizationRuleSummaries: [CentralizationRuleSummary]? = nil, nextToken: String? = nil) {
            self.centralizationRuleSummaries = centralizationRuleSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case centralizationRuleSummaries = "CentralizationRuleSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListResourceTelemetryForOrganizationInput: AWSEncodableShape {
        ///  A list of Amazon Web Services accounts used to filter the resources to those associated with the specified accounts.
        public let accountIdentifiers: [String]?
        ///  A number field used to limit the number of results within the returned list.
        public let maxResults: Int?
        ///  The token for the next set of items to return. A previous call provides this token.
        public let nextToken: String?
        ///  A string used to filter resources in the organization which have a ResourceIdentifier starting with the ResourceIdentifierPrefix.
        public let resourceIdentifierPrefix: String?
        ///  A key-value pair to filter resources in the organization based on tags associated with the resource. Fore more information about tags, see What are tags?
        public let resourceTags: [String: String]?
        ///  A list of resource types used to filter resources in the organization. If this parameter is provided, the resources will be returned in the same order used in the request.
        public let resourceTypes: [ResourceType]?
        ///  A key-value pair to filter resources in the organization based on the telemetry type and the state of the telemetry configuration. The key is the telemetry type and the value is the state.
        public let telemetryConfigurationState: [TelemetryType: TelemetryState]?

        @inlinable
        public init(accountIdentifiers: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceIdentifierPrefix: String? = nil, resourceTags: [String: String]? = nil, resourceTypes: [ResourceType]? = nil, telemetryConfigurationState: [TelemetryType: TelemetryState]? = nil) {
            self.accountIdentifiers = accountIdentifiers
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceIdentifierPrefix = resourceIdentifierPrefix
            self.resourceTags = resourceTags
            self.resourceTypes = resourceTypes
            self.telemetryConfigurationState = telemetryConfigurationState
        }

        public func validate(name: String) throws {
            try self.accountIdentifiers?.forEach {
                try validate($0, name: "accountIdentifiers[]", parent: name, max: 12)
                try validate($0, name: "accountIdentifiers[]", parent: name, min: 12)
                try validate($0, name: "accountIdentifiers[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.accountIdentifiers, name: "accountIdentifiers", parent: name, max: 10)
            try self.validate(self.accountIdentifiers, name: "accountIdentifiers", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceIdentifierPrefix, name: "resourceIdentifierPrefix", parent: name, max: 768)
            try self.validate(self.resourceIdentifierPrefix, name: "resourceIdentifierPrefix", parent: name, min: 3)
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 50)
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, min: 1)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 9)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIdentifiers = "AccountIdentifiers"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceIdentifierPrefix = "ResourceIdentifierPrefix"
            case resourceTags = "ResourceTags"
            case resourceTypes = "ResourceTypes"
            case telemetryConfigurationState = "TelemetryConfigurationState"
        }
    }

    public struct ListResourceTelemetryForOrganizationOutput: AWSDecodableShape {
        ///  The token for the next set of items to return. A previous call provides this token.
        public let nextToken: String?
        ///  A list of telemetry configurations for Amazon Web Services resources supported by telemetry config in the organization.
        public let telemetryConfigurations: [TelemetryConfiguration]?

        @inlinable
        public init(nextToken: String? = nil, telemetryConfigurations: [TelemetryConfiguration]? = nil) {
            self.nextToken = nextToken
            self.telemetryConfigurations = telemetryConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case telemetryConfigurations = "TelemetryConfigurations"
        }
    }

    public struct ListResourceTelemetryInput: AWSEncodableShape {
        ///  A number field used to limit the number of results within the returned list.
        public let maxResults: Int?
        ///  The token for the next set of items to return. A previous call generates this token.
        public let nextToken: String?
        ///  A string used to filter resources which have a ResourceIdentifier starting with the ResourceIdentifierPrefix.
        public let resourceIdentifierPrefix: String?
        ///  A key-value pair to filter resources based on tags associated with the resource. For more information about tags, see What are tags?
        public let resourceTags: [String: String]?
        ///  A list of resource types used to filter resources supported by telemetry config. If this parameter is provided, the resources will be returned in the same order used in the request.
        public let resourceTypes: [ResourceType]?
        ///  A key-value pair to filter resources based on the telemetry type and the state of the telemetry configuration. The key is the telemetry type and the value is the state.
        public let telemetryConfigurationState: [TelemetryType: TelemetryState]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceIdentifierPrefix: String? = nil, resourceTags: [String: String]? = nil, resourceTypes: [ResourceType]? = nil, telemetryConfigurationState: [TelemetryType: TelemetryState]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceIdentifierPrefix = resourceIdentifierPrefix
            self.resourceTags = resourceTags
            self.resourceTypes = resourceTypes
            self.telemetryConfigurationState = telemetryConfigurationState
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceIdentifierPrefix, name: "resourceIdentifierPrefix", parent: name, max: 768)
            try self.validate(self.resourceIdentifierPrefix, name: "resourceIdentifierPrefix", parent: name, min: 3)
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 50)
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, min: 1)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 9)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceIdentifierPrefix = "ResourceIdentifierPrefix"
            case resourceTags = "ResourceTags"
            case resourceTypes = "ResourceTypes"
            case telemetryConfigurationState = "TelemetryConfigurationState"
        }
    }

    public struct ListResourceTelemetryOutput: AWSDecodableShape {
        ///  The token for the next set of items to return. A previous call generates this token.
        public let nextToken: String?
        ///  A list of telemetry configurations for Amazon Web Services resources supported by telemetry config in the caller's account.
        public let telemetryConfigurations: [TelemetryConfiguration]?

        @inlinable
        public init(nextToken: String? = nil, telemetryConfigurations: [TelemetryConfiguration]? = nil) {
            self.nextToken = nextToken
            self.telemetryConfigurations = telemetryConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case telemetryConfigurations = "TelemetryConfigurations"
        }
    }

    public struct ListS3TableIntegrationsInput: AWSEncodableShape {
        /// The maximum number of S3 Table integrations to return in a single call.
        public let maxResults: Int?
        /// The token for the next set of results. A previous call generates this token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListS3TableIntegrationsOutput: AWSDecodableShape {
        /// A list of S3 Table integration summaries containing key information about each integration.
        public let integrationSummaries: [IntegrationSummary]?
        /// A token to resume pagination of results.
        public let nextToken: String?

        @inlinable
        public init(integrationSummaries: [IntegrationSummary]? = nil, nextToken: String? = nil) {
            self.integrationSummaries = integrationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case integrationSummaries = "IntegrationSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the telemetry rule resource whose tags you want to list.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        ///  The list of tags associated with the telemetry rule resource.
        public let tags: [String: String]

        @inlinable
        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTelemetryPipelinesInput: AWSEncodableShape {
        /// The maximum number of telemetry pipelines to return in a single call.
        public let maxResults: Int?
        /// The token for the next set of results. A previous call generates this token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTelemetryPipelinesOutput: AWSDecodableShape {
        /// A token to resume pagination of results.
        public let nextToken: String?
        /// A list of telemetry pipeline summaries containing key information about each pipeline.
        public let pipelineSummaries: [TelemetryPipelineSummary]?

        @inlinable
        public init(nextToken: String? = nil, pipelineSummaries: [TelemetryPipelineSummary]? = nil) {
            self.nextToken = nextToken
            self.pipelineSummaries = pipelineSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pipelineSummaries = "PipelineSummaries"
        }
    }

    public struct ListTelemetryRulesForOrganizationInput: AWSEncodableShape {
        ///  The maximum number of organization telemetry rules to return in a single call.
        public let maxResults: Int?
        ///  The token for the next set of results. A previous call generates this token.
        public let nextToken: String?
        ///  A string to filter organization telemetry rules whose names begin with the specified prefix.
        public let ruleNamePrefix: String?
        ///  The list of account IDs to filter organization telemetry rules by their source accounts.
        public let sourceAccountIds: [String]?
        ///  The list of organizational unit IDs to filter organization telemetry rules by their source organizational units.
        public let sourceOrganizationUnitIds: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, ruleNamePrefix: String? = nil, sourceAccountIds: [String]? = nil, sourceOrganizationUnitIds: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ruleNamePrefix = ruleNamePrefix
            self.sourceAccountIds = sourceAccountIds
            self.sourceOrganizationUnitIds = sourceOrganizationUnitIds
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.sourceAccountIds?.forEach {
                try validate($0, name: "sourceAccountIds[]", parent: name, max: 12)
                try validate($0, name: "sourceAccountIds[]", parent: name, min: 12)
                try validate($0, name: "sourceAccountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.sourceAccountIds, name: "sourceAccountIds", parent: name, max: 10)
            try self.validate(self.sourceAccountIds, name: "sourceAccountIds", parent: name, min: 1)
            try self.sourceOrganizationUnitIds?.forEach {
                try validate($0, name: "sourceOrganizationUnitIds[]", parent: name, pattern: "^ou-[0-9a-z]{4,32}-[a-z0-9]{8,32}$")
            }
            try self.validate(self.sourceOrganizationUnitIds, name: "sourceOrganizationUnitIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case ruleNamePrefix = "RuleNamePrefix"
            case sourceAccountIds = "SourceAccountIds"
            case sourceOrganizationUnitIds = "SourceOrganizationUnitIds"
        }
    }

    public struct ListTelemetryRulesForOrganizationOutput: AWSDecodableShape {
        ///  A token to resume pagination of results.
        public let nextToken: String?
        ///  A list of organization telemetry rule summaries.
        public let telemetryRuleSummaries: [TelemetryRuleSummary]?

        @inlinable
        public init(nextToken: String? = nil, telemetryRuleSummaries: [TelemetryRuleSummary]? = nil) {
            self.nextToken = nextToken
            self.telemetryRuleSummaries = telemetryRuleSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case telemetryRuleSummaries = "TelemetryRuleSummaries"
        }
    }

    public struct ListTelemetryRulesInput: AWSEncodableShape {
        ///  The maximum number of telemetry rules to return in a single call.
        public let maxResults: Int?
        ///  The token for the next set of results. A previous call generates this token.
        public let nextToken: String?
        ///  A string to filter telemetry rules whose names begin with the specified prefix.
        public let ruleNamePrefix: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, ruleNamePrefix: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ruleNamePrefix = ruleNamePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case ruleNamePrefix = "RuleNamePrefix"
        }
    }

    public struct ListTelemetryRulesOutput: AWSDecodableShape {
        ///  A token to resume pagination of results.
        public let nextToken: String?
        ///  A list of telemetry rule summaries.
        public let telemetryRuleSummaries: [TelemetryRuleSummary]?

        @inlinable
        public init(nextToken: String? = nil, telemetryRuleSummaries: [TelemetryRuleSummary]? = nil) {
            self.nextToken = nextToken
            self.telemetryRuleSummaries = telemetryRuleSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case telemetryRuleSummaries = "TelemetryRuleSummaries"
        }
    }

    public struct LogDeliveryParameters: AWSEncodableShape & AWSDecodableShape {
        /// The type of log that the source is sending.
        public let logTypes: [LogType]?

        @inlinable
        public init(logTypes: [LogType]? = nil) {
            self.logTypes = logTypes
        }

        private enum CodingKeys: String, CodingKey {
            case logTypes = "LogTypes"
        }
    }

    public struct LoggingFilter: AWSEncodableShape & AWSDecodableShape {
        ///  The default action (KEEP or DROP) for log records that don't match any filter conditions.
        public let defaultBehavior: FilterBehavior?
        ///  A list of filter conditions that determine log record handling behavior.
        public let filters: [Filter]?

        @inlinable
        public init(defaultBehavior: FilterBehavior? = nil, filters: [Filter]? = nil) {
            self.defaultBehavior = defaultBehavior
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultBehavior = "DefaultBehavior"
            case filters = "Filters"
        }
    }

    public struct LogsBackupConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// KMS Key ARN belonging to the primary destination account and backup region, to encrypt newly created central log groups in the backup destination.
        public let kmsKeyArn: String?
        /// Logs specific backup destination region within the primary destination account to which log data should be centralized.
        public let region: String

        @inlinable
        public init(kmsKeyArn: String? = nil, region: String) {
            self.kmsKeyArn = kmsKeyArn
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 1011)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
            try self.validate(self.region, name: "region", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
            case region = "Region"
        }
    }

    public struct LogsEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Conflict resolution strategy for centralization if the encryption strategy is set to CUSTOMER_MANAGED and the destination log group is encrypted with an AWS_OWNED KMS Key. ALLOW lets centralization go through while SKIP prevents centralization into the destination log group.
        public let encryptionConflictResolutionStrategy: EncryptionConflictResolutionStrategy?
        /// Configuration that determines the encryption strategy of the destination log groups. CUSTOMER_MANAGED uses the configured KmsKeyArn to encrypt newly created destination log groups.
        public let encryptionStrategy: EncryptionStrategy
        /// KMS Key ARN belonging to the primary destination account and region, to encrypt newly created central log groups in the primary destination.
        public let kmsKeyArn: String?

        @inlinable
        public init(encryptionConflictResolutionStrategy: EncryptionConflictResolutionStrategy? = nil, encryptionStrategy: EncryptionStrategy, kmsKeyArn: String? = nil) {
            self.encryptionConflictResolutionStrategy = encryptionConflictResolutionStrategy
            self.encryptionStrategy = encryptionStrategy
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 1011)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConflictResolutionStrategy = "EncryptionConflictResolutionStrategy"
            case encryptionStrategy = "EncryptionStrategy"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct PipelineOutput: AWSDecodableShape {
        /// Any error that occurred during the pipeline test operation for this record.
        public let error: PipelineOutputError?
        /// The processed record output from the pipeline test operation.
        public let record: Record?

        @inlinable
        public init(error: PipelineOutputError? = nil, record: Record? = nil) {
            self.error = error
            self.record = record
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case record = "Record"
        }
    }

    public struct PipelineOutputError: AWSDecodableShape {
        /// The detailed error message describing what went wrong during the pipeline test operation for this record.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct Record: AWSEncodableShape & AWSDecodableShape {
        /// The data content of the test record used for pipeline validation.
        public let data: String?
        /// The type of the test record, indicating the format or category of the data.
        public let type: RecordFormat?

        @inlinable
        public init(data: String? = nil, type: RecordFormat? = nil) {
            self.data = data
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
            case type = "Type"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        ///  The identifier of the resource which could not be found.
        public let resourceId: String?
        ///  The type of the resource which could not be found.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        ///  The name of the exception.
        public let amznErrorType: String?
        public let message: String?
        ///  The code for the exceeded service quota.
        public let quotaCode: String?
        ///  The identifier of the resource which exceeds the service quota.
        public let resourceId: String?
        ///  The type of the resource which exceeds the service quota.
        public let resourceType: String?
        ///  The code for the service of the exceeded quota.
        public let serviceCode: String?

        @inlinable
        public init(amznErrorType: String? = nil, message: String? = nil, quotaCode: String? = nil, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String? = nil) {
            self.amznErrorType = amznErrorType
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.amznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.resourceId = try container.decodeIfPresent(String.self, forKey: .resourceId)
            self.resourceType = try container.decodeIfPresent(String.self, forKey: .resourceType)
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case serviceCode = "ServiceCode"
        }
    }

    public struct SingleHeader: AWSEncodableShape & AWSDecodableShape {
        ///  The name value, limited to 64 characters.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Source: AWSDecodableShape {
        /// The plugin name of the source, such as cloudwatch_logs or s3.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct SourceLogsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A strategy determining whether to centralize source log groups that are encrypted with customer managed KMS keys (CMK). ALLOW will consider CMK encrypted source log groups for centralization while SKIP will skip CMK encrypted source log groups from centralization.
        public let encryptedLogGroupStrategy: EncryptedLogGroupStrategy
        /// The selection criteria that specifies which source log groups to centralize. The selection criteria uses the same format as OAM link filters.
        public let logGroupSelectionCriteria: String

        @inlinable
        public init(encryptedLogGroupStrategy: EncryptedLogGroupStrategy, logGroupSelectionCriteria: String) {
            self.encryptedLogGroupStrategy = encryptedLogGroupStrategy
            self.logGroupSelectionCriteria = logGroupSelectionCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroupSelectionCriteria, name: "logGroupSelectionCriteria", parent: name, max: 2000)
            try self.validate(self.logGroupSelectionCriteria, name: "logGroupSelectionCriteria", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptedLogGroupStrategy = "EncryptedLogGroupStrategy"
            case logGroupSelectionCriteria = "LogGroupSelectionCriteria"
        }
    }

    public struct StartTelemetryEnrichmentOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the Resource Explorer managed view created for resource tags for telemetry.
        public let awsResourceExplorerManagedViewArn: String?
        ///  The status of the resource tags for telemetry feature after the start operation (Running, Stopped, or Impaired).
        public let status: TelemetryEnrichmentStatus?

        @inlinable
        public init(awsResourceExplorerManagedViewArn: String? = nil, status: TelemetryEnrichmentStatus? = nil) {
            self.awsResourceExplorerManagedViewArn = awsResourceExplorerManagedViewArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case awsResourceExplorerManagedViewArn = "AwsResourceExplorerManagedViewArn"
            case status = "Status"
        }
    }

    public struct StopTelemetryEnrichmentOutput: AWSDecodableShape {
        ///  The status of the resource tags for telemetry feature after the stop operation (Running, Stopped, or Impaired).
        public let status: TelemetryEnrichmentStatus?

        @inlinable
        public init(status: TelemetryEnrichmentStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the telemetry rule resource to tag.
        public let resourceARN: String
        ///  The key-value pairs to add or update for the telemetry rule resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceARN: String, tags: [String: String]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TelemetryConfiguration: AWSDecodableShape {
        ///  The account ID which contains the resource managed in telemetry configuration. An example of a valid account ID is 012345678901.
        public let accountIdentifier: String?
        ///  The timestamp of the last change to the telemetry configuration for the resource. For example, 1728679196318.
        public let lastUpdateTimeStamp: Int64?
        ///  The identifier of the resource, for example for Amazon VPC, it would be vpc-1a2b3c4d5e6f1a2b3.
        public let resourceIdentifier: String?
        ///  Tags associated with the resource, for example { Name: "ExampleInstance", Environment: "Development" }.
        public let resourceTags: [String: String]?
        ///  The type of resource, for example Amazon Web Services::EC2::Instance, or Amazon Web Services::EKS::Cluster, etc.
        public let resourceType: ResourceType?
        ///  The configuration state for the resource, for example { Logs: NotApplicable; Metrics: Enabled; Traces: NotApplicable; }.
        public let telemetryConfigurationState: [TelemetryType: TelemetryState]?

        @inlinable
        public init(accountIdentifier: String? = nil, lastUpdateTimeStamp: Int64? = nil, resourceIdentifier: String? = nil, resourceTags: [String: String]? = nil, resourceType: ResourceType? = nil, telemetryConfigurationState: [TelemetryType: TelemetryState]? = nil) {
            self.accountIdentifier = accountIdentifier
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.resourceIdentifier = resourceIdentifier
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.telemetryConfigurationState = telemetryConfigurationState
        }

        private enum CodingKeys: String, CodingKey {
            case accountIdentifier = "AccountIdentifier"
            case lastUpdateTimeStamp = "LastUpdateTimeStamp"
            case resourceIdentifier = "ResourceIdentifier"
            case resourceTags = "ResourceTags"
            case resourceType = "ResourceType"
            case telemetryConfigurationState = "TelemetryConfigurationState"
        }
    }

    public struct TelemetryDestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Configuration parameters specific to Amazon Web Services CloudTrail when CloudTrail is the source type.
        public let cloudtrailParameters: CloudtrailParameters?
        ///  The pattern used to generate the destination path or name, supporting macros like &lt;resourceId&gt; and &lt;accountId&gt;.
        public let destinationPattern: String?
        ///  The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        public let destinationType: DestinationType?
        ///  Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        public let elbLoadBalancerLoggingParameters: ELBLoadBalancerLoggingParameters?
        /// Configuration parameters specific to Amazon Bedrock AgentCore logging when Amazon Bedrock AgentCore is the resource type.
        public let logDeliveryParameters: LogDeliveryParameters?
        ///  The number of days to retain the telemetry data in the destination.
        public let retentionInDays: Int?
        ///  Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        public let vpcFlowLogParameters: VPCFlowLogParameters?
        ///  Configuration parameters specific to WAF logging when WAF is the resource type.
        public let wafLoggingParameters: WAFLoggingParameters?

        @inlinable
        public init(cloudtrailParameters: CloudtrailParameters? = nil, destinationPattern: String? = nil, destinationType: DestinationType? = nil, elbLoadBalancerLoggingParameters: ELBLoadBalancerLoggingParameters? = nil, logDeliveryParameters: LogDeliveryParameters? = nil, retentionInDays: Int? = nil, vpcFlowLogParameters: VPCFlowLogParameters? = nil, wafLoggingParameters: WAFLoggingParameters? = nil) {
            self.cloudtrailParameters = cloudtrailParameters
            self.destinationPattern = destinationPattern
            self.destinationType = destinationType
            self.elbLoadBalancerLoggingParameters = elbLoadBalancerLoggingParameters
            self.logDeliveryParameters = logDeliveryParameters
            self.retentionInDays = retentionInDays
            self.vpcFlowLogParameters = vpcFlowLogParameters
            self.wafLoggingParameters = wafLoggingParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.retentionInDays, name: "retentionInDays", parent: name, max: 3653)
            try self.validate(self.retentionInDays, name: "retentionInDays", parent: name, min: 1)
            try self.wafLoggingParameters?.validate(name: "\(name).wafLoggingParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudtrailParameters = "CloudtrailParameters"
            case destinationPattern = "DestinationPattern"
            case destinationType = "DestinationType"
            case elbLoadBalancerLoggingParameters = "ELBLoadBalancerLoggingParameters"
            case logDeliveryParameters = "LogDeliveryParameters"
            case retentionInDays = "RetentionInDays"
            case vpcFlowLogParameters = "VPCFlowLogParameters"
            case wafLoggingParameters = "WAFLoggingParameters"
        }
    }

    public struct TelemetryPipeline: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the telemetry pipeline.
        public let arn: String?
        /// The configuration that defines how the telemetry pipeline processes data.
        public let configuration: TelemetryPipelineConfiguration?
        /// The timestamp when the telemetry pipeline was created.
        public let createdTimeStamp: Int64?
        /// The timestamp when the telemetry pipeline was last updated.
        public let lastUpdateTimeStamp: Int64?
        /// The name of the telemetry pipeline.
        public let name: String?
        /// The current status of the telemetry pipeline.
        public let status: TelemetryPipelineStatus?
        /// Additional information about the pipeline status, including reasons for failure states.
        public let statusReason: TelemetryPipelineStatusReason?
        /// The key-value pairs associated with the telemetry pipeline resource.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, configuration: TelemetryPipelineConfiguration? = nil, createdTimeStamp: Int64? = nil, lastUpdateTimeStamp: Int64? = nil, name: String? = nil, status: TelemetryPipelineStatus? = nil, statusReason: TelemetryPipelineStatusReason? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.configuration = configuration
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case configuration = "Configuration"
            case createdTimeStamp = "CreatedTimeStamp"
            case lastUpdateTimeStamp = "LastUpdateTimeStamp"
            case name = "Name"
            case status = "Status"
            case statusReason = "StatusReason"
            case tags = "Tags"
        }
    }

    public struct TelemetryPipelineConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The pipeline configuration body that defines the data processing rules and transformations.
        public let body: String

        @inlinable
        public init(body: String) {
            self.body = body
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 24000)
            try self.validate(self.body, name: "body", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
        }
    }

    public struct TelemetryPipelineStatusReason: AWSDecodableShape {
        /// A description of the pipeline status reason, providing additional context about the current state.
        public let description: String?

        @inlinable
        public init(description: String? = nil) {
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct TelemetryPipelineSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the telemetry pipeline.
        public let arn: String?
        /// A summary of the pipeline configuration components.
        public let configurationSummary: ConfigurationSummary?
        /// The timestamp when the telemetry pipeline was created.
        public let createdTimeStamp: Int64?
        /// The timestamp when the telemetry pipeline was last updated.
        public let lastUpdateTimeStamp: Int64?
        /// The name of the telemetry pipeline.
        public let name: String?
        /// The current status of the telemetry pipeline.
        public let status: TelemetryPipelineStatus?
        /// The key-value pairs associated with the telemetry pipeline resource.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, configurationSummary: ConfigurationSummary? = nil, createdTimeStamp: Int64? = nil, lastUpdateTimeStamp: Int64? = nil, name: String? = nil, status: TelemetryPipelineStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.configurationSummary = configurationSummary
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case configurationSummary = "ConfigurationSummary"
            case createdTimeStamp = "CreatedTimeStamp"
            case lastUpdateTimeStamp = "LastUpdateTimeStamp"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct TelemetryRule: AWSEncodableShape & AWSDecodableShape {
        ///  Configuration specifying where and how the telemetry data should be delivered.
        public let destinationConfiguration: TelemetryDestinationConfiguration?
        ///  The type of Amazon Web Services resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        public let resourceType: ResourceType?
        ///  The organizational scope to which the rule applies, specified using accounts or organizational units.
        public let scope: String?
        ///  Criteria for selecting which resources the rule applies to, such as resource tags.
        public let selectionCriteria: String?
        ///  The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        public let telemetrySourceTypes: [TelemetrySourceType]?
        ///  The type of telemetry to collect (Logs, Metrics, or Traces).
        public let telemetryType: TelemetryType

        @inlinable
        public init(destinationConfiguration: TelemetryDestinationConfiguration? = nil, resourceType: ResourceType? = nil, scope: String? = nil, selectionCriteria: String? = nil, telemetrySourceTypes: [TelemetrySourceType]? = nil, telemetryType: TelemetryType) {
            self.destinationConfiguration = destinationConfiguration
            self.resourceType = resourceType
            self.scope = scope
            self.selectionCriteria = selectionCriteria
            self.telemetrySourceTypes = telemetrySourceTypes
            self.telemetryType = telemetryType
        }

        public func validate(name: String) throws {
            try self.destinationConfiguration?.validate(name: "\(name).destinationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfiguration = "DestinationConfiguration"
            case resourceType = "ResourceType"
            case scope = "Scope"
            case selectionCriteria = "SelectionCriteria"
            case telemetrySourceTypes = "TelemetrySourceTypes"
            case telemetryType = "TelemetryType"
        }
    }

    public struct TelemetryRuleSummary: AWSDecodableShape {
        ///  The timestamp when the telemetry rule was created.
        public let createdTimeStamp: Int64?
        ///  The timestamp when the telemetry rule was last modified.
        public let lastUpdateTimeStamp: Int64?
        ///  The type of Amazon Web Services resource the rule applies to.
        public let resourceType: ResourceType?
        ///  The Amazon Resource Name (ARN) of the telemetry rule.
        public let ruleArn: String?
        ///  The name of the telemetry rule.
        public let ruleName: String?
        ///  The types of telemetry sources configured for this rule, such as VPC Flow Logs or EKS audit logs. TelemetrySourceTypes must be correlated with the specific resource type.
        public let telemetrySourceTypes: [TelemetrySourceType]?
        ///  The type of telemetry (Logs, Metrics, or Traces) the rule configures.
        public let telemetryType: TelemetryType?

        @inlinable
        public init(createdTimeStamp: Int64? = nil, lastUpdateTimeStamp: Int64? = nil, resourceType: ResourceType? = nil, ruleArn: String? = nil, ruleName: String? = nil, telemetrySourceTypes: [TelemetrySourceType]? = nil, telemetryType: TelemetryType? = nil) {
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.resourceType = resourceType
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.telemetrySourceTypes = telemetrySourceTypes
            self.telemetryType = telemetryType
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimeStamp = "CreatedTimeStamp"
            case lastUpdateTimeStamp = "LastUpdateTimeStamp"
            case resourceType = "ResourceType"
            case ruleArn = "RuleArn"
            case ruleName = "RuleName"
            case telemetrySourceTypes = "TelemetrySourceTypes"
            case telemetryType = "TelemetryType"
        }
    }

    public struct TestTelemetryPipelineInput: AWSEncodableShape {
        /// The pipeline configuration to test with the provided sample records.
        public let configuration: TelemetryPipelineConfiguration
        /// The sample records to process through the pipeline configuration for testing purposes.
        public let records: [Record]

        @inlinable
        public init(configuration: TelemetryPipelineConfiguration, records: [Record]) {
            self.configuration = configuration
            self.records = records
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case records = "Records"
        }
    }

    public struct TestTelemetryPipelineOutput: AWSDecodableShape {
        /// The results of processing the test records through the pipeline configuration, including any outputs or errors.
        public let results: [PipelineOutput]?

        @inlinable
        public init(results: [PipelineOutput]? = nil) {
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the telemetry rule resource to remove tags from.
        public let resourceARN: String
        ///  The list of tag keys to remove from the telemetry rule resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws([a-z0-9\\-]+)?:([a-zA-Z0-9\\-]+):([a-z0-9\\-]+)?:([0-9]{12})?:(.+)$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UpdateCentralizationRuleForOrganizationInput: AWSEncodableShape {
        /// The configuration details for the organization-wide centralization rule, including the source configuration and the destination configuration to centralize telemetry data across the organization.
        public let rule: CentralizationRule
        /// The identifier (name or ARN) of the organization centralization rule to update.
        public let ruleIdentifier: String

        @inlinable
        public init(rule: CentralizationRule, ruleIdentifier: String) {
            self.rule = rule
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.rule.validate(name: "\(name).rule")
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct UpdateCentralizationRuleForOrganizationOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated organization centralization rule.
        public let ruleArn: String?

        @inlinable
        public init(ruleArn: String? = nil) {
            self.ruleArn = ruleArn
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
        }
    }

    public struct UpdateTelemetryPipelineInput: AWSEncodableShape {
        /// The new configuration for the telemetry pipeline, including updated sources, processors, and destinations.
        public let configuration: TelemetryPipelineConfiguration
        /// The ARN of the telemetry pipeline to update.
        public let pipelineIdentifier: String

        @inlinable
        public init(configuration: TelemetryPipelineConfiguration, pipelineIdentifier: String) {
            self.configuration = configuration
            self.pipelineIdentifier = pipelineIdentifier
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.pipelineIdentifier, name: "pipelineIdentifier", parent: name, max: 512)
            try self.validate(self.pipelineIdentifier, name: "pipelineIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case pipelineIdentifier = "PipelineIdentifier"
        }
    }

    public struct UpdateTelemetryPipelineOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTelemetryRuleForOrganizationInput: AWSEncodableShape {
        ///  The new configuration details for the organization telemetry rule, including resource type, telemetry type, and destination configuration.
        public let rule: TelemetryRule
        ///  The identifier (name or ARN) of the organization telemetry rule to update.
        public let ruleIdentifier: String

        @inlinable
        public init(rule: TelemetryRule, ruleIdentifier: String) {
            self.rule = rule
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.rule.validate(name: "\(name).rule")
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct UpdateTelemetryRuleForOrganizationOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the updated organization telemetry rule.
        public let ruleArn: String?

        @inlinable
        public init(ruleArn: String? = nil) {
            self.ruleArn = ruleArn
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
        }
    }

    public struct UpdateTelemetryRuleInput: AWSEncodableShape {
        ///  The new configuration details for the telemetry rule.
        public let rule: TelemetryRule
        ///  The identifier (name or ARN) of the telemetry rule to update.
        public let ruleIdentifier: String

        @inlinable
        public init(rule: TelemetryRule, ruleIdentifier: String) {
            self.rule = rule
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.rule.validate(name: "\(name).rule")
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 1011)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
            case ruleIdentifier = "RuleIdentifier"
        }
    }

    public struct UpdateTelemetryRuleOutput: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the updated telemetry rule.
        public let ruleArn: String?

        @inlinable
        public init(ruleArn: String? = nil) {
            self.ruleArn = ruleArn
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
        }
    }

    public struct VPCFlowLogParameters: AWSEncodableShape & AWSDecodableShape {
        ///  The format in which VPC Flow Log entries should be logged.
        public let logFormat: String?
        ///  The maximum interval in seconds between the capture of flow log records.
        public let maxAggregationInterval: Int?
        ///  The type of traffic to log (ACCEPT, REJECT, or ALL).
        public let trafficType: String?

        @inlinable
        public init(logFormat: String? = nil, maxAggregationInterval: Int? = nil, trafficType: String? = nil) {
            self.logFormat = logFormat
            self.maxAggregationInterval = maxAggregationInterval
            self.trafficType = trafficType
        }

        private enum CodingKeys: String, CodingKey {
            case logFormat = "LogFormat"
            case maxAggregationInterval = "MaxAggregationInterval"
            case trafficType = "TrafficType"
        }
    }

    public struct ValidateTelemetryPipelineConfigurationInput: AWSEncodableShape {
        /// The pipeline configuration to validate for syntax and compatibility.
        public let configuration: TelemetryPipelineConfiguration

        @inlinable
        public init(configuration: TelemetryPipelineConfiguration) {
            self.configuration = configuration
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
        }
    }

    public struct ValidateTelemetryPipelineConfigurationOutput: AWSDecodableShape {
        /// A list of validation errors found in the pipeline configuration, if any.
        public let errors: [ValidationError]?

        @inlinable
        public init(errors: [ValidationError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct ValidationError: AWSDecodableShape {
        /// A mapping of field names to specific validation issues within the configuration.
        public let fieldMap: [String: String]?
        /// The error message describing the validation issue.
        public let message: String?
        /// The reason code or category for the validation error.
        public let reason: String?

        @inlinable
        public init(fieldMap: [String: String]? = nil, message: String? = nil, reason: String? = nil) {
            self.fieldMap = fieldMap
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldMap = "FieldMap"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationException: AWSErrorShape {
        ///  The errors in the input which caused the exception.
        public let errors: [ValidationError]?
        public let message: String?

        @inlinable
        public init(errors: [ValidationError]? = nil, message: String? = nil) {
            self.errors = errors
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case message = "Message"
        }
    }

    public struct WAFLoggingParameters: AWSEncodableShape & AWSDecodableShape {
        ///  A filter configuration that determines which WAF log records to include or exclude.
        public let loggingFilter: LoggingFilter?
        ///  The type of WAF logs to collect (currently supports WAF_LOGS).
        public let logType: WAFLogType?
        ///  The fields to redact from WAF logs to protect sensitive information.
        public let redactedFields: [FieldToMatch]?

        @inlinable
        public init(loggingFilter: LoggingFilter? = nil, logType: WAFLogType? = nil, redactedFields: [FieldToMatch]? = nil) {
            self.loggingFilter = loggingFilter
            self.logType = logType
            self.redactedFields = redactedFields
        }

        public func validate(name: String) throws {
            try self.loggingFilter?.validate(name: "\(name).loggingFilter")
            try self.validate(self.redactedFields, name: "redactedFields", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case loggingFilter = "LoggingFilter"
            case logType = "LogType"
            case redactedFields = "RedactedFields"
        }
    }
}

// MARK: - Errors

/// Error enum for ObservabilityAdmin
public struct ObservabilityAdminErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidStateException = "InvalidStateException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case tooManyRequestsException = "TooManyRequestsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ObservabilityAdmin
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  Indicates you don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see Access management for Amazon Web Services resources in the IAM user guide.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  The requested operation conflicts with the current state of the specified resource or with another request.
    public static var conflictException: Self { .init(.conflictException) }
    ///  Indicates the request has failed to process because of an unknown server error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The requested operation cannot be completed on the specified resource in the current state.
    public static var invalidStateException: Self { .init(.invalidStateException) }
    ///  The specified resource (such as a telemetry rule) could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  The requested operation would exceed the allowed quota for the specified resource type.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    ///  The request throughput limit was exceeded.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    ///  Indicates input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension ObservabilityAdminErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": ObservabilityAdmin.AccessDeniedException.self,
        "ConflictException": ObservabilityAdmin.ConflictException.self,
        "InternalServerException": ObservabilityAdmin.InternalServerException.self,
        "ResourceNotFoundException": ObservabilityAdmin.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": ObservabilityAdmin.ServiceQuotaExceededException.self,
        "ValidationException": ObservabilityAdmin.ValidationException.self
    ]
}

extension ObservabilityAdminErrorType: Equatable {
    public static func == (lhs: ObservabilityAdminErrorType, rhs: ObservabilityAdminErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ObservabilityAdminErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
