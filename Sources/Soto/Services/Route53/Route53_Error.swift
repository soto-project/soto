//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

/// Error enum for Route53
public struct Route53ErrorType: AWSErrorType {
    enum Code: String {
        case concurrentModification = "ConcurrentModification"
        case conflictingDomainExists = "ConflictingDomainExists"
        case conflictingTypes = "ConflictingTypes"
        case delegationSetAlreadyCreated = "DelegationSetAlreadyCreated"
        case delegationSetAlreadyReusable = "DelegationSetAlreadyReusable"
        case delegationSetInUse = "DelegationSetInUse"
        case delegationSetNotAvailable = "DelegationSetNotAvailable"
        case delegationSetNotReusable = "DelegationSetNotReusable"
        case healthCheckAlreadyExists = "HealthCheckAlreadyExists"
        case healthCheckInUse = "HealthCheckInUse"
        case healthCheckVersionMismatch = "HealthCheckVersionMismatch"
        case hostedZoneAlreadyExists = "HostedZoneAlreadyExists"
        case hostedZoneNotEmpty = "HostedZoneNotEmpty"
        case hostedZoneNotFound = "HostedZoneNotFound"
        case hostedZoneNotPrivate = "HostedZoneNotPrivate"
        case incompatibleVersion = "IncompatibleVersion"
        case insufficientCloudWatchLogsResourcePolicy = "InsufficientCloudWatchLogsResourcePolicy"
        case invalidArgument = "InvalidArgument"
        case invalidChangeBatch = "InvalidChangeBatch"
        case invalidDomainName = "InvalidDomainName"
        case invalidInput = "InvalidInput"
        case invalidPaginationToken = "InvalidPaginationToken"
        case invalidTrafficPolicyDocument = "InvalidTrafficPolicyDocument"
        case invalidVPCId = "InvalidVPCId"
        case lastVPCAssociation = "LastVPCAssociation"
        case limitsExceeded = "LimitsExceeded"
        case noSuchChange = "NoSuchChange"
        case noSuchCloudWatchLogsLogGroup = "NoSuchCloudWatchLogsLogGroup"
        case noSuchDelegationSet = "NoSuchDelegationSet"
        case noSuchGeoLocation = "NoSuchGeoLocation"
        case noSuchHealthCheck = "NoSuchHealthCheck"
        case noSuchHostedZone = "NoSuchHostedZone"
        case noSuchQueryLoggingConfig = "NoSuchQueryLoggingConfig"
        case noSuchTrafficPolicy = "NoSuchTrafficPolicy"
        case noSuchTrafficPolicyInstance = "NoSuchTrafficPolicyInstance"
        case notAuthorizedException = "NotAuthorizedException"
        case priorRequestNotComplete = "PriorRequestNotComplete"
        case publicZoneVPCAssociation = "PublicZoneVPCAssociation"
        case queryLoggingConfigAlreadyExists = "QueryLoggingConfigAlreadyExists"
        case throttlingException = "ThrottlingException"
        case tooManyHealthChecks = "TooManyHealthChecks"
        case tooManyHostedZones = "TooManyHostedZones"
        case tooManyTrafficPolicies = "TooManyTrafficPolicies"
        case tooManyTrafficPolicyInstances = "TooManyTrafficPolicyInstances"
        case tooManyTrafficPolicyVersionsForCurrentPolicy = "TooManyTrafficPolicyVersionsForCurrentPolicy"
        case tooManyVPCAssociationAuthorizations = "TooManyVPCAssociationAuthorizations"
        case trafficPolicyAlreadyExists = "TrafficPolicyAlreadyExists"
        case trafficPolicyInUse = "TrafficPolicyInUse"
        case trafficPolicyInstanceAlreadyExists = "TrafficPolicyInstanceAlreadyExists"
        case vPCAssociationAuthorizationNotFound = "VPCAssociationAuthorizationNotFound"
        case vPCAssociationNotFound = "VPCAssociationNotFound"
    }

    private var error: Code
    public var message: String?

    public init?(errorCode: String, message: String?) {
        var errorCode = errorCode
        if let index = errorCode.firstIndex(of: "#") {
            errorCode = String(errorCode[errorCode.index(index, offsetBy: 1)...])
        }
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.message = message
    }

    internal init(_ error: Code) {
        self.error = error
        self.message = nil
    }

    public static var concurrentModification: Self { .init(.concurrentModification) }
    public static var conflictingDomainExists: Self { .init(.conflictingDomainExists) }
    public static var conflictingTypes: Self { .init(.conflictingTypes) }
    public static var delegationSetAlreadyCreated: Self { .init(.delegationSetAlreadyCreated) }
    public static var delegationSetAlreadyReusable: Self { .init(.delegationSetAlreadyReusable) }
    public static var delegationSetInUse: Self { .init(.delegationSetInUse) }
    public static var delegationSetNotAvailable: Self { .init(.delegationSetNotAvailable) }
    public static var delegationSetNotReusable: Self { .init(.delegationSetNotReusable) }
    public static var healthCheckAlreadyExists: Self { .init(.healthCheckAlreadyExists) }
    public static var healthCheckInUse: Self { .init(.healthCheckInUse) }
    public static var healthCheckVersionMismatch: Self { .init(.healthCheckVersionMismatch) }
    public static var hostedZoneAlreadyExists: Self { .init(.hostedZoneAlreadyExists) }
    public static var hostedZoneNotEmpty: Self { .init(.hostedZoneNotEmpty) }
    public static var hostedZoneNotFound: Self { .init(.hostedZoneNotFound) }
    public static var hostedZoneNotPrivate: Self { .init(.hostedZoneNotPrivate) }
    public static var incompatibleVersion: Self { .init(.incompatibleVersion) }
    public static var insufficientCloudWatchLogsResourcePolicy: Self { .init(.insufficientCloudWatchLogsResourcePolicy) }
    public static var invalidArgument: Self { .init(.invalidArgument) }
    public static var invalidChangeBatch: Self { .init(.invalidChangeBatch) }
    public static var invalidDomainName: Self { .init(.invalidDomainName) }
    public static var invalidInput: Self { .init(.invalidInput) }
    public static var invalidPaginationToken: Self { .init(.invalidPaginationToken) }
    public static var invalidTrafficPolicyDocument: Self { .init(.invalidTrafficPolicyDocument) }
    public static var invalidVPCId: Self { .init(.invalidVPCId) }
    public static var lastVPCAssociation: Self { .init(.lastVPCAssociation) }
    public static var limitsExceeded: Self { .init(.limitsExceeded) }
    public static var noSuchChange: Self { .init(.noSuchChange) }
    public static var noSuchCloudWatchLogsLogGroup: Self { .init(.noSuchCloudWatchLogsLogGroup) }
    public static var noSuchDelegationSet: Self { .init(.noSuchDelegationSet) }
    public static var noSuchGeoLocation: Self { .init(.noSuchGeoLocation) }
    public static var noSuchHealthCheck: Self { .init(.noSuchHealthCheck) }
    public static var noSuchHostedZone: Self { .init(.noSuchHostedZone) }
    public static var noSuchQueryLoggingConfig: Self { .init(.noSuchQueryLoggingConfig) }
    public static var noSuchTrafficPolicy: Self { .init(.noSuchTrafficPolicy) }
    public static var noSuchTrafficPolicyInstance: Self { .init(.noSuchTrafficPolicyInstance) }
    public static var notAuthorizedException: Self { .init(.notAuthorizedException) }
    public static var priorRequestNotComplete: Self { .init(.priorRequestNotComplete) }
    public static var publicZoneVPCAssociation: Self { .init(.publicZoneVPCAssociation) }
    public static var queryLoggingConfigAlreadyExists: Self { .init(.queryLoggingConfigAlreadyExists) }
    public static var throttlingException: Self { .init(.throttlingException) }
    public static var tooManyHealthChecks: Self { .init(.tooManyHealthChecks) }
    public static var tooManyHostedZones: Self { .init(.tooManyHostedZones) }
    public static var tooManyTrafficPolicies: Self { .init(.tooManyTrafficPolicies) }
    public static var tooManyTrafficPolicyInstances: Self { .init(.tooManyTrafficPolicyInstances) }
    public static var tooManyTrafficPolicyVersionsForCurrentPolicy: Self { .init(.tooManyTrafficPolicyVersionsForCurrentPolicy) }
    public static var tooManyVPCAssociationAuthorizations: Self { .init(.tooManyVPCAssociationAuthorizations) }
    public static var trafficPolicyAlreadyExists: Self { .init(.trafficPolicyAlreadyExists) }
    public static var trafficPolicyInUse: Self { .init(.trafficPolicyInUse) }
    public static var trafficPolicyInstanceAlreadyExists: Self { .init(.trafficPolicyInstanceAlreadyExists) }
    public static var vPCAssociationAuthorizationNotFound: Self { .init(.vPCAssociationAuthorizationNotFound) }
    public static var vPCAssociationNotFound: Self { .init(.vPCAssociationNotFound) }
}

extension Route53ErrorType: Equatable {
    public static func == (lhs: Route53ErrorType, rhs: Route53ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension Route53ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
