//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MediaPackageV2 {
    // MARK: Enums

    public enum AdMarkerDash: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binary = "BINARY"
        case xml = "XML"
        public var description: String { return self.rawValue }
    }

    public enum AdMarkerHls: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daterange = "DATERANGE"
        public var description: String { return self.rawValue }
    }

    public enum CmafEncryptionMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cbcs = "CBCS"
        case cenc = "CENC"
        public var description: String { return self.rawValue }
    }

    public enum ConflictExceptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conflictingOperation = "CONFLICTING_OPERATION"
        case idempotentParameterMismatch = "IDEMPOTENT_PARAMETER_MISMATCH"
        case resourceAlreadyExists = "RESOURCE_ALREADY_EXISTS"
        case resourceInUse = "RESOURCE_IN_USE"
        public var description: String { return self.rawValue }
    }

    public enum ContainerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cmaf = "CMAF"
        case ts = "TS"
        public var description: String { return self.rawValue }
    }

    public enum DashDrmSignaling: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case individual = "INDIVIDUAL"
        case referenced = "REFERENCED"
        public var description: String { return self.rawValue }
    }

    public enum DashPeriodTrigger: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avails = "AVAILS"
        case drmKeyRotation = "DRM_KEY_ROTATION"
        case none = "NONE"
        case sourceChanges = "SOURCE_CHANGES"
        case sourceDisruptions = "SOURCE_DISRUPTIONS"
        public var description: String { return self.rawValue }
    }

    public enum DashSegmentTemplateFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case numberWithTimeline = "NUMBER_WITH_TIMELINE"
        public var description: String { return self.rawValue }
    }

    public enum DashUtcTimingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case httpHead = "HTTP_HEAD"
        case httpIso = "HTTP_ISO"
        case httpXsdate = "HTTP_XSDATE"
        case utcDirect = "UTC_DIRECT"
        public var description: String { return self.rawValue }
    }

    public enum DrmSystem: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clearKeyAes128 = "CLEAR_KEY_AES_128"
        case fairplay = "FAIRPLAY"
        case irdeto = "IRDETO"
        case playready = "PLAYREADY"
        case widevine = "WIDEVINE"
        public var description: String { return self.rawValue }
    }

    public enum EndpointErrorCondition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case incompleteManifest = "INCOMPLETE_MANIFEST"
        case missingDrmKey = "MISSING_DRM_KEY"
        case slateInput = "SLATE_INPUT"
        case staleManifest = "STALE_MANIFEST"
        public var description: String { return self.rawValue }
    }

    public enum HarvestJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        public var description: String { return self.rawValue }
    }

    public enum InputType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cmaf = "CMAF"
        case hls = "HLS"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Audio: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case presetAudio1 = "PRESET_AUDIO_1"
        case presetAudio2 = "PRESET_AUDIO_2"
        case presetAudio3 = "PRESET_AUDIO_3"
        case shared = "SHARED"
        case unencrypted = "UNENCRYPTED"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Video: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case presetVideo1 = "PRESET_VIDEO_1"
        case presetVideo2 = "PRESET_VIDEO_2"
        case presetVideo3 = "PRESET_VIDEO_3"
        case presetVideo4 = "PRESET_VIDEO_4"
        case presetVideo5 = "PRESET_VIDEO_5"
        case presetVideo6 = "PRESET_VIDEO_6"
        case presetVideo7 = "PRESET_VIDEO_7"
        case presetVideo8 = "PRESET_VIDEO_8"
        case shared = "SHARED"
        case unencrypted = "UNENCRYPTED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceTypeNotFound: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case channel = "CHANNEL"
        case channelGroup = "CHANNEL_GROUP"
        case harvestJob = "HARVEST_JOB"
        case originEndpoint = "ORIGIN_ENDPOINT"
        public var description: String { return self.rawValue }
    }

    public enum ScteFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `break` = "BREAK"
        case distributorAdvertisement = "DISTRIBUTOR_ADVERTISEMENT"
        case distributorOverlayPlacementOpportunity = "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
        case distributorPlacementOpportunity = "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
        case program = "PROGRAM"
        case providerAdvertisement = "PROVIDER_ADVERTISEMENT"
        case providerOverlayPlacementOpportunity = "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
        case providerPlacementOpportunity = "PROVIDER_PLACEMENT_OPPORTUNITY"
        case spliceInsert = "SPLICE_INSERT"
        public var description: String { return self.rawValue }
    }

    public enum TsEncryptionMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cencIvIncompatible = "CENC_IV_INCOMPATIBLE"
        case clipStartTimeWithStartOrEnd = "CLIP_START_TIME_WITH_START_OR_END"
        case containerTypeImmutable = "CONTAINER_TYPE_IMMUTABLE"
        case directModeWithTimingSource = "DIRECT_MODE_WITH_TIMING_SOURCE"
        case drmSignalingMismatchSegmentEncryptionStatus = "DRM_SIGNALING_MISMATCH_SEGMENT_ENCRYPTION_STATUS"
        case drmSystemsEncryptionMethodIncompatible = "DRM_SYSTEMS_ENCRYPTION_METHOD_INCOMPATIBLE"
        case encryptionContractShared = "ENCRYPTION_CONTRACT_SHARED"
        case encryptionContractUnencrypted = "ENCRYPTION_CONTRACT_UNENCRYPTED"
        case encryptionContractWithoutAudioRenditionIncompatible = "ENCRYPTION_CONTRACT_WITHOUT_AUDIO_RENDITION_INCOMPATIBLE"
        case encryptionMethodContainerTypeMismatch = "ENCRYPTION_METHOD_CONTAINER_TYPE_MISMATCH"
        case endTimeEarlierThanStartTime = "END_TIME_EARLIER_THAN_START_TIME"
        case harvestJobCustomerEndpointReadAccessDenied = "HARVEST_JOB_CUSTOMER_ENDPOINT_READ_ACCESS_DENIED"
        case harvestJobIneligibleForCancellation = "HARVEST_JOB_INELIGIBLE_FOR_CANCELLATION"
        case harvestJobS3DestinationMissingOrIncomplete = "HARVEST_JOB_S3_DESTINATION_MISSING_OR_INCOMPLETE"
        case harvestJobUnableToWriteToS3Destination = "HARVEST_JOB_UNABLE_TO_WRITE_TO_S3_DESTINATION"
        case harvestedManifestHasStartEndFilterConfiguration = "HARVESTED_MANIFEST_HAS_START_END_FILTER_CONFIGURATION"
        case harvestedManifestNotFoundOnEndpoint = "HARVESTED_MANIFEST_NOT_FOUND_ON_ENDPOINT"
        case invalidHarvestJobDuration = "INVALID_HARVEST_JOB_DURATION"
        case invalidManifestFilter = "INVALID_MANIFEST_FILTER"
        case invalidPaginationMaxResults = "INVALID_PAGINATION_MAX_RESULTS"
        case invalidPaginationToken = "INVALID_PAGINATION_TOKEN"
        case invalidPolicy = "INVALID_POLICY"
        case invalidRoleArn = "INVALID_ROLE_ARN"
        case invalidTimeDelaySeconds = "INVALID_TIME_DELAY_SECONDS"
        case manifestDrmSystemsIncompatible = "MANIFEST_DRM_SYSTEMS_INCOMPATIBLE"
        case manifestNameCollision = "MANIFEST_NAME_COLLISION"
        case memberDoesNotMatchPattern = "MEMBER_DOES_NOT_MATCH_PATTERN"
        case memberInvalid = "MEMBER_INVALID"
        case memberInvalidEnumValue = "MEMBER_INVALID_ENUM_VALUE"
        case memberMaxLength = "MEMBER_MAX_LENGTH"
        case memberMaxValue = "MEMBER_MAX_VALUE"
        case memberMinLength = "MEMBER_MIN_LENGTH"
        case memberMinValue = "MEMBER_MIN_VALUE"
        case memberMissing = "MEMBER_MISSING"
        case noneModeWithTimingSource = "NONE_MODE_WITH_TIMING_SOURCE"
        case numManifestsHigh = "NUM_MANIFESTS_HIGH"
        case numManifestsLow = "NUM_MANIFESTS_LOW"
        case onlyCmafInputTypeAllowForceEndpointErrorConfiguration = "ONLY_CMAF_INPUT_TYPE_ALLOW_FORCE_ENDPOINT_ERROR_CONFIGURATION"
        case onlyCmafInputTypeAllowMqcsInputSwitching = "ONLY_CMAF_INPUT_TYPE_ALLOW_MQCS_INPUT_SWITCHING"
        case onlyCmafInputTypeAllowMqcsOutputConfiguration = "ONLY_CMAF_INPUT_TYPE_ALLOW_MQCS_OUTPUT_CONFIGURATION"
        case periodTriggersNoneSpecifiedWithAdditionalValues = "PERIOD_TRIGGERS_NONE_SPECIFIED_WITH_ADDITIONAL_VALUES"
        case roleArnInvalidFormat = "ROLE_ARN_INVALID_FORMAT"
        case roleArnLengthOutOfRange = "ROLE_ARN_LENGTH_OUT_OF_RANGE"
        case roleArnNotAssumable = "ROLE_ARN_NOT_ASSUMABLE"
        case sourceDisruptionsEnabledIncorrectly = "SOURCE_DISRUPTIONS_ENABLED_INCORRECTLY"
        case startTagTimeOffsetInvalid = "START_TAG_TIME_OFFSET_INVALID"
        case timingSourceMissing = "TIMING_SOURCE_MISSING"
        case tooManyInProgressHarvestJobs = "TOO_MANY_IN_PROGRESS_HARVEST_JOBS"
        case tsContainerTypeWithDashManifest = "TS_CONTAINER_TYPE_WITH_DASH_MANIFEST"
        case updatePeriodSmallerThanSegmentDuration = "UPDATE_PERIOD_SMALLER_THAN_SEGMENT_DURATION"
        case urlInvalid = "URL_INVALID"
        case urlLinkLocalAddress = "URL_LINK_LOCAL_ADDRESS"
        case urlLocalAddress = "URL_LOCAL_ADDRESS"
        case urlLoopbackAddress = "URL_LOOPBACK_ADDRESS"
        case urlMulticastAddress = "URL_MULTICAST_ADDRESS"
        case urlPort = "URL_PORT"
        case urlScheme = "URL_SCHEME"
        case urlUnknownHost = "URL_UNKNOWN_HOST"
        case urlUserInfo = "URL_USER_INFO"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CancelHarvestJobRequest: AWSEncodableShape {
        /// The name of the channel group containing the channel from which the harvest job is running.
        public let channelGroupName: String
        /// The name of the channel from which the harvest job is running.
        public let channelName: String
        /// The current Entity Tag (ETag) associated with the harvest job. Used for concurrency control.
        public let eTag: String?
        /// The name of the harvest job to cancel. This name must be unique within the channel and cannot be changed after the harvest job is submitted.
        public let harvestJobName: String
        /// The name of the origin endpoint that the harvest job is harvesting from. This cannot be changed after the harvest job is submitted.
        public let originEndpointName: String

        @inlinable
        public init(channelGroupName: String, channelName: String, eTag: String? = nil, harvestJobName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.eTag = eTag
            self.harvestJobName = harvestJobName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodeHeader(self.eTag, key: "x-amzn-update-if-match")
            request.encodePath(self.harvestJobName, key: "HarvestJobName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.eTag, name: "eTag", parent: name, max: 256)
            try self.validate(self.eTag, name: "eTag", parent: name, min: 1)
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, max: 256)
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, min: 1)
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelHarvestJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ChannelGroupListConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The date and time the channel group was created.
        public let createdAt: Date
        /// Any descriptive information that you want to add to the channel group for future identification purposes.
        public let description: String?
        /// The date and time the channel group was modified.
        public let modifiedAt: Date

        @inlinable
        public init(arn: String, channelGroupName: String, createdAt: Date, description: String? = nil, modifiedAt: Date) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case modifiedAt = "ModifiedAt"
        }
    }

    public struct ChannelListConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The date and time the channel was created.
        public let createdAt: Date
        /// Any descriptive information that you want to add to the channel for future identification purposes.
        public let description: String?
        /// The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior. The allowed values are:    HLS - The HLS streaming specification (which defines M3U8 manifests and TS segments).    CMAF - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).
        public let inputType: InputType?
        /// The date and time the channel was modified.
        public let modifiedAt: Date

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, inputType: InputType? = nil, modifiedAt: Date) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.inputType = inputType
            self.modifiedAt = modifiedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case inputType = "InputType"
            case modifiedAt = "ModifiedAt"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// The type of ConflictException.
        public let conflictExceptionType: ConflictExceptionType?
        public let message: String?

        @inlinable
        public init(conflictExceptionType: ConflictExceptionType? = nil, message: String? = nil) {
            self.conflictExceptionType = conflictExceptionType
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case conflictExceptionType = "ConflictExceptionType"
            case message = "Message"
        }
    }

    public struct CreateChannelGroupRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region. You can't use spaces in the name. You can't change the name after you create the channel group.
        public let channelGroupName: String
        /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// Enter any descriptive text that helps you to identify the channel group.
        public let description: String?
        /// A comma-separated list of tag key:value pairs that you define. For example:  "Key1": "Value1",   "Key2": "Value2"
        public let tags: [String: String]?

        @inlinable
        public init(channelGroupName: String, clientToken: String? = CreateChannelGroupRequest.idempotencyToken(), description: String? = nil, tags: [String: String]? = nil) {
            self.channelGroupName = channelGroupName
            self.clientToken = clientToken
            self.description = description
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.channelGroupName, forKey: .channelGroupName)
            request.encodeHeader(self.clientToken, key: "x-amzn-client-token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case channelGroupName = "ChannelGroupName"
            case description = "Description"
            case tags = "tags"
        }
    }

    public struct CreateChannelGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The date and time the channel group was created.
        public let createdAt: Date
        /// The description for your channel group.
        public let description: String?
        /// The output domain where the source stream should be sent. Integrate the egress domain with a downstream CDN (such as Amazon CloudFront) or playback device.
        public let egressDomain: String
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The date and time the channel group was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel group.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, createdAt: Date, description: String? = nil, egressDomain: String, eTag: String? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.egressDomain = egressDomain
            self.eTag = eTag
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case egressDomain = "EgressDomain"
            case eTag = "ETag"
            case modifiedAt = "ModifiedAt"
            case tags = "Tags"
        }
    }

    public struct CreateChannelRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.
        public let channelName: String
        /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// Enter any descriptive text that helps you to identify the channel.
        public let description: String?
        /// The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when InputType is CMAF.
        public let inputSwitchConfiguration: InputSwitchConfiguration?
        /// The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior. The allowed values are:    HLS - The HLS streaming specification (which defines M3U8 manifests and TS segments).    CMAF - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).
        public let inputType: InputType?
        /// The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when InputType is CMAF.
        public let outputHeaderConfiguration: OutputHeaderConfiguration?
        /// A comma-separated list of tag key:value pairs that you define. For example:  "Key1": "Value1",   "Key2": "Value2"
        public let tags: [String: String]?

        @inlinable
        public init(channelGroupName: String, channelName: String, clientToken: String? = CreateChannelRequest.idempotencyToken(), description: String? = nil, inputSwitchConfiguration: InputSwitchConfiguration? = nil, inputType: InputType? = nil, outputHeaderConfiguration: OutputHeaderConfiguration? = nil, tags: [String: String]? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.clientToken = clientToken
            self.description = description
            self.inputSwitchConfiguration = inputSwitchConfiguration
            self.inputType = inputType
            self.outputHeaderConfiguration = outputHeaderConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            try container.encode(self.channelName, forKey: .channelName)
            request.encodeHeader(self.clientToken, key: "x-amzn-client-token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.inputSwitchConfiguration, forKey: .inputSwitchConfiguration)
            try container.encodeIfPresent(self.inputType, forKey: .inputType)
            try container.encodeIfPresent(self.outputHeaderConfiguration, forKey: .outputHeaderConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case channelName = "ChannelName"
            case description = "Description"
            case inputSwitchConfiguration = "InputSwitchConfiguration"
            case inputType = "InputType"
            case outputHeaderConfiguration = "OutputHeaderConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The date and time the channel was created.
        public let createdAt: Date
        /// The description for your channel.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        public let ingestEndpoints: [IngestEndpoint]?
        /// The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when InputType is CMAF.
        public let inputSwitchConfiguration: InputSwitchConfiguration?
        /// The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior. The allowed values are:    HLS - The HLS streaming specification (which defines M3U8 manifests and TS segments).    CMAF - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).
        public let inputType: InputType?
        /// The date and time the channel was modified.
        public let modifiedAt: Date
        /// The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when InputType is CMAF.
        public let outputHeaderConfiguration: OutputHeaderConfiguration?
        /// The comma-separated list of tag key:value pairs assigned to the channel.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, eTag: String? = nil, ingestEndpoints: [IngestEndpoint]? = nil, inputSwitchConfiguration: InputSwitchConfiguration? = nil, inputType: InputType? = nil, modifiedAt: Date, outputHeaderConfiguration: OutputHeaderConfiguration? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.ingestEndpoints = ingestEndpoints
            self.inputSwitchConfiguration = inputSwitchConfiguration
            self.inputType = inputType
            self.modifiedAt = modifiedAt
            self.outputHeaderConfiguration = outputHeaderConfiguration
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case ingestEndpoints = "IngestEndpoints"
            case inputSwitchConfiguration = "InputSwitchConfiguration"
            case inputType = "InputType"
            case modifiedAt = "ModifiedAt"
            case outputHeaderConfiguration = "OutputHeaderConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateDashManifestConfiguration: AWSEncodableShape {
        /// Determines how the DASH manifest signals the DRM content.
        public let drmSignaling: DashDrmSignaling?
        public let filterConfiguration: FilterConfiguration?
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Minimum amount of content (in seconds) that a player must keep available in the buffer.
        public let minBufferTimeSeconds: Int?
        /// Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest.
        public let minUpdatePeriodSeconds: Int?
        /// A list of triggers that controls when AWS Elemental MediaPackage separates the MPEG-DASH manifest into multiple periods. Type ADS to indicate that AWS Elemental MediaPackage must create periods in the output manifest that correspond to SCTE-35 ad markers in the input source. Leave this value empty to indicate that the manifest is contained all in one period. For more information about periods in the DASH manifest, see Multi-period DASH in AWS Elemental MediaPackage.
        public let periodTriggers: [DashPeriodTrigger]?
        /// The SCTE configuration.
        public let scteDash: ScteDash?
        /// Determines the type of variable used in the media URL of the SegmentTemplate tag in the manifest. Also specifies if segment timeline information is included in SegmentTimeline or SegmentTemplate. Value description:    NUMBER_WITH_TIMELINE - The $Number$ variable is used in the media URL. The value of this variable is the sequential number of the segment. A full SegmentTimeline object is presented in each SegmentTemplate.
        public let segmentTemplateFormat: DashSegmentTemplateFormat?
        /// The amount of time (in seconds) that the player should be from the end of the manifest.
        public let suggestedPresentationDelaySeconds: Int?
        /// Determines the type of UTC timing included in the DASH Media Presentation Description (MPD).
        public let utcTiming: DashUtcTiming?

        @inlinable
        public init(drmSignaling: DashDrmSignaling? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, minBufferTimeSeconds: Int? = nil, minUpdatePeriodSeconds: Int? = nil, periodTriggers: [DashPeriodTrigger]? = nil, scteDash: ScteDash? = nil, segmentTemplateFormat: DashSegmentTemplateFormat? = nil, suggestedPresentationDelaySeconds: Int? = nil, utcTiming: DashUtcTiming? = nil) {
            self.drmSignaling = drmSignaling
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.scteDash = scteDash
            self.segmentTemplateFormat = segmentTemplateFormat
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
            self.utcTiming = utcTiming
        }

        public func validate(name: String) throws {
            try self.validate(self.manifestName, name: "manifestName", parent: name, max: 256)
            try self.validate(self.manifestName, name: "manifestName", parent: name, min: 1)
            try self.validate(self.manifestName, name: "manifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.periodTriggers, name: "periodTriggers", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case drmSignaling = "DrmSignaling"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case minBufferTimeSeconds = "MinBufferTimeSeconds"
            case minUpdatePeriodSeconds = "MinUpdatePeriodSeconds"
            case periodTriggers = "PeriodTriggers"
            case scteDash = "ScteDash"
            case segmentTemplateFormat = "SegmentTemplateFormat"
            case suggestedPresentationDelaySeconds = "SuggestedPresentationDelaySeconds"
            case utcTiming = "UtcTiming"
        }
    }

    public struct CreateHarvestJobRequest: AWSEncodableShape {
        /// The name of the channel group containing the channel from which to harvest content.
        public let channelGroupName: String
        /// The name of the channel from which to harvest content.
        public let channelName: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// An optional description for the harvest job.
        public let description: String?
        /// The S3 destination where the harvested content will be placed.
        public let destination: Destination
        /// A list of manifests to be harvested.
        public let harvestedManifests: HarvestedManifests
        /// A name for the harvest job. This name must be unique within the channel.
        public let harvestJobName: String?
        /// The name of the origin endpoint from which to harvest content.
        public let originEndpointName: String
        /// The configuration for when the harvest job should run, including start and end times.
        public let scheduleConfiguration: HarvesterScheduleConfiguration
        /// A collection of tags associated with the harvest job.
        public let tags: [String: String]?

        @inlinable
        public init(channelGroupName: String, channelName: String, clientToken: String? = CreateHarvestJobRequest.idempotencyToken(), description: String? = nil, destination: Destination, harvestedManifests: HarvestedManifests, harvestJobName: String? = nil, originEndpointName: String, scheduleConfiguration: HarvesterScheduleConfiguration, tags: [String: String]? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.clientToken = clientToken
            self.description = description
            self.destination = destination
            self.harvestedManifests = harvestedManifests
            self.harvestJobName = harvestJobName
            self.originEndpointName = originEndpointName
            self.scheduleConfiguration = scheduleConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodeHeader(self.clientToken, key: "x-amzn-client-token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.destination, forKey: .destination)
            try container.encode(self.harvestedManifests, forKey: .harvestedManifests)
            try container.encodeIfPresent(self.harvestJobName, forKey: .harvestJobName)
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
            try container.encode(self.scheduleConfiguration, forKey: .scheduleConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.destination.validate(name: "\(name).destination")
            try self.harvestedManifests.validate(name: "\(name).harvestedManifests")
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, max: 256)
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, min: 1)
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case destination = "Destination"
            case harvestedManifests = "HarvestedManifests"
            case harvestJobName = "HarvestJobName"
            case scheduleConfiguration = "ScheduleConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateHarvestJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created harvest job.
        public let arn: String
        /// The name of the channel group containing the channel from which content is being harvested.
        public let channelGroupName: String
        /// The name of the channel from which content is being harvested.
        public let channelName: String
        /// The date and time the harvest job was created.
        public let createdAt: Date
        /// The description of the harvest job, if provided.
        public let description: String?
        /// The S3 destination where the harvested content will be placed.
        public let destination: Destination
        /// An error message if the harvest job creation failed.
        public let errorMessage: String?
        /// The current version of the harvest job. Used for concurrency control.
        public let eTag: String?
        /// A list of manifests that will be harvested.
        public let harvestedManifests: HarvestedManifests
        /// The name of the created harvest job.
        public let harvestJobName: String
        /// The date and time the harvest job was last modified.
        public let modifiedAt: Date
        /// The name of the origin endpoint from which content is being harvested.
        public let originEndpointName: String
        /// The configuration for when the harvest job will run, including start and end times.
        public let scheduleConfiguration: HarvesterScheduleConfiguration
        /// The current status of the harvest job (e.g., CREATED, IN_PROGRESS, ABORTED, COMPLETED, FAILED).
        public let status: HarvestJobStatus
        /// A collection of tags associated with the harvest job.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, destination: Destination, errorMessage: String? = nil, eTag: String? = nil, harvestedManifests: HarvestedManifests, harvestJobName: String, modifiedAt: Date, originEndpointName: String, scheduleConfiguration: HarvesterScheduleConfiguration, status: HarvestJobStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.destination = destination
            self.errorMessage = errorMessage
            self.eTag = eTag
            self.harvestedManifests = harvestedManifests
            self.harvestJobName = harvestJobName
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.scheduleConfiguration = scheduleConfiguration
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case destination = "Destination"
            case errorMessage = "ErrorMessage"
            case eTag = "ETag"
            case harvestedManifests = "HarvestedManifests"
            case harvestJobName = "HarvestJobName"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case scheduleConfiguration = "ScheduleConfiguration"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct CreateHlsManifestConfiguration: AWSEncodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index, with an added suffix to distinguish it from the manifest name. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        public let filterConfiguration: FilterConfiguration?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public let programDateTimeIntervalSeconds: Int?
        public let scteHls: ScteHls?
        public let startTag: StartTag?
        /// When enabled, MediaPackage URL-encodes the query string for API requests for HLS child manifests to comply with Amazon Web Services Signature Version 4 (SigV4) signature signing protocol. For more information, see Amazon Web Services Signature Version 4 for API requests in Identity and Access Management User Guide.
        public let urlEncodeChildManifest: Bool?

        @inlinable
        public init(childManifestName: String? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, scteHls: ScteHls? = nil, startTag: StartTag? = nil, urlEncodeChildManifest: Bool? = nil) {
            self.childManifestName = childManifestName
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.startTag = startTag
            self.urlEncodeChildManifest = urlEncodeChildManifest
        }

        public func validate(name: String) throws {
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, max: 256)
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, min: 1)
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.manifestName, name: "manifestName", parent: name, max: 256)
            try self.validate(self.manifestName, name: "manifestName", parent: name, min: 1)
            try self.validate(self.manifestName, name: "manifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
            case scteHls = "ScteHls"
            case startTag = "StartTag"
            case urlEncodeChildManifest = "UrlEncodeChildManifest"
        }
    }

    public struct CreateLowLatencyHlsManifestConfiguration: AWSEncodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index, with an added suffix to distinguish it from the manifest name. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        public let filterConfiguration: FilterConfiguration?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public let programDateTimeIntervalSeconds: Int?
        public let scteHls: ScteHls?
        public let startTag: StartTag?
        /// When enabled, MediaPackage URL-encodes the query string for API requests for LL-HLS child manifests to comply with Amazon Web Services Signature Version 4 (SigV4) signature signing protocol. For more information, see Amazon Web Services Signature Version 4 for API requests in Identity and Access Management User Guide.
        public let urlEncodeChildManifest: Bool?

        @inlinable
        public init(childManifestName: String? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, scteHls: ScteHls? = nil, startTag: StartTag? = nil, urlEncodeChildManifest: Bool? = nil) {
            self.childManifestName = childManifestName
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.startTag = startTag
            self.urlEncodeChildManifest = urlEncodeChildManifest
        }

        public func validate(name: String) throws {
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, max: 256)
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, min: 1)
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.manifestName, name: "manifestName", parent: name, max: 256)
            try self.validate(self.manifestName, name: "manifestName", parent: name, min: 1)
            try self.validate(self.manifestName, name: "manifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
            case scteHls = "ScteHls"
            case startTag = "StartTag"
            case urlEncodeChildManifest = "UrlEncodeChildManifest"
        }
    }

    public struct CreateOriginEndpointRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The type of container to attach to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file. You can't change the container type after you create the endpoint.
        public let containerType: ContainerType
        /// A DASH manifest configuration.
        public let dashManifests: [CreateDashManifestConfiguration]?
        /// Enter any descriptive text that helps you to identify the origin endpoint.
        public let description: String?
        /// The failover settings for the endpoint.
        public let forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [CreateHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [CreateLowLatencyHlsManifestConfiguration]?
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and must be unique for your account in the AWS Region and channel. You can't use spaces in the name. You can't change the name after you create the endpoint.
        public let originEndpointName: String
        /// The segment configuration, including the segment name, duration, and other configuration values.
        public let segment: Segment?
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window. The maximum startover window is 1,209,600 seconds (14 days).
        public let startoverWindowSeconds: Int?
        /// A comma-separated list of tag key:value pairs that you define. For example:  "Key1": "Value1",   "Key2": "Value2"
        public let tags: [String: String]?

        @inlinable
        public init(channelGroupName: String, channelName: String, clientToken: String? = CreateOriginEndpointRequest.idempotencyToken(), containerType: ContainerType, dashManifests: [CreateDashManifestConfiguration]? = nil, description: String? = nil, forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration? = nil, hlsManifests: [CreateHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [CreateLowLatencyHlsManifestConfiguration]? = nil, originEndpointName: String, segment: Segment? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.clientToken = clientToken
            self.containerType = containerType
            self.dashManifests = dashManifests
            self.description = description
            self.forceEndpointErrorConfiguration = forceEndpointErrorConfiguration
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodeHeader(self.clientToken, key: "x-amzn-client-token")
            try container.encode(self.containerType, forKey: .containerType)
            try container.encodeIfPresent(self.dashManifests, forKey: .dashManifests)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.forceEndpointErrorConfiguration, forKey: .forceEndpointErrorConfiguration)
            try container.encodeIfPresent(self.hlsManifests, forKey: .hlsManifests)
            try container.encodeIfPresent(self.lowLatencyHlsManifests, forKey: .lowLatencyHlsManifests)
            try container.encode(self.originEndpointName, forKey: .originEndpointName)
            try container.encodeIfPresent(self.segment, forKey: .segment)
            try container.encodeIfPresent(self.startoverWindowSeconds, forKey: .startoverWindowSeconds)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.dashManifests?.forEach {
                try $0.validate(name: "\(name).dashManifests[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.hlsManifests?.forEach {
                try $0.validate(name: "\(name).hlsManifests[]")
            }
            try self.lowLatencyHlsManifests?.forEach {
                try $0.validate(name: "\(name).lowLatencyHlsManifests[]")
            }
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.segment?.validate(name: "\(name).segment")
        }

        private enum CodingKeys: String, CodingKey {
            case containerType = "ContainerType"
            case dashManifests = "DashManifests"
            case description = "Description"
            case forceEndpointErrorConfiguration = "ForceEndpointErrorConfiguration"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case originEndpointName = "OriginEndpointName"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
            case tags = "Tags"
        }
    }

    public struct CreateOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint.
        public let containerType: ContainerType
        /// The date and time the origin endpoint was created.
        public let createdAt: Date
        /// A DASH manifest configuration.
        public let dashManifests: [GetDashManifestConfiguration]?
        /// The description for your origin endpoint.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The failover settings for the endpoint.
        public let forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [GetHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public let modifiedAt: Date
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The segment configuration, including the segment name, duration, and other configuration values.
        public let segment: Segment
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
        public let startoverWindowSeconds: Int?
        /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, containerType: ContainerType, createdAt: Date, dashManifests: [GetDashManifestConfiguration]? = nil, description: String? = nil, eTag: String? = nil, forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration? = nil, hlsManifests: [GetHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]? = nil, modifiedAt: Date, originEndpointName: String, segment: Segment, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.dashManifests = dashManifests
            self.description = description
            self.eTag = eTag
            self.forceEndpointErrorConfiguration = forceEndpointErrorConfiguration
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case containerType = "ContainerType"
            case createdAt = "CreatedAt"
            case dashManifests = "DashManifests"
            case description = "Description"
            case eTag = "ETag"
            case forceEndpointErrorConfiguration = "ForceEndpointErrorConfiguration"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
            case tags = "Tags"
        }
    }

    public struct DashUtcTiming: AWSEncodableShape & AWSDecodableShape {
        /// The UTC timing mode.
        public let timingMode: DashUtcTimingMode?
        /// The the method that the player uses to synchronize to coordinated universal time (UTC) wall clock time.
        public let timingSource: String?

        @inlinable
        public init(timingMode: DashUtcTimingMode? = nil, timingSource: String? = nil) {
            self.timingMode = timingMode
            self.timingSource = timingSource
        }

        private enum CodingKeys: String, CodingKey {
            case timingMode = "TimingMode"
            case timingSource = "TimingSource"
        }
    }

    public struct DeleteChannelGroupRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String

        @inlinable
        public init(channelGroupName: String) {
            self.channelGroupName = channelGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteChannelPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String

        @inlinable
        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteChannelRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String

        @inlinable
        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOriginEndpointPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        @inlinable
        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOriginEndpointPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOriginEndpointRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        @inlinable
        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOriginEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Destination: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for exporting harvested content to an S3 bucket. This includes details such as the bucket name and destination path within the bucket.
        public let s3Destination: S3DestinationConfig

        @inlinable
        public init(s3Destination: S3DestinationConfig) {
            self.s3Destination = s3Destination
        }

        public func validate(name: String) throws {
            try self.s3Destination.validate(name: "\(name).s3Destination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Destination = "S3Destination"
        }
    }

    public struct Encryption: AWSEncodableShape & AWSDecodableShape {
        /// A 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting content. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public let constantInitializationVector: String?
        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod
        /// The frequency (in seconds) of key changes for live workflows, in which content is streamed real time. The service retrieves content keys before the live content begins streaming, and then retrieves them as needed over the lifetime of the workflow. By default, key rotation is set to 300 seconds (5 minutes), the minimum rotation interval, which is equivalent to setting it to 300. If you don't enter an interval, content keys aren't rotated. The following example setting causes the service to rotate keys every thirty minutes: 1800
        public let keyRotationIntervalSeconds: Int?
        /// The parameters for the SPEKE key provider.
        public let spekeKeyProvider: SpekeKeyProvider

        @inlinable
        public init(constantInitializationVector: String? = nil, encryptionMethod: EncryptionMethod, keyRotationIntervalSeconds: Int? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "ConstantInitializationVector"
            case encryptionMethod = "EncryptionMethod"
            case keyRotationIntervalSeconds = "KeyRotationIntervalSeconds"
            case spekeKeyProvider = "SpekeKeyProvider"
        }
    }

    public struct EncryptionContractConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of audio encryption presets. Value description:    PRESET-AUDIO-1 - Use one content key to encrypt all of the audio tracks in your stream.   PRESET-AUDIO-2 - Use one content key to encrypt all of the stereo audio tracks and one content key to encrypt all of the multichannel audio tracks.   PRESET-AUDIO-3 - Use one content key to encrypt all of the stereo audio tracks, one content key to encrypt all of the multichannel audio tracks with 3 to 6 channels, and one content key to encrypt all of the multichannel audio tracks with more than 6 channels.   SHARED - Use the same content key for all of the audio and video tracks in your stream.   UNENCRYPTED - Don't encrypt any of the audio tracks in your stream.
        public let presetSpeke20Audio: PresetSpeke20Audio
        /// A collection of video encryption presets. Value description:    PRESET-VIDEO-1 - Use one content key to encrypt all of the video tracks in your stream.   PRESET-VIDEO-2 - Use one content key to encrypt all of the SD video tracks and one content key for all HD and higher resolutions video tracks.   PRESET-VIDEO-3 - Use one content key to encrypt all of the SD video tracks, one content key for HD video tracks and one content key for all UHD video tracks.   PRESET-VIDEO-4 - Use one content key to encrypt all of the SD video tracks, one content key for HD video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.   PRESET-VIDEO-5 - Use one content key to encrypt all of the SD video tracks, one content key for HD1 video tracks, one content key for HD2 video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.   PRESET-VIDEO-6 - Use one content key to encrypt all of the SD video tracks, one content key for HD1 video tracks, one content key for HD2 video tracks and one content key for all UHD video tracks.   PRESET-VIDEO-7 - Use one content key to encrypt all of the SD+HD1 video tracks, one content key for HD2 video tracks and one content key for all UHD video tracks.   PRESET-VIDEO-8 - Use one content key to encrypt all of the SD+HD1 video tracks, one content key for HD2 video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.   SHARED - Use the same content key for all of the video and audio tracks in your stream.   UNENCRYPTED - Don't encrypt any of the video tracks in your stream.
        public let presetSpeke20Video: PresetSpeke20Video

        @inlinable
        public init(presetSpeke20Audio: PresetSpeke20Audio, presetSpeke20Video: PresetSpeke20Video) {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }

        private enum CodingKeys: String, CodingKey {
            case presetSpeke20Audio = "PresetSpeke20Audio"
            case presetSpeke20Video = "PresetSpeke20Video"
        }
    }

    public struct EncryptionMethod: AWSEncodableShape & AWSDecodableShape {
        /// The encryption method to use.
        public let cmafEncryptionMethod: CmafEncryptionMethod?
        /// The encryption method to use.
        public let tsEncryptionMethod: TsEncryptionMethod?

        @inlinable
        public init(cmafEncryptionMethod: CmafEncryptionMethod? = nil, tsEncryptionMethod: TsEncryptionMethod? = nil) {
            self.cmafEncryptionMethod = cmafEncryptionMethod
            self.tsEncryptionMethod = tsEncryptionMethod
        }

        private enum CodingKeys: String, CodingKey {
            case cmafEncryptionMethod = "CmafEncryptionMethod"
            case tsEncryptionMethod = "TsEncryptionMethod"
        }
    }

    public struct FilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Optionally specify the clip start time for all of your manifest egress requests. When you include clip start time, note that you cannot use clip start time query parameters for this manifest's endpoint URL.
        public let clipStartTime: Date?
        /// Optionally specify the end time for all of your manifest egress requests. When you include end time, note that you cannot use end time query parameters for this manifest's endpoint URL.
        public let end: Date?
        /// Optionally specify one or more manifest filters for all of your manifest egress requests. When you include a manifest filter, note that you cannot use an identical manifest filter query parameter for this manifest's endpoint URL.
        public let manifestFilter: String?
        /// Optionally specify the start time for all of your manifest egress requests. When you include start time, note that you cannot use start time query parameters for this manifest's endpoint URL.
        public let start: Date?
        /// Optionally specify the time delay for all of your manifest egress requests. Enter a value that is smaller than your endpoint's startover window. When you include time delay, note that you cannot use time delay query parameters for this manifest's endpoint URL.
        public let timeDelaySeconds: Int?

        @inlinable
        public init(clipStartTime: Date? = nil, end: Date? = nil, manifestFilter: String? = nil, start: Date? = nil, timeDelaySeconds: Int? = nil) {
            self.clipStartTime = clipStartTime
            self.end = end
            self.manifestFilter = manifestFilter
            self.start = start
            self.timeDelaySeconds = timeDelaySeconds
        }

        private enum CodingKeys: String, CodingKey {
            case clipStartTime = "ClipStartTime"
            case end = "End"
            case manifestFilter = "ManifestFilter"
            case start = "Start"
            case timeDelaySeconds = "TimeDelaySeconds"
        }
    }

    public struct ForceEndpointErrorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The failover conditions for the endpoint. The options are:    STALE_MANIFEST - The manifest stalled and there are no new segments or parts.    INCOMPLETE_MANIFEST - There is a gap in the manifest.    MISSING_DRM_KEY - Key rotation is enabled but we're unable to fetch the key for the current key period.    SLATE_INPUT - The segments which contain slate content are considered to be missing content.
        public let endpointErrorConditions: [EndpointErrorCondition]?

        @inlinable
        public init(endpointErrorConditions: [EndpointErrorCondition]? = nil) {
            self.endpointErrorConditions = endpointErrorConditions
        }

        private enum CodingKeys: String, CodingKey {
            case endpointErrorConditions = "EndpointErrorConditions"
        }
    }

    public struct GetChannelGroupRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String

        @inlinable
        public init(channelGroupName: String) {
            self.channelGroupName = channelGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The date and time the channel group was created.
        public let createdAt: Date
        /// The description for your channel group.
        public let description: String?
        /// The output domain where the source stream should be sent. Integrate the domain with a downstream CDN (such as Amazon CloudFront) or playback device.
        public let egressDomain: String
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The date and time the channel group was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel group.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, createdAt: Date, description: String? = nil, egressDomain: String, eTag: String? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.egressDomain = egressDomain
            self.eTag = eTag
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case egressDomain = "EgressDomain"
            case eTag = "ETag"
            case modifiedAt = "ModifiedAt"
            case tags = "tags"
        }
    }

    public struct GetChannelPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String

        @inlinable
        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelPolicyResponse: AWSDecodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The policy assigned to the channel.
        public let policy: String

        @inlinable
        public init(channelGroupName: String, channelName: String, policy: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case policy = "Policy"
        }
    }

    public struct GetChannelRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String

        @inlinable
        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The date and time the channel was created.
        public let createdAt: Date
        /// The description for your channel.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        public let ingestEndpoints: [IngestEndpoint]?
        /// The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when InputType is CMAF.
        public let inputSwitchConfiguration: InputSwitchConfiguration?
        /// The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior. The allowed values are:    HLS - The HLS streaming specification (which defines M3U8 manifests and TS segments).    CMAF - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).
        public let inputType: InputType?
        /// The date and time the channel was modified.
        public let modifiedAt: Date
        /// The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when InputType is CMAF.
        public let outputHeaderConfiguration: OutputHeaderConfiguration?
        /// The time that the channel was last reset.
        public let resetAt: Date?
        /// The comma-separated list of tag key:value pairs assigned to the channel.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, eTag: String? = nil, ingestEndpoints: [IngestEndpoint]? = nil, inputSwitchConfiguration: InputSwitchConfiguration? = nil, inputType: InputType? = nil, modifiedAt: Date, outputHeaderConfiguration: OutputHeaderConfiguration? = nil, resetAt: Date? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.ingestEndpoints = ingestEndpoints
            self.inputSwitchConfiguration = inputSwitchConfiguration
            self.inputType = inputType
            self.modifiedAt = modifiedAt
            self.outputHeaderConfiguration = outputHeaderConfiguration
            self.resetAt = resetAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case ingestEndpoints = "IngestEndpoints"
            case inputSwitchConfiguration = "InputSwitchConfiguration"
            case inputType = "InputType"
            case modifiedAt = "ModifiedAt"
            case outputHeaderConfiguration = "OutputHeaderConfiguration"
            case resetAt = "ResetAt"
            case tags = "Tags"
        }
    }

    public struct GetDashManifestConfiguration: AWSDecodableShape {
        /// Determines how the DASH manifest signals the DRM content.
        public let drmSignaling: DashDrmSignaling?
        public let filterConfiguration: FilterConfiguration?
        /// A short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Minimum amount of content (in seconds) that a player must keep available in the buffer.
        public let minBufferTimeSeconds: Int?
        /// Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest.
        public let minUpdatePeriodSeconds: Int?
        /// A list of triggers that controls when AWS Elemental MediaPackage separates the MPEG-DASH manifest into multiple periods. Leave this value empty to indicate that the manifest is contained all in one period. For more information about periods in the DASH manifest, see Multi-period DASH in AWS Elemental MediaPackage.
        public let periodTriggers: [DashPeriodTrigger]?
        /// The SCTE configuration.
        public let scteDash: ScteDash?
        /// Determines the type of variable used in the media URL of the SegmentTemplate tag in the manifest. Also specifies if segment timeline information is included in SegmentTimeline or SegmentTemplate. Value description:    NUMBER_WITH_TIMELINE - The $Number$ variable is used in the media URL. The value of this variable is the sequential number of the segment. A full SegmentTimeline object is presented in each SegmentTemplate.
        public let segmentTemplateFormat: DashSegmentTemplateFormat?
        /// The amount of time (in seconds) that the player should be from the end of the manifest.
        public let suggestedPresentationDelaySeconds: Int?
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String
        /// Determines the type of UTC timing included in the DASH Media Presentation Description (MPD).
        public let utcTiming: DashUtcTiming?

        @inlinable
        public init(drmSignaling: DashDrmSignaling? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, minBufferTimeSeconds: Int? = nil, minUpdatePeriodSeconds: Int? = nil, periodTriggers: [DashPeriodTrigger]? = nil, scteDash: ScteDash? = nil, segmentTemplateFormat: DashSegmentTemplateFormat? = nil, suggestedPresentationDelaySeconds: Int? = nil, url: String, utcTiming: DashUtcTiming? = nil) {
            self.drmSignaling = drmSignaling
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.scteDash = scteDash
            self.segmentTemplateFormat = segmentTemplateFormat
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
            self.url = url
            self.utcTiming = utcTiming
        }

        private enum CodingKeys: String, CodingKey {
            case drmSignaling = "DrmSignaling"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case minBufferTimeSeconds = "MinBufferTimeSeconds"
            case minUpdatePeriodSeconds = "MinUpdatePeriodSeconds"
            case periodTriggers = "PeriodTriggers"
            case scteDash = "ScteDash"
            case segmentTemplateFormat = "SegmentTemplateFormat"
            case suggestedPresentationDelaySeconds = "SuggestedPresentationDelaySeconds"
            case url = "Url"
            case utcTiming = "UtcTiming"
        }
    }

    public struct GetHarvestJobRequest: AWSEncodableShape {
        /// The name of the channel group containing the channel associated with the harvest job.
        public let channelGroupName: String
        /// The name of the channel associated with the harvest job.
        public let channelName: String
        /// The name of the harvest job to retrieve.
        public let harvestJobName: String
        /// The name of the origin endpoint associated with the harvest job.
        public let originEndpointName: String

        @inlinable
        public init(channelGroupName: String, channelName: String, harvestJobName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.harvestJobName = harvestJobName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.harvestJobName, key: "HarvestJobName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, max: 256)
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, min: 1)
            try self.validate(self.harvestJobName, name: "harvestJobName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetHarvestJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the harvest job.
        public let arn: String
        /// The name of the channel group containing the channel associated with the harvest job.
        public let channelGroupName: String
        /// The name of the channel associated with the harvest job.
        public let channelName: String
        /// The date and time when the harvest job was created.
        public let createdAt: Date
        /// The description of the harvest job, if provided.
        public let description: String?
        /// The S3 destination where the harvested content is being placed.
        public let destination: Destination
        /// An error message if the harvest job encountered any issues.
        public let errorMessage: String?
        /// The current version of the harvest job. Used for concurrency control.
        public let eTag: String?
        /// A list of manifests that are being or have been harvested.
        public let harvestedManifests: HarvestedManifests
        /// The name of the harvest job.
        public let harvestJobName: String
        /// The date and time when the harvest job was last modified.
        public let modifiedAt: Date
        /// The name of the origin endpoint associated with the harvest job.
        public let originEndpointName: String
        /// The configuration for when the harvest job is scheduled to run, including start and end times.
        public let scheduleConfiguration: HarvesterScheduleConfiguration
        /// The current status of the harvest job (e.g., QUEUED, IN_PROGRESS, CANCELLED, COMPLETED, FAILED).
        public let status: HarvestJobStatus
        /// A collection of tags associated with the harvest job.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, destination: Destination, errorMessage: String? = nil, eTag: String? = nil, harvestedManifests: HarvestedManifests, harvestJobName: String, modifiedAt: Date, originEndpointName: String, scheduleConfiguration: HarvesterScheduleConfiguration, status: HarvestJobStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.destination = destination
            self.errorMessage = errorMessage
            self.eTag = eTag
            self.harvestedManifests = harvestedManifests
            self.harvestJobName = harvestJobName
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.scheduleConfiguration = scheduleConfiguration
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case destination = "Destination"
            case errorMessage = "ErrorMessage"
            case eTag = "ETag"
            case harvestedManifests = "HarvestedManifests"
            case harvestJobName = "HarvestJobName"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case scheduleConfiguration = "ScheduleConfiguration"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct GetHlsManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        public let filterConfiguration: FilterConfiguration?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public let programDateTimeIntervalSeconds: Int?
        public let scteHls: ScteHls?
        public let startTag: StartTag?
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String
        /// When enabled, MediaPackage URL-encodes the query string for API requests for HLS child manifests to comply with Amazon Web Services Signature Version 4 (SigV4) signature signing protocol. For more information, see Amazon Web Services Signature Version 4 for API requests in Identity and Access Management User Guide.
        public let urlEncodeChildManifest: Bool?

        @inlinable
        public init(childManifestName: String? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, scteHls: ScteHls? = nil, startTag: StartTag? = nil, url: String, urlEncodeChildManifest: Bool? = nil) {
            self.childManifestName = childManifestName
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.startTag = startTag
            self.url = url
            self.urlEncodeChildManifest = urlEncodeChildManifest
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
            case scteHls = "ScteHls"
            case startTag = "StartTag"
            case url = "Url"
            case urlEncodeChildManifest = "UrlEncodeChildManifest"
        }
    }

    public struct GetLowLatencyHlsManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        public let filterConfiguration: FilterConfiguration?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public let programDateTimeIntervalSeconds: Int?
        public let scteHls: ScteHls?
        public let startTag: StartTag?
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String
        /// When enabled, MediaPackage URL-encodes the query string for API requests for LL-HLS child manifests to comply with Amazon Web Services Signature Version 4 (SigV4) signature signing protocol. For more information, see Amazon Web Services Signature Version 4 for API requests in Identity and Access Management User Guide.
        public let urlEncodeChildManifest: Bool?

        @inlinable
        public init(childManifestName: String? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, scteHls: ScteHls? = nil, startTag: StartTag? = nil, url: String, urlEncodeChildManifest: Bool? = nil) {
            self.childManifestName = childManifestName
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.startTag = startTag
            self.url = url
            self.urlEncodeChildManifest = urlEncodeChildManifest
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
            case scteHls = "ScteHls"
            case startTag = "StartTag"
            case url = "Url"
            case urlEncodeChildManifest = "UrlEncodeChildManifest"
        }
    }

    public struct GetOriginEndpointPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        @inlinable
        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOriginEndpointPolicyResponse: AWSDecodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The policy assigned to the origin endpoint.
        public let policy: String

        @inlinable
        public init(channelGroupName: String, channelName: String, originEndpointName: String, policy: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case originEndpointName = "OriginEndpointName"
            case policy = "Policy"
        }
    }

    public struct GetOriginEndpointRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        @inlinable
        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint.
        public let containerType: ContainerType
        /// The date and time the origin endpoint was created.
        public let createdAt: Date
        /// A DASH manifest configuration.
        public let dashManifests: [GetDashManifestConfiguration]?
        /// The description for your origin endpoint.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The failover settings for the endpoint.
        public let forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [GetHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public let modifiedAt: Date
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The time that the origin endpoint was last reset.
        public let resetAt: Date?
        public let segment: Segment
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
        public let startoverWindowSeconds: Int?
        /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, containerType: ContainerType, createdAt: Date, dashManifests: [GetDashManifestConfiguration]? = nil, description: String? = nil, eTag: String? = nil, forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration? = nil, hlsManifests: [GetHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]? = nil, modifiedAt: Date, originEndpointName: String, resetAt: Date? = nil, segment: Segment, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.dashManifests = dashManifests
            self.description = description
            self.eTag = eTag
            self.forceEndpointErrorConfiguration = forceEndpointErrorConfiguration
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.resetAt = resetAt
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case containerType = "ContainerType"
            case createdAt = "CreatedAt"
            case dashManifests = "DashManifests"
            case description = "Description"
            case eTag = "ETag"
            case forceEndpointErrorConfiguration = "ForceEndpointErrorConfiguration"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case resetAt = "ResetAt"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
            case tags = "Tags"
        }
    }

    public struct HarvestJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the harvest job.
        public let arn: String
        /// The name of the channel group containing the channel associated with this harvest job.
        public let channelGroupName: String
        /// The name of the channel associated with this harvest job.
        public let channelName: String
        /// The date and time when the harvest job was created.
        public let createdAt: Date
        /// An optional description of the harvest job.
        public let description: String?
        /// The S3 destination where the harvested content will be placed.
        public let destination: Destination
        /// An error message if the harvest job encountered any issues.
        public let errorMessage: String?
        /// The current version of the harvest job. Used for concurrency control.
        public let eTag: String?
        /// A list of manifests that are being or have been harvested.
        public let harvestedManifests: HarvestedManifests
        /// The name of the harvest job.
        public let harvestJobName: String
        /// The date and time when the harvest job was last modified.
        public let modifiedAt: Date
        /// The name of the origin endpoint associated with this harvest job.
        public let originEndpointName: String
        /// The configuration for when the harvest job is scheduled to run.
        public let scheduleConfiguration: HarvesterScheduleConfiguration
        /// The current status of the harvest job (e.g., QUEUED, IN_PROGRESS, CANCELLED, COMPLETED, FAILED).
        public let status: HarvestJobStatus

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, destination: Destination, errorMessage: String? = nil, eTag: String? = nil, harvestedManifests: HarvestedManifests, harvestJobName: String, modifiedAt: Date, originEndpointName: String, scheduleConfiguration: HarvesterScheduleConfiguration, status: HarvestJobStatus) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.destination = destination
            self.errorMessage = errorMessage
            self.eTag = eTag
            self.harvestedManifests = harvestedManifests
            self.harvestJobName = harvestJobName
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.scheduleConfiguration = scheduleConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case destination = "Destination"
            case errorMessage = "ErrorMessage"
            case eTag = "ETag"
            case harvestedManifests = "HarvestedManifests"
            case harvestJobName = "HarvestJobName"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case scheduleConfiguration = "ScheduleConfiguration"
            case status = "Status"
        }
    }

    public struct HarvestedDashManifest: AWSEncodableShape & AWSDecodableShape {
        /// The name of the harvested DASH manifest.
        public let manifestName: String

        @inlinable
        public init(manifestName: String) {
            self.manifestName = manifestName
        }

        public func validate(name: String) throws {
            try self.validate(self.manifestName, name: "manifestName", parent: name, max: 256)
            try self.validate(self.manifestName, name: "manifestName", parent: name, min: 1)
            try self.validate(self.manifestName, name: "manifestName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case manifestName = "ManifestName"
        }
    }

    public struct HarvestedHlsManifest: AWSEncodableShape & AWSDecodableShape {
        /// The name of the harvested HLS manifest.
        public let manifestName: String

        @inlinable
        public init(manifestName: String) {
            self.manifestName = manifestName
        }

        public func validate(name: String) throws {
            try self.validate(self.manifestName, name: "manifestName", parent: name, max: 256)
            try self.validate(self.manifestName, name: "manifestName", parent: name, min: 1)
            try self.validate(self.manifestName, name: "manifestName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case manifestName = "ManifestName"
        }
    }

    public struct HarvestedLowLatencyHlsManifest: AWSEncodableShape & AWSDecodableShape {
        /// The name of the harvested Low-Latency HLS manifest.
        public let manifestName: String

        @inlinable
        public init(manifestName: String) {
            self.manifestName = manifestName
        }

        public func validate(name: String) throws {
            try self.validate(self.manifestName, name: "manifestName", parent: name, max: 256)
            try self.validate(self.manifestName, name: "manifestName", parent: name, min: 1)
            try self.validate(self.manifestName, name: "manifestName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case manifestName = "ManifestName"
        }
    }

    public struct HarvestedManifests: AWSEncodableShape & AWSDecodableShape {
        /// A list of harvested DASH manifests.
        public let dashManifests: [HarvestedDashManifest]?
        /// A list of harvested HLS manifests.
        public let hlsManifests: [HarvestedHlsManifest]?
        /// A list of harvested Low-Latency HLS manifests.
        public let lowLatencyHlsManifests: [HarvestedLowLatencyHlsManifest]?

        @inlinable
        public init(dashManifests: [HarvestedDashManifest]? = nil, hlsManifests: [HarvestedHlsManifest]? = nil, lowLatencyHlsManifests: [HarvestedLowLatencyHlsManifest]? = nil) {
            self.dashManifests = dashManifests
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
        }

        public func validate(name: String) throws {
            try self.dashManifests?.forEach {
                try $0.validate(name: "\(name).dashManifests[]")
            }
            try self.hlsManifests?.forEach {
                try $0.validate(name: "\(name).hlsManifests[]")
            }
            try self.lowLatencyHlsManifests?.forEach {
                try $0.validate(name: "\(name).lowLatencyHlsManifests[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dashManifests = "DashManifests"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
        }
    }

    public struct HarvesterScheduleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The end time for the harvest job.
        public let endTime: Date
        /// The start time for the harvest job.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct IngestEndpoint: AWSDecodableShape {
        /// The system-generated unique identifier for the IngestEndpoint.
        public let id: String?
        /// The ingest domain URL where the source stream should be sent.
        public let url: String?

        @inlinable
        public init(id: String? = nil, url: String? = nil) {
            self.id = id
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case url = "Url"
        }
    }

    public struct InputSwitchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// When true, AWS Elemental MediaPackage performs input switching based on the MQCS. Default is true. This setting is valid only when InputType is CMAF.
        public let mqcsInputSwitching: Bool?

        @inlinable
        public init(mqcsInputSwitching: Bool? = nil) {
            self.mqcsInputSwitching = mqcsInputSwitching
        }

        private enum CodingKeys: String, CodingKey {
            case mqcsInputSwitching = "MQCSInputSwitching"
        }
    }

    public struct ListChannelGroupsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelGroupsResponse: AWSDecodableShape {
        /// The objects being returned.
        public let items: [ChannelGroupListConfiguration]?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ChannelGroupListConfiguration]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        @inlinable
        public init(channelGroupName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelGroupName = channelGroupName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// The objects being returned.
        public let items: [ChannelListConfiguration]?
        /// The pagination token from the GET list request.
        public let nextToken: String?

        @inlinable
        public init(items: [ChannelListConfiguration]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListDashManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index.
        public let manifestName: String
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String?

        @inlinable
        public init(manifestName: String, url: String? = nil) {
            self.manifestName = manifestName
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case manifestName = "ManifestName"
            case url = "Url"
        }
    }

    public struct ListHarvestJobsRequest: AWSEncodableShape {
        /// The name of the channel group to filter the harvest jobs by. If specified, only harvest jobs associated with channels in this group will be returned.
        public let channelGroupName: String
        /// The name of the channel to filter the harvest jobs by. If specified, only harvest jobs associated with this channel will be returned.
        public let channelName: String?
        /// The maximum number of harvest jobs to return in a single request. If not specified, a default value will be used.
        public let maxResults: Int?
        /// A token used for pagination. Provide this value in subsequent requests to retrieve the next set of results.
        public let nextToken: String?
        /// The name of the origin endpoint to filter the harvest jobs by. If specified, only harvest jobs associated with this origin endpoint will be returned.
        public let originEndpointName: String?
        /// The status to filter the harvest jobs by. If specified, only harvest jobs with this status will be returned.
        public let status: HarvestJobStatus?

        @inlinable
        public init(channelGroupName: String, channelName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, originEndpointName: String? = nil, status: HarvestJobStatus? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.originEndpointName = originEndpointName
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodeQuery(self.channelName, key: "channelName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.originEndpointName, key: "originEndpointName")
            request.encodeQuery(self.status, key: "includeStatus")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHarvestJobsResponse: AWSDecodableShape {
        /// An array of harvest job objects that match the specified criteria.
        public let items: [HarvestJob]?
        /// A token used for pagination. Include this value in subsequent requests to retrieve the next set of results. If null, there are no more results to retrieve.
        public let nextToken: String?

        @inlinable
        public init(items: [HarvestJob]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListHlsManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String?

        @inlinable
        public init(childManifestName: String? = nil, manifestName: String, url: String? = nil) {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case manifestName = "ManifestName"
            case url = "Url"
        }
    }

    public struct ListLowLatencyHlsManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String?

        @inlinable
        public init(childManifestName: String? = nil, manifestName: String, url: String? = nil) {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case manifestName = "ManifestName"
            case url = "Url"
        }
    }

    public struct ListOriginEndpointsRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        @inlinable
        public init(channelGroupName: String, channelName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOriginEndpointsResponse: AWSDecodableShape {
        /// The objects being returned.
        public let items: [OriginEndpointListConfiguration]?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [OriginEndpointListConfiguration]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the CloudWatch resource that you want to view tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct OriginEndpointListConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file.
        public let containerType: ContainerType
        /// The date and time the origin endpoint was created.
        public let createdAt: Date?
        /// A DASH manifest configuration.
        public let dashManifests: [ListDashManifestConfiguration]?
        /// Any descriptive information that you want to add to the origin endpoint for future identification purposes.
        public let description: String?
        /// The failover settings for the endpoint.
        public let forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [ListHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [ListLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public let modifiedAt: Date?
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, containerType: ContainerType, createdAt: Date? = nil, dashManifests: [ListDashManifestConfiguration]? = nil, description: String? = nil, forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration? = nil, hlsManifests: [ListHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [ListLowLatencyHlsManifestConfiguration]? = nil, modifiedAt: Date? = nil, originEndpointName: String) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.dashManifests = dashManifests
            self.description = description
            self.forceEndpointErrorConfiguration = forceEndpointErrorConfiguration
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case containerType = "ContainerType"
            case createdAt = "CreatedAt"
            case dashManifests = "DashManifests"
            case description = "Description"
            case forceEndpointErrorConfiguration = "ForceEndpointErrorConfiguration"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
        }
    }

    public struct OutputHeaderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// When true, AWS Elemental MediaPackage includes the MQCS in responses to the CDN. This setting is valid only when InputType is CMAF.
        public let publishMQCS: Bool?

        @inlinable
        public init(publishMQCS: Bool? = nil) {
            self.publishMQCS = publishMQCS
        }

        private enum CodingKeys: String, CodingKey {
            case publishMQCS = "PublishMQCS"
        }
    }

    public struct PutChannelPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The policy to attach to the specified channel.
        public let policy: String

        @inlinable
        public init(channelGroupName: String, channelName: String, policy: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encode(self.policy, forKey: .policy)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 6144)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutChannelPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutOriginEndpointPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The policy to attach to the specified origin endpoint.
        public let policy: String

        @inlinable
        public init(channelGroupName: String, channelName: String, originEndpointName: String, policy: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
            try container.encode(self.policy, forKey: .policy)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 6144)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutOriginEndpointPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ResetChannelStateRequest: AWSEncodableShape {
        /// The name of the channel group that contains the channel that you are resetting.
        public let channelGroupName: String
        /// The name of the channel that you are resetting.
        public let channelName: String

        @inlinable
        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ResetChannelStateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the channel that you just reset.
        public let arn: String
        /// The name of the channel group that contains the channel that you just reset.
        public let channelGroupName: String
        /// The name of the channel that you just reset.
        public let channelName: String
        /// The time that the channel was last reset.
        public let resetAt: Date

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, resetAt: Date) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.resetAt = resetAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case resetAt = "ResetAt"
        }
    }

    public struct ResetOriginEndpointStateRequest: AWSEncodableShape {
        /// The name of the channel group that contains the channel with the origin endpoint that you are resetting.
        public let channelGroupName: String
        /// The name of the channel with the origin endpoint that you are resetting.
        public let channelName: String
        /// The name of the origin endpoint that you are resetting.
        public let originEndpointName: String

        @inlinable
        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ResetOriginEndpointStateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the endpoint that you just reset.
        public let arn: String
        /// The name of the channel group that contains the channel with the origin endpoint that you just reset.
        public let channelGroupName: String
        /// The name of the channel with the origin endpoint that you just reset.
        public let channelName: String
        /// The name of the origin endpoint that you just reset.
        public let originEndpointName: String
        /// The time that the origin endpoint was last reset.
        public let resetAt: Date

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, originEndpointName: String, resetAt: Date) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
            self.resetAt = resetAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case originEndpointName = "OriginEndpointName"
            case resetAt = "ResetAt"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// The specified resource type wasn't found.
        public let resourceTypeNotFound: ResourceTypeNotFound?

        @inlinable
        public init(message: String? = nil, resourceTypeNotFound: ResourceTypeNotFound? = nil) {
            self.message = message
            self.resourceTypeNotFound = resourceTypeNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceTypeNotFound = "ResourceTypeNotFound"
        }
    }

    public struct S3DestinationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of an S3 bucket within which harvested content will be exported.
        public let bucketName: String
        /// The path within the specified S3 bucket where the harvested content will be placed.
        public let destinationPath: String

        @inlinable
        public init(bucketName: String, destinationPath: String) {
            self.bucketName = bucketName
            self.destinationPath = destinationPath
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.destinationPath, name: "destinationPath", parent: name, max: 1024)
            try self.validate(self.destinationPath, name: "destinationPath", parent: name, min: 1)
            try self.validate(self.destinationPath, name: "destinationPath", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case destinationPath = "DestinationPath"
        }
    }

    public struct Scte: AWSEncodableShape & AWSDecodableShape {
        /// The SCTE-35 message types that you want to be treated as ad markers in the output.
        public let scteFilter: [ScteFilter]?

        @inlinable
        public init(scteFilter: [ScteFilter]? = nil) {
            self.scteFilter = scteFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.scteFilter, name: "scteFilter", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case scteFilter = "ScteFilter"
        }
    }

    public struct ScteDash: AWSEncodableShape & AWSDecodableShape {
        /// Choose how ad markers are included in the packaged content. If you include ad markers in the content stream in your upstream encoders, then you need to inform MediaPackage what to do with the ad markers in the output. Value description:    Binary - The SCTE-35 marker is expressed as a hex-string (Base64 string) rather than full XML.    XML - The SCTE marker is expressed fully in XML.
        public let adMarkerDash: AdMarkerDash?

        @inlinable
        public init(adMarkerDash: AdMarkerDash? = nil) {
            self.adMarkerDash = adMarkerDash
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkerDash = "AdMarkerDash"
        }
    }

    public struct ScteHls: AWSEncodableShape & AWSDecodableShape {
        /// Ad markers indicate when ads should be inserted during playback. If you include ad markers in the content stream in your upstream encoders, then you need to inform MediaPackage what to do with the ad markers in the output. Choose what you want MediaPackage to do with the ad markers. Value description:    DATERANGE - Insert EXT-X-DATERANGE tags to signal ad and program transition events in TS and CMAF manifests. If you use DATERANGE, you must set a programDateTimeIntervalSeconds value of 1 or higher. To learn more about DATERANGE, see SCTE-35 Ad Marker EXT-X-DATERANGE.
        public let adMarkerHls: AdMarkerHls?

        @inlinable
        public init(adMarkerHls: AdMarkerHls? = nil) {
            self.adMarkerHls = adMarkerHls
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkerHls = "AdMarkerHls"
        }
    }

    public struct Segment: AWSEncodableShape & AWSDecodableShape {
        public let encryption: Encryption?
        /// When selected, the stream set includes an additional I-frame only stream, along with the other tracks. If false, this extra stream is not included. MediaPackage generates an I-frame only stream from the first rendition in the manifest. The service inserts EXT-I-FRAMES-ONLY tags in the output manifest, and then generates and includes an I-frames only playlist in the stream. This playlist permits player functionality like fast forward and rewind.
        public let includeIframeOnlyStreams: Bool?
        /// The SCTE configuration options in the segment settings.
        public let scte: Scte?
        /// The duration (in seconds) of each segment. Enter a value equal to, or a multiple of, the input segment duration. If the value that you enter is different from the input segment duration, MediaPackage rounds segments to the nearest multiple of the input segment duration.
        public let segmentDurationSeconds: Int?
        /// The name that describes the segment. The name is the base name of the segment used in all content manifests inside of the endpoint. You can't use spaces in the name.
        public let segmentName: String?
        /// By default, MediaPackage excludes all digital video broadcasting (DVB) subtitles from the output. When selected, MediaPackage passes through DVB subtitles into the output.
        public let tsIncludeDvbSubtitles: Bool?
        /// When selected, MediaPackage bundles all audio tracks in a rendition group. All other tracks in the stream can be used with any audio rendition from the group.
        public let tsUseAudioRenditionGroup: Bool?

        @inlinable
        public init(encryption: Encryption? = nil, includeIframeOnlyStreams: Bool? = nil, scte: Scte? = nil, segmentDurationSeconds: Int? = nil, segmentName: String? = nil, tsIncludeDvbSubtitles: Bool? = nil, tsUseAudioRenditionGroup: Bool? = nil) {
            self.encryption = encryption
            self.includeIframeOnlyStreams = includeIframeOnlyStreams
            self.scte = scte
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentName = segmentName
            self.tsIncludeDvbSubtitles = tsIncludeDvbSubtitles
            self.tsUseAudioRenditionGroup = tsUseAudioRenditionGroup
        }

        public func validate(name: String) throws {
            try self.scte?.validate(name: "\(name).scte")
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "Encryption"
            case includeIframeOnlyStreams = "IncludeIframeOnlyStreams"
            case scte = "Scte"
            case segmentDurationSeconds = "SegmentDurationSeconds"
            case segmentName = "SegmentName"
            case tsIncludeDvbSubtitles = "TsIncludeDvbSubtitles"
            case tsUseAudioRenditionGroup = "TsUseAudioRenditionGroup"
        }
    }

    public struct SpekeKeyProvider: AWSEncodableShape & AWSDecodableShape {
        /// The DRM solution provider you're using to protect your content during distribution.
        public let drmSystems: [DrmSystem]
        /// Configure one or more content encryption keys for your endpoints that use SPEKE Version 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use.
        public let encryptionContractConfiguration: EncryptionContractConfiguration
        /// The unique identifier for the content. The service sends this to the key server to identify the current endpoint. How unique you make this depends on how fine-grained you want access controls to be. The service does not permit you to use the same ID for two simultaneous encryption processes. The resource ID is also known as the content ID. The following example shows a resource ID: MovieNight20171126093045
        public let resourceId: String
        /// The ARN for the IAM role granted by the key provider that provides access to the key provider API. This role must have a trust policy that allows MediaPackage to assume the role, and it must have a sufficient permissions policy to allow access to the specific key retrieval URL. Get this from your DRM solution provider. Valid format: arn:aws:iam::{accountID}:role/{name}. The following example shows a role ARN: arn:aws:iam::444455556666:role/SpekeAccess
        public let roleArn: String
        /// The URL of the API Gateway proxy that you set up to talk to your key server. The API Gateway proxy must reside in the same AWS Region as MediaPackage and must start with https://. The following example shows a URL: https://1wm2dx1f33.execute-api.us-west-2.amazonaws.com/SpekeSample/copyProtection
        public let url: String

        @inlinable
        public init(drmSystems: [DrmSystem], encryptionContractConfiguration: EncryptionContractConfiguration, resourceId: String, roleArn: String, url: String) {
            self.drmSystems = drmSystems
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case drmSystems = "DrmSystems"
            case encryptionContractConfiguration = "EncryptionContractConfiguration"
            case resourceId = "ResourceId"
            case roleArn = "RoleArn"
            case url = "Url"
        }
    }

    public struct StartTag: AWSEncodableShape & AWSDecodableShape {
        /// Specify the value for PRECISE within your EXT-X-START tag. Leave blank, or choose false, to use the default value NO. Choose yes to use the value YES.
        public let precise: Bool?
        /// Specify the value for TIME-OFFSET within your EXT-X-START tag. Enter a signed floating point value which, if positive, must be less than the configured manifest duration minus three times the configured segment target duration. If negative, the absolute value must be larger than three times the configured segment target duration, and the absolute value must be smaller than the configured manifest duration.
        public let timeOffset: Float

        @inlinable
        public init(precise: Bool? = nil, timeOffset: Float) {
            self.precise = precise
            self.timeOffset = timeOffset
        }

        private enum CodingKeys: String, CodingKey {
            case precise = "Precise"
            case timeOffset = "TimeOffset"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the MediaPackage resource that you're adding tags to.
        public let resourceArn: String
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the MediaPackage resource that you're removing tags from.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateChannelGroupRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// Any descriptive information that you want to add to the channel group for future identification purposes.
        public let description: String?
        /// The expected current Entity Tag (ETag) for the resource. If the specified ETag does not match the resource's current entity tag, the update request will be rejected.
        public let eTag: String?

        @inlinable
        public init(channelGroupName: String, description: String? = nil, eTag: String? = nil) {
            self.channelGroupName = channelGroupName
            self.description = description
            self.eTag = eTag
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.eTag, key: "x-amzn-update-if-match")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.eTag, name: "eTag", parent: name, max: 256)
            try self.validate(self.eTag, name: "eTag", parent: name, min: 1)
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateChannelGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The date and time the channel group was created.
        public let createdAt: Date
        /// The description for your channel group.
        public let description: String?
        /// The output domain where the source stream is sent. Integrate the domain with a downstream CDN (such as Amazon CloudFront) or playback device.
        public let egressDomain: String
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The date and time the channel group was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel group.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, createdAt: Date, description: String? = nil, egressDomain: String, eTag: String? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.egressDomain = egressDomain
            self.eTag = eTag
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case egressDomain = "EgressDomain"
            case eTag = "ETag"
            case modifiedAt = "ModifiedAt"
            case tags = "tags"
        }
    }

    public struct UpdateChannelRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// Any descriptive information that you want to add to the channel for future identification purposes.
        public let description: String?
        /// The expected current Entity Tag (ETag) for the resource. If the specified ETag does not match the resource's current entity tag, the update request will be rejected.
        public let eTag: String?
        /// The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when InputType is CMAF.
        public let inputSwitchConfiguration: InputSwitchConfiguration?
        /// The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when InputType is CMAF.
        public let outputHeaderConfiguration: OutputHeaderConfiguration?

        @inlinable
        public init(channelGroupName: String, channelName: String, description: String? = nil, eTag: String? = nil, inputSwitchConfiguration: InputSwitchConfiguration? = nil, outputHeaderConfiguration: OutputHeaderConfiguration? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.description = description
            self.eTag = eTag
            self.inputSwitchConfiguration = inputSwitchConfiguration
            self.outputHeaderConfiguration = outputHeaderConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.eTag, key: "x-amzn-update-if-match")
            try container.encodeIfPresent(self.inputSwitchConfiguration, forKey: .inputSwitchConfiguration)
            try container.encodeIfPresent(self.outputHeaderConfiguration, forKey: .outputHeaderConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.eTag, name: "eTag", parent: name, max: 256)
            try self.validate(self.eTag, name: "eTag", parent: name, min: 1)
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case inputSwitchConfiguration = "InputSwitchConfiguration"
            case outputHeaderConfiguration = "OutputHeaderConfiguration"
        }
    }

    public struct UpdateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The date and time the channel was created.
        public let createdAt: Date
        /// The description for your channel.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        public let ingestEndpoints: [IngestEndpoint]?
        /// The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when InputType is CMAF.
        public let inputSwitchConfiguration: InputSwitchConfiguration?
        /// The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior. The allowed values are:    HLS - The HLS streaming specification (which defines M3U8 manifests and TS segments).    CMAF - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).
        public let inputType: InputType?
        /// The date and time the channel was modified.
        public let modifiedAt: Date
        /// The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when InputType is CMAF.
        public let outputHeaderConfiguration: OutputHeaderConfiguration?
        /// The comma-separated list of tag key:value pairs assigned to the channel.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, eTag: String? = nil, ingestEndpoints: [IngestEndpoint]? = nil, inputSwitchConfiguration: InputSwitchConfiguration? = nil, inputType: InputType? = nil, modifiedAt: Date, outputHeaderConfiguration: OutputHeaderConfiguration? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.ingestEndpoints = ingestEndpoints
            self.inputSwitchConfiguration = inputSwitchConfiguration
            self.inputType = inputType
            self.modifiedAt = modifiedAt
            self.outputHeaderConfiguration = outputHeaderConfiguration
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case ingestEndpoints = "IngestEndpoints"
            case inputSwitchConfiguration = "InputSwitchConfiguration"
            case inputType = "InputType"
            case modifiedAt = "ModifiedAt"
            case outputHeaderConfiguration = "OutputHeaderConfiguration"
            case tags = "tags"
        }
    }

    public struct UpdateOriginEndpointRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file.
        public let containerType: ContainerType
        /// A DASH manifest configuration.
        public let dashManifests: [CreateDashManifestConfiguration]?
        /// Any descriptive information that you want to add to the origin endpoint for future identification purposes.
        public let description: String?
        /// The expected current Entity Tag (ETag) for the resource. If the specified ETag does not match the resource's current entity tag, the update request will be rejected.
        public let eTag: String?
        /// The failover settings for the endpoint.
        public let forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [CreateHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [CreateLowLatencyHlsManifestConfiguration]?
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The segment configuration, including the segment name, duration, and other configuration values.
        public let segment: Segment?
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window. The maximum startover window is 1,209,600 seconds (14 days).
        public let startoverWindowSeconds: Int?

        @inlinable
        public init(channelGroupName: String, channelName: String, containerType: ContainerType, dashManifests: [CreateDashManifestConfiguration]? = nil, description: String? = nil, eTag: String? = nil, forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration? = nil, hlsManifests: [CreateHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [CreateLowLatencyHlsManifestConfiguration]? = nil, originEndpointName: String, segment: Segment? = nil, startoverWindowSeconds: Int? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.dashManifests = dashManifests
            self.description = description
            self.eTag = eTag
            self.forceEndpointErrorConfiguration = forceEndpointErrorConfiguration
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encode(self.containerType, forKey: .containerType)
            try container.encodeIfPresent(self.dashManifests, forKey: .dashManifests)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.eTag, key: "x-amzn-update-if-match")
            try container.encodeIfPresent(self.forceEndpointErrorConfiguration, forKey: .forceEndpointErrorConfiguration)
            try container.encodeIfPresent(self.hlsManifests, forKey: .hlsManifests)
            try container.encodeIfPresent(self.lowLatencyHlsManifests, forKey: .lowLatencyHlsManifests)
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
            try container.encodeIfPresent(self.segment, forKey: .segment)
            try container.encodeIfPresent(self.startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.dashManifests?.forEach {
                try $0.validate(name: "\(name).dashManifests[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.eTag, name: "eTag", parent: name, max: 256)
            try self.validate(self.eTag, name: "eTag", parent: name, min: 1)
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "^[\\S]+$")
            try self.hlsManifests?.forEach {
                try $0.validate(name: "\(name).hlsManifests[]")
            }
            try self.lowLatencyHlsManifests?.forEach {
                try $0.validate(name: "\(name).lowLatencyHlsManifests[]")
            }
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.segment?.validate(name: "\(name).segment")
        }

        private enum CodingKeys: String, CodingKey {
            case containerType = "ContainerType"
            case dashManifests = "DashManifests"
            case description = "Description"
            case forceEndpointErrorConfiguration = "ForceEndpointErrorConfiguration"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
        }
    }

    public struct UpdateOriginEndpointResponse: AWSDecodableShape {
        /// The ARN associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint.
        public let containerType: ContainerType
        /// The date and time the origin endpoint was created.
        public let createdAt: Date
        /// A DASH manifest configuration.
        public let dashManifests: [GetDashManifestConfiguration]?
        /// The description of the origin endpoint.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The failover settings for the endpoint.
        public let forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [GetHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public let modifiedAt: Date
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The segment configuration, including the segment name, duration, and other configuration values.
        public let segment: Segment
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
        public let startoverWindowSeconds: Int?
        /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, channelGroupName: String, channelName: String, containerType: ContainerType, createdAt: Date, dashManifests: [GetDashManifestConfiguration]? = nil, description: String? = nil, eTag: String? = nil, forceEndpointErrorConfiguration: ForceEndpointErrorConfiguration? = nil, hlsManifests: [GetHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]? = nil, modifiedAt: Date, originEndpointName: String, segment: Segment, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.dashManifests = dashManifests
            self.description = description
            self.eTag = eTag
            self.forceEndpointErrorConfiguration = forceEndpointErrorConfiguration
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case containerType = "ContainerType"
            case createdAt = "CreatedAt"
            case dashManifests = "DashManifests"
            case description = "Description"
            case eTag = "ETag"
            case forceEndpointErrorConfiguration = "ForceEndpointErrorConfiguration"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
            case tags = "tags"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let message: String?
        /// The type of ValidationException.
        public let validationExceptionType: ValidationExceptionType?

        @inlinable
        public init(message: String? = nil, validationExceptionType: ValidationExceptionType? = nil) {
            self.message = message
            self.validationExceptionType = validationExceptionType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case validationExceptionType = "ValidationExceptionType"
        }
    }
}

// MARK: - Errors

/// Error enum for MediaPackageV2
public struct MediaPackageV2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MediaPackageV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see Access Management in the IAM User Guide.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting this resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Indicates that an error from the service occurred while trying to process a request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request throughput limit was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input failed to meet the constraints specified by the AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension MediaPackageV2ErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": MediaPackageV2.ConflictException.self,
        "ResourceNotFoundException": MediaPackageV2.ResourceNotFoundException.self,
        "ValidationException": MediaPackageV2.ValidationException.self
    ]
}

extension MediaPackageV2ErrorType: Equatable {
    public static func == (lhs: MediaPackageV2ErrorType, rhs: MediaPackageV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MediaPackageV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
