//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MediaPackageV2 {
    // MARK: Enums

    public enum AdMarkerHls: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daterange = "DATERANGE"
        public var description: String { return self.rawValue }
    }

    public enum CmafEncryptionMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cbcs = "CBCS"
        case cenc = "CENC"
        public var description: String { return self.rawValue }
    }

    public enum ContainerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cmaf = "CMAF"
        case ts = "TS"
        public var description: String { return self.rawValue }
    }

    public enum DrmSystem: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clearKeyAes128 = "CLEAR_KEY_AES_128"
        case fairplay = "FAIRPLAY"
        case playready = "PLAYREADY"
        case widevine = "WIDEVINE"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Audio: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case presetAudio1 = "PRESET_AUDIO_1"
        case presetAudio2 = "PRESET_AUDIO_2"
        case presetAudio3 = "PRESET_AUDIO_3"
        case shared = "SHARED"
        case unencrypted = "UNENCRYPTED"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Video: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case presetVideo1 = "PRESET_VIDEO_1"
        case presetVideo2 = "PRESET_VIDEO_2"
        case presetVideo3 = "PRESET_VIDEO_3"
        case presetVideo4 = "PRESET_VIDEO_4"
        case presetVideo5 = "PRESET_VIDEO_5"
        case presetVideo6 = "PRESET_VIDEO_6"
        case presetVideo7 = "PRESET_VIDEO_7"
        case presetVideo8 = "PRESET_VIDEO_8"
        case shared = "SHARED"
        case unencrypted = "UNENCRYPTED"
        public var description: String { return self.rawValue }
    }

    public enum ScteFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `break` = "BREAK"
        case distributorAdvertisement = "DISTRIBUTOR_ADVERTISEMENT"
        case distributorOverlayPlacementOpportunity = "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
        case distributorPlacementOpportunity = "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
        case program = "PROGRAM"
        case providerAdvertisement = "PROVIDER_ADVERTISEMENT"
        case providerOverlayPlacementOpportunity = "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
        case providerPlacementOpportunity = "PROVIDER_PLACEMENT_OPPORTUNITY"
        case spliceInsert = "SPLICE_INSERT"
        public var description: String { return self.rawValue }
    }

    public enum TsEncryptionMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ChannelGroupListConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The date and time the channel group was created.
        public let createdAt: Date
        /// Any descriptive information that you want to add to the channel group for future identification purposes.
        public let description: String?
        /// The date and time the channel group was modified.
        public let modifiedAt: Date

        public init(arn: String, channelGroupName: String, createdAt: Date, description: String? = nil, modifiedAt: Date) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case modifiedAt = "ModifiedAt"
        }
    }

    public struct ChannelListConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The date and time the channel was created.
        public let createdAt: Date
        /// Any descriptive information that you want to add to the channel for future identification purposes.
        public let description: String?
        /// The date and time the channel was modified.
        public let modifiedAt: Date

        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, modifiedAt: Date) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case modifiedAt = "ModifiedAt"
        }
    }

    public struct CreateChannelGroupRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region. You can't use spaces in the name. You can't change the name after you create the channel group.
        public let channelGroupName: String
        /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// Enter any descriptive text that helps you to identify the channel group.
        public let description: String?
        /// A comma-separated list of tag key:value pairs that you define. For example:  "Key1": "Value1",   "Key2": "Value2"
        public let tags: [String: String]?

        public init(channelGroupName: String, clientToken: String? = CreateChannelGroupRequest.idempotencyToken(), description: String? = nil, tags: [String: String]? = nil) {
            self.channelGroupName = channelGroupName
            self.clientToken = clientToken
            self.description = description
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.channelGroupName, forKey: .channelGroupName)
            request.encodeHeader(self.clientToken, key: "x-amzn-client-token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case channelGroupName = "ChannelGroupName"
            case description = "Description"
            case tags = "tags"
        }
    }

    public struct CreateChannelGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The date and time the channel group was created.
        public let createdAt: Date
        /// The description for your channel group.
        public let description: String?
        /// The output domain where the source stream should be sent. Integrate the egress domain with a downstream CDN (such as Amazon CloudFront) or playback device.
        public let egressDomain: String
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The date and time the channel group was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel group.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, createdAt: Date, description: String? = nil, egressDomain: String, eTag: String? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.egressDomain = egressDomain
            self.eTag = eTag
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case egressDomain = "EgressDomain"
            case eTag = "ETag"
            case modifiedAt = "ModifiedAt"
            case tags = "Tags"
        }
    }

    public struct CreateChannelRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.
        public let channelName: String
        /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// Enter any descriptive text that helps you to identify the channel.
        public let description: String?
        /// A comma-separated list of tag key:value pairs that you define. For example:  "Key1": "Value1",   "Key2": "Value2"
        public let tags: [String: String]?

        public init(channelGroupName: String, channelName: String, clientToken: String? = CreateChannelRequest.idempotencyToken(), description: String? = nil, tags: [String: String]? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.clientToken = clientToken
            self.description = description
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            try container.encode(self.channelName, forKey: .channelName)
            request.encodeHeader(self.clientToken, key: "x-amzn-client-token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case channelName = "ChannelName"
            case description = "Description"
            case tags = "tags"
        }
    }

    public struct CreateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The date and time the channel was created.
        public let createdAt: Date
        /// The description for your channel.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        public let ingestEndpoints: [IngestEndpoint]?
        /// The date and time the channel was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, eTag: String? = nil, ingestEndpoints: [IngestEndpoint]? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.ingestEndpoints = ingestEndpoints
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case ingestEndpoints = "IngestEndpoints"
            case modifiedAt = "ModifiedAt"
            case tags = "Tags"
        }
    }

    public struct CreateHlsManifestConfiguration: AWSEncodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index, with an added suffix to distinguish it from the manifest name. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        public let filterConfiguration: FilterConfiguration?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval,  EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest.  The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player.  ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public let programDateTimeIntervalSeconds: Int?
        public let scteHls: ScteHls?

        public init(childManifestName: String? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, scteHls: ScteHls? = nil) {
            self.childManifestName = childManifestName
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
        }

        public func validate(name: String) throws {
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, max: 256)
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, min: 1)
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.manifestName, name: "manifestName", parent: name, max: 256)
            try self.validate(self.manifestName, name: "manifestName", parent: name, min: 1)
            try self.validate(self.manifestName, name: "manifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
            case scteHls = "ScteHls"
        }
    }

    public struct CreateLowLatencyHlsManifestConfiguration: AWSEncodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index, with an added suffix to distinguish it from the manifest name. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        public let filterConfiguration: FilterConfiguration?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval,  EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest.  The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player.  ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public let programDateTimeIntervalSeconds: Int?
        public let scteHls: ScteHls?

        public init(childManifestName: String? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, scteHls: ScteHls? = nil) {
            self.childManifestName = childManifestName
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
        }

        public func validate(name: String) throws {
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, max: 256)
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, min: 1)
            try self.validate(self.childManifestName, name: "childManifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.manifestName, name: "manifestName", parent: name, max: 256)
            try self.validate(self.manifestName, name: "manifestName", parent: name, min: 1)
            try self.validate(self.manifestName, name: "manifestName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
            case scteHls = "ScteHls"
        }
    }

    public struct CreateOriginEndpointRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// A unique, case-sensitive token that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The type of container to attach to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file. You can't change the container type after you create the endpoint.
        public let containerType: ContainerType
        /// Enter any descriptive text that helps you to identify the origin endpoint.
        public let description: String?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [CreateHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [CreateLowLatencyHlsManifestConfiguration]?
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and must be unique for your account in the AWS Region and channel. You can't use spaces in the name. You can't change the name after you create the endpoint.
        public let originEndpointName: String
        /// The segment configuration, including the segment name, duration, and other configuration values.
        public let segment: Segment?
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window. The maximum startover window is 1,209,600 seconds (14 days).
        public let startoverWindowSeconds: Int?
        /// A comma-separated list of tag key:value pairs that you define. For example:  "Key1": "Value1",   "Key2": "Value2"
        public let tags: [String: String]?

        public init(channelGroupName: String, channelName: String, clientToken: String? = CreateOriginEndpointRequest.idempotencyToken(), containerType: ContainerType, description: String? = nil, hlsManifests: [CreateHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [CreateLowLatencyHlsManifestConfiguration]? = nil, originEndpointName: String, segment: Segment? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.clientToken = clientToken
            self.containerType = containerType
            self.description = description
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodeHeader(self.clientToken, key: "x-amzn-client-token")
            try container.encode(self.containerType, forKey: .containerType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.hlsManifests, forKey: .hlsManifests)
            try container.encodeIfPresent(self.lowLatencyHlsManifests, forKey: .lowLatencyHlsManifests)
            try container.encode(self.originEndpointName, forKey: .originEndpointName)
            try container.encodeIfPresent(self.segment, forKey: .segment)
            try container.encodeIfPresent(self.startoverWindowSeconds, forKey: .startoverWindowSeconds)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.hlsManifests?.forEach {
                try $0.validate(name: "\(name).hlsManifests[]")
            }
            try self.lowLatencyHlsManifests?.forEach {
                try $0.validate(name: "\(name).lowLatencyHlsManifests[]")
            }
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.segment?.validate(name: "\(name).segment")
        }

        private enum CodingKeys: String, CodingKey {
            case containerType = "ContainerType"
            case description = "Description"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case originEndpointName = "OriginEndpointName"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
            case tags = "Tags"
        }
    }

    public struct CreateOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint.
        public let containerType: ContainerType
        /// The date and time the origin endpoint was created.
        public let createdAt: Date
        /// The description for your origin endpoint.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [GetHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public let modifiedAt: Date
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The segment configuration, including the segment name, duration, and other configuration values.
        public let segment: Segment
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
        public let startoverWindowSeconds: Int?
        /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, channelName: String, containerType: ContainerType, createdAt: Date, description: String? = nil, eTag: String? = nil, hlsManifests: [GetHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]? = nil, modifiedAt: Date, originEndpointName: String, segment: Segment, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case containerType = "ContainerType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
            case tags = "Tags"
        }
    }

    public struct DeleteChannelGroupRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String

        public init(channelGroupName: String) {
            self.channelGroupName = channelGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteChannelPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String

        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteChannelRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String

        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOriginEndpointPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOriginEndpointPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOriginEndpointRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOriginEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Encryption: AWSEncodableShape & AWSDecodableShape {
        /// A 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting content. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public let constantInitializationVector: String?
        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod
        /// The frequency (in seconds) of key changes for live workflows, in which content is streamed real time. The service retrieves content keys before the live content begins streaming, and then retrieves them as needed over the lifetime of the workflow. By default, key rotation is set to 300 seconds (5 minutes), the minimum rotation interval, which is equivalent to setting it to 300. If you don't enter an interval, content keys aren't rotated. The following example setting causes the service to rotate keys every thirty minutes: 1800
        public let keyRotationIntervalSeconds: Int?
        /// The parameters for the SPEKE key provider.
        public let spekeKeyProvider: SpekeKeyProvider

        public init(constantInitializationVector: String? = nil, encryptionMethod: EncryptionMethod, keyRotationIntervalSeconds: Int? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "ConstantInitializationVector"
            case encryptionMethod = "EncryptionMethod"
            case keyRotationIntervalSeconds = "KeyRotationIntervalSeconds"
            case spekeKeyProvider = "SpekeKeyProvider"
        }
    }

    public struct EncryptionContractConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of audio encryption presets. Value description:    PRESET-AUDIO-1 - Use one content key to encrypt all of the audio tracks in your stream.   PRESET-AUDIO-2 - Use one content key to encrypt all of the stereo audio tracks and one content key to encrypt all of the multichannel audio tracks.   PRESET-AUDIO-3 - Use one content key to encrypt all of the stereo audio tracks, one content key to encrypt all of the multichannel audio tracks with 3 to 6 channels, and one content key to encrypt all of the multichannel audio tracks with more than 6 channels.   SHARED - Use the same content key for all of the audio and video tracks in your stream.   UNENCRYPTED - Don't encrypt any of the audio tracks in your stream.
        public let presetSpeke20Audio: PresetSpeke20Audio
        /// A collection of video encryption presets. Value description:    PRESET-VIDEO-1 - Use one content key to encrypt all of the video tracks in your stream.   PRESET-VIDEO-2 - Use one content key to encrypt all of the SD video tracks and one content key for all HD and higher resolutions video tracks.   PRESET-VIDEO-3 - Use one content key to encrypt all of the SD video tracks, one content key for HD video tracks and one content key for all UHD video tracks.   PRESET-VIDEO-4 - Use one content key to encrypt all of the SD video tracks, one content key for HD video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.   PRESET-VIDEO-5 - Use one content key to encrypt all of the SD video tracks, one content key for HD1 video tracks, one content key for HD2 video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.   PRESET-VIDEO-6 - Use one content key to encrypt all of the SD video tracks, one content key for HD1 video tracks, one content key for HD2 video tracks and one content key for all UHD video tracks.   PRESET-VIDEO-7 - Use one content key to encrypt all of the SD+HD1 video tracks, one content key for HD2 video tracks and one content key for all UHD video tracks.   PRESET-VIDEO-8 - Use one content key to encrypt all of the SD+HD1 video tracks, one content key for HD2 video tracks, one content key for all UHD1 video tracks and one content key for all UHD2 video tracks.   SHARED - Use the same content key for all of the video and audio tracks in your stream.   UNENCRYPTED - Don't encrypt any of the video tracks in your stream.
        public let presetSpeke20Video: PresetSpeke20Video

        public init(presetSpeke20Audio: PresetSpeke20Audio, presetSpeke20Video: PresetSpeke20Video) {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }

        private enum CodingKeys: String, CodingKey {
            case presetSpeke20Audio = "PresetSpeke20Audio"
            case presetSpeke20Video = "PresetSpeke20Video"
        }
    }

    public struct EncryptionMethod: AWSEncodableShape & AWSDecodableShape {
        /// The encryption method to use.
        public let cmafEncryptionMethod: CmafEncryptionMethod?
        /// The encryption method to use.
        public let tsEncryptionMethod: TsEncryptionMethod?

        public init(cmafEncryptionMethod: CmafEncryptionMethod? = nil, tsEncryptionMethod: TsEncryptionMethod? = nil) {
            self.cmafEncryptionMethod = cmafEncryptionMethod
            self.tsEncryptionMethod = tsEncryptionMethod
        }

        private enum CodingKeys: String, CodingKey {
            case cmafEncryptionMethod = "CmafEncryptionMethod"
            case tsEncryptionMethod = "TsEncryptionMethod"
        }
    }

    public struct FilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Optionally specify the end time for all of your manifest egress requests. When you include end time, note that you cannot use end time query parameters for this manifest's endpoint URL.
        public let end: Date?
        /// Optionally specify one or more manifest filters for all of your manifest egress requests. When you include a manifest filter, note that you cannot use an identical manifest filter query parameter for this manifest's endpoint URL.
        public let manifestFilter: String?
        /// Optionally specify the start time for all of your manifest egress requests. When you include start time, note that you cannot use start time query parameters for this manifest's endpoint URL.
        public let start: Date?
        /// Optionally specify the time delay for all of your manifest egress requests. Enter a value that is smaller than your endpoint's startover window. When you include time delay, note that you cannot use time delay query parameters for this manifest's endpoint URL.
        public let timeDelaySeconds: Int?

        public init(end: Date? = nil, manifestFilter: String? = nil, start: Date? = nil, timeDelaySeconds: Int? = nil) {
            self.end = end
            self.manifestFilter = manifestFilter
            self.start = start
            self.timeDelaySeconds = timeDelaySeconds
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case manifestFilter = "ManifestFilter"
            case start = "Start"
            case timeDelaySeconds = "TimeDelaySeconds"
        }
    }

    public struct GetChannelGroupRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String

        public init(channelGroupName: String) {
            self.channelGroupName = channelGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The date and time the channel group was created.
        public let createdAt: Date
        /// The description for your channel group.
        public let description: String?
        /// The output domain where the source stream should be sent. Integrate the domain with a downstream CDN (such as Amazon CloudFront) or playback device.
        public let egressDomain: String
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The date and time the channel group was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel group.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, createdAt: Date, description: String? = nil, egressDomain: String, eTag: String? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.egressDomain = egressDomain
            self.eTag = eTag
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case egressDomain = "EgressDomain"
            case eTag = "ETag"
            case modifiedAt = "ModifiedAt"
            case tags = "tags"
        }
    }

    public struct GetChannelPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String

        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelPolicyResponse: AWSDecodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The policy assigned to the channel.
        public let policy: String

        public init(channelGroupName: String, channelName: String, policy: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case policy = "Policy"
        }
    }

    public struct GetChannelRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String

        public init(channelGroupName: String, channelName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The date and time the channel was created.
        public let createdAt: Date
        /// The description for your channel.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        public let ingestEndpoints: [IngestEndpoint]?
        /// The date and time the channel was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, eTag: String? = nil, ingestEndpoints: [IngestEndpoint]? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.ingestEndpoints = ingestEndpoints
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case ingestEndpoints = "IngestEndpoints"
            case modifiedAt = "ModifiedAt"
            case tags = "Tags"
        }
    }

    public struct GetHlsManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        public let filterConfiguration: FilterConfiguration?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval,  EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest.  The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player.  ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public let programDateTimeIntervalSeconds: Int?
        public let scteHls: ScteHls?
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String

        public init(childManifestName: String? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, scteHls: ScteHls? = nil, url: String) {
            self.childManifestName = childManifestName
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
            case scteHls = "ScteHls"
            case url = "Url"
        }
    }

    public struct GetLowLatencyHlsManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        public let filterConfiguration: FilterConfiguration?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The total duration (in seconds) of the manifest's content.
        public let manifestWindowSeconds: Int?
        /// Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval,  EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest.  The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player.  ID3Timed metadata messages generate every 5 seconds whenever the content is ingested. Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.
        public let programDateTimeIntervalSeconds: Int?
        public let scteHls: ScteHls?
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String

        public init(childManifestName: String? = nil, filterConfiguration: FilterConfiguration? = nil, manifestName: String, manifestWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, scteHls: ScteHls? = nil, url: String) {
            self.childManifestName = childManifestName
            self.filterConfiguration = filterConfiguration
            self.manifestName = manifestName
            self.manifestWindowSeconds = manifestWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.scteHls = scteHls
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case filterConfiguration = "FilterConfiguration"
            case manifestName = "ManifestName"
            case manifestWindowSeconds = "ManifestWindowSeconds"
            case programDateTimeIntervalSeconds = "ProgramDateTimeIntervalSeconds"
            case scteHls = "ScteHls"
            case url = "Url"
        }
    }

    public struct GetOriginEndpointPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOriginEndpointPolicyResponse: AWSDecodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The policy assigned to the origin endpoint.
        public let policy: String

        public init(channelGroupName: String, channelName: String, originEndpointName: String, policy: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case originEndpointName = "OriginEndpointName"
            case policy = "Policy"
        }
    }

    public struct GetOriginEndpointRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        public init(channelGroupName: String, channelName: String, originEndpointName: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint.
        public let containerType: ContainerType
        /// The date and time the origin endpoint was created.
        public let createdAt: Date
        /// The description for your origin endpoint.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [GetHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public let modifiedAt: Date
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        public let segment: Segment
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
        public let startoverWindowSeconds: Int?
        /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, channelName: String, containerType: ContainerType, createdAt: Date, description: String? = nil, eTag: String? = nil, hlsManifests: [GetHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]? = nil, modifiedAt: Date, originEndpointName: String, segment: Segment, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case containerType = "ContainerType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
            case tags = "Tags"
        }
    }

    public struct IngestEndpoint: AWSDecodableShape {
        /// The system-generated unique identifier for the IngestEndpoint.
        public let id: String?
        /// The ingest domain URL where the source stream should be sent.
        public let url: String?

        public init(id: String? = nil, url: String? = nil) {
            self.id = id
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case url = "Url"
        }
    }

    public struct ListChannelGroupsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelGroupsResponse: AWSDecodableShape {
        /// The objects being returned.
        public let items: [ChannelGroupListConfiguration]?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [ChannelGroupListConfiguration]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(channelGroupName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelGroupName = channelGroupName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// The objects being returned.
        public let items: [ChannelListConfiguration]?
        /// The pagination token from the GET list request.
        public let nextToken: String?

        public init(items: [ChannelListConfiguration]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListHlsManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String?

        public init(childManifestName: String? = nil, manifestName: String, url: String? = nil) {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case manifestName = "ManifestName"
            case url = "Url"
        }
    }

    public struct ListLowLatencyHlsManifestConfiguration: AWSDecodableShape {
        /// A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let childManifestName: String?
        /// A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.
        public let manifestName: String
        /// The egress domain URL for stream delivery from MediaPackage.
        public let url: String?

        public init(childManifestName: String? = nil, manifestName: String, url: String? = nil) {
            self.childManifestName = childManifestName
            self.manifestName = manifestName
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case childManifestName = "ChildManifestName"
            case manifestName = "ManifestName"
            case url = "Url"
        }
    }

    public struct ListOriginEndpointsRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(channelGroupName: String, channelName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOriginEndpointsResponse: AWSDecodableShape {
        /// The objects being returned.
        public let items: [OriginEndpointListConfiguration]?
        /// The pagination token from the GET list request. Use the token to fetch the next page of results.
        public let nextToken: String?

        public init(items: [OriginEndpointListConfiguration]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the CloudWatch resource that you want to view tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct OriginEndpointListConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file.
        public let containerType: ContainerType
        /// The date and time the origin endpoint was created.
        public let createdAt: Date?
        /// Any descriptive information that you want to add to the origin endpoint for future identification purposes.
        public let description: String?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [ListHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [ListLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public let modifiedAt: Date?
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String

        public init(arn: String, channelGroupName: String, channelName: String, containerType: ContainerType, createdAt: Date? = nil, description: String? = nil, hlsManifests: [ListHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [ListLowLatencyHlsManifestConfiguration]? = nil, modifiedAt: Date? = nil, originEndpointName: String) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.description = description
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case containerType = "ContainerType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
        }
    }

    public struct PutChannelPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The policy to attach to the specified channel.
        public let policy: String

        public init(channelGroupName: String, channelName: String, policy: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encode(self.policy, forKey: .policy)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 6144)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutChannelPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutOriginEndpointPolicyRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The policy to attach to the specified origin endpoint.
        public let policy: String

        public init(channelGroupName: String, channelName: String, originEndpointName: String, policy: String) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.originEndpointName = originEndpointName
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
            try container.encode(self.policy, forKey: .policy)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 6144)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutOriginEndpointPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Scte: AWSEncodableShape & AWSDecodableShape {
        /// The SCTE-35 message types that you want to be treated as ad markers in the output.
        public let scteFilter: [ScteFilter]?

        public init(scteFilter: [ScteFilter]? = nil) {
            self.scteFilter = scteFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.scteFilter, name: "scteFilter", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case scteFilter = "ScteFilter"
        }
    }

    public struct ScteHls: AWSEncodableShape & AWSDecodableShape {
        /// Ad markers indicate when ads should be inserted during playback. If you include ad markers in the content stream in your upstream encoders, then you need to inform MediaPackage what to do with the ad markers in the output. Choose what you want MediaPackage to do with the ad markers. Value description:    DATERANGE - Insert EXT-X-DATERANGE tags to signal ad and program transition events in TS and CMAF manifests. If you use DATERANGE, you must set a programDateTimeIntervalSeconds value of 1 or higher. To learn more about DATERANGE, see SCTE-35 Ad Marker EXT-X-DATERANGE.
        public let adMarkerHls: AdMarkerHls?

        public init(adMarkerHls: AdMarkerHls? = nil) {
            self.adMarkerHls = adMarkerHls
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkerHls = "AdMarkerHls"
        }
    }

    public struct Segment: AWSEncodableShape & AWSDecodableShape {
        public let encryption: Encryption?
        /// When selected, the stream set includes an additional I-frame only stream, along with the other tracks. If false, this extra stream is not included. MediaPackage generates an I-frame only stream from the first rendition in the manifest. The service inserts EXT-I-FRAMES-ONLY tags in the output manifest, and then generates and includes an I-frames only playlist in the stream. This playlist permits player functionality like fast forward and rewind.
        public let includeIframeOnlyStreams: Bool?
        /// The SCTE configuration options in the segment settings.
        public let scte: Scte?
        /// The duration (in seconds) of each segment. Enter a value equal to, or a multiple of, the input segment duration. If the value that you enter is different from the input segment duration, MediaPackage rounds segments to the nearest multiple of the input segment duration.
        public let segmentDurationSeconds: Int?
        /// The name that describes the segment. The name is the base name of the segment used in all content manifests inside of the endpoint. You can't use spaces in the name.
        public let segmentName: String?
        /// By default, MediaPackage excludes all digital video broadcasting (DVB) subtitles from the output. When selected, MediaPackage passes through DVB subtitles into the output.
        public let tsIncludeDvbSubtitles: Bool?
        /// When selected, MediaPackage bundles all audio tracks in a rendition group. All other tracks in the stream can be used with any audio rendition from the group.
        public let tsUseAudioRenditionGroup: Bool?

        public init(encryption: Encryption? = nil, includeIframeOnlyStreams: Bool? = nil, scte: Scte? = nil, segmentDurationSeconds: Int? = nil, segmentName: String? = nil, tsIncludeDvbSubtitles: Bool? = nil, tsUseAudioRenditionGroup: Bool? = nil) {
            self.encryption = encryption
            self.includeIframeOnlyStreams = includeIframeOnlyStreams
            self.scte = scte
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentName = segmentName
            self.tsIncludeDvbSubtitles = tsIncludeDvbSubtitles
            self.tsUseAudioRenditionGroup = tsUseAudioRenditionGroup
        }

        public func validate(name: String) throws {
            try self.scte?.validate(name: "\(name).scte")
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "Encryption"
            case includeIframeOnlyStreams = "IncludeIframeOnlyStreams"
            case scte = "Scte"
            case segmentDurationSeconds = "SegmentDurationSeconds"
            case segmentName = "SegmentName"
            case tsIncludeDvbSubtitles = "TsIncludeDvbSubtitles"
            case tsUseAudioRenditionGroup = "TsUseAudioRenditionGroup"
        }
    }

    public struct SpekeKeyProvider: AWSEncodableShape & AWSDecodableShape {
        /// The DRM solution provider you're using to protect your content during distribution.
        public let drmSystems: [DrmSystem]
        /// Configure one or more content encryption keys for your endpoints that use SPEKE Version 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use.
        public let encryptionContractConfiguration: EncryptionContractConfiguration
        /// The unique identifier for the content. The service sends this to the key server to identify the current endpoint. How unique you make this depends on how fine-grained you want access controls to be. The service does not permit you to use the same ID for two simultaneous encryption processes. The resource ID is also known as the content ID. The following example shows a resource ID: MovieNight20171126093045
        public let resourceId: String
        /// The ARN for the IAM role granted by the key provider that provides access to the key provider API. This role must have a trust policy that allows MediaPackage to assume the role, and it must have a sufficient permissions policy to allow access to the specific key retrieval URL. Get this from your DRM solution provider. Valid format: arn:aws:iam::{accountID}:role/{name}. The following example shows a role ARN: arn:aws:iam::444455556666:role/SpekeAccess
        public let roleArn: String
        /// The URL of the API Gateway proxy that you set up to talk to your key server. The API Gateway proxy must reside in the same AWS Region as MediaPackage and must start with https://. The following example shows a URL: https://1wm2dx1f33.execute-api.us-west-2.amazonaws.com/SpekeSample/copyProtection
        public let url: String

        public init(drmSystems: [DrmSystem], encryptionContractConfiguration: EncryptionContractConfiguration, resourceId: String, roleArn: String, url: String) {
            self.drmSystems = drmSystems
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case drmSystems = "DrmSystems"
            case encryptionContractConfiguration = "EncryptionContractConfiguration"
            case resourceId = "ResourceId"
            case roleArn = "RoleArn"
            case url = "Url"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the MediaPackage resource that you're adding tags to.
        public let resourceArn: String
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the MediaPackage resource that you're removing tags from.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateChannelGroupRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// Any descriptive information that you want to add to the channel group for future identification purposes.
        public let description: String?
        /// The expected current Entity Tag (ETag) for the resource. If the specified ETag does not match the resource's current entity tag, the update request will be rejected.
        public let eTag: String?

        public init(channelGroupName: String, description: String? = nil, eTag: String? = nil) {
            self.channelGroupName = channelGroupName
            self.description = description
            self.eTag = eTag
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.eTag, key: "x-amzn-update-if-match")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.eTag, name: "eTag", parent: name, max: 256)
            try self.validate(self.eTag, name: "eTag", parent: name, min: 1)
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateChannelGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The date and time the channel group was created.
        public let createdAt: Date
        /// The description for your channel group.
        public let description: String?
        /// The output domain where the source stream is sent. Integrate the domain with a downstream CDN (such as Amazon CloudFront) or playback device.
        public let egressDomain: String
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// The date and time the channel group was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel group.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, createdAt: Date, description: String? = nil, egressDomain: String, eTag: String? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.createdAt = createdAt
            self.description = description
            self.egressDomain = egressDomain
            self.eTag = eTag
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case egressDomain = "EgressDomain"
            case eTag = "ETag"
            case modifiedAt = "ModifiedAt"
            case tags = "tags"
        }
    }

    public struct UpdateChannelRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// Any descriptive information that you want to add to the channel for future identification purposes.
        public let description: String?
        /// The expected current Entity Tag (ETag) for the resource. If the specified ETag does not match the resource's current entity tag, the update request will be rejected.
        public let eTag: String?

        public init(channelGroupName: String, channelName: String, description: String? = nil, eTag: String? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.description = description
            self.eTag = eTag
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.eTag, key: "x-amzn-update-if-match")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.eTag, name: "eTag", parent: name, max: 256)
            try self.validate(self.eTag, name: "eTag", parent: name, min: 1)
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The date and time the channel was created.
        public let createdAt: Date
        /// The description for your channel.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        public let ingestEndpoints: [IngestEndpoint]?
        /// The date and time the channel was modified.
        public let modifiedAt: Date
        /// The comma-separated list of tag key:value pairs assigned to the channel.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, channelName: String, createdAt: Date, description: String? = nil, eTag: String? = nil, ingestEndpoints: [IngestEndpoint]? = nil, modifiedAt: Date, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.ingestEndpoints = ingestEndpoints
            self.modifiedAt = modifiedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case ingestEndpoints = "IngestEndpoints"
            case modifiedAt = "ModifiedAt"
            case tags = "tags"
        }
    }

    public struct UpdateOriginEndpointRequest: AWSEncodableShape {
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint. A container type is a file format that encapsulates one or more media streams, such as audio and video, into a single file.
        public let containerType: ContainerType
        /// Any descriptive information that you want to add to the origin endpoint for future identification purposes.
        public let description: String?
        /// The expected current Entity Tag (ETag) for the resource. If the specified ETag does not match the resource's current entity tag, the update request will be rejected.
        public let eTag: String?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [CreateHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [CreateLowLatencyHlsManifestConfiguration]?
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The segment configuration, including the segment name, duration, and other configuration values.
        public let segment: Segment?
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window. The maximum startover window is 1,209,600 seconds (14 days).
        public let startoverWindowSeconds: Int?

        public init(channelGroupName: String, channelName: String, containerType: ContainerType, description: String? = nil, eTag: String? = nil, hlsManifests: [CreateHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [CreateLowLatencyHlsManifestConfiguration]? = nil, originEndpointName: String, segment: Segment? = nil, startoverWindowSeconds: Int? = nil) {
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.description = description
            self.eTag = eTag
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelGroupName, key: "ChannelGroupName")
            request.encodePath(self.channelName, key: "ChannelName")
            try container.encode(self.containerType, forKey: .containerType)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.eTag, key: "x-amzn-update-if-match")
            try container.encodeIfPresent(self.hlsManifests, forKey: .hlsManifests)
            try container.encodeIfPresent(self.lowLatencyHlsManifests, forKey: .lowLatencyHlsManifests)
            request.encodePath(self.originEndpointName, key: "OriginEndpointName")
            try container.encodeIfPresent(self.segment, forKey: .segment)
            try container.encodeIfPresent(self.startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, max: 256)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, min: 1)
            try self.validate(self.channelGroupName, name: "channelGroupName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.channelName, name: "channelName", parent: name, max: 256)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.channelName, name: "channelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.eTag, name: "eTag", parent: name, max: 256)
            try self.validate(self.eTag, name: "eTag", parent: name, min: 1)
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "^[\\S]+$")
            try self.hlsManifests?.forEach {
                try $0.validate(name: "\(name).hlsManifests[]")
            }
            try self.lowLatencyHlsManifests?.forEach {
                try $0.validate(name: "\(name).lowLatencyHlsManifests[]")
            }
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, max: 256)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, min: 1)
            try self.validate(self.originEndpointName, name: "originEndpointName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.segment?.validate(name: "\(name).segment")
        }

        private enum CodingKeys: String, CodingKey {
            case containerType = "ContainerType"
            case description = "Description"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
        }
    }

    public struct UpdateOriginEndpointResponse: AWSDecodableShape {
        /// The ARN associated with the resource.
        public let arn: String
        /// The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.
        public let channelGroupName: String
        /// The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group.
        public let channelName: String
        /// The type of container attached to this origin endpoint.
        public let containerType: ContainerType
        /// The date and time the origin endpoint was created.
        public let createdAt: Date
        /// The description of the origin endpoint.
        public let description: String?
        /// The current Entity Tag (ETag) associated with this resource. The entity tag can be used to safely make concurrent updates to the resource.
        public let eTag: String?
        /// An HTTP live streaming (HLS) manifest configuration.
        public let hlsManifests: [GetHlsManifestConfiguration]?
        /// A low-latency HLS manifest configuration.
        public let lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]?
        /// The date and time the origin endpoint was modified.
        public let modifiedAt: Date
        /// The name that describes the origin endpoint. The name is the primary identifier for the origin endpoint, and and must be unique for your account in the AWS Region and channel.
        public let originEndpointName: String
        /// The segment configuration, including the segment name, duration, and other configuration values.
        public let segment: Segment
        /// The size of the window (in seconds) to create a window of the live stream that's available for on-demand viewing. Viewers can start-over or catch-up on content that falls within the window.
        public let startoverWindowSeconds: Int?
        /// The comma-separated list of tag key:value pairs assigned to the origin endpoint.
        public let tags: [String: String]?

        public init(arn: String, channelGroupName: String, channelName: String, containerType: ContainerType, createdAt: Date, description: String? = nil, eTag: String? = nil, hlsManifests: [GetHlsManifestConfiguration]? = nil, lowLatencyHlsManifests: [GetLowLatencyHlsManifestConfiguration]? = nil, modifiedAt: Date, originEndpointName: String, segment: Segment, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelGroupName = channelGroupName
            self.channelName = channelName
            self.containerType = containerType
            self.createdAt = createdAt
            self.description = description
            self.eTag = eTag
            self.hlsManifests = hlsManifests
            self.lowLatencyHlsManifests = lowLatencyHlsManifests
            self.modifiedAt = modifiedAt
            self.originEndpointName = originEndpointName
            self.segment = segment
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case channelGroupName = "ChannelGroupName"
            case channelName = "ChannelName"
            case containerType = "ContainerType"
            case createdAt = "CreatedAt"
            case description = "Description"
            case eTag = "ETag"
            case hlsManifests = "HlsManifests"
            case lowLatencyHlsManifests = "LowLatencyHlsManifests"
            case modifiedAt = "ModifiedAt"
            case originEndpointName = "OriginEndpointName"
            case segment = "Segment"
            case startoverWindowSeconds = "StartoverWindowSeconds"
            case tags = "tags"
        }
    }
}

// MARK: - Errors

/// Error enum for MediaPackageV2
public struct MediaPackageV2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MediaPackageV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see Access Management in the IAM User Guide.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting this resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Indicates that an error from the service occurred while trying to process a request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request throughput limit was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input failed to meet the constraints specified by the AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension MediaPackageV2ErrorType: Equatable {
    public static func == (lhs: MediaPackageV2ErrorType, rhs: MediaPackageV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MediaPackageV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
